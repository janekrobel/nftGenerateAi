{"ast":null,"code":"'use strict';\n\nconst {\n  webidl\n} = require('../fetch/webidl');\nconst {\n  DOMException\n} = require('../fetch/constants');\nconst {\n  URLSerializer\n} = require('../fetch/dataURL');\nconst {\n  staticPropertyDescriptors,\n  states,\n  opcodes,\n  emptyBuffer\n} = require('./constants');\nconst {\n  kWebSocketURL,\n  kReadyState,\n  kController,\n  kExtensions,\n  kProtocol,\n  kBinaryType,\n  kResponse,\n  kSentClose\n} = require('./symbols');\nconst {\n  isEstablished,\n  isClosing,\n  isValidSubprotocol,\n  failWebsocketConnection\n} = require('./util');\nconst {\n  establishWebSocketConnection\n} = require('./connection');\nconst {\n  WebsocketFrameSend\n} = require('./frame');\nconst {\n  kEnumerableProperty,\n  isBlobLike\n} = require('../core/util');\nconst {\n  types\n} = require('util');\nlet experimentalWarned = false;\n\n// https://websockets.spec.whatwg.org/#interface-definition\nclass WebSocket extends EventTarget {\n  #events = {\n    open: null,\n    error: null,\n    close: null,\n    message: null\n  };\n  #bufferedAmount = 0;\n\n  /**\n   * @param {string} url\n   * @param {string|string[]} protocols\n   */\n  constructor(url) {\n    let protocols = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n    super();\n    webidl.argumentLengthCheck(arguments, 1, {\n      header: 'WebSocket constructor'\n    });\n    if (!experimentalWarned) {\n      experimentalWarned = true;\n      process.emitWarning('WebSockets are experimental, expect them to change at any time.', {\n        code: 'UNDICI-WS'\n      });\n    }\n    url = webidl.converters.USVString(url);\n    protocols = webidl.converters['DOMString or sequence<DOMString>'](protocols);\n\n    // 1. Let urlRecord be the result of applying the URL parser to url.\n    let urlRecord;\n    try {\n      urlRecord = new URL(url);\n    } catch (e) {\n      // 2. If urlRecord is failure, then throw a \"SyntaxError\" DOMException.\n      throw new DOMException(e, 'SyntaxError');\n    }\n\n    // 3. If urlRecord’s scheme is not \"ws\" or \"wss\", then throw a\n    //    \"SyntaxError\" DOMException.\n    if (urlRecord.protocol !== 'ws:' && urlRecord.protocol !== 'wss:') {\n      throw new DOMException(`Expected a ws: or wss: protocol, got ${urlRecord.protocol}`, 'SyntaxError');\n    }\n\n    // 4. If urlRecord’s fragment is non-null, then throw a \"SyntaxError\"\n    //    DOMException.\n    if (urlRecord.hash) {\n      throw new DOMException('Got fragment', 'SyntaxError');\n    }\n\n    // 5. If protocols is a string, set protocols to a sequence consisting\n    //    of just that string.\n    if (typeof protocols === 'string') {\n      protocols = [protocols];\n    }\n\n    // 6. If any of the values in protocols occur more than once or otherwise\n    //    fail to match the requirements for elements that comprise the value\n    //    of `Sec-WebSocket-Protocol` fields as defined by The WebSocket\n    //    protocol, then throw a \"SyntaxError\" DOMException.\n    if (protocols.length !== new Set(protocols.map(p => p.toLowerCase())).size) {\n      throw new DOMException('Invalid Sec-WebSocket-Protocol value', 'SyntaxError');\n    }\n    if (protocols.length > 0 && !protocols.every(p => isValidSubprotocol(p))) {\n      throw new DOMException('Invalid Sec-WebSocket-Protocol value', 'SyntaxError');\n    }\n\n    // 7. Set this's url to urlRecord.\n    this[kWebSocketURL] = urlRecord;\n\n    // 8. Let client be this's relevant settings object.\n\n    // 9. Run this step in parallel:\n\n    //    1. Establish a WebSocket connection given urlRecord, protocols,\n    //       and client.\n    this[kController] = establishWebSocketConnection(urlRecord, protocols, this);\n\n    // Each WebSocket object has an associated ready state, which is a\n    // number representing the state of the connection. Initially it must\n    // be CONNECTING (0).\n    this[kReadyState] = WebSocket.CONNECTING;\n\n    // The extensions attribute must initially return the empty string.\n    this[kExtensions] = '';\n\n    // The protocol attribute must initially return the empty string.\n    this[kProtocol] = '';\n\n    // Each WebSocket object has an associated binary type, which is a\n    // BinaryType. Initially it must be \"blob\".\n    this[kBinaryType] = 'blob';\n  }\n\n  /**\n   * @see https://websockets.spec.whatwg.org/#dom-websocket-close\n   * @param {number|undefined} code\n   * @param {string|undefined} reason\n   */\n  close() {\n    let code = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : undefined;\n    let reason = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : undefined;\n    webidl.brandCheck(this, WebSocket);\n    if (code !== undefined) {\n      code = webidl.converters['unsigned short'](code, {\n        clamp: true\n      });\n    }\n    if (reason !== undefined) {\n      reason = webidl.converters.USVString(reason);\n    }\n\n    // 1. If code is present, but is neither an integer equal to 1000 nor an\n    //    integer in the range 3000 to 4999, inclusive, throw an\n    //    \"InvalidAccessError\" DOMException.\n    if (code !== undefined) {\n      if (code !== 1000 && (code < 3000 || code > 4999)) {\n        throw new DOMException('invalid code', 'InvalidAccessError');\n      }\n    }\n    let reasonByteLength = 0;\n\n    // 2. If reason is present, then run these substeps:\n    if (reason !== undefined) {\n      // 1. Let reasonBytes be the result of encoding reason.\n      // 2. If reasonBytes is longer than 123 bytes, then throw a\n      //    \"SyntaxError\" DOMException.\n      reasonByteLength = Buffer.byteLength(reason);\n      if (reasonByteLength > 123) {\n        throw new DOMException(`Reason must be less than 123 bytes; received ${reasonByteLength}`, 'SyntaxError');\n      }\n    }\n\n    // 3. Run the first matching steps from the following list:\n    if (this[kReadyState] === WebSocket.CLOSING || this[kReadyState] === WebSocket.CLOSED) {\n      // If this's ready state is CLOSING (2) or CLOSED (3)\n      // Do nothing.\n    } else if (!isEstablished(this)) {\n      // If the WebSocket connection is not yet established\n      // Fail the WebSocket connection and set this's ready state\n      // to CLOSING (2).\n      failWebsocketConnection(this, 'Connection was closed before it was established.');\n      this[kReadyState] = WebSocket.CLOSING;\n    } else if (!isClosing(this)) {\n      // If the WebSocket closing handshake has not yet been started\n      // Start the WebSocket closing handshake and set this's ready\n      // state to CLOSING (2).\n      // - If neither code nor reason is present, the WebSocket Close\n      //   message must not have a body.\n      // - If code is present, then the status code to use in the\n      //   WebSocket Close message must be the integer given by code.\n      // - If reason is also present, then reasonBytes must be\n      //   provided in the Close message after the status code.\n\n      const frame = new WebsocketFrameSend();\n\n      // If neither code nor reason is present, the WebSocket Close\n      // message must not have a body.\n\n      // If code is present, then the status code to use in the\n      // WebSocket Close message must be the integer given by code.\n      if (code !== undefined && reason === undefined) {\n        frame.frameData = Buffer.allocUnsafe(2);\n        frame.frameData.writeUInt16BE(code, 0);\n      } else if (code !== undefined && reason !== undefined) {\n        // If reason is also present, then reasonBytes must be\n        // provided in the Close message after the status code.\n        frame.frameData = Buffer.allocUnsafe(2 + reasonByteLength);\n        frame.frameData.writeUInt16BE(code, 0);\n        // the body MAY contain UTF-8-encoded data with value /reason/\n        frame.frameData.write(reason, 2, 'utf-8');\n      } else {\n        frame.frameData = emptyBuffer;\n      }\n\n      /** @type {import('stream').Duplex} */\n      const socket = this[kResponse].socket;\n      socket.write(frame.createFrame(opcodes.CLOSE), err => {\n        if (!err) {\n          this[kSentClose] = true;\n        }\n      });\n\n      // Upon either sending or receiving a Close control frame, it is said\n      // that _The WebSocket Closing Handshake is Started_ and that the\n      // WebSocket connection is in the CLOSING state.\n      this[kReadyState] = states.CLOSING;\n    } else {\n      // Otherwise\n      // Set this's ready state to CLOSING (2).\n      this[kReadyState] = WebSocket.CLOSING;\n    }\n  }\n\n  /**\n   * @see https://websockets.spec.whatwg.org/#dom-websocket-send\n   * @param {NodeJS.TypedArray|ArrayBuffer|Blob|string} data\n   */\n  send(data) {\n    webidl.brandCheck(this, WebSocket);\n    webidl.argumentLengthCheck(arguments, 1, {\n      header: 'WebSocket.send'\n    });\n    data = webidl.converters.WebSocketSendData(data);\n\n    // 1. If this's ready state is CONNECTING, then throw an\n    //    \"InvalidStateError\" DOMException.\n    if (this[kReadyState] === WebSocket.CONNECTING) {\n      throw new DOMException('Sent before connected.', 'InvalidStateError');\n    }\n\n    // 2. Run the appropriate set of steps from the following list:\n    // https://datatracker.ietf.org/doc/html/rfc6455#section-6.1\n    // https://datatracker.ietf.org/doc/html/rfc6455#section-5.2\n\n    if (!isEstablished(this) || isClosing(this)) {\n      return;\n    }\n\n    /** @type {import('stream').Duplex} */\n    const socket = this[kResponse].socket;\n\n    // If data is a string\n    if (typeof data === 'string') {\n      // If the WebSocket connection is established and the WebSocket\n      // closing handshake has not yet started, then the user agent\n      // must send a WebSocket Message comprised of the data argument\n      // using a text frame opcode; if the data cannot be sent, e.g.\n      // because it would need to be buffered but the buffer is full,\n      // the user agent must flag the WebSocket as full and then close\n      // the WebSocket connection. Any invocation of this method with a\n      // string argument that does not throw an exception must increase\n      // the bufferedAmount attribute by the number of bytes needed to\n      // express the argument as UTF-8.\n\n      const value = Buffer.from(data);\n      const frame = new WebsocketFrameSend(value);\n      const buffer = frame.createFrame(opcodes.TEXT);\n      this.#bufferedAmount += value.byteLength;\n      socket.write(buffer, () => {\n        this.#bufferedAmount -= value.byteLength;\n      });\n    } else if (types.isArrayBuffer(data)) {\n      // If the WebSocket connection is established, and the WebSocket\n      // closing handshake has not yet started, then the user agent must\n      // send a WebSocket Message comprised of data using a binary frame\n      // opcode; if the data cannot be sent, e.g. because it would need\n      // to be buffered but the buffer is full, the user agent must flag\n      // the WebSocket as full and then close the WebSocket connection.\n      // The data to be sent is the data stored in the buffer described\n      // by the ArrayBuffer object. Any invocation of this method with an\n      // ArrayBuffer argument that does not throw an exception must\n      // increase the bufferedAmount attribute by the length of the\n      // ArrayBuffer in bytes.\n\n      const value = Buffer.from(data);\n      const frame = new WebsocketFrameSend(value);\n      const buffer = frame.createFrame(opcodes.BINARY);\n      this.#bufferedAmount += value.byteLength;\n      socket.write(buffer, () => {\n        this.#bufferedAmount -= value.byteLength;\n      });\n    } else if (ArrayBuffer.isView(data)) {\n      // If the WebSocket connection is established, and the WebSocket\n      // closing handshake has not yet started, then the user agent must\n      // send a WebSocket Message comprised of data using a binary frame\n      // opcode; if the data cannot be sent, e.g. because it would need to\n      // be buffered but the buffer is full, the user agent must flag the\n      // WebSocket as full and then close the WebSocket connection. The\n      // data to be sent is the data stored in the section of the buffer\n      // described by the ArrayBuffer object that data references. Any\n      // invocation of this method with this kind of argument that does\n      // not throw an exception must increase the bufferedAmount attribute\n      // by the length of data’s buffer in bytes.\n\n      const ab = Buffer.from(data, data.byteOffset, data.byteLength);\n      const frame = new WebsocketFrameSend(ab);\n      const buffer = frame.createFrame(opcodes.BINARY);\n      this.#bufferedAmount += ab.byteLength;\n      socket.write(buffer, () => {\n        this.#bufferedAmount -= ab.byteLength;\n      });\n    } else if (isBlobLike(data)) {\n      // If the WebSocket connection is established, and the WebSocket\n      // closing handshake has not yet started, then the user agent must\n      // send a WebSocket Message comprised of data using a binary frame\n      // opcode; if the data cannot be sent, e.g. because it would need to\n      // be buffered but the buffer is full, the user agent must flag the\n      // WebSocket as full and then close the WebSocket connection. The data\n      // to be sent is the raw data represented by the Blob object. Any\n      // invocation of this method with a Blob argument that does not throw\n      // an exception must increase the bufferedAmount attribute by the size\n      // of the Blob object’s raw data, in bytes.\n\n      const frame = new WebsocketFrameSend();\n      data.arrayBuffer().then(ab => {\n        const value = Buffer.from(ab);\n        frame.frameData = value;\n        const buffer = frame.createFrame(opcodes.BINARY);\n        this.#bufferedAmount += value.byteLength;\n        socket.write(buffer, () => {\n          this.#bufferedAmount -= value.byteLength;\n        });\n      });\n    }\n  }\n  get readyState() {\n    webidl.brandCheck(this, WebSocket);\n\n    // The readyState getter steps are to return this's ready state.\n    return this[kReadyState];\n  }\n  get bufferedAmount() {\n    webidl.brandCheck(this, WebSocket);\n    return this.#bufferedAmount;\n  }\n  get url() {\n    webidl.brandCheck(this, WebSocket);\n\n    // The url getter steps are to return this's url, serialized.\n    return URLSerializer(this[kWebSocketURL]);\n  }\n  get extensions() {\n    webidl.brandCheck(this, WebSocket);\n    return this[kExtensions];\n  }\n  get protocol() {\n    webidl.brandCheck(this, WebSocket);\n    return this[kProtocol];\n  }\n  get onopen() {\n    webidl.brandCheck(this, WebSocket);\n    return this.#events.open;\n  }\n  set onopen(fn) {\n    webidl.brandCheck(this, WebSocket);\n    if (this.#events.open) {\n      this.removeEventListener('open', this.#events.open);\n    }\n    if (typeof fn === 'function') {\n      this.#events.open = fn;\n      this.addEventListener('open', fn);\n    } else {\n      this.#events.open = null;\n    }\n  }\n  get onerror() {\n    webidl.brandCheck(this, WebSocket);\n    return this.#events.error;\n  }\n  set onerror(fn) {\n    webidl.brandCheck(this, WebSocket);\n    if (this.#events.error) {\n      this.removeEventListener('error', this.#events.error);\n    }\n    if (typeof fn === 'function') {\n      this.#events.error = fn;\n      this.addEventListener('error', fn);\n    } else {\n      this.#events.error = null;\n    }\n  }\n  get onclose() {\n    webidl.brandCheck(this, WebSocket);\n    return this.#events.close;\n  }\n  set onclose(fn) {\n    webidl.brandCheck(this, WebSocket);\n    if (this.#events.close) {\n      this.removeEventListener('close', this.#events.close);\n    }\n    if (typeof fn === 'function') {\n      this.#events.close = fn;\n      this.addEventListener('close', fn);\n    } else {\n      this.#events.close = null;\n    }\n  }\n  get onmessage() {\n    webidl.brandCheck(this, WebSocket);\n    return this.#events.message;\n  }\n  set onmessage(fn) {\n    webidl.brandCheck(this, WebSocket);\n    if (this.#events.message) {\n      this.removeEventListener('message', this.#events.message);\n    }\n    if (typeof fn === 'function') {\n      this.#events.message = fn;\n      this.addEventListener('message', fn);\n    } else {\n      this.#events.message = null;\n    }\n  }\n  get binaryType() {\n    webidl.brandCheck(this, WebSocket);\n    return this[kBinaryType];\n  }\n  set binaryType(type) {\n    webidl.brandCheck(this, WebSocket);\n    if (type !== 'blob' && type !== 'arraybuffer') {\n      this[kBinaryType] = 'blob';\n    } else {\n      this[kBinaryType] = type;\n    }\n  }\n}\n\n// https://websockets.spec.whatwg.org/#dom-websocket-connecting\nWebSocket.CONNECTING = WebSocket.prototype.CONNECTING = states.CONNECTING;\n// https://websockets.spec.whatwg.org/#dom-websocket-open\nWebSocket.OPEN = WebSocket.prototype.OPEN = states.OPEN;\n// https://websockets.spec.whatwg.org/#dom-websocket-closing\nWebSocket.CLOSING = WebSocket.prototype.CLOSING = states.CLOSING;\n// https://websockets.spec.whatwg.org/#dom-websocket-closed\nWebSocket.CLOSED = WebSocket.prototype.CLOSED = states.CLOSED;\nObject.defineProperties(WebSocket.prototype, {\n  CONNECTING: staticPropertyDescriptors,\n  OPEN: staticPropertyDescriptors,\n  CLOSING: staticPropertyDescriptors,\n  CLOSED: staticPropertyDescriptors,\n  url: kEnumerableProperty,\n  readyState: kEnumerableProperty,\n  bufferedAmount: kEnumerableProperty,\n  onopen: kEnumerableProperty,\n  onerror: kEnumerableProperty,\n  onclose: kEnumerableProperty,\n  close: kEnumerableProperty,\n  onmessage: kEnumerableProperty,\n  binaryType: kEnumerableProperty,\n  send: kEnumerableProperty,\n  extensions: kEnumerableProperty,\n  protocol: kEnumerableProperty,\n  [Symbol.toStringTag]: {\n    value: 'WebSocket',\n    writable: false,\n    enumerable: false,\n    configurable: true\n  }\n});\nObject.defineProperties(WebSocket, {\n  CONNECTING: staticPropertyDescriptors,\n  OPEN: staticPropertyDescriptors,\n  CLOSING: staticPropertyDescriptors,\n  CLOSED: staticPropertyDescriptors\n});\nwebidl.converters['sequence<DOMString>'] = webidl.sequenceConverter(webidl.converters.DOMString);\nwebidl.converters['DOMString or sequence<DOMString>'] = function (V) {\n  if (webidl.util.Type(V) === 'Object' && Symbol.iterator in V) {\n    return webidl.converters['sequence<DOMString>'](V);\n  }\n  return webidl.converters.DOMString(V);\n};\nwebidl.converters.WebSocketSendData = function (V) {\n  if (webidl.util.Type(V) === 'Object') {\n    if (isBlobLike(V)) {\n      return webidl.converters.Blob(V, {\n        strict: false\n      });\n    }\n    if (ArrayBuffer.isView(V) || types.isAnyArrayBuffer(V)) {\n      return webidl.converters.BufferSource(V);\n    }\n  }\n  return webidl.converters.USVString(V);\n};\nmodule.exports = {\n  WebSocket\n};","map":{"version":3,"names":["webidl","require","DOMException","URLSerializer","staticPropertyDescriptors","states","opcodes","emptyBuffer","kWebSocketURL","kReadyState","kController","kExtensions","kProtocol","kBinaryType","kResponse","kSentClose","isEstablished","isClosing","isValidSubprotocol","failWebsocketConnection","establishWebSocketConnection","WebsocketFrameSend","kEnumerableProperty","isBlobLike","types","experimentalWarned","WebSocket","EventTarget","events","open","error","close","message","bufferedAmount","constructor","url","protocols","argumentLengthCheck","arguments","header","process","emitWarning","code","converters","USVString","urlRecord","URL","e","protocol","hash","length","Set","map","p","toLowerCase","size","every","CONNECTING","undefined","reason","brandCheck","clamp","reasonByteLength","Buffer","byteLength","CLOSING","CLOSED","frame","frameData","allocUnsafe","writeUInt16BE","write","socket","createFrame","CLOSE","err","send","data","WebSocketSendData","value","from","buffer","TEXT","isArrayBuffer","BINARY","ArrayBuffer","isView","ab","byteOffset","arrayBuffer","then","readyState","extensions","onopen","fn","removeEventListener","addEventListener","onerror","onclose","onmessage","binaryType","type","prototype","OPEN","Object","defineProperties","Symbol","toStringTag","writable","enumerable","configurable","sequenceConverter","DOMString","V","util","Type","iterator","Blob","strict","isAnyArrayBuffer","BufferSource","module","exports"],"sources":["/Users/janrobel/Documents/PersonalProjekty/nftGenerateAi/clientAndContract/node_modules/undici/lib/websocket/websocket.js"],"sourcesContent":["'use strict'\n\nconst { webidl } = require('../fetch/webidl')\nconst { DOMException } = require('../fetch/constants')\nconst { URLSerializer } = require('../fetch/dataURL')\nconst { staticPropertyDescriptors, states, opcodes, emptyBuffer } = require('./constants')\nconst {\n  kWebSocketURL,\n  kReadyState,\n  kController,\n  kExtensions,\n  kProtocol,\n  kBinaryType,\n  kResponse,\n  kSentClose\n} = require('./symbols')\nconst { isEstablished, isClosing, isValidSubprotocol, failWebsocketConnection } = require('./util')\nconst { establishWebSocketConnection } = require('./connection')\nconst { WebsocketFrameSend } = require('./frame')\nconst { kEnumerableProperty, isBlobLike } = require('../core/util')\nconst { types } = require('util')\n\nlet experimentalWarned = false\n\n// https://websockets.spec.whatwg.org/#interface-definition\nclass WebSocket extends EventTarget {\n  #events = {\n    open: null,\n    error: null,\n    close: null,\n    message: null\n  }\n\n  #bufferedAmount = 0\n\n  /**\n   * @param {string} url\n   * @param {string|string[]} protocols\n   */\n  constructor (url, protocols = []) {\n    super()\n\n    webidl.argumentLengthCheck(arguments, 1, { header: 'WebSocket constructor' })\n\n    if (!experimentalWarned) {\n      experimentalWarned = true\n      process.emitWarning('WebSockets are experimental, expect them to change at any time.', {\n        code: 'UNDICI-WS'\n      })\n    }\n\n    url = webidl.converters.USVString(url)\n    protocols = webidl.converters['DOMString or sequence<DOMString>'](protocols)\n\n    // 1. Let urlRecord be the result of applying the URL parser to url.\n    let urlRecord\n\n    try {\n      urlRecord = new URL(url)\n    } catch (e) {\n      // 2. If urlRecord is failure, then throw a \"SyntaxError\" DOMException.\n      throw new DOMException(e, 'SyntaxError')\n    }\n\n    // 3. If urlRecord’s scheme is not \"ws\" or \"wss\", then throw a\n    //    \"SyntaxError\" DOMException.\n    if (urlRecord.protocol !== 'ws:' && urlRecord.protocol !== 'wss:') {\n      throw new DOMException(\n        `Expected a ws: or wss: protocol, got ${urlRecord.protocol}`,\n        'SyntaxError'\n      )\n    }\n\n    // 4. If urlRecord’s fragment is non-null, then throw a \"SyntaxError\"\n    //    DOMException.\n    if (urlRecord.hash) {\n      throw new DOMException('Got fragment', 'SyntaxError')\n    }\n\n    // 5. If protocols is a string, set protocols to a sequence consisting\n    //    of just that string.\n    if (typeof protocols === 'string') {\n      protocols = [protocols]\n    }\n\n    // 6. If any of the values in protocols occur more than once or otherwise\n    //    fail to match the requirements for elements that comprise the value\n    //    of `Sec-WebSocket-Protocol` fields as defined by The WebSocket\n    //    protocol, then throw a \"SyntaxError\" DOMException.\n    if (protocols.length !== new Set(protocols.map(p => p.toLowerCase())).size) {\n      throw new DOMException('Invalid Sec-WebSocket-Protocol value', 'SyntaxError')\n    }\n\n    if (protocols.length > 0 && !protocols.every(p => isValidSubprotocol(p))) {\n      throw new DOMException('Invalid Sec-WebSocket-Protocol value', 'SyntaxError')\n    }\n\n    // 7. Set this's url to urlRecord.\n    this[kWebSocketURL] = urlRecord\n\n    // 8. Let client be this's relevant settings object.\n\n    // 9. Run this step in parallel:\n\n    //    1. Establish a WebSocket connection given urlRecord, protocols,\n    //       and client.\n    this[kController] = establishWebSocketConnection(urlRecord, protocols, this)\n\n    // Each WebSocket object has an associated ready state, which is a\n    // number representing the state of the connection. Initially it must\n    // be CONNECTING (0).\n    this[kReadyState] = WebSocket.CONNECTING\n\n    // The extensions attribute must initially return the empty string.\n    this[kExtensions] = ''\n\n    // The protocol attribute must initially return the empty string.\n    this[kProtocol] = ''\n\n    // Each WebSocket object has an associated binary type, which is a\n    // BinaryType. Initially it must be \"blob\".\n    this[kBinaryType] = 'blob'\n  }\n\n  /**\n   * @see https://websockets.spec.whatwg.org/#dom-websocket-close\n   * @param {number|undefined} code\n   * @param {string|undefined} reason\n   */\n  close (code = undefined, reason = undefined) {\n    webidl.brandCheck(this, WebSocket)\n\n    if (code !== undefined) {\n      code = webidl.converters['unsigned short'](code, { clamp: true })\n    }\n\n    if (reason !== undefined) {\n      reason = webidl.converters.USVString(reason)\n    }\n\n    // 1. If code is present, but is neither an integer equal to 1000 nor an\n    //    integer in the range 3000 to 4999, inclusive, throw an\n    //    \"InvalidAccessError\" DOMException.\n    if (code !== undefined) {\n      if (code !== 1000 && (code < 3000 || code > 4999)) {\n        throw new DOMException('invalid code', 'InvalidAccessError')\n      }\n    }\n\n    let reasonByteLength = 0\n\n    // 2. If reason is present, then run these substeps:\n    if (reason !== undefined) {\n      // 1. Let reasonBytes be the result of encoding reason.\n      // 2. If reasonBytes is longer than 123 bytes, then throw a\n      //    \"SyntaxError\" DOMException.\n      reasonByteLength = Buffer.byteLength(reason)\n\n      if (reasonByteLength > 123) {\n        throw new DOMException(\n          `Reason must be less than 123 bytes; received ${reasonByteLength}`,\n          'SyntaxError'\n        )\n      }\n    }\n\n    // 3. Run the first matching steps from the following list:\n    if (this[kReadyState] === WebSocket.CLOSING || this[kReadyState] === WebSocket.CLOSED) {\n      // If this's ready state is CLOSING (2) or CLOSED (3)\n      // Do nothing.\n    } else if (!isEstablished(this)) {\n      // If the WebSocket connection is not yet established\n      // Fail the WebSocket connection and set this's ready state\n      // to CLOSING (2).\n      failWebsocketConnection(this, 'Connection was closed before it was established.')\n      this[kReadyState] = WebSocket.CLOSING\n    } else if (!isClosing(this)) {\n      // If the WebSocket closing handshake has not yet been started\n      // Start the WebSocket closing handshake and set this's ready\n      // state to CLOSING (2).\n      // - If neither code nor reason is present, the WebSocket Close\n      //   message must not have a body.\n      // - If code is present, then the status code to use in the\n      //   WebSocket Close message must be the integer given by code.\n      // - If reason is also present, then reasonBytes must be\n      //   provided in the Close message after the status code.\n\n      const frame = new WebsocketFrameSend()\n\n      // If neither code nor reason is present, the WebSocket Close\n      // message must not have a body.\n\n      // If code is present, then the status code to use in the\n      // WebSocket Close message must be the integer given by code.\n      if (code !== undefined && reason === undefined) {\n        frame.frameData = Buffer.allocUnsafe(2)\n        frame.frameData.writeUInt16BE(code, 0)\n      } else if (code !== undefined && reason !== undefined) {\n        // If reason is also present, then reasonBytes must be\n        // provided in the Close message after the status code.\n        frame.frameData = Buffer.allocUnsafe(2 + reasonByteLength)\n        frame.frameData.writeUInt16BE(code, 0)\n        // the body MAY contain UTF-8-encoded data with value /reason/\n        frame.frameData.write(reason, 2, 'utf-8')\n      } else {\n        frame.frameData = emptyBuffer\n      }\n\n      /** @type {import('stream').Duplex} */\n      const socket = this[kResponse].socket\n\n      socket.write(frame.createFrame(opcodes.CLOSE), (err) => {\n        if (!err) {\n          this[kSentClose] = true\n        }\n      })\n\n      // Upon either sending or receiving a Close control frame, it is said\n      // that _The WebSocket Closing Handshake is Started_ and that the\n      // WebSocket connection is in the CLOSING state.\n      this[kReadyState] = states.CLOSING\n    } else {\n      // Otherwise\n      // Set this's ready state to CLOSING (2).\n      this[kReadyState] = WebSocket.CLOSING\n    }\n  }\n\n  /**\n   * @see https://websockets.spec.whatwg.org/#dom-websocket-send\n   * @param {NodeJS.TypedArray|ArrayBuffer|Blob|string} data\n   */\n  send (data) {\n    webidl.brandCheck(this, WebSocket)\n\n    webidl.argumentLengthCheck(arguments, 1, { header: 'WebSocket.send' })\n\n    data = webidl.converters.WebSocketSendData(data)\n\n    // 1. If this's ready state is CONNECTING, then throw an\n    //    \"InvalidStateError\" DOMException.\n    if (this[kReadyState] === WebSocket.CONNECTING) {\n      throw new DOMException('Sent before connected.', 'InvalidStateError')\n    }\n\n    // 2. Run the appropriate set of steps from the following list:\n    // https://datatracker.ietf.org/doc/html/rfc6455#section-6.1\n    // https://datatracker.ietf.org/doc/html/rfc6455#section-5.2\n\n    if (!isEstablished(this) || isClosing(this)) {\n      return\n    }\n\n    /** @type {import('stream').Duplex} */\n    const socket = this[kResponse].socket\n\n    // If data is a string\n    if (typeof data === 'string') {\n      // If the WebSocket connection is established and the WebSocket\n      // closing handshake has not yet started, then the user agent\n      // must send a WebSocket Message comprised of the data argument\n      // using a text frame opcode; if the data cannot be sent, e.g.\n      // because it would need to be buffered but the buffer is full,\n      // the user agent must flag the WebSocket as full and then close\n      // the WebSocket connection. Any invocation of this method with a\n      // string argument that does not throw an exception must increase\n      // the bufferedAmount attribute by the number of bytes needed to\n      // express the argument as UTF-8.\n\n      const value = Buffer.from(data)\n      const frame = new WebsocketFrameSend(value)\n      const buffer = frame.createFrame(opcodes.TEXT)\n\n      this.#bufferedAmount += value.byteLength\n      socket.write(buffer, () => {\n        this.#bufferedAmount -= value.byteLength\n      })\n    } else if (types.isArrayBuffer(data)) {\n      // If the WebSocket connection is established, and the WebSocket\n      // closing handshake has not yet started, then the user agent must\n      // send a WebSocket Message comprised of data using a binary frame\n      // opcode; if the data cannot be sent, e.g. because it would need\n      // to be buffered but the buffer is full, the user agent must flag\n      // the WebSocket as full and then close the WebSocket connection.\n      // The data to be sent is the data stored in the buffer described\n      // by the ArrayBuffer object. Any invocation of this method with an\n      // ArrayBuffer argument that does not throw an exception must\n      // increase the bufferedAmount attribute by the length of the\n      // ArrayBuffer in bytes.\n\n      const value = Buffer.from(data)\n      const frame = new WebsocketFrameSend(value)\n      const buffer = frame.createFrame(opcodes.BINARY)\n\n      this.#bufferedAmount += value.byteLength\n      socket.write(buffer, () => {\n        this.#bufferedAmount -= value.byteLength\n      })\n    } else if (ArrayBuffer.isView(data)) {\n      // If the WebSocket connection is established, and the WebSocket\n      // closing handshake has not yet started, then the user agent must\n      // send a WebSocket Message comprised of data using a binary frame\n      // opcode; if the data cannot be sent, e.g. because it would need to\n      // be buffered but the buffer is full, the user agent must flag the\n      // WebSocket as full and then close the WebSocket connection. The\n      // data to be sent is the data stored in the section of the buffer\n      // described by the ArrayBuffer object that data references. Any\n      // invocation of this method with this kind of argument that does\n      // not throw an exception must increase the bufferedAmount attribute\n      // by the length of data’s buffer in bytes.\n\n      const ab = Buffer.from(data, data.byteOffset, data.byteLength)\n\n      const frame = new WebsocketFrameSend(ab)\n      const buffer = frame.createFrame(opcodes.BINARY)\n\n      this.#bufferedAmount += ab.byteLength\n      socket.write(buffer, () => {\n        this.#bufferedAmount -= ab.byteLength\n      })\n    } else if (isBlobLike(data)) {\n      // If the WebSocket connection is established, and the WebSocket\n      // closing handshake has not yet started, then the user agent must\n      // send a WebSocket Message comprised of data using a binary frame\n      // opcode; if the data cannot be sent, e.g. because it would need to\n      // be buffered but the buffer is full, the user agent must flag the\n      // WebSocket as full and then close the WebSocket connection. The data\n      // to be sent is the raw data represented by the Blob object. Any\n      // invocation of this method with a Blob argument that does not throw\n      // an exception must increase the bufferedAmount attribute by the size\n      // of the Blob object’s raw data, in bytes.\n\n      const frame = new WebsocketFrameSend()\n\n      data.arrayBuffer().then((ab) => {\n        const value = Buffer.from(ab)\n        frame.frameData = value\n        const buffer = frame.createFrame(opcodes.BINARY)\n\n        this.#bufferedAmount += value.byteLength\n        socket.write(buffer, () => {\n          this.#bufferedAmount -= value.byteLength\n        })\n      })\n    }\n  }\n\n  get readyState () {\n    webidl.brandCheck(this, WebSocket)\n\n    // The readyState getter steps are to return this's ready state.\n    return this[kReadyState]\n  }\n\n  get bufferedAmount () {\n    webidl.brandCheck(this, WebSocket)\n\n    return this.#bufferedAmount\n  }\n\n  get url () {\n    webidl.brandCheck(this, WebSocket)\n\n    // The url getter steps are to return this's url, serialized.\n    return URLSerializer(this[kWebSocketURL])\n  }\n\n  get extensions () {\n    webidl.brandCheck(this, WebSocket)\n\n    return this[kExtensions]\n  }\n\n  get protocol () {\n    webidl.brandCheck(this, WebSocket)\n\n    return this[kProtocol]\n  }\n\n  get onopen () {\n    webidl.brandCheck(this, WebSocket)\n\n    return this.#events.open\n  }\n\n  set onopen (fn) {\n    webidl.brandCheck(this, WebSocket)\n\n    if (this.#events.open) {\n      this.removeEventListener('open', this.#events.open)\n    }\n\n    if (typeof fn === 'function') {\n      this.#events.open = fn\n      this.addEventListener('open', fn)\n    } else {\n      this.#events.open = null\n    }\n  }\n\n  get onerror () {\n    webidl.brandCheck(this, WebSocket)\n\n    return this.#events.error\n  }\n\n  set onerror (fn) {\n    webidl.brandCheck(this, WebSocket)\n\n    if (this.#events.error) {\n      this.removeEventListener('error', this.#events.error)\n    }\n\n    if (typeof fn === 'function') {\n      this.#events.error = fn\n      this.addEventListener('error', fn)\n    } else {\n      this.#events.error = null\n    }\n  }\n\n  get onclose () {\n    webidl.brandCheck(this, WebSocket)\n\n    return this.#events.close\n  }\n\n  set onclose (fn) {\n    webidl.brandCheck(this, WebSocket)\n\n    if (this.#events.close) {\n      this.removeEventListener('close', this.#events.close)\n    }\n\n    if (typeof fn === 'function') {\n      this.#events.close = fn\n      this.addEventListener('close', fn)\n    } else {\n      this.#events.close = null\n    }\n  }\n\n  get onmessage () {\n    webidl.brandCheck(this, WebSocket)\n\n    return this.#events.message\n  }\n\n  set onmessage (fn) {\n    webidl.brandCheck(this, WebSocket)\n\n    if (this.#events.message) {\n      this.removeEventListener('message', this.#events.message)\n    }\n\n    if (typeof fn === 'function') {\n      this.#events.message = fn\n      this.addEventListener('message', fn)\n    } else {\n      this.#events.message = null\n    }\n  }\n\n  get binaryType () {\n    webidl.brandCheck(this, WebSocket)\n\n    return this[kBinaryType]\n  }\n\n  set binaryType (type) {\n    webidl.brandCheck(this, WebSocket)\n\n    if (type !== 'blob' && type !== 'arraybuffer') {\n      this[kBinaryType] = 'blob'\n    } else {\n      this[kBinaryType] = type\n    }\n  }\n}\n\n// https://websockets.spec.whatwg.org/#dom-websocket-connecting\nWebSocket.CONNECTING = WebSocket.prototype.CONNECTING = states.CONNECTING\n// https://websockets.spec.whatwg.org/#dom-websocket-open\nWebSocket.OPEN = WebSocket.prototype.OPEN = states.OPEN\n// https://websockets.spec.whatwg.org/#dom-websocket-closing\nWebSocket.CLOSING = WebSocket.prototype.CLOSING = states.CLOSING\n// https://websockets.spec.whatwg.org/#dom-websocket-closed\nWebSocket.CLOSED = WebSocket.prototype.CLOSED = states.CLOSED\n\nObject.defineProperties(WebSocket.prototype, {\n  CONNECTING: staticPropertyDescriptors,\n  OPEN: staticPropertyDescriptors,\n  CLOSING: staticPropertyDescriptors,\n  CLOSED: staticPropertyDescriptors,\n  url: kEnumerableProperty,\n  readyState: kEnumerableProperty,\n  bufferedAmount: kEnumerableProperty,\n  onopen: kEnumerableProperty,\n  onerror: kEnumerableProperty,\n  onclose: kEnumerableProperty,\n  close: kEnumerableProperty,\n  onmessage: kEnumerableProperty,\n  binaryType: kEnumerableProperty,\n  send: kEnumerableProperty,\n  extensions: kEnumerableProperty,\n  protocol: kEnumerableProperty,\n  [Symbol.toStringTag]: {\n    value: 'WebSocket',\n    writable: false,\n    enumerable: false,\n    configurable: true\n  }\n})\n\nObject.defineProperties(WebSocket, {\n  CONNECTING: staticPropertyDescriptors,\n  OPEN: staticPropertyDescriptors,\n  CLOSING: staticPropertyDescriptors,\n  CLOSED: staticPropertyDescriptors\n})\n\nwebidl.converters['sequence<DOMString>'] = webidl.sequenceConverter(\n  webidl.converters.DOMString\n)\n\nwebidl.converters['DOMString or sequence<DOMString>'] = function (V) {\n  if (webidl.util.Type(V) === 'Object' && Symbol.iterator in V) {\n    return webidl.converters['sequence<DOMString>'](V)\n  }\n\n  return webidl.converters.DOMString(V)\n}\n\nwebidl.converters.WebSocketSendData = function (V) {\n  if (webidl.util.Type(V) === 'Object') {\n    if (isBlobLike(V)) {\n      return webidl.converters.Blob(V, { strict: false })\n    }\n\n    if (ArrayBuffer.isView(V) || types.isAnyArrayBuffer(V)) {\n      return webidl.converters.BufferSource(V)\n    }\n  }\n\n  return webidl.converters.USVString(V)\n}\n\nmodule.exports = {\n  WebSocket\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}