{"ast":null,"code":"/*istanbul ignore start*/\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports[\"default\"] = Diff;\n\n/*istanbul ignore end*/\nfunction Diff() {}\nDiff.prototype = {\n  /*istanbul ignore start*/\n\n  /*istanbul ignore end*/\n  diff: function diff(oldString, newString) {\n    /*istanbul ignore start*/\n    var /*istanbul ignore end*/\n    options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    var callback = options.callback;\n    if (typeof options === 'function') {\n      callback = options;\n      options = {};\n    }\n    this.options = options;\n    var self = this;\n    function done(value) {\n      if (callback) {\n        setTimeout(function () {\n          callback(undefined, value);\n        }, 0);\n        return true;\n      } else {\n        return value;\n      }\n    } // Allow subclasses to massage the input prior to running\n\n    oldString = this.castInput(oldString);\n    newString = this.castInput(newString);\n    oldString = this.removeEmpty(this.tokenize(oldString));\n    newString = this.removeEmpty(this.tokenize(newString));\n    var newLen = newString.length,\n      oldLen = oldString.length;\n    var editLength = 1;\n    var maxEditLength = newLen + oldLen;\n    var bestPath = [{\n      newPos: -1,\n      components: []\n    }]; // Seed editLength = 0, i.e. the content starts with the same values\n\n    var oldPos = this.extractCommon(bestPath[0], newString, oldString, 0);\n    if (bestPath[0].newPos + 1 >= newLen && oldPos + 1 >= oldLen) {\n      // Identity per the equality and tokenizer\n      return done([{\n        value: this.join(newString),\n        count: newString.length\n      }]);\n    } // Main worker method. checks all permutations of a given edit length for acceptance.\n\n    function execEditLength() {\n      for (var diagonalPath = -1 * editLength; diagonalPath <= editLength; diagonalPath += 2) {\n        var basePath = /*istanbul ignore start*/\n        void 0\n        /*istanbul ignore end*/;\n\n        var addPath = bestPath[diagonalPath - 1],\n          removePath = bestPath[diagonalPath + 1],\n          _oldPos = (removePath ? removePath.newPos : 0) - diagonalPath;\n        if (addPath) {\n          // No one else is going to attempt to use this value, clear it\n          bestPath[diagonalPath - 1] = undefined;\n        }\n        var canAdd = addPath && addPath.newPos + 1 < newLen,\n          canRemove = removePath && 0 <= _oldPos && _oldPos < oldLen;\n        if (!canAdd && !canRemove) {\n          // If this path is a terminal then prune\n          bestPath[diagonalPath] = undefined;\n          continue;\n        } // Select the diagonal that we want to branch from. We select the prior\n        // path whose position in the new string is the farthest from the origin\n        // and does not pass the bounds of the diff graph\n\n        if (!canAdd || canRemove && addPath.newPos < removePath.newPos) {\n          basePath = clonePath(removePath);\n          self.pushComponent(basePath.components, undefined, true);\n        } else {\n          basePath = addPath; // No need to clone, we've pulled it from the list\n\n          basePath.newPos++;\n          self.pushComponent(basePath.components, true, undefined);\n        }\n        _oldPos = self.extractCommon(basePath, newString, oldString, diagonalPath); // If we have hit the end of both strings, then we are done\n\n        if (basePath.newPos + 1 >= newLen && _oldPos + 1 >= oldLen) {\n          return done(buildValues(self, basePath.components, newString, oldString, self.useLongestToken));\n        } else {\n          // Otherwise track this path as a potential candidate and continue.\n          bestPath[diagonalPath] = basePath;\n        }\n      }\n      editLength++;\n    } // Performs the length of edit iteration. Is a bit fugly as this has to support the\n    // sync and async mode which is never fun. Loops over execEditLength until a value\n    // is produced.\n\n    if (callback) {\n      (function exec() {\n        setTimeout(function () {\n          // This should not happen, but we want to be safe.\n\n          /* istanbul ignore next */\n          if (editLength > maxEditLength) {\n            return callback();\n          }\n          if (!execEditLength()) {\n            exec();\n          }\n        }, 0);\n      })();\n    } else {\n      while (editLength <= maxEditLength) {\n        var ret = execEditLength();\n        if (ret) {\n          return ret;\n        }\n      }\n    }\n  },\n  /*istanbul ignore start*/\n\n  /*istanbul ignore end*/\n  pushComponent: function pushComponent(components, added, removed) {\n    var last = components[components.length - 1];\n    if (last && last.added === added && last.removed === removed) {\n      // We need to clone here as the component clone operation is just\n      // as shallow array clone\n      components[components.length - 1] = {\n        count: last.count + 1,\n        added: added,\n        removed: removed\n      };\n    } else {\n      components.push({\n        count: 1,\n        added: added,\n        removed: removed\n      });\n    }\n  },\n  /*istanbul ignore start*/\n\n  /*istanbul ignore end*/\n  extractCommon: function extractCommon(basePath, newString, oldString, diagonalPath) {\n    var newLen = newString.length,\n      oldLen = oldString.length,\n      newPos = basePath.newPos,\n      oldPos = newPos - diagonalPath,\n      commonCount = 0;\n    while (newPos + 1 < newLen && oldPos + 1 < oldLen && this.equals(newString[newPos + 1], oldString[oldPos + 1])) {\n      newPos++;\n      oldPos++;\n      commonCount++;\n    }\n    if (commonCount) {\n      basePath.components.push({\n        count: commonCount\n      });\n    }\n    basePath.newPos = newPos;\n    return oldPos;\n  },\n  /*istanbul ignore start*/\n\n  /*istanbul ignore end*/\n  equals: function equals(left, right) {\n    if (this.options.comparator) {\n      return this.options.comparator(left, right);\n    } else {\n      return left === right || this.options.ignoreCase && left.toLowerCase() === right.toLowerCase();\n    }\n  },\n  /*istanbul ignore start*/\n\n  /*istanbul ignore end*/\n  removeEmpty: function removeEmpty(array) {\n    var ret = [];\n    for (var i = 0; i < array.length; i++) {\n      if (array[i]) {\n        ret.push(array[i]);\n      }\n    }\n    return ret;\n  },\n  /*istanbul ignore start*/\n\n  /*istanbul ignore end*/\n  castInput: function castInput(value) {\n    return value;\n  },\n  /*istanbul ignore start*/\n\n  /*istanbul ignore end*/\n  tokenize: function tokenize(value) {\n    return value.split('');\n  },\n  /*istanbul ignore start*/\n\n  /*istanbul ignore end*/\n  join: function join(chars) {\n    return chars.join('');\n  }\n};\nfunction buildValues(diff, components, newString, oldString, useLongestToken) {\n  var componentPos = 0,\n    componentLen = components.length,\n    newPos = 0,\n    oldPos = 0;\n  for (; componentPos < componentLen; componentPos++) {\n    var component = components[componentPos];\n    if (!component.removed) {\n      if (!component.added && useLongestToken) {\n        var value = newString.slice(newPos, newPos + component.count);\n        value = value.map(function (value, i) {\n          var oldValue = oldString[oldPos + i];\n          return oldValue.length > value.length ? oldValue : value;\n        });\n        component.value = diff.join(value);\n      } else {\n        component.value = diff.join(newString.slice(newPos, newPos + component.count));\n      }\n      newPos += component.count; // Common case\n\n      if (!component.added) {\n        oldPos += component.count;\n      }\n    } else {\n      component.value = diff.join(oldString.slice(oldPos, oldPos + component.count));\n      oldPos += component.count; // Reverse add and remove so removes are output first to match common convention\n      // The diffing algorithm is tied to add then remove output and this is the simplest\n      // route to get the desired output with minimal overhead.\n\n      if (componentPos && components[componentPos - 1].added) {\n        var tmp = components[componentPos - 1];\n        components[componentPos - 1] = components[componentPos];\n        components[componentPos] = tmp;\n      }\n    }\n  } // Special case handle for when one terminal is ignored (i.e. whitespace).\n  // For this case we merge the terminal into the prior string and drop the change.\n  // This is only available for string mode.\n\n  var lastComponent = components[componentLen - 1];\n  if (componentLen > 1 && typeof lastComponent.value === 'string' && (lastComponent.added || lastComponent.removed) && diff.equals('', lastComponent.value)) {\n    components[componentLen - 2].value += lastComponent.value;\n    components.pop();\n  }\n  return components;\n}\nfunction clonePath(path) {\n  return {\n    newPos: path.newPos,\n    components: path.components.slice(0)\n  };\n}","map":{"version":3,"mappings":"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","names":["Diff","prototype","diff","oldString","newString","options","callback","self","done","value","setTimeout","undefined","castInput","removeEmpty","tokenize","newLen","length","oldLen","editLength","maxEditLength","bestPath","newPos","components","oldPos","extractCommon","join","count","execEditLength","diagonalPath","basePath","addPath","removePath","canAdd","canRemove","clonePath","pushComponent","buildValues","useLongestToken","exec","ret","added","removed","last","push","commonCount","equals","left","right","comparator","ignoreCase","toLowerCase","array","i","split","chars","componentPos","componentLen","component","slice","map","oldValue","tmp","lastComponent","pop","path"],"sources":["/Users/janrobel/Documents/PersonalProjekty/nftGenerateAi/clientAndContract/node_modules/diff/src/diff/base.js"],"sourcesContent":["export default function Diff() {}\n\nDiff.prototype = {\n  diff(oldString, newString, options = {}) {\n    let callback = options.callback;\n    if (typeof options === 'function') {\n      callback = options;\n      options = {};\n    }\n    this.options = options;\n\n    let self = this;\n\n    function done(value) {\n      if (callback) {\n        setTimeout(function() { callback(undefined, value); }, 0);\n        return true;\n      } else {\n        return value;\n      }\n    }\n\n    // Allow subclasses to massage the input prior to running\n    oldString = this.castInput(oldString);\n    newString = this.castInput(newString);\n\n    oldString = this.removeEmpty(this.tokenize(oldString));\n    newString = this.removeEmpty(this.tokenize(newString));\n\n    let newLen = newString.length, oldLen = oldString.length;\n    let editLength = 1;\n    let maxEditLength = newLen + oldLen;\n    let bestPath = [{ newPos: -1, components: [] }];\n\n    // Seed editLength = 0, i.e. the content starts with the same values\n    let oldPos = this.extractCommon(bestPath[0], newString, oldString, 0);\n    if (bestPath[0].newPos + 1 >= newLen && oldPos + 1 >= oldLen) {\n      // Identity per the equality and tokenizer\n      return done([{value: this.join(newString), count: newString.length}]);\n    }\n\n    // Main worker method. checks all permutations of a given edit length for acceptance.\n    function execEditLength() {\n      for (let diagonalPath = -1 * editLength; diagonalPath <= editLength; diagonalPath += 2) {\n        let basePath;\n        let addPath = bestPath[diagonalPath - 1],\n            removePath = bestPath[diagonalPath + 1],\n            oldPos = (removePath ? removePath.newPos : 0) - diagonalPath;\n        if (addPath) {\n          // No one else is going to attempt to use this value, clear it\n          bestPath[diagonalPath - 1] = undefined;\n        }\n\n        let canAdd = addPath && addPath.newPos + 1 < newLen,\n            canRemove = removePath && 0 <= oldPos && oldPos < oldLen;\n        if (!canAdd && !canRemove) {\n          // If this path is a terminal then prune\n          bestPath[diagonalPath] = undefined;\n          continue;\n        }\n\n        // Select the diagonal that we want to branch from. We select the prior\n        // path whose position in the new string is the farthest from the origin\n        // and does not pass the bounds of the diff graph\n        if (!canAdd || (canRemove && addPath.newPos < removePath.newPos)) {\n          basePath = clonePath(removePath);\n          self.pushComponent(basePath.components, undefined, true);\n        } else {\n          basePath = addPath; // No need to clone, we've pulled it from the list\n          basePath.newPos++;\n          self.pushComponent(basePath.components, true, undefined);\n        }\n\n        oldPos = self.extractCommon(basePath, newString, oldString, diagonalPath);\n\n        // If we have hit the end of both strings, then we are done\n        if (basePath.newPos + 1 >= newLen && oldPos + 1 >= oldLen) {\n          return done(buildValues(self, basePath.components, newString, oldString, self.useLongestToken));\n        } else {\n          // Otherwise track this path as a potential candidate and continue.\n          bestPath[diagonalPath] = basePath;\n        }\n      }\n\n      editLength++;\n    }\n\n    // Performs the length of edit iteration. Is a bit fugly as this has to support the\n    // sync and async mode which is never fun. Loops over execEditLength until a value\n    // is produced.\n    if (callback) {\n      (function exec() {\n        setTimeout(function() {\n          // This should not happen, but we want to be safe.\n          /* istanbul ignore next */\n          if (editLength > maxEditLength) {\n            return callback();\n          }\n\n          if (!execEditLength()) {\n            exec();\n          }\n        }, 0);\n      }());\n    } else {\n      while (editLength <= maxEditLength) {\n        let ret = execEditLength();\n        if (ret) {\n          return ret;\n        }\n      }\n    }\n  },\n\n  pushComponent(components, added, removed) {\n    let last = components[components.length - 1];\n    if (last && last.added === added && last.removed === removed) {\n      // We need to clone here as the component clone operation is just\n      // as shallow array clone\n      components[components.length - 1] = {count: last.count + 1, added: added, removed: removed };\n    } else {\n      components.push({count: 1, added: added, removed: removed });\n    }\n  },\n  extractCommon(basePath, newString, oldString, diagonalPath) {\n    let newLen = newString.length,\n        oldLen = oldString.length,\n        newPos = basePath.newPos,\n        oldPos = newPos - diagonalPath,\n\n        commonCount = 0;\n    while (newPos + 1 < newLen && oldPos + 1 < oldLen && this.equals(newString[newPos + 1], oldString[oldPos + 1])) {\n      newPos++;\n      oldPos++;\n      commonCount++;\n    }\n\n    if (commonCount) {\n      basePath.components.push({count: commonCount});\n    }\n\n    basePath.newPos = newPos;\n    return oldPos;\n  },\n\n  equals(left, right) {\n    if (this.options.comparator) {\n      return this.options.comparator(left, right);\n    } else {\n      return left === right\n        || (this.options.ignoreCase && left.toLowerCase() === right.toLowerCase());\n    }\n  },\n  removeEmpty(array) {\n    let ret = [];\n    for (let i = 0; i < array.length; i++) {\n      if (array[i]) {\n        ret.push(array[i]);\n      }\n    }\n    return ret;\n  },\n  castInput(value) {\n    return value;\n  },\n  tokenize(value) {\n    return value.split('');\n  },\n  join(chars) {\n    return chars.join('');\n  }\n};\n\nfunction buildValues(diff, components, newString, oldString, useLongestToken) {\n  let componentPos = 0,\n      componentLen = components.length,\n      newPos = 0,\n      oldPos = 0;\n\n  for (; componentPos < componentLen; componentPos++) {\n    let component = components[componentPos];\n    if (!component.removed) {\n      if (!component.added && useLongestToken) {\n        let value = newString.slice(newPos, newPos + component.count);\n        value = value.map(function(value, i) {\n          let oldValue = oldString[oldPos + i];\n          return oldValue.length > value.length ? oldValue : value;\n        });\n\n        component.value = diff.join(value);\n      } else {\n        component.value = diff.join(newString.slice(newPos, newPos + component.count));\n      }\n      newPos += component.count;\n\n      // Common case\n      if (!component.added) {\n        oldPos += component.count;\n      }\n    } else {\n      component.value = diff.join(oldString.slice(oldPos, oldPos + component.count));\n      oldPos += component.count;\n\n      // Reverse add and remove so removes are output first to match common convention\n      // The diffing algorithm is tied to add then remove output and this is the simplest\n      // route to get the desired output with minimal overhead.\n      if (componentPos && components[componentPos - 1].added) {\n        let tmp = components[componentPos - 1];\n        components[componentPos - 1] = components[componentPos];\n        components[componentPos] = tmp;\n      }\n    }\n  }\n\n  // Special case handle for when one terminal is ignored (i.e. whitespace).\n  // For this case we merge the terminal into the prior string and drop the change.\n  // This is only available for string mode.\n  let lastComponent = components[componentLen - 1];\n  if (componentLen > 1\n      && typeof lastComponent.value === 'string'\n      && (lastComponent.added || lastComponent.removed)\n      && diff.equals('', lastComponent.value)) {\n    components[componentLen - 2].value += lastComponent.value;\n    components.pop();\n  }\n\n  return components;\n}\n\nfunction clonePath(path) {\n  return { newPos: path.newPos, components: path.components.slice(0) };\n}\n"]},"metadata":{},"sourceType":"script","externalDependencies":[]}