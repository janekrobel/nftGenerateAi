{"ast":null,"code":"\"use strict\";\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.resolveProjectPaths = exports.resolveConfig = void 0;\nconst cloneDeep_1 = __importDefault(require(\"lodash/cloneDeep\"));\nconst path_1 = __importDefault(require(\"path\"));\nconst constants_1 = require(\"../../constants\");\nconst lang_1 = require(\"../../util/lang\");\nconst errors_1 = require(\"../errors\");\nconst fs_utils_1 = require(\"../../util/fs-utils\");\nconst default_config_1 = require(\"./default-config\");\n/**\n * This functions resolves the hardhat config, setting its defaults and\n * normalizing its types if necessary.\n *\n * @param userConfigPath the user config filepath\n * @param userConfig     the user config object\n *\n * @returns the resolved config\n */\nfunction resolveConfig(userConfigPath, userConfig) {\n  userConfig = (0, cloneDeep_1.default)(userConfig);\n  return {\n    ...userConfig,\n    defaultNetwork: userConfig.defaultNetwork ?? default_config_1.defaultDefaultNetwork,\n    paths: resolveProjectPaths(userConfigPath, userConfig.paths),\n    networks: resolveNetworksConfig(userConfig.networks),\n    solidity: resolveSolidityConfig(userConfig),\n    mocha: resolveMochaConfig(userConfig)\n  };\n}\nexports.resolveConfig = resolveConfig;\nfunction resolveNetworksConfig() {\n  let networksConfig = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  const hardhatNetworkConfig = networksConfig[constants_1.HARDHAT_NETWORK_NAME];\n  const localhostNetworkConfig = networksConfig.localhost ?? undefined;\n  const hardhat = resolveHardhatNetworkConfig(hardhatNetworkConfig);\n  const localhost = resolveHttpNetworkConfig({\n    ...(0, cloneDeep_1.default)(default_config_1.defaultLocalhostNetworkParams),\n    ...localhostNetworkConfig\n  });\n  const otherNetworks = (0, lang_1.fromEntries)(Object.entries(networksConfig).filter(_ref => {\n    let [name, config] = _ref;\n    return name !== \"localhost\" && name !== \"hardhat\" && config !== undefined && isHttpNetworkConfig(config);\n  }).map(_ref2 => {\n    let [name, config] = _ref2;\n    return [name, resolveHttpNetworkConfig(config)];\n  }));\n  return {\n    hardhat,\n    localhost,\n    ...otherNetworks\n  };\n}\nfunction isHttpNetworkConfig(config) {\n  return \"url\" in config;\n}\nfunction normalizeHexString(str) {\n  const normalized = str.trim().toLowerCase();\n  if (normalized.startsWith(\"0x\")) {\n    return normalized;\n  }\n  return `0x${normalized}`;\n}\nfunction resolveHardhatNetworkConfig() {\n  let hardhatNetworkConfig = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  const clonedDefaultHardhatNetworkParams = (0, cloneDeep_1.default)(default_config_1.defaultHardhatNetworkParams);\n  const accounts = hardhatNetworkConfig.accounts === undefined ? default_config_1.defaultHardhatNetworkHdAccountsConfigParams : Array.isArray(hardhatNetworkConfig.accounts) ? hardhatNetworkConfig.accounts.map(_ref3 => {\n    let {\n      privateKey,\n      balance\n    } = _ref3;\n    return {\n      privateKey: normalizeHexString(privateKey),\n      balance\n    };\n  }) : {\n    ...default_config_1.defaultHardhatNetworkHdAccountsConfigParams,\n    ...hardhatNetworkConfig.accounts\n  };\n  const forking = hardhatNetworkConfig.forking !== undefined ? {\n    url: hardhatNetworkConfig.forking.url,\n    enabled: hardhatNetworkConfig.forking.enabled ?? true,\n    httpHeaders: {}\n  } : undefined;\n  if (forking !== undefined) {\n    const blockNumber = hardhatNetworkConfig?.forking?.blockNumber;\n    if (blockNumber !== undefined) {\n      forking.blockNumber = hardhatNetworkConfig?.forking?.blockNumber;\n    }\n    const httpHeaders = hardhatNetworkConfig.forking?.httpHeaders;\n    if (httpHeaders !== undefined) {\n      forking.httpHeaders = httpHeaders;\n    }\n  }\n  const mining = resolveMiningConfig(hardhatNetworkConfig.mining);\n  const minGasPrice = BigInt(hardhatNetworkConfig.minGasPrice ?? clonedDefaultHardhatNetworkParams.minGasPrice);\n  const blockGasLimit = hardhatNetworkConfig.blockGasLimit ?? clonedDefaultHardhatNetworkParams.blockGasLimit;\n  const gas = hardhatNetworkConfig.gas ?? blockGasLimit;\n  const gasPrice = hardhatNetworkConfig.gasPrice ?? clonedDefaultHardhatNetworkParams.gasPrice;\n  const initialBaseFeePerGas = hardhatNetworkConfig.initialBaseFeePerGas ?? clonedDefaultHardhatNetworkParams.initialBaseFeePerGas;\n  const initialDate = hardhatNetworkConfig.initialDate ?? new Date().toISOString();\n  const chains = new Map(default_config_1.defaultHardhatNetworkParams.chains);\n  if (hardhatNetworkConfig.chains !== undefined) {\n    for (const [chainId, userChainConfig] of Object.entries(hardhatNetworkConfig.chains)) {\n      const chainConfig = {\n        hardforkHistory: new Map()\n      };\n      if (userChainConfig.hardforkHistory !== undefined) {\n        for (const [name, block] of Object.entries(userChainConfig.hardforkHistory)) {\n          chainConfig.hardforkHistory.set(name, block);\n        }\n      }\n      chains.set(parseInt(chainId, 10), chainConfig);\n    }\n  }\n  const config = {\n    ...clonedDefaultHardhatNetworkParams,\n    ...hardhatNetworkConfig,\n    accounts,\n    forking,\n    mining,\n    blockGasLimit,\n    gas,\n    gasPrice,\n    initialBaseFeePerGas,\n    initialDate,\n    minGasPrice,\n    chains\n  };\n  // We do it this way because ts gets lost otherwise\n  if (config.forking === undefined) {\n    delete config.forking;\n  }\n  if (config.initialBaseFeePerGas === undefined) {\n    delete config.initialBaseFeePerGas;\n  }\n  return config;\n}\nfunction isHdAccountsConfig(accounts) {\n  return typeof accounts === \"object\" && !Array.isArray(accounts);\n}\nfunction resolveHttpNetworkConfig(networkConfig) {\n  const accounts = networkConfig.accounts === undefined ? default_config_1.defaultHttpNetworkParams.accounts : isHdAccountsConfig(networkConfig.accounts) ? {\n    ...default_config_1.defaultHdAccountsConfigParams,\n    ...networkConfig.accounts\n  } : Array.isArray(networkConfig.accounts) ? networkConfig.accounts.map(normalizeHexString) : \"remote\";\n  const url = networkConfig.url;\n  (0, errors_1.assertHardhatInvariant)(url !== undefined, \"Invalid http network config provided. URL missing.\");\n  return {\n    ...(0, cloneDeep_1.default)(default_config_1.defaultHttpNetworkParams),\n    ...networkConfig,\n    accounts,\n    url,\n    gas: networkConfig.gas ?? default_config_1.defaultHttpNetworkParams.gas,\n    gasPrice: networkConfig.gasPrice ?? default_config_1.defaultHttpNetworkParams.gasPrice\n  };\n}\nfunction resolveMiningConfig(userConfig) {\n  const mempool = resolveMempoolConfig(userConfig?.mempool);\n  if (userConfig === undefined) {\n    return {\n      auto: true,\n      interval: 0,\n      mempool\n    };\n  }\n  const {\n    auto,\n    interval\n  } = userConfig;\n  if (auto === undefined && interval === undefined) {\n    return {\n      auto: true,\n      interval: 0,\n      mempool\n    };\n  }\n  if (auto === undefined && interval !== undefined) {\n    return {\n      auto: false,\n      interval,\n      mempool\n    };\n  }\n  if (auto !== undefined && interval === undefined) {\n    return {\n      auto,\n      interval: 0,\n      mempool\n    };\n  }\n  // ts can't infer it, but both values are defined here\n  return {\n    auto: auto,\n    interval: interval,\n    mempool\n  };\n}\nfunction resolveMempoolConfig(userConfig) {\n  if (userConfig === undefined) {\n    return {\n      order: \"priority\"\n    };\n  }\n  if (userConfig.order === undefined) {\n    return {\n      order: \"priority\"\n    };\n  }\n  return {\n    order: userConfig.order\n  };\n}\nfunction resolveSolidityConfig(userConfig) {\n  const userSolidityConfig = userConfig.solidity ?? default_config_1.DEFAULT_SOLC_VERSION;\n  const multiSolcConfig = normalizeSolidityConfig(userSolidityConfig);\n  const overrides = multiSolcConfig.overrides ?? {};\n  return {\n    compilers: multiSolcConfig.compilers.map(resolveCompiler),\n    overrides: (0, lang_1.fromEntries)(Object.entries(overrides).map(_ref4 => {\n      let [name, config] = _ref4;\n      return [name, resolveCompiler(config)];\n    }))\n  };\n}\nfunction normalizeSolidityConfig(solidityConfig) {\n  if (typeof solidityConfig === \"string\") {\n    return {\n      compilers: [{\n        version: solidityConfig\n      }]\n    };\n  }\n  if (\"version\" in solidityConfig) {\n    return {\n      compilers: [solidityConfig]\n    };\n  }\n  return solidityConfig;\n}\nfunction resolveCompiler(compiler) {\n  const resolved = {\n    version: compiler.version,\n    settings: compiler.settings ?? {}\n  };\n  resolved.settings.optimizer = {\n    enabled: false,\n    runs: 200,\n    ...resolved.settings.optimizer\n  };\n  if (resolved.settings.outputSelection === undefined) {\n    resolved.settings.outputSelection = {};\n  }\n  for (const [file, contractSelection] of Object.entries(default_config_1.defaultSolcOutputSelection)) {\n    if (resolved.settings.outputSelection[file] === undefined) {\n      resolved.settings.outputSelection[file] = {};\n    }\n    for (const [contract, outputs] of Object.entries(contractSelection)) {\n      if (resolved.settings.outputSelection[file][contract] === undefined) {\n        resolved.settings.outputSelection[file][contract] = [];\n      }\n      for (const output of outputs) {\n        const includesOutput = resolved.settings.outputSelection[file][contract].includes(output);\n        if (!includesOutput) {\n          resolved.settings.outputSelection[file][contract].push(output);\n        }\n      }\n    }\n  }\n  return resolved;\n}\nfunction resolveMochaConfig(userConfig) {\n  return {\n    ...(0, cloneDeep_1.default)(default_config_1.defaultMochaOptions),\n    ...userConfig.mocha\n  };\n}\n/**\n * This function resolves the ProjectPathsConfig object from the user-provided config\n * and its path. The logic of this is not obvious and should well be document.\n * The good thing is that most users will never use this.\n *\n * Explanation:\n *    - paths.configFile is not overridable\n *    - If a path is absolute it is used \"as is\".\n *    - If the root path is relative, it's resolved from paths.configFile's dir.\n *    - If any other path is relative, it's resolved from paths.root.\n *    - Plugin-defined paths are not resolved, but encouraged to follow the same pattern.\n */\nfunction resolveProjectPaths(userConfigPath) {\n  let userPaths = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  const configFile = (0, fs_utils_1.getRealPathSync)(userConfigPath);\n  const configDir = path_1.default.dirname(configFile);\n  const root = resolvePathFrom(configDir, \"\", userPaths.root);\n  return {\n    ...userPaths,\n    root,\n    configFile,\n    sources: resolvePathFrom(root, \"contracts\", userPaths.sources),\n    cache: resolvePathFrom(root, \"cache\", userPaths.cache),\n    artifacts: resolvePathFrom(root, \"artifacts\", userPaths.artifacts),\n    tests: resolvePathFrom(root, \"test\", userPaths.tests)\n  };\n}\nexports.resolveProjectPaths = resolveProjectPaths;\nfunction resolvePathFrom(from, defaultPath) {\n  let relativeOrAbsolutePath = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : defaultPath;\n  if (path_1.default.isAbsolute(relativeOrAbsolutePath)) {\n    return relativeOrAbsolutePath;\n  }\n  return path_1.default.join(from, relativeOrAbsolutePath);\n}","map":{"version":3,"mappings":"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","names":["resolveConfig","userConfigPath","userConfig","defaultNetwork","default_config_1","paths","resolveProjectPaths","networks","resolveNetworksConfig","solidity","resolveSolidityConfig","mocha","resolveMochaConfig","exports","networksConfig","hardhatNetworkConfig","constants_1","localhostNetworkConfig","localhost","undefined","hardhat","resolveHardhatNetworkConfig","resolveHttpNetworkConfig","otherNetworks","Object","entries","filter","name","config","isHttpNetworkConfig","map","normalizeHexString","str","normalized","trim","toLowerCase","startsWith","clonedDefaultHardhatNetworkParams","accounts","Array","isArray","privateKey","balance","forking","url","enabled","httpHeaders","blockNumber","mining","resolveMiningConfig","minGasPrice","BigInt","blockGasLimit","gas","gasPrice","initialBaseFeePerGas","initialDate","Date","toISOString","chains","Map","chainId","userChainConfig","chainConfig","hardforkHistory","block","set","parseInt","isHdAccountsConfig","networkConfig","mempool","resolveMempoolConfig","auto","interval","order","userSolidityConfig","multiSolcConfig","normalizeSolidityConfig","overrides","compilers","resolveCompiler","solidityConfig","version","compiler","resolved","settings","optimizer","runs","outputSelection","file","contractSelection","contract","outputs","output","includesOutput","includes","push","userPaths","configFile","configDir","path_1","dirname","root","resolvePathFrom","sources","cache","artifacts","tests","from","defaultPath","relativeOrAbsolutePath","isAbsolute","join"],"sources":["/Users/janrobel/Documents/PersonalProjekty/nftGenerateAi/clientAndContract/node_modules/hardhat/src/internal/core/config/config-resolution.ts"],"sourcesContent":["import cloneDeep from \"lodash/cloneDeep\";\nimport path from \"path\";\n\nimport {\n  HardhatConfig,\n  HardhatNetworkAccountsConfig,\n  HardhatNetworkChainConfig,\n  HardhatNetworkChainsConfig,\n  HardhatNetworkConfig,\n  HardhatNetworkForkingConfig,\n  HardhatNetworkMiningConfig,\n  HardhatNetworkMiningUserConfig,\n  HardhatNetworkMempoolConfig,\n  HardhatNetworkMempoolUserConfig,\n  HardhatNetworkUserConfig,\n  HardhatUserConfig,\n  HDAccountsUserConfig,\n  HttpNetworkAccountsConfig,\n  HttpNetworkAccountsUserConfig,\n  HttpNetworkConfig,\n  HttpNetworkUserConfig,\n  MultiSolcUserConfig,\n  NetworksConfig,\n  NetworksUserConfig,\n  NetworkUserConfig,\n  ProjectPathsConfig,\n  ProjectPathsUserConfig,\n  SolcConfig,\n  SolcUserConfig,\n  SolidityConfig,\n  SolidityUserConfig,\n} from \"../../../types\";\nimport { HARDHAT_NETWORK_NAME } from \"../../constants\";\nimport { HardforkName } from \"../../util/hardforks\";\nimport { fromEntries } from \"../../util/lang\";\nimport { assertHardhatInvariant } from \"../errors\";\n\nimport { getRealPathSync } from \"../../util/fs-utils\";\nimport {\n  DEFAULT_SOLC_VERSION,\n  defaultDefaultNetwork,\n  defaultHardhatNetworkHdAccountsConfigParams,\n  defaultHardhatNetworkParams,\n  defaultHdAccountsConfigParams,\n  defaultHttpNetworkParams,\n  defaultLocalhostNetworkParams,\n  defaultMochaOptions,\n  defaultSolcOutputSelection,\n} from \"./default-config\";\n\n/**\n * This functions resolves the hardhat config, setting its defaults and\n * normalizing its types if necessary.\n *\n * @param userConfigPath the user config filepath\n * @param userConfig     the user config object\n *\n * @returns the resolved config\n */\nexport function resolveConfig(\n  userConfigPath: string,\n  userConfig: HardhatUserConfig\n): HardhatConfig {\n  userConfig = cloneDeep(userConfig);\n\n  return {\n    ...userConfig,\n    defaultNetwork: userConfig.defaultNetwork ?? defaultDefaultNetwork,\n    paths: resolveProjectPaths(userConfigPath, userConfig.paths),\n    networks: resolveNetworksConfig(userConfig.networks),\n    solidity: resolveSolidityConfig(userConfig),\n    mocha: resolveMochaConfig(userConfig),\n  };\n}\n\nfunction resolveNetworksConfig(\n  networksConfig: NetworksUserConfig = {}\n): NetworksConfig {\n  const hardhatNetworkConfig = networksConfig[HARDHAT_NETWORK_NAME];\n\n  const localhostNetworkConfig =\n    (networksConfig.localhost as HttpNetworkUserConfig) ?? undefined;\n\n  const hardhat = resolveHardhatNetworkConfig(hardhatNetworkConfig);\n  const localhost = resolveHttpNetworkConfig({\n    ...cloneDeep(defaultLocalhostNetworkParams),\n    ...localhostNetworkConfig,\n  });\n\n  const otherNetworks: { [name: string]: HttpNetworkConfig } = fromEntries(\n    Object.entries(networksConfig)\n      .filter(\n        ([name, config]) =>\n          name !== \"localhost\" &&\n          name !== \"hardhat\" &&\n          config !== undefined &&\n          isHttpNetworkConfig(config)\n      )\n      .map(([name, config]) => [\n        name,\n        resolveHttpNetworkConfig(config as HttpNetworkUserConfig),\n      ])\n  );\n\n  return {\n    hardhat,\n    localhost,\n    ...otherNetworks,\n  };\n}\n\nfunction isHttpNetworkConfig(\n  config: NetworkUserConfig\n): config is HttpNetworkUserConfig {\n  return \"url\" in config;\n}\n\nfunction normalizeHexString(str: string): string {\n  const normalized = str.trim().toLowerCase();\n  if (normalized.startsWith(\"0x\")) {\n    return normalized;\n  }\n\n  return `0x${normalized}`;\n}\n\nfunction resolveHardhatNetworkConfig(\n  hardhatNetworkConfig: HardhatNetworkUserConfig = {}\n): HardhatNetworkConfig {\n  const clonedDefaultHardhatNetworkParams = cloneDeep(\n    defaultHardhatNetworkParams\n  );\n\n  const accounts: HardhatNetworkAccountsConfig =\n    hardhatNetworkConfig.accounts === undefined\n      ? defaultHardhatNetworkHdAccountsConfigParams\n      : Array.isArray(hardhatNetworkConfig.accounts)\n      ? hardhatNetworkConfig.accounts.map(({ privateKey, balance }) => ({\n          privateKey: normalizeHexString(privateKey),\n          balance,\n        }))\n      : {\n          ...defaultHardhatNetworkHdAccountsConfigParams,\n          ...hardhatNetworkConfig.accounts,\n        };\n\n  const forking: HardhatNetworkForkingConfig | undefined =\n    hardhatNetworkConfig.forking !== undefined\n      ? {\n          url: hardhatNetworkConfig.forking.url,\n          enabled: hardhatNetworkConfig.forking.enabled ?? true,\n          httpHeaders: {},\n        }\n      : undefined;\n\n  if (forking !== undefined) {\n    const blockNumber = hardhatNetworkConfig?.forking?.blockNumber;\n    if (blockNumber !== undefined) {\n      forking.blockNumber = hardhatNetworkConfig?.forking?.blockNumber;\n    }\n\n    const httpHeaders = hardhatNetworkConfig.forking?.httpHeaders;\n    if (httpHeaders !== undefined) {\n      forking.httpHeaders = httpHeaders;\n    }\n  }\n\n  const mining = resolveMiningConfig(hardhatNetworkConfig.mining);\n\n  const minGasPrice = BigInt(\n    hardhatNetworkConfig.minGasPrice ??\n      clonedDefaultHardhatNetworkParams.minGasPrice\n  );\n\n  const blockGasLimit =\n    hardhatNetworkConfig.blockGasLimit ??\n    clonedDefaultHardhatNetworkParams.blockGasLimit;\n\n  const gas = hardhatNetworkConfig.gas ?? blockGasLimit;\n  const gasPrice =\n    hardhatNetworkConfig.gasPrice ?? clonedDefaultHardhatNetworkParams.gasPrice;\n  const initialBaseFeePerGas =\n    hardhatNetworkConfig.initialBaseFeePerGas ??\n    clonedDefaultHardhatNetworkParams.initialBaseFeePerGas;\n\n  const initialDate =\n    hardhatNetworkConfig.initialDate ?? new Date().toISOString();\n\n  const chains: HardhatNetworkChainsConfig = new Map(\n    defaultHardhatNetworkParams.chains\n  );\n  if (hardhatNetworkConfig.chains !== undefined) {\n    for (const [chainId, userChainConfig] of Object.entries(\n      hardhatNetworkConfig.chains\n    )) {\n      const chainConfig: HardhatNetworkChainConfig = {\n        hardforkHistory: new Map(),\n      };\n      if (userChainConfig.hardforkHistory !== undefined) {\n        for (const [name, block] of Object.entries(\n          userChainConfig.hardforkHistory\n        )) {\n          chainConfig.hardforkHistory.set(\n            name as HardforkName,\n            block as number\n          );\n        }\n      }\n      chains.set(parseInt(chainId, 10), chainConfig);\n    }\n  }\n\n  const config: HardhatNetworkConfig = {\n    ...clonedDefaultHardhatNetworkParams,\n    ...hardhatNetworkConfig,\n    accounts,\n    forking,\n    mining,\n    blockGasLimit,\n    gas,\n    gasPrice,\n    initialBaseFeePerGas,\n    initialDate,\n    minGasPrice,\n    chains,\n  };\n\n  // We do it this way because ts gets lost otherwise\n  if (config.forking === undefined) {\n    delete config.forking;\n  }\n  if (config.initialBaseFeePerGas === undefined) {\n    delete config.initialBaseFeePerGas;\n  }\n\n  return config;\n}\n\nfunction isHdAccountsConfig(\n  accounts: HttpNetworkAccountsUserConfig\n): accounts is HDAccountsUserConfig {\n  return typeof accounts === \"object\" && !Array.isArray(accounts);\n}\n\nfunction resolveHttpNetworkConfig(\n  networkConfig: HttpNetworkUserConfig\n): HttpNetworkConfig {\n  const accounts: HttpNetworkAccountsConfig =\n    networkConfig.accounts === undefined\n      ? defaultHttpNetworkParams.accounts\n      : isHdAccountsConfig(networkConfig.accounts)\n      ? {\n          ...defaultHdAccountsConfigParams,\n          ...networkConfig.accounts,\n        }\n      : Array.isArray(networkConfig.accounts)\n      ? networkConfig.accounts.map(normalizeHexString)\n      : \"remote\";\n\n  const url = networkConfig.url;\n\n  assertHardhatInvariant(\n    url !== undefined,\n    \"Invalid http network config provided. URL missing.\"\n  );\n\n  return {\n    ...cloneDeep(defaultHttpNetworkParams),\n    ...networkConfig,\n    accounts,\n    url,\n    gas: networkConfig.gas ?? defaultHttpNetworkParams.gas,\n    gasPrice: networkConfig.gasPrice ?? defaultHttpNetworkParams.gasPrice,\n  };\n}\n\nfunction resolveMiningConfig(\n  userConfig: HardhatNetworkMiningUserConfig | undefined\n): HardhatNetworkMiningConfig {\n  const mempool = resolveMempoolConfig(userConfig?.mempool);\n  if (userConfig === undefined) {\n    return {\n      auto: true,\n      interval: 0,\n      mempool,\n    };\n  }\n\n  const { auto, interval } = userConfig;\n\n  if (auto === undefined && interval === undefined) {\n    return {\n      auto: true,\n      interval: 0,\n      mempool,\n    };\n  }\n\n  if (auto === undefined && interval !== undefined) {\n    return {\n      auto: false,\n      interval,\n      mempool,\n    };\n  }\n\n  if (auto !== undefined && interval === undefined) {\n    return {\n      auto,\n      interval: 0,\n      mempool,\n    };\n  }\n\n  // ts can't infer it, but both values are defined here\n  return {\n    auto: auto!,\n    interval: interval!,\n    mempool,\n  };\n}\n\nfunction resolveMempoolConfig(\n  userConfig: HardhatNetworkMempoolUserConfig | undefined\n): HardhatNetworkMempoolConfig {\n  if (userConfig === undefined) {\n    return {\n      order: \"priority\",\n    };\n  }\n\n  if (userConfig.order === undefined) {\n    return {\n      order: \"priority\",\n    };\n  }\n\n  return {\n    order: userConfig.order,\n  } as HardhatNetworkMempoolConfig;\n}\n\nfunction resolveSolidityConfig(userConfig: HardhatUserConfig): SolidityConfig {\n  const userSolidityConfig = userConfig.solidity ?? DEFAULT_SOLC_VERSION;\n\n  const multiSolcConfig: MultiSolcUserConfig =\n    normalizeSolidityConfig(userSolidityConfig);\n\n  const overrides = multiSolcConfig.overrides ?? {};\n\n  return {\n    compilers: multiSolcConfig.compilers.map(resolveCompiler),\n    overrides: fromEntries(\n      Object.entries(overrides).map(([name, config]) => [\n        name,\n        resolveCompiler(config),\n      ])\n    ),\n  };\n}\n\nfunction normalizeSolidityConfig(\n  solidityConfig: SolidityUserConfig\n): MultiSolcUserConfig {\n  if (typeof solidityConfig === \"string\") {\n    return {\n      compilers: [\n        {\n          version: solidityConfig,\n        },\n      ],\n    };\n  }\n\n  if (\"version\" in solidityConfig) {\n    return { compilers: [solidityConfig] };\n  }\n\n  return solidityConfig;\n}\n\nfunction resolveCompiler(compiler: SolcUserConfig): SolcConfig {\n  const resolved: SolcConfig = {\n    version: compiler.version,\n    settings: compiler.settings ?? {},\n  };\n\n  resolved.settings.optimizer = {\n    enabled: false,\n    runs: 200,\n    ...resolved.settings.optimizer,\n  };\n\n  if (resolved.settings.outputSelection === undefined) {\n    resolved.settings.outputSelection = {};\n  }\n\n  for (const [file, contractSelection] of Object.entries(\n    defaultSolcOutputSelection\n  )) {\n    if (resolved.settings.outputSelection[file] === undefined) {\n      resolved.settings.outputSelection[file] = {};\n    }\n\n    for (const [contract, outputs] of Object.entries(contractSelection)) {\n      if (resolved.settings.outputSelection[file][contract] === undefined) {\n        resolved.settings.outputSelection[file][contract] = [];\n      }\n\n      for (const output of outputs) {\n        const includesOutput: boolean =\n          resolved.settings.outputSelection[file][contract].includes(output);\n\n        if (!includesOutput) {\n          resolved.settings.outputSelection[file][contract].push(output);\n        }\n      }\n    }\n  }\n\n  return resolved;\n}\n\nfunction resolveMochaConfig(userConfig: HardhatUserConfig): Mocha.MochaOptions {\n  return {\n    ...cloneDeep(defaultMochaOptions),\n    ...userConfig.mocha,\n  };\n}\n\n/**\n * This function resolves the ProjectPathsConfig object from the user-provided config\n * and its path. The logic of this is not obvious and should well be document.\n * The good thing is that most users will never use this.\n *\n * Explanation:\n *    - paths.configFile is not overridable\n *    - If a path is absolute it is used \"as is\".\n *    - If the root path is relative, it's resolved from paths.configFile's dir.\n *    - If any other path is relative, it's resolved from paths.root.\n *    - Plugin-defined paths are not resolved, but encouraged to follow the same pattern.\n */\nexport function resolveProjectPaths(\n  userConfigPath: string,\n  userPaths: ProjectPathsUserConfig = {}\n): ProjectPathsConfig {\n  const configFile = getRealPathSync(userConfigPath);\n  const configDir = path.dirname(configFile);\n\n  const root = resolvePathFrom(configDir, \"\", userPaths.root);\n\n  return {\n    ...userPaths,\n    root,\n    configFile,\n    sources: resolvePathFrom(root, \"contracts\", userPaths.sources),\n    cache: resolvePathFrom(root, \"cache\", userPaths.cache),\n    artifacts: resolvePathFrom(root, \"artifacts\", userPaths.artifacts),\n    tests: resolvePathFrom(root, \"test\", userPaths.tests),\n  };\n}\n\nfunction resolvePathFrom(\n  from: string,\n  defaultPath: string,\n  relativeOrAbsolutePath: string = defaultPath\n) {\n  if (path.isAbsolute(relativeOrAbsolutePath)) {\n    return relativeOrAbsolutePath;\n  }\n\n  return path.join(from, relativeOrAbsolutePath);\n}\n"]},"metadata":{},"sourceType":"script","externalDependencies":[]}