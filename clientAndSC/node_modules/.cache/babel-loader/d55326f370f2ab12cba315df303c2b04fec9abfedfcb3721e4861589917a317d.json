{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.setupContext = exports.createEvalAwarePartialHost = exports.EvalState = exports.createRepl = exports.REPL_NAME = exports.REPL_FILENAME = exports.STDIN_NAME = exports.STDIN_FILENAME = exports.EVAL_NAME = exports.EVAL_FILENAME = void 0;\nconst os_1 = require(\"os\");\nconst path_1 = require(\"path\");\nconst repl_1 = require(\"repl\");\nconst vm_1 = require(\"vm\");\nconst index_1 = require(\"./index\");\nconst fs_1 = require(\"fs\");\nconst console_1 = require(\"console\");\nconst assert = require(\"assert\");\nconst module_1 = require(\"module\");\n// Lazy-loaded.\nlet _processTopLevelAwait;\nfunction getProcessTopLevelAwait() {\n  if (_processTopLevelAwait === undefined) {\n    ({\n      processTopLevelAwait: _processTopLevelAwait\n    } = require('../dist-raw/node-internal-repl-await'));\n  }\n  return _processTopLevelAwait;\n}\nlet diff;\nfunction getDiffLines() {\n  if (diff === undefined) {\n    diff = require('diff');\n  }\n  return diff.diffLines;\n}\n/** @internal */\nexports.EVAL_FILENAME = `[eval].ts`;\n/** @internal */\nexports.EVAL_NAME = `[eval]`;\n/** @internal */\nexports.STDIN_FILENAME = `[stdin].ts`;\n/** @internal */\nexports.STDIN_NAME = `[stdin]`;\n/** @internal */\nexports.REPL_FILENAME = '<repl>.ts';\n/** @internal */\nexports.REPL_NAME = '<repl>';\n/**\n * Create a ts-node REPL instance.\n *\n * Pay close attention to the example below.  Today, the API requires a few lines\n * of boilerplate to correctly bind the `ReplService` to the ts-node `Service` and\n * vice-versa.\n *\n * Usage example:\n *\n *     const repl = tsNode.createRepl();\n *     const service = tsNode.create({...repl.evalAwarePartialHost});\n *     repl.setService(service);\n *     repl.start();\n *\n * @category REPL\n */\nfunction createRepl() {\n  let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  var _a, _b, _c, _d, _e;\n  const {\n    ignoreDiagnosticsThatAreAnnoyingInInteractiveRepl = true\n  } = options;\n  let service = options.service;\n  let nodeReplServer;\n  // If `useGlobal` is not true, then REPL creates a context when started.\n  // This stores a reference to it or to `global`, whichever is used, after REPL has started.\n  let context;\n  const state = (_a = options.state) !== null && _a !== void 0 ? _a : new EvalState((0, path_1.join)(process.cwd(), exports.REPL_FILENAME));\n  const evalAwarePartialHost = createEvalAwarePartialHost(state, options.composeWithEvalAwarePartialHost);\n  const stdin = (_b = options.stdin) !== null && _b !== void 0 ? _b : process.stdin;\n  const stdout = (_c = options.stdout) !== null && _c !== void 0 ? _c : process.stdout;\n  const stderr = (_d = options.stderr) !== null && _d !== void 0 ? _d : process.stderr;\n  const _console = stdout === process.stdout && stderr === process.stderr ? console : new console_1.Console(stdout, stderr);\n  const replService = {\n    state: (_e = options.state) !== null && _e !== void 0 ? _e : new EvalState((0, path_1.join)(process.cwd(), exports.EVAL_FILENAME)),\n    setService,\n    evalCode,\n    evalCodeInternal,\n    nodeEval,\n    evalAwarePartialHost,\n    start,\n    startInternal,\n    stdin,\n    stdout,\n    stderr,\n    console: _console\n  };\n  return replService;\n  function setService(_service) {\n    service = _service;\n    if (ignoreDiagnosticsThatAreAnnoyingInInteractiveRepl) {\n      service.addDiagnosticFilter({\n        appliesToAllFiles: false,\n        filenamesAbsolute: [state.path],\n        diagnosticsIgnored: [2393, 6133, 7027, ...(service.shouldReplAwait ? topLevelAwaitDiagnosticCodes : [])]\n      });\n    }\n  }\n  function evalCode(code) {\n    const result = appendCompileAndEvalInput({\n      service: service,\n      state,\n      input: code,\n      context,\n      overrideIsCompletion: false\n    });\n    assert(result.containsTopLevelAwait === false);\n    return result.value;\n  }\n  function evalCodeInternal(options) {\n    const {\n      code,\n      enableTopLevelAwait,\n      context\n    } = options;\n    return appendCompileAndEvalInput({\n      service: service,\n      state,\n      input: code,\n      enableTopLevelAwait,\n      context\n    });\n  }\n  function nodeEval(code, context, _filename, callback) {\n    // TODO: Figure out how to handle completion here.\n    if (code === '.scope') {\n      callback(null);\n      return;\n    }\n    try {\n      const evalResult = evalCodeInternal({\n        code,\n        enableTopLevelAwait: true,\n        context\n      });\n      if (evalResult.containsTopLevelAwait) {\n        (async () => {\n          try {\n            callback(null, await evalResult.valuePromise);\n          } catch (promiseError) {\n            handleError(promiseError);\n          }\n        })();\n      } else {\n        callback(null, evalResult.value);\n      }\n    } catch (error) {\n      handleError(error);\n    }\n    // Log TSErrors, check if they're recoverable, log helpful hints for certain\n    // well-known errors, and invoke `callback()`\n    // TODO should evalCode API get the same error-handling benefits?\n    function handleError(error) {\n      var _a, _b;\n      // Don't show TLA hint if the user explicitly disabled repl top level await\n      const canLogTopLevelAwaitHint = service.options.experimentalReplAwait !== false && !service.shouldReplAwait;\n      if (error instanceof index_1.TSError) {\n        // Support recoverable compilations using >= node 6.\n        if (repl_1.Recoverable && isRecoverable(error)) {\n          callback(new repl_1.Recoverable(error));\n          return;\n        } else {\n          _console.error(error);\n          if (canLogTopLevelAwaitHint && error.diagnosticCodes.some(dC => topLevelAwaitDiagnosticCodes.includes(dC))) {\n            _console.error(getTopLevelAwaitHint());\n          }\n          callback(null);\n        }\n      } else {\n        let _error = error;\n        if (canLogTopLevelAwaitHint && _error instanceof SyntaxError && ((_a = _error.message) === null || _a === void 0 ? void 0 : _a.includes('await is only valid'))) {\n          try {\n            // Only way I know to make our hint appear after the error\n            _error.message += `\\n\\n${getTopLevelAwaitHint()}`;\n            _error.stack = (_b = _error.stack) === null || _b === void 0 ? void 0 : _b.replace(/(SyntaxError:.*)/, (_, $1) => `${$1}\\n\\n${getTopLevelAwaitHint()}`);\n          } catch {}\n        }\n        callback(_error);\n      }\n    }\n    function getTopLevelAwaitHint() {\n      return `Hint: REPL top-level await requires TypeScript version 3.8 or higher and target ES2018 or higher. You are using TypeScript ${service.ts.version} and target ${service.ts.ScriptTarget[service.config.options.target]}.`;\n    }\n  }\n  // Note: `code` argument is deprecated\n  function start(code) {\n    startInternal({\n      code\n    });\n  }\n  // Note: `code` argument is deprecated\n  function startInternal(options) {\n    const {\n      code,\n      forceToBeModule = true,\n      ...optionsOverride\n    } = options !== null && options !== void 0 ? options : {};\n    // TODO assert that `service` is set; remove all `service!` non-null assertions\n    // Eval incoming code before the REPL starts.\n    // Note: deprecated\n    if (code) {\n      try {\n        evalCode(`${code}\\n`);\n      } catch (err) {\n        _console.error(err);\n        // Note: should not be killing the process here, but this codepath is deprecated anyway\n        process.exit(1);\n      }\n    }\n    // In case the typescript compiler hasn't compiled anything yet,\n    // make it run though compilation at least one time before\n    // the REPL starts for a snappier user experience on startup.\n    service === null || service === void 0 ? void 0 : service.compile('', state.path);\n    const repl = (0, repl_1.start)({\n      prompt: '> ',\n      input: replService.stdin,\n      output: replService.stdout,\n      // Mimicking node's REPL implementation: https://github.com/nodejs/node/blob/168b22ba073ee1cbf8d0bcb4ded7ff3099335d04/lib/internal/repl.js#L28-L30\n      terminal: stdout.isTTY && !parseInt(index_1.env.NODE_NO_READLINE, 10),\n      eval: nodeEval,\n      useGlobal: true,\n      ...optionsOverride\n    });\n    nodeReplServer = repl;\n    context = repl.context;\n    // Bookmark the point where we should reset the REPL state.\n    const resetEval = appendToEvalState(state, '');\n    function reset() {\n      resetEval();\n      // Hard fix for TypeScript forcing `Object.defineProperty(exports, ...)`.\n      runInContext('exports = module.exports', state.path, context);\n      if (forceToBeModule) {\n        state.input += 'export {};void 0;\\n';\n      }\n      // Declare node builtins.\n      // Skip the same builtins as `addBuiltinLibsToObject`:\n      //   those starting with _\n      //   those containing /\n      //   those that already exist as globals\n      // Intentionally suppress type errors in case @types/node does not declare any of them, and because\n      // `declare import` is technically invalid syntax.\n      // Avoid this when in transpileOnly, because third-party transpilers may not handle `declare import`.\n      if (!(service === null || service === void 0 ? void 0 : service.transpileOnly)) {\n        state.input += `// @ts-ignore\\n${module_1.builtinModules.filter(name => !name.startsWith('_') && !name.includes('/') && !['console', 'module', 'process'].includes(name)).map(name => `declare import ${name} = require('${name}')`).join(';')}\\n`;\n      }\n    }\n    reset();\n    repl.on('reset', reset);\n    repl.defineCommand('type', {\n      help: 'Check the type of a TypeScript identifier',\n      action: function (identifier) {\n        if (!identifier) {\n          repl.displayPrompt();\n          return;\n        }\n        const undo = appendToEvalState(state, identifier);\n        const {\n          name,\n          comment\n        } = service.getTypeInfo(state.input, state.path, state.input.length);\n        undo();\n        if (name) repl.outputStream.write(`${name}\\n`);\n        if (comment) repl.outputStream.write(`${comment}\\n`);\n        repl.displayPrompt();\n      }\n    });\n    // Set up REPL history when available natively via node.js >= 11.\n    if (repl.setupHistory) {\n      const historyPath = index_1.env.TS_NODE_HISTORY || (0, path_1.join)((0, os_1.homedir)(), '.ts_node_repl_history');\n      repl.setupHistory(historyPath, err => {\n        if (!err) return;\n        _console.error(err);\n        process.exit(1);\n      });\n    }\n    return repl;\n  }\n}\nexports.createRepl = createRepl;\n/**\n * Eval state management. Stores virtual `[eval].ts` file\n */\nclass EvalState {\n  constructor(path) {\n    this.path = path;\n    /** @internal */\n    this.input = '';\n    /** @internal */\n    this.output = '';\n    /** @internal */\n    this.version = 0;\n    /** @internal */\n    this.lines = 0;\n  }\n}\nexports.EvalState = EvalState;\nfunction createEvalAwarePartialHost(state, composeWith) {\n  function readFile(path) {\n    if (path === state.path) return state.input;\n    if (composeWith === null || composeWith === void 0 ? void 0 : composeWith.readFile) return composeWith.readFile(path);\n    try {\n      return (0, fs_1.readFileSync)(path, 'utf8');\n    } catch (err) {\n      /* Ignore. */\n    }\n  }\n  function fileExists(path) {\n    if (path === state.path) return true;\n    if (composeWith === null || composeWith === void 0 ? void 0 : composeWith.fileExists) return composeWith.fileExists(path);\n    try {\n      const stats = (0, fs_1.statSync)(path);\n      return stats.isFile() || stats.isFIFO();\n    } catch (err) {\n      return false;\n    }\n  }\n  return {\n    readFile,\n    fileExists\n  };\n}\nexports.createEvalAwarePartialHost = createEvalAwarePartialHost;\nconst sourcemapCommentRe = /\\/\\/# ?sourceMappingURL=\\S+[\\s\\r\\n]*$/;\n/**\n * Evaluate the code snippet.\n *\n * Append it to virtual .ts file, compile, handle compiler errors, compute a diff of the JS, and eval any code that\n * appears as \"added\" in the diff.\n */\nfunction appendCompileAndEvalInput(options) {\n  const {\n    service,\n    state,\n    wrappedErr,\n    enableTopLevelAwait = false,\n    context,\n    overrideIsCompletion\n  } = options;\n  let {\n    input\n  } = options;\n  // It's confusing for `{ a: 1 }` to be interpreted as a block statement\n  // rather than an object literal. So, we first try to wrap it in\n  // parentheses, so that it will be interpreted as an expression.\n  // Based on https://github.com/nodejs/node/blob/c2e6822153bad023ab7ebd30a6117dcc049e475c/lib/repl.js#L413-L422\n  let wrappedCmd = false;\n  if (!wrappedErr && /^\\s*{/.test(input) && !/;\\s*$/.test(input)) {\n    input = `(${input.trim()})\\n`;\n    wrappedCmd = true;\n  }\n  const lines = state.lines;\n  const isCompletion = overrideIsCompletion !== null && overrideIsCompletion !== void 0 ? overrideIsCompletion : !/\\n$/.test(input);\n  const undo = appendToEvalState(state, input);\n  let output;\n  // Based on https://github.com/nodejs/node/blob/92573721c7cff104ccb82b6ed3e8aa69c4b27510/lib/repl.js#L457-L461\n  function adjustUseStrict(code) {\n    // \"void 0\" keeps the repl from returning \"use strict\" as the result\n    // value for statements and declarations that don't return a value.\n    return code.replace(/^\"use strict\";/, '\"use strict\"; void 0;');\n  }\n  try {\n    output = service.compile(state.input, state.path, -lines);\n  } catch (err) {\n    undo();\n    if (wrappedCmd) {\n      if (err instanceof index_1.TSError && err.diagnosticCodes[0] === 2339) {\n        // Ensure consistent and more sane behavior between { a: 1 }['b'] and ({ a: 1 }['b'])\n        throw err;\n      }\n      // Unwrap and try again\n      return appendCompileAndEvalInput({\n        ...options,\n        wrappedErr: err\n      });\n    }\n    if (wrappedErr) throw wrappedErr;\n    throw err;\n  }\n  output = adjustUseStrict(output);\n  // Note: REPL does not respect sourcemaps!\n  // To properly do that, we'd need to prefix the code we eval -- which comes\n  // from `diffLines` -- with newlines so that it's at the proper line numbers.\n  // Then we'd need to ensure each bit of eval-ed code, if there are multiples,\n  // has the sourcemap appended to it.\n  // We might also need to integrate with our sourcemap hooks' cache; I'm not sure.\n  const outputWithoutSourcemapComment = output.replace(sourcemapCommentRe, '');\n  const oldOutputWithoutSourcemapComment = state.output.replace(sourcemapCommentRe, '');\n  // Use `diff` to check for new JavaScript to execute.\n  const changes = getDiffLines()(oldOutputWithoutSourcemapComment, outputWithoutSourcemapComment);\n  if (isCompletion) {\n    undo();\n  } else {\n    state.output = output;\n    // Insert a semicolon to make sure that the code doesn't interact with the next line,\n    // for example to prevent `2\\n+ 2` from producing 4.\n    // This is safe since the output will not change since we can only get here with successful inputs,\n    // and adding a semicolon to the end of a successful input won't ever change the output.\n    state.input = state.input.replace(/([^\\n\\s])([\\n\\s]*)$/, (all, lastChar, whitespace) => {\n      if (lastChar !== ';') return `${lastChar};${whitespace}`;\n      return all;\n    });\n  }\n  let commands = [];\n  let containsTopLevelAwait = false;\n  // Build a list of \"commands\": bits of JS code in the diff that must be executed.\n  for (const change of changes) {\n    if (change.added) {\n      if (enableTopLevelAwait && service.shouldReplAwait && change.value.indexOf('await') > -1) {\n        const processTopLevelAwait = getProcessTopLevelAwait();\n        // Newline prevents comments to mess with wrapper\n        const wrappedResult = processTopLevelAwait(change.value + '\\n');\n        if (wrappedResult !== null) {\n          containsTopLevelAwait = true;\n          commands.push({\n            mustAwait: true,\n            execCommand: () => runInContext(wrappedResult, state.path, context)\n          });\n          continue;\n        }\n      }\n      commands.push({\n        execCommand: () => runInContext(change.value, state.path, context)\n      });\n    }\n  }\n  // Execute all commands asynchronously if necessary, returning the result or a\n  // promise of the result.\n  if (containsTopLevelAwait) {\n    return {\n      containsTopLevelAwait,\n      valuePromise: (async () => {\n        let value;\n        for (const command of commands) {\n          const r = command.execCommand();\n          value = command.mustAwait ? await r : r;\n        }\n        return value;\n      })()\n    };\n  } else {\n    return {\n      containsTopLevelAwait: false,\n      value: commands.reduce((_, c) => c.execCommand(), undefined)\n    };\n  }\n}\n/**\n * Low-level execution of JS code in context\n */\nfunction runInContext(code, filename, context) {\n  const script = new vm_1.Script(code, {\n    filename\n  });\n  if (context === undefined || context === global) {\n    return script.runInThisContext();\n  } else {\n    return script.runInContext(context);\n  }\n}\n/**\n * Append to the eval instance and return an undo function.\n */\nfunction appendToEvalState(state, input) {\n  const undoInput = state.input;\n  const undoVersion = state.version;\n  const undoOutput = state.output;\n  const undoLines = state.lines;\n  state.input += input;\n  state.lines += lineCount(input);\n  state.version++;\n  return function () {\n    state.input = undoInput;\n    state.output = undoOutput;\n    state.version = undoVersion;\n    state.lines = undoLines;\n  };\n}\n/**\n * Count the number of lines.\n */\nfunction lineCount(value) {\n  let count = 0;\n  for (const char of value) {\n    if (char === '\\n') {\n      count++;\n    }\n  }\n  return count;\n}\n/**\n * TS diagnostic codes which are recoverable, meaning that the user likely entered an incomplete line of code\n * and should be prompted for the next.  For example, starting a multi-line for() loop and not finishing it.\n * null value means code is always recoverable.  `Set` means code is only recoverable when occurring alongside at least one\n * of the other codes.\n */\nconst RECOVERY_CODES = new Map([[1003, null], [1005, null], [1109, null], [1126, null], [1136, new Set([1005]) // happens when typing out an object literal or block scope across multiple lines: '{ foo: 123,'\n], [1160, null], [1161, null], [2355, null], [2391, null], [7010, new Set([1005]) // happens when fn signature spread across multiple lines: 'function a(\\nb: any\\n) {'\n]]);\n/**\n * Diagnostic codes raised when using top-level await.\n * These are suppressed when top-level await is enabled.\n * When it is *not* enabled, these trigger a helpful hint about enabling top-level await.\n */\nconst topLevelAwaitDiagnosticCodes = [1375, 1378, 1431, 1432 // Top-level 'for await' loops are only allowed when the 'module' option is set to 'esnext' or 'system', and the 'target' option is set to 'es2017' or higher.\n];\n/**\n * Check if a function can recover gracefully.\n */\nfunction isRecoverable(error) {\n  return error.diagnosticCodes.every(code => {\n    const deps = RECOVERY_CODES.get(code);\n    return deps === null || deps && error.diagnosticCodes.some(code => deps.has(code));\n  });\n}\n/**\n * @internal\n * Set properties on `context` before eval-ing [stdin] or [eval] input.\n */\nfunction setupContext(context, module, filenameAndDirname) {\n  if (filenameAndDirname) {\n    context.__dirname = '.';\n    context.__filename = `[${filenameAndDirname}]`;\n  }\n  context.module = module;\n  context.exports = module.exports;\n  context.require = module.require.bind(module);\n}\nexports.setupContext = setupContext;","map":{"version":3,"mappings":"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","names":["_processTopLevelAwait","getProcessTopLevelAwait","undefined","processTopLevelAwait","require","diff","getDiffLines","diffLines","exports","createRepl","options","ignoreDiagnosticsThatAreAnnoyingInInteractiveRepl","service","nodeReplServer","context","state","EvalState","process","cwd","evalAwarePartialHost","createEvalAwarePartialHost","composeWithEvalAwarePartialHost","stdin","stdout","stderr","_console","console","console_1","replService","setService","evalCode","evalCodeInternal","nodeEval","start","startInternal","_service","addDiagnosticFilter","appliesToAllFiles","filenamesAbsolute","path","diagnosticsIgnored","shouldReplAwait","topLevelAwaitDiagnosticCodes","code","result","appendCompileAndEvalInput","input","overrideIsCompletion","assert","containsTopLevelAwait","value","enableTopLevelAwait","_filename","callback","evalResult","valuePromise","promiseError","handleError","error","canLogTopLevelAwaitHint","experimentalReplAwait","index_1","repl_1","isRecoverable","diagnosticCodes","some","dC","includes","getTopLevelAwaitHint","_error","SyntaxError","message","stack","replace","_","$1","ts","version","ScriptTarget","config","target","forceToBeModule","optionsOverride","err","exit","compile","repl","prompt","output","terminal","isTTY","parseInt","NODE_NO_READLINE","eval","useGlobal","resetEval","appendToEvalState","reset","runInContext","transpileOnly","module_1","filter","name","startsWith","map","join","on","defineCommand","help","action","identifier","displayPrompt","undo","comment","getTypeInfo","length","outputStream","write","setupHistory","historyPath","TS_NODE_HISTORY","constructor","composeWith","readFile","fileExists","stats","isFile","isFIFO","sourcemapCommentRe","wrappedErr","wrappedCmd","test","trim","lines","isCompletion","adjustUseStrict","outputWithoutSourcemapComment","oldOutputWithoutSourcemapComment","changes","all","lastChar","whitespace","commands","change","added","indexOf","wrappedResult","push","mustAwait","execCommand","command","r","reduce","c","filename","script","vm_1","global","runInThisContext","undoInput","undoVersion","undoOutput","undoLines","lineCount","count","char","RECOVERY_CODES","Map","Set","every","deps","get","has","setupContext","module","filenameAndDirname","__dirname","__filename","bind"],"sources":["/Users/janrobel/Documents/PersonalProjekty/nftGenerateAi/clientAndContract/node_modules/ts-node/src/repl.ts"],"sourcesContent":["import type * as _diff from 'diff';\nimport { homedir } from 'os';\nimport { join } from 'path';\nimport {\n  Recoverable,\n  ReplOptions,\n  REPLServer,\n  start as nodeReplStart,\n} from 'repl';\nimport { Context, createContext, Script } from 'vm';\nimport { Service, CreateOptions, TSError, env } from './index';\nimport { readFileSync, statSync } from 'fs';\nimport { Console } from 'console';\nimport * as assert from 'assert';\nimport type * as tty from 'tty';\nimport type * as Module from 'module';\nimport { builtinModules } from 'module';\n\n// Lazy-loaded.\nlet _processTopLevelAwait: (src: string) => string | null;\nfunction getProcessTopLevelAwait() {\n  if (_processTopLevelAwait === undefined) {\n    ({\n      processTopLevelAwait: _processTopLevelAwait,\n    } = require('../dist-raw/node-internal-repl-await'));\n  }\n  return _processTopLevelAwait;\n}\nlet diff: typeof _diff;\nfunction getDiffLines() {\n  if (diff === undefined) {\n    diff = require('diff');\n  }\n  return diff.diffLines;\n}\n\n/** @internal */\nexport const EVAL_FILENAME = `[eval].ts`;\n/** @internal */\nexport const EVAL_NAME = `[eval]`;\n/** @internal */\nexport const STDIN_FILENAME = `[stdin].ts`;\n/** @internal */\nexport const STDIN_NAME = `[stdin]`;\n/** @internal */\nexport const REPL_FILENAME = '<repl>.ts';\n/** @internal */\nexport const REPL_NAME = '<repl>';\n\nexport interface ReplService {\n  readonly state: EvalState;\n  /**\n   * Bind this REPL to a ts-node compiler service.  A compiler service must be bound before `eval`-ing code or starting the REPL\n   */\n  setService(service: Service): void;\n  /**\n   * Append code to the virtual <repl> source file, compile it to JavaScript, throw semantic errors if the typechecker is enabled,\n   * and execute it.\n   *\n   * Note: typically, you will want to call `start()` instead of using this method.\n   *\n   * @param code string of TypeScript.\n   */\n  evalCode(code: string): any;\n  /** @internal */\n  evalCodeInternal(opts: {\n    code: string;\n    enableTopLevelAwait?: boolean;\n    context?: Context;\n  }):\n    | {\n        containsTopLevelAwait: true;\n        valuePromise: Promise<any>;\n      }\n    | {\n        containsTopLevelAwait: false;\n        value: any;\n      };\n  /**\n   * `eval` implementation compatible with node's REPL API\n   *\n   * Can be used in advanced scenarios if you want to manually create your own\n   * node REPL instance and delegate eval to this `ReplService`.\n   *\n   * Example:\n   *\n   *     import {start} from 'repl';\n   *     const replService: tsNode.ReplService = ...; // assuming you have already created a ts-node ReplService\n   *     const nodeRepl = start({eval: replService.eval});\n   */\n  nodeEval(\n    code: string,\n    // TODO change to `Context` in a future release?  Technically a breaking change\n    context: any,\n    _filename: string,\n    callback: (err: Error | null, result?: any) => any\n  ): void;\n  evalAwarePartialHost: EvalAwarePartialHost;\n  /** Start a node REPL */\n  start(): void;\n  /**\n   * Start a node REPL, evaling a string of TypeScript before it starts.\n   * @deprecated\n   */\n  start(code: string): void;\n  /** @internal */\n  startInternal(opts?: ReplOptions): REPLServer;\n  /** @internal */\n  readonly stdin: NodeJS.ReadableStream;\n  /** @internal */\n  readonly stdout: NodeJS.WritableStream;\n  /** @internal */\n  readonly stderr: NodeJS.WritableStream;\n  /** @internal */\n  readonly console: Console;\n}\n\n/** @category REPL */\nexport interface CreateReplOptions {\n  service?: Service;\n  state?: EvalState;\n  stdin?: NodeJS.ReadableStream;\n  stdout?: NodeJS.WritableStream;\n  stderr?: NodeJS.WritableStream;\n  /** @internal */\n  composeWithEvalAwarePartialHost?: EvalAwarePartialHost;\n  /**\n   * @internal\n   * Ignore diagnostics that are annoying when interactively entering input line-by-line.\n   */\n  ignoreDiagnosticsThatAreAnnoyingInInteractiveRepl?: boolean;\n}\n\n/**\n * Create a ts-node REPL instance.\n *\n * Pay close attention to the example below.  Today, the API requires a few lines\n * of boilerplate to correctly bind the `ReplService` to the ts-node `Service` and\n * vice-versa.\n *\n * Usage example:\n *\n *     const repl = tsNode.createRepl();\n *     const service = tsNode.create({...repl.evalAwarePartialHost});\n *     repl.setService(service);\n *     repl.start();\n *\n * @category REPL\n */\nexport function createRepl(options: CreateReplOptions = {}) {\n  const { ignoreDiagnosticsThatAreAnnoyingInInteractiveRepl = true } = options;\n  let service = options.service;\n  let nodeReplServer: REPLServer;\n  // If `useGlobal` is not true, then REPL creates a context when started.\n  // This stores a reference to it or to `global`, whichever is used, after REPL has started.\n  let context: Context | undefined;\n  const state =\n    options.state ?? new EvalState(join(process.cwd(), REPL_FILENAME));\n  const evalAwarePartialHost = createEvalAwarePartialHost(\n    state,\n    options.composeWithEvalAwarePartialHost\n  );\n  const stdin = options.stdin ?? process.stdin;\n  const stdout = options.stdout ?? process.stdout;\n  const stderr = options.stderr ?? process.stderr;\n  const _console =\n    stdout === process.stdout && stderr === process.stderr\n      ? console\n      : new Console(stdout, stderr);\n\n  const replService: ReplService = {\n    state: options.state ?? new EvalState(join(process.cwd(), EVAL_FILENAME)),\n    setService,\n    evalCode,\n    evalCodeInternal,\n    nodeEval,\n    evalAwarePartialHost,\n    start,\n    startInternal,\n    stdin,\n    stdout,\n    stderr,\n    console: _console,\n  };\n\n  return replService;\n\n  function setService(_service: Service) {\n    service = _service;\n    if (ignoreDiagnosticsThatAreAnnoyingInInteractiveRepl) {\n      service.addDiagnosticFilter({\n        appliesToAllFiles: false,\n        filenamesAbsolute: [state.path],\n        diagnosticsIgnored: [\n          2393, // Duplicate function implementation: https://github.com/TypeStrong/ts-node/issues/729\n          6133, // <identifier> is declared but its value is never read. https://github.com/TypeStrong/ts-node/issues/850\n          7027, // Unreachable code detected. https://github.com/TypeStrong/ts-node/issues/469\n          ...(service.shouldReplAwait ? topLevelAwaitDiagnosticCodes : []),\n        ],\n      });\n    }\n  }\n\n  function evalCode(code: string) {\n    const result = appendCompileAndEvalInput({\n      service: service!,\n      state,\n      input: code,\n      context,\n      overrideIsCompletion: false,\n    });\n    assert(result.containsTopLevelAwait === false);\n    return result.value;\n  }\n\n  function evalCodeInternal(options: {\n    code: string;\n    enableTopLevelAwait?: boolean;\n    context: Context;\n  }) {\n    const { code, enableTopLevelAwait, context } = options;\n    return appendCompileAndEvalInput({\n      service: service!,\n      state,\n      input: code,\n      enableTopLevelAwait,\n      context,\n    });\n  }\n\n  function nodeEval(\n    code: string,\n    context: any,\n    _filename: string,\n    callback: (err: Error | null, result?: any) => any\n  ) {\n    // TODO: Figure out how to handle completion here.\n    if (code === '.scope') {\n      callback(null);\n      return;\n    }\n\n    try {\n      const evalResult = evalCodeInternal({\n        code,\n        enableTopLevelAwait: true,\n        context,\n      });\n\n      if (evalResult.containsTopLevelAwait) {\n        (async () => {\n          try {\n            callback(null, await evalResult.valuePromise);\n          } catch (promiseError) {\n            handleError(promiseError);\n          }\n        })();\n      } else {\n        callback(null, evalResult.value);\n      }\n    } catch (error) {\n      handleError(error);\n    }\n\n    // Log TSErrors, check if they're recoverable, log helpful hints for certain\n    // well-known errors, and invoke `callback()`\n    // TODO should evalCode API get the same error-handling benefits?\n    function handleError(error: unknown) {\n      // Don't show TLA hint if the user explicitly disabled repl top level await\n      const canLogTopLevelAwaitHint =\n        service!.options.experimentalReplAwait !== false &&\n        !service!.shouldReplAwait;\n      if (error instanceof TSError) {\n        // Support recoverable compilations using >= node 6.\n        if (Recoverable && isRecoverable(error)) {\n          callback(new Recoverable(error));\n          return;\n        } else {\n          _console.error(error);\n\n          if (\n            canLogTopLevelAwaitHint &&\n            error.diagnosticCodes.some((dC) =>\n              topLevelAwaitDiagnosticCodes.includes(dC)\n            )\n          ) {\n            _console.error(getTopLevelAwaitHint());\n          }\n          callback(null);\n        }\n      } else {\n        let _error = error as Error | undefined;\n        if (\n          canLogTopLevelAwaitHint &&\n          _error instanceof SyntaxError &&\n          _error.message?.includes('await is only valid')\n        ) {\n          try {\n            // Only way I know to make our hint appear after the error\n            _error.message += `\\n\\n${getTopLevelAwaitHint()}`;\n            _error.stack = _error.stack?.replace(\n              /(SyntaxError:.*)/,\n              (_, $1) => `${$1}\\n\\n${getTopLevelAwaitHint()}`\n            );\n          } catch {}\n        }\n        callback(_error as Error);\n      }\n    }\n    function getTopLevelAwaitHint() {\n      return `Hint: REPL top-level await requires TypeScript version 3.8 or higher and target ES2018 or higher. You are using TypeScript ${\n        service!.ts.version\n      } and target ${\n        service!.ts.ScriptTarget[service!.config.options.target!]\n      }.`;\n    }\n  }\n\n  // Note: `code` argument is deprecated\n  function start(code?: string) {\n    startInternal({ code });\n  }\n\n  // Note: `code` argument is deprecated\n  function startInternal(\n    options?: ReplOptions & { code?: string; forceToBeModule?: boolean }\n  ) {\n    const { code, forceToBeModule = true, ...optionsOverride } = options ?? {};\n    // TODO assert that `service` is set; remove all `service!` non-null assertions\n\n    // Eval incoming code before the REPL starts.\n    // Note: deprecated\n    if (code) {\n      try {\n        evalCode(`${code}\\n`);\n      } catch (err) {\n        _console.error(err);\n        // Note: should not be killing the process here, but this codepath is deprecated anyway\n        process.exit(1);\n      }\n    }\n\n    // In case the typescript compiler hasn't compiled anything yet,\n    // make it run though compilation at least one time before\n    // the REPL starts for a snappier user experience on startup.\n    service?.compile('', state.path);\n\n    const repl = nodeReplStart({\n      prompt: '> ',\n      input: replService.stdin,\n      output: replService.stdout,\n      // Mimicking node's REPL implementation: https://github.com/nodejs/node/blob/168b22ba073ee1cbf8d0bcb4ded7ff3099335d04/lib/internal/repl.js#L28-L30\n      terminal:\n        (stdout as tty.WriteStream).isTTY &&\n        !parseInt(env.NODE_NO_READLINE!, 10),\n      eval: nodeEval,\n      useGlobal: true,\n      ...optionsOverride,\n    });\n\n    nodeReplServer = repl;\n    context = repl.context;\n\n    // Bookmark the point where we should reset the REPL state.\n    const resetEval = appendToEvalState(state, '');\n\n    function reset() {\n      resetEval();\n\n      // Hard fix for TypeScript forcing `Object.defineProperty(exports, ...)`.\n      runInContext('exports = module.exports', state.path, context);\n      if (forceToBeModule) {\n        state.input += 'export {};void 0;\\n';\n      }\n\n      // Declare node builtins.\n      // Skip the same builtins as `addBuiltinLibsToObject`:\n      //   those starting with _\n      //   those containing /\n      //   those that already exist as globals\n      // Intentionally suppress type errors in case @types/node does not declare any of them, and because\n      // `declare import` is technically invalid syntax.\n      // Avoid this when in transpileOnly, because third-party transpilers may not handle `declare import`.\n      if (!service?.transpileOnly) {\n        state.input += `// @ts-ignore\\n${builtinModules\n          .filter(\n            (name) =>\n              !name.startsWith('_') &&\n              !name.includes('/') &&\n              !['console', 'module', 'process'].includes(name)\n          )\n          .map((name) => `declare import ${name} = require('${name}')`)\n          .join(';')}\\n`;\n      }\n    }\n\n    reset();\n    repl.on('reset', reset);\n\n    repl.defineCommand('type', {\n      help: 'Check the type of a TypeScript identifier',\n      action: function (identifier: string) {\n        if (!identifier) {\n          repl.displayPrompt();\n          return;\n        }\n\n        const undo = appendToEvalState(state, identifier);\n        const { name, comment } = service!.getTypeInfo(\n          state.input,\n          state.path,\n          state.input.length\n        );\n\n        undo();\n\n        if (name) repl.outputStream.write(`${name}\\n`);\n        if (comment) repl.outputStream.write(`${comment}\\n`);\n        repl.displayPrompt();\n      },\n    });\n\n    // Set up REPL history when available natively via node.js >= 11.\n    if (repl.setupHistory) {\n      const historyPath =\n        env.TS_NODE_HISTORY || join(homedir(), '.ts_node_repl_history');\n\n      repl.setupHistory(historyPath, (err) => {\n        if (!err) return;\n\n        _console.error(err);\n        process.exit(1);\n      });\n    }\n\n    return repl;\n  }\n}\n\n/**\n * Eval state management. Stores virtual `[eval].ts` file\n */\nexport class EvalState {\n  /** @internal */\n  input = '';\n  /** @internal */\n  output = '';\n  /** @internal */\n  version = 0;\n  /** @internal */\n  lines = 0;\n\n  __tsNodeEvalStateBrand: unknown;\n\n  constructor(public path: string) {}\n}\n\n/**\n * Filesystem host functions which are aware of the \"virtual\" `[eval].ts`, `<repl>`, or `[stdin].ts` file used to compile REPL inputs.\n * Must be passed to `create()` to create a ts-node compiler service which can compile REPL inputs.\n */\nexport type EvalAwarePartialHost = Pick<\n  CreateOptions,\n  'readFile' | 'fileExists'\n>;\n\nexport function createEvalAwarePartialHost(\n  state: EvalState,\n  composeWith?: EvalAwarePartialHost\n): EvalAwarePartialHost {\n  function readFile(path: string) {\n    if (path === state.path) return state.input;\n\n    if (composeWith?.readFile) return composeWith.readFile(path);\n\n    try {\n      return readFileSync(path, 'utf8');\n    } catch (err) {\n      /* Ignore. */\n    }\n  }\n  function fileExists(path: string) {\n    if (path === state.path) return true;\n\n    if (composeWith?.fileExists) return composeWith.fileExists(path);\n\n    try {\n      const stats = statSync(path);\n      return stats.isFile() || stats.isFIFO();\n    } catch (err) {\n      return false;\n    }\n  }\n  return { readFile, fileExists };\n}\n\nconst sourcemapCommentRe = /\\/\\/# ?sourceMappingURL=\\S+[\\s\\r\\n]*$/;\n\ntype AppendCompileAndEvalInputResult =\n  | { containsTopLevelAwait: true; valuePromise: Promise<any> }\n  | { containsTopLevelAwait: false; value: any };\n/**\n * Evaluate the code snippet.\n *\n * Append it to virtual .ts file, compile, handle compiler errors, compute a diff of the JS, and eval any code that\n * appears as \"added\" in the diff.\n */\nfunction appendCompileAndEvalInput(options: {\n  service: Service;\n  state: EvalState;\n  input: string;\n  wrappedErr?: unknown;\n  /** Enable top-level await but only if the TSNode service allows it. */\n  enableTopLevelAwait?: boolean;\n  context: Context | undefined;\n  /**\n   * Added so that `evalCode` can be guaranteed *not* to trigger the `isCompletion`\n   * codepath.  However, the `isCompletion` logic is ancient and maybe should be removed entirely.\n   * Nobody's looked at it in a long time.\n   */\n  overrideIsCompletion?: boolean;\n}): AppendCompileAndEvalInputResult {\n  const {\n    service,\n    state,\n    wrappedErr,\n    enableTopLevelAwait = false,\n    context,\n    overrideIsCompletion,\n  } = options;\n  let { input } = options;\n\n  // It's confusing for `{ a: 1 }` to be interpreted as a block statement\n  // rather than an object literal. So, we first try to wrap it in\n  // parentheses, so that it will be interpreted as an expression.\n  // Based on https://github.com/nodejs/node/blob/c2e6822153bad023ab7ebd30a6117dcc049e475c/lib/repl.js#L413-L422\n  let wrappedCmd = false;\n  if (!wrappedErr && /^\\s*{/.test(input) && !/;\\s*$/.test(input)) {\n    input = `(${input.trim()})\\n`;\n    wrappedCmd = true;\n  }\n\n  const lines = state.lines;\n  const isCompletion = overrideIsCompletion ?? !/\\n$/.test(input);\n  const undo = appendToEvalState(state, input);\n  let output: string;\n\n  // Based on https://github.com/nodejs/node/blob/92573721c7cff104ccb82b6ed3e8aa69c4b27510/lib/repl.js#L457-L461\n  function adjustUseStrict(code: string) {\n    // \"void 0\" keeps the repl from returning \"use strict\" as the result\n    // value for statements and declarations that don't return a value.\n    return code.replace(/^\"use strict\";/, '\"use strict\"; void 0;');\n  }\n\n  try {\n    output = service.compile(state.input, state.path, -lines);\n  } catch (err) {\n    undo();\n\n    if (wrappedCmd) {\n      if (err instanceof TSError && err.diagnosticCodes[0] === 2339) {\n        // Ensure consistent and more sane behavior between { a: 1 }['b'] and ({ a: 1 }['b'])\n        throw err;\n      }\n      // Unwrap and try again\n      return appendCompileAndEvalInput({\n        ...options,\n        wrappedErr: err,\n      });\n    }\n\n    if (wrappedErr) throw wrappedErr;\n    throw err;\n  }\n\n  output = adjustUseStrict(output);\n\n  // Note: REPL does not respect sourcemaps!\n  // To properly do that, we'd need to prefix the code we eval -- which comes\n  // from `diffLines` -- with newlines so that it's at the proper line numbers.\n  // Then we'd need to ensure each bit of eval-ed code, if there are multiples,\n  // has the sourcemap appended to it.\n  // We might also need to integrate with our sourcemap hooks' cache; I'm not sure.\n  const outputWithoutSourcemapComment = output.replace(sourcemapCommentRe, '');\n  const oldOutputWithoutSourcemapComment = state.output.replace(\n    sourcemapCommentRe,\n    ''\n  );\n\n  // Use `diff` to check for new JavaScript to execute.\n  const changes = getDiffLines()(\n    oldOutputWithoutSourcemapComment,\n    outputWithoutSourcemapComment\n  );\n\n  if (isCompletion) {\n    undo();\n  } else {\n    state.output = output;\n\n    // Insert a semicolon to make sure that the code doesn't interact with the next line,\n    // for example to prevent `2\\n+ 2` from producing 4.\n    // This is safe since the output will not change since we can only get here with successful inputs,\n    // and adding a semicolon to the end of a successful input won't ever change the output.\n    state.input = state.input.replace(\n      /([^\\n\\s])([\\n\\s]*)$/,\n      (all, lastChar, whitespace) => {\n        if (lastChar !== ';') return `${lastChar};${whitespace}`;\n        return all;\n      }\n    );\n  }\n\n  let commands: Array<{ mustAwait?: true; execCommand: () => any }> = [];\n  let containsTopLevelAwait = false;\n\n  // Build a list of \"commands\": bits of JS code in the diff that must be executed.\n  for (const change of changes) {\n    if (change.added) {\n      if (\n        enableTopLevelAwait &&\n        service.shouldReplAwait &&\n        change.value.indexOf('await') > -1\n      ) {\n        const processTopLevelAwait = getProcessTopLevelAwait();\n\n        // Newline prevents comments to mess with wrapper\n        const wrappedResult = processTopLevelAwait(change.value + '\\n');\n        if (wrappedResult !== null) {\n          containsTopLevelAwait = true;\n          commands.push({\n            mustAwait: true,\n            execCommand: () => runInContext(wrappedResult, state.path, context),\n          });\n          continue;\n        }\n      }\n      commands.push({\n        execCommand: () => runInContext(change.value, state.path, context),\n      });\n    }\n  }\n\n  // Execute all commands asynchronously if necessary, returning the result or a\n  // promise of the result.\n  if (containsTopLevelAwait) {\n    return {\n      containsTopLevelAwait,\n      valuePromise: (async () => {\n        let value;\n        for (const command of commands) {\n          const r = command.execCommand();\n          value = command.mustAwait ? await r : r;\n        }\n        return value;\n      })(),\n    };\n  } else {\n    return {\n      containsTopLevelAwait: false,\n      value: commands.reduce<any>((_, c) => c.execCommand(), undefined),\n    };\n  }\n}\n\n/**\n * Low-level execution of JS code in context\n */\nfunction runInContext(code: string, filename: string, context?: Context) {\n  const script = new Script(code, { filename });\n\n  if (context === undefined || context === global) {\n    return script.runInThisContext();\n  } else {\n    return script.runInContext(context);\n  }\n}\n\n/**\n * Append to the eval instance and return an undo function.\n */\nfunction appendToEvalState(state: EvalState, input: string) {\n  const undoInput = state.input;\n  const undoVersion = state.version;\n  const undoOutput = state.output;\n  const undoLines = state.lines;\n\n  state.input += input;\n  state.lines += lineCount(input);\n  state.version++;\n\n  return function () {\n    state.input = undoInput;\n    state.output = undoOutput;\n    state.version = undoVersion;\n    state.lines = undoLines;\n  };\n}\n\n/**\n * Count the number of lines.\n */\nfunction lineCount(value: string) {\n  let count = 0;\n\n  for (const char of value) {\n    if (char === '\\n') {\n      count++;\n    }\n  }\n\n  return count;\n}\n\n/**\n * TS diagnostic codes which are recoverable, meaning that the user likely entered an incomplete line of code\n * and should be prompted for the next.  For example, starting a multi-line for() loop and not finishing it.\n * null value means code is always recoverable.  `Set` means code is only recoverable when occurring alongside at least one\n * of the other codes.\n */\nconst RECOVERY_CODES: Map<number, Set<number> | null> = new Map([\n  [1003, null], // \"Identifier expected.\"\n  [1005, null], // \"')' expected.\", \"'}' expected.\"\n  [1109, null], // \"Expression expected.\"\n  [1126, null], // \"Unexpected end of text.\"\n  [\n    1136, // \"Property assignment expected.\"\n    new Set([1005]), // happens when typing out an object literal or block scope across multiple lines: '{ foo: 123,'\n  ],\n  [1160, null], // \"Unterminated template literal.\"\n  [1161, null], // \"Unterminated regular expression literal.\"\n  [2355, null], // \"A function whose declared type is neither 'void' nor 'any' must return a value.\"\n  [2391, null], // \"Function implementation is missing or not immediately following the declaration.\"\n  [\n    7010, // \"Function, which lacks return-type annotation, implicitly has an 'any' return type.\"\n    new Set([1005]), // happens when fn signature spread across multiple lines: 'function a(\\nb: any\\n) {'\n  ],\n]);\n\n/**\n * Diagnostic codes raised when using top-level await.\n * These are suppressed when top-level await is enabled.\n * When it is *not* enabled, these trigger a helpful hint about enabling top-level await.\n */\nconst topLevelAwaitDiagnosticCodes = [\n  1375, // 'await' expressions are only allowed at the top level of a file when that file is a module, but this file has no imports or exports. Consider adding an empty 'export {}' to make this file a module.\n  1378, // Top-level 'await' expressions are only allowed when the 'module' option is set to 'esnext' or 'system', and the 'target' option is set to 'es2017' or higher.\n  1431, // 'for await' loops are only allowed at the top level of a file when that file is a module, but this file has no imports or exports. Consider adding an empty 'export {}' to make this file a module.\n  1432, // Top-level 'for await' loops are only allowed when the 'module' option is set to 'esnext' or 'system', and the 'target' option is set to 'es2017' or higher.\n];\n\n/**\n * Check if a function can recover gracefully.\n */\nfunction isRecoverable(error: TSError) {\n  return error.diagnosticCodes.every((code) => {\n    const deps = RECOVERY_CODES.get(code);\n    return (\n      deps === null ||\n      (deps && error.diagnosticCodes.some((code) => deps.has(code)))\n    );\n  });\n}\n\n/**\n * @internal\n * Set properties on `context` before eval-ing [stdin] or [eval] input.\n */\nexport function setupContext(\n  context: any,\n  module: Module,\n  filenameAndDirname: 'eval' | 'stdin' | null\n) {\n  if (filenameAndDirname) {\n    context.__dirname = '.';\n    context.__filename = `[${filenameAndDirname}]`;\n  }\n  context.module = module;\n  context.exports = module.exports;\n  context.require = module.require.bind(module);\n}\n"]},"metadata":{},"sourceType":"script","externalDependencies":[]}