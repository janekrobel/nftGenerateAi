{"ast":null,"code":"\"use strict\";\n\nvar _a;\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.versionGteLt = exports.once = exports.getBasePathForProjectLocalDependencyResolution = exports.createProjectLocalResolveHelper = exports.attemptRequireWithV8CompileCache = exports.cachedLookup = exports.hasOwnProperty = exports.normalizeSlashes = exports.parse = exports.split = exports.assign = exports.yn = exports.createRequire = void 0;\nconst module_1 = require(\"module\");\nconst ynModule = require(\"yn\");\nconst path_1 = require(\"path\");\n/** @internal */\nexports.createRequire = (_a = module_1.createRequire !== null && module_1.createRequire !== void 0 ? module_1.createRequire : module_1.createRequireFromPath) !== null && _a !== void 0 ? _a : require('create-require');\n/**\n * Wrapper around yn module that returns `undefined` instead of `null`.\n * This is implemented by yn v4, but we're staying on v3 to avoid v4's node 10 requirement.\n * @internal\n */\nfunction yn(value) {\n  var _a;\n  return (_a = ynModule(value)) !== null && _a !== void 0 ? _a : undefined;\n}\nexports.yn = yn;\n/**\n * Like `Object.assign`, but ignores `undefined` properties.\n *\n * @internal\n */\nfunction assign(initialValue) {\n  for (var _len = arguments.length, sources = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n    sources[_key - 1] = arguments[_key];\n  }\n  for (const source of sources) {\n    for (const key of Object.keys(source)) {\n      const value = source[key];\n      if (value !== undefined) initialValue[key] = value;\n    }\n  }\n  return initialValue;\n}\nexports.assign = assign;\n/**\n * Split a string array of values\n * and remove empty strings from the resulting array.\n * @internal\n */\nfunction split(value) {\n  return typeof value === 'string' ? value.split(/ *, */g).filter(v => v !== '') : undefined;\n}\nexports.split = split;\n/**\n * Parse a string as JSON.\n * @internal\n */\nfunction parse(value) {\n  return typeof value === 'string' ? JSON.parse(value) : undefined;\n}\nexports.parse = parse;\nconst directorySeparator = '/';\nconst backslashRegExp = /\\\\/g;\n/**\n * Replace backslashes with forward slashes.\n * @internal\n */\nfunction normalizeSlashes(value) {\n  return value.replace(backslashRegExp, directorySeparator);\n}\nexports.normalizeSlashes = normalizeSlashes;\n/**\n * Safe `hasOwnProperty`\n * @internal\n */\nfunction hasOwnProperty(object, property) {\n  return Object.prototype.hasOwnProperty.call(object, property);\n}\nexports.hasOwnProperty = hasOwnProperty;\n/**\n * Cached fs operation wrapper.\n */\nfunction cachedLookup(fn) {\n  const cache = new Map();\n  return arg => {\n    if (!cache.has(arg)) {\n      const v = fn(arg);\n      cache.set(arg, v);\n      return v;\n    }\n    return cache.get(arg);\n  };\n}\nexports.cachedLookup = cachedLookup;\n/**\n * @internal\n * Require something with v8-compile-cache, which should make subsequent requires faster.\n * Do lots of error-handling so that, worst case, we require without the cache, and users are not blocked.\n */\nfunction attemptRequireWithV8CompileCache(requireFn, specifier) {\n  try {\n    const v8CC = require('v8-compile-cache-lib').install();\n    try {\n      return requireFn(specifier);\n    } finally {\n      v8CC === null || v8CC === void 0 ? void 0 : v8CC.uninstall();\n    }\n  } catch (e) {\n    return requireFn(specifier);\n  }\n}\nexports.attemptRequireWithV8CompileCache = attemptRequireWithV8CompileCache;\n/**\n * Helper to discover dependencies relative to a user's project, optionally\n * falling back to relative to ts-node.  This supports global installations of\n * ts-node, for example where someone does `#!/usr/bin/env -S ts-node --swc` and\n * we need to fallback to a global install of @swc/core\n * @internal\n */\nfunction createProjectLocalResolveHelper(localDirectory) {\n  return function projectLocalResolveHelper(specifier, fallbackToTsNodeRelative) {\n    return require.resolve(specifier, {\n      paths: fallbackToTsNodeRelative ? [localDirectory, __dirname] : [localDirectory]\n    });\n  };\n}\nexports.createProjectLocalResolveHelper = createProjectLocalResolveHelper;\n/**\n * Used as a reminder of all the factors we must consider when finding project-local dependencies and when a config file\n * on disk may or may not exist.\n * @internal\n */\nfunction getBasePathForProjectLocalDependencyResolution(configFilePath, projectSearchDirOption, projectOption, cwdOption) {\n  var _a;\n  if (configFilePath != null) return (0, path_1.dirname)(configFilePath);\n  return (_a = projectSearchDirOption !== null && projectSearchDirOption !== void 0 ? projectSearchDirOption : projectOption) !== null && _a !== void 0 ? _a : cwdOption;\n  // TODO technically breaks if projectOption is path to a file, not a directory,\n  // and we attempt to resolve relative specifiers.  By the time we resolve relative specifiers,\n  // should have configFilePath, so not reach this codepath.\n}\n\nexports.getBasePathForProjectLocalDependencyResolution = getBasePathForProjectLocalDependencyResolution;\n/** @internal */\nfunction once(fn) {\n  let value;\n  let ran = false;\n  function onceFn() {\n    if (ran) return value;\n    value = fn(...arguments);\n    ran = true;\n    return value;\n  }\n  return onceFn;\n}\nexports.once = once;\n/** @internal */\nfunction versionGteLt(version, gteRequirement, ltRequirement) {\n  const [major, minor, patch, extra] = parse(version);\n  const [gteMajor, gteMinor, gtePatch] = parse(gteRequirement);\n  const isGte = major > gteMajor || major === gteMajor && (minor > gteMinor || minor === gteMinor && patch >= gtePatch);\n  let isLt = true;\n  if (ltRequirement) {\n    const [ltMajor, ltMinor, ltPatch] = parse(ltRequirement);\n    isLt = major < ltMajor || major === ltMajor && (minor < ltMinor || minor === ltMinor && patch < ltPatch);\n  }\n  return isGte && isLt;\n  function parse(requirement) {\n    return requirement.split(/[\\.-]/).map(s => parseInt(s, 10));\n  }\n}\nexports.versionGteLt = versionGteLt;","map":{"version":3,"mappings":";;;;;;;AAAA;AAKA;AACA;AAEA;AACaA,qBAAa,GACxB,4BAAiB,aAAjBC,sBAAiB,cAAjBA,sBAAiB,GACjBA,8BAAyB,mCACxBC,OAAO,CAAC,gBAAgB,CAA2B;AAEtD;;;;;AAKA,SAAgBC,EAAE,CAACC,KAAyB;;EAC1C,OAAO,cAAQ,CAACA,KAAK,CAAC,mCAAIC,SAAS;AACrC;AAFAL;AAIA;;;;;AAKA,SAAgBM,MAAM,CACpBC,YAAe,EACK;EAAA,kCAAjBC,OAAiB;IAAjBA,OAAiB;EAAA;EAEpB,KAAK,MAAMC,MAAM,IAAID,OAAO,EAAE;IAC5B,KAAK,MAAME,GAAG,IAAIC,MAAM,CAACC,IAAI,CAACH,MAAM,CAAC,EAAE;MACrC,MAAML,KAAK,GAAIK,MAAc,CAACC,GAAG,CAAC;MAClC,IAAIN,KAAK,KAAKC,SAAS,EAAGE,YAAoB,CAACG,GAAG,CAAC,GAAGN,KAAK;;;EAG/D,OAAOG,YAAY;AACrB;AAXAP;AAaA;;;;;AAKA,SAAgBa,KAAK,CAACT,KAAyB;EAC7C,OAAO,OAAOA,KAAK,KAAK,QAAQ,GAC5BA,KAAK,CAACS,KAAK,CAAC,QAAQ,CAAC,CAACC,MAAM,CAAEC,CAAC,IAAKA,CAAC,KAAK,EAAE,CAAC,GAC7CV,SAAS;AACf;AAJAL;AAMA;;;;AAIA,SAAgBgB,KAAK,CAACZ,KAAyB;EAC7C,OAAO,OAAOA,KAAK,KAAK,QAAQ,GAAGa,IAAI,CAACD,KAAK,CAACZ,KAAK,CAAC,GAAGC,SAAS;AAClE;AAFAL;AAIA,MAAMkB,kBAAkB,GAAG,GAAG;AAC9B,MAAMC,eAAe,GAAG,KAAK;AAC7B;;;;AAIA,SAAgBC,gBAAgB,CAAChB,KAAa;EAC5C,OAAOA,KAAK,CAACiB,OAAO,CAACF,eAAe,EAAED,kBAAkB,CAAC;AAC3D;AAFAlB;AAIA;;;;AAIA,SAAgBsB,cAAc,CAACC,MAAW,EAAEC,QAAgB;EAC1D,OAAOb,MAAM,CAACc,SAAS,CAACH,cAAc,CAACI,IAAI,CAACH,MAAM,EAAEC,QAAQ,CAAC;AAC/D;AAFAxB;AAIA;;;AAGA,SAAgB2B,YAAY,CAAOC,EAAiB;EAClD,MAAMC,KAAK,GAAG,IAAIC,GAAG,EAAQ;EAE7B,OAAQC,GAAM,IAAO;IACnB,IAAI,CAACF,KAAK,CAACG,GAAG,CAACD,GAAG,CAAC,EAAE;MACnB,MAAMhB,CAAC,GAAGa,EAAE,CAACG,GAAG,CAAC;MACjBF,KAAK,CAACI,GAAG,CAACF,GAAG,EAAEhB,CAAC,CAAC;MACjB,OAAOA,CAAC;;IAEV,OAAOc,KAAK,CAACK,GAAG,CAACH,GAAG,CAAE;EACxB,CAAC;AACH;AAXA/B;AAaA;;;;;AAKA,SAAgBmC,gCAAgC,CAC9CC,SAAyB,EACzBC,SAAiB;EAEjB,IAAI;IACF,MAAMC,IAAI,GACRpC,OAAO,CAAC,sBAAsB,CAC/B,CAACqC,OAAO,EAAE;IACX,IAAI;MACF,OAAOH,SAAS,CAACC,SAAS,CAAC;KAC5B,SAAS;MACRC,IAAI,aAAJA,IAAI,uBAAJA,IAAI,CAAEE,SAAS,EAAE;;GAEpB,CAAC,OAAOC,CAAC,EAAE;IACV,OAAOL,SAAS,CAACC,SAAS,CAAC;;AAE/B;AAhBArC;AAkBA;;;;;;;AAOA,SAAgB0C,+BAA+B,CAACC,cAAsB;EACpE,OAAO,SAASC,yBAAyB,CACvCP,SAAiB,EACjBQ,wBAAiC;IAEjC,OAAO3C,OAAO,CAAC4C,OAAO,CAACT,SAAS,EAAE;MAChCU,KAAK,EAAEF,wBAAwB,GAC3B,CAACF,cAAc,EAAEK,SAAS,CAAC,GAC3B,CAACL,cAAc;KACpB,CAAC;EACJ,CAAC;AACH;AAXA3C;AAiBA;;;;;AAKA,SAAgBiD,8CAA8C,CAC5DC,cAAkC,EAClCC,sBAA0C,EAC1CC,aAAiC,EACjCC,SAAiB;;EAEjB,IAAIH,cAAc,IAAI,IAAI,EAAE,OAAO,kBAAO,EAACA,cAAc,CAAC;EAC1D,OAAO,4BAAsB,aAAtBC,sBAAsB,cAAtBA,sBAAsB,GAAIC,aAAa,mCAAIC,SAAS;EAC3D;EACA;EACA;AACF;;AAXArD;AAaA;AACA,SAAgBsD,IAAI,CAAqC1B,EAAM;EAC7D,IAAIxB,KAAqB;EACzB,IAAImD,GAAG,GAAG,KAAK;EACf,SAASC,MAAM,GAAwB;IACrC,IAAID,GAAG,EAAE,OAAOnD,KAAK;IACrBA,KAAK,GAAGwB,EAAE,CAAC,YAAO,CAAC;IACnB2B,GAAG,GAAG,IAAI;IACV,OAAOnD,KAAK;EACd;EACA,OAAOoD,MAAM;AACf;AAVAxD;AAYA;AACA,SAAgByD,YAAY,CAC1BC,OAAe,EACfC,cAAsB,EACtBC,aAAsB;EAEtB,MAAM,CAACC,KAAK,EAAEC,KAAK,EAAEC,KAAK,EAAEC,KAAK,CAAC,GAAGhD,KAAK,CAAC0C,OAAO,CAAC;EACnD,MAAM,CAACO,QAAQ,EAAEC,QAAQ,EAAEC,QAAQ,CAAC,GAAGnD,KAAK,CAAC2C,cAAc,CAAC;EAC5D,MAAMS,KAAK,GACTP,KAAK,GAAGI,QAAQ,IACfJ,KAAK,KAAKI,QAAQ,KAChBH,KAAK,GAAGI,QAAQ,IAAKJ,KAAK,KAAKI,QAAQ,IAAIH,KAAK,IAAII,QAAS,CAAE;EACpE,IAAIE,IAAI,GAAG,IAAI;EACf,IAAIT,aAAa,EAAE;IACjB,MAAM,CAACU,OAAO,EAAEC,OAAO,EAAEC,OAAO,CAAC,GAAGxD,KAAK,CAAC4C,aAAa,CAAC;IACxDS,IAAI,GACFR,KAAK,GAAGS,OAAO,IACdT,KAAK,KAAKS,OAAO,KACfR,KAAK,GAAGS,OAAO,IAAKT,KAAK,KAAKS,OAAO,IAAIR,KAAK,GAAGS,OAAQ,CAAE;;EAElE,OAAOJ,KAAK,IAAIC,IAAI;EAEpB,SAASrD,KAAK,CAACyD,WAAmB;IAChC,OAAOA,WAAW,CAAC5D,KAAK,CAAC,OAAO,CAAC,CAAC6D,GAAG,CAAEC,CAAC,IAAKC,QAAQ,CAACD,CAAC,EAAE,EAAE,CAAC,CAAC;EAC/D;AACF;AAxBA3E","names":["exports","module_1","require","yn","value","undefined","assign","initialValue","sources","source","key","Object","keys","split","filter","v","parse","JSON","directorySeparator","backslashRegExp","normalizeSlashes","replace","hasOwnProperty","object","property","prototype","call","cachedLookup","fn","cache","Map","arg","has","set","get","attemptRequireWithV8CompileCache","requireFn","specifier","v8CC","install","uninstall","e","createProjectLocalResolveHelper","localDirectory","projectLocalResolveHelper","fallbackToTsNodeRelative","resolve","paths","__dirname","getBasePathForProjectLocalDependencyResolution","configFilePath","projectSearchDirOption","projectOption","cwdOption","once","ran","onceFn","versionGteLt","version","gteRequirement","ltRequirement","major","minor","patch","extra","gteMajor","gteMinor","gtePatch","isGte","isLt","ltMajor","ltMinor","ltPatch","requirement","map","s","parseInt"],"sources":["/Users/janrobel/Documents/PersonalProjekty/nftGenerateAi/clientAndContract/node_modules/ts-node/src/util.ts"],"sourcesContent":["import {\n  createRequire as nodeCreateRequire,\n  createRequireFromPath as nodeCreateRequireFromPath,\n} from 'module';\nimport type _createRequire from 'create-require';\nimport * as ynModule from 'yn';\nimport { dirname } from 'path';\n\n/** @internal */\nexport const createRequire =\n  nodeCreateRequire ??\n  nodeCreateRequireFromPath ??\n  (require('create-require') as typeof _createRequire);\n\n/**\n * Wrapper around yn module that returns `undefined` instead of `null`.\n * This is implemented by yn v4, but we're staying on v3 to avoid v4's node 10 requirement.\n * @internal\n */\nexport function yn(value: string | undefined) {\n  return ynModule(value) ?? undefined;\n}\n\n/**\n * Like `Object.assign`, but ignores `undefined` properties.\n *\n * @internal\n */\nexport function assign<T extends object>(\n  initialValue: T,\n  ...sources: Array<T>\n): T {\n  for (const source of sources) {\n    for (const key of Object.keys(source)) {\n      const value = (source as any)[key];\n      if (value !== undefined) (initialValue as any)[key] = value;\n    }\n  }\n  return initialValue;\n}\n\n/**\n * Split a string array of values\n * and remove empty strings from the resulting array.\n * @internal\n */\nexport function split(value: string | undefined) {\n  return typeof value === 'string'\n    ? value.split(/ *, */g).filter((v) => v !== '')\n    : undefined;\n}\n\n/**\n * Parse a string as JSON.\n * @internal\n */\nexport function parse(value: string | undefined): object | undefined {\n  return typeof value === 'string' ? JSON.parse(value) : undefined;\n}\n\nconst directorySeparator = '/';\nconst backslashRegExp = /\\\\/g;\n/**\n * Replace backslashes with forward slashes.\n * @internal\n */\nexport function normalizeSlashes(value: string): string {\n  return value.replace(backslashRegExp, directorySeparator);\n}\n\n/**\n * Safe `hasOwnProperty`\n * @internal\n */\nexport function hasOwnProperty(object: any, property: string): boolean {\n  return Object.prototype.hasOwnProperty.call(object, property);\n}\n\n/**\n * Cached fs operation wrapper.\n */\nexport function cachedLookup<T, R>(fn: (arg: T) => R): (arg: T) => R {\n  const cache = new Map<T, R>();\n\n  return (arg: T): R => {\n    if (!cache.has(arg)) {\n      const v = fn(arg);\n      cache.set(arg, v);\n      return v;\n    }\n    return cache.get(arg)!;\n  };\n}\n\n/**\n * @internal\n * Require something with v8-compile-cache, which should make subsequent requires faster.\n * Do lots of error-handling so that, worst case, we require without the cache, and users are not blocked.\n */\nexport function attemptRequireWithV8CompileCache(\n  requireFn: typeof require,\n  specifier: string\n) {\n  try {\n    const v8CC = (\n      require('v8-compile-cache-lib') as typeof import('v8-compile-cache-lib')\n    ).install();\n    try {\n      return requireFn(specifier);\n    } finally {\n      v8CC?.uninstall();\n    }\n  } catch (e) {\n    return requireFn(specifier);\n  }\n}\n\n/**\n * Helper to discover dependencies relative to a user's project, optionally\n * falling back to relative to ts-node.  This supports global installations of\n * ts-node, for example where someone does `#!/usr/bin/env -S ts-node --swc` and\n * we need to fallback to a global install of @swc/core\n * @internal\n */\nexport function createProjectLocalResolveHelper(localDirectory: string) {\n  return function projectLocalResolveHelper(\n    specifier: string,\n    fallbackToTsNodeRelative: boolean\n  ) {\n    return require.resolve(specifier, {\n      paths: fallbackToTsNodeRelative\n        ? [localDirectory, __dirname]\n        : [localDirectory],\n    });\n  };\n}\n/** @internal */\nexport type ProjectLocalResolveHelper = ReturnType<\n  typeof createProjectLocalResolveHelper\n>;\n\n/**\n * Used as a reminder of all the factors we must consider when finding project-local dependencies and when a config file\n * on disk may or may not exist.\n * @internal\n */\nexport function getBasePathForProjectLocalDependencyResolution(\n  configFilePath: string | undefined,\n  projectSearchDirOption: string | undefined,\n  projectOption: string | undefined,\n  cwdOption: string\n) {\n  if (configFilePath != null) return dirname(configFilePath);\n  return projectSearchDirOption ?? projectOption ?? cwdOption;\n  // TODO technically breaks if projectOption is path to a file, not a directory,\n  // and we attempt to resolve relative specifiers.  By the time we resolve relative specifiers,\n  // should have configFilePath, so not reach this codepath.\n}\n\n/** @internal */\nexport function once<Fn extends (...args: any[]) => any>(fn: Fn) {\n  let value: ReturnType<Fn>;\n  let ran = false;\n  function onceFn(...args: Parameters<Fn>): ReturnType<Fn> {\n    if (ran) return value;\n    value = fn(...args);\n    ran = true;\n    return value;\n  }\n  return onceFn;\n}\n\n/** @internal */\nexport function versionGteLt(\n  version: string,\n  gteRequirement: string,\n  ltRequirement?: string\n) {\n  const [major, minor, patch, extra] = parse(version);\n  const [gteMajor, gteMinor, gtePatch] = parse(gteRequirement);\n  const isGte =\n    major > gteMajor ||\n    (major === gteMajor &&\n      (minor > gteMinor || (minor === gteMinor && patch >= gtePatch)));\n  let isLt = true;\n  if (ltRequirement) {\n    const [ltMajor, ltMinor, ltPatch] = parse(ltRequirement);\n    isLt =\n      major < ltMajor ||\n      (major === ltMajor &&\n        (minor < ltMinor || (minor === ltMinor && patch < ltPatch)));\n  }\n  return isGte && isLt;\n\n  function parse(requirement: string) {\n    return requirement.split(/[\\.-]/).map((s) => parseInt(s, 10));\n  }\n}\n"]},"metadata":{},"sourceType":"script","externalDependencies":[]}