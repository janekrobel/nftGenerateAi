{"ast":null,"code":"/*istanbul ignore start*/\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.calcLineCount = calcLineCount;\nexports.merge = merge;\n\n/*istanbul ignore end*/\nvar /*istanbul ignore start*/\n_create = require(\"./create\")\n/*istanbul ignore end*/;\n\nvar /*istanbul ignore start*/\n_parse = require(\"./parse\")\n/*istanbul ignore end*/;\n\nvar /*istanbul ignore start*/\n_array = require(\"../util/array\")\n/*istanbul ignore end*/;\n\n/*istanbul ignore start*/\nfunction _toConsumableArray(arr) {\n  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();\n}\nfunction _nonIterableSpread() {\n  throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\nfunction _unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(o);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n}\nfunction _iterableToArray(iter) {\n  if (typeof Symbol !== \"undefined\" && Symbol.iterator in Object(iter)) return Array.from(iter);\n}\nfunction _arrayWithoutHoles(arr) {\n  if (Array.isArray(arr)) return _arrayLikeToArray(arr);\n}\nfunction _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n  for (var i = 0, arr2 = new Array(len); i < len; i++) {\n    arr2[i] = arr[i];\n  }\n  return arr2;\n}\n\n/*istanbul ignore end*/\nfunction calcLineCount(hunk) {\n  /*istanbul ignore start*/\n  var _calcOldNewLineCount = /*istanbul ignore end*/\n    calcOldNewLineCount(hunk.lines),\n    oldLines = _calcOldNewLineCount.oldLines,\n    newLines = _calcOldNewLineCount.newLines;\n  if (oldLines !== undefined) {\n    hunk.oldLines = oldLines;\n  } else {\n    delete hunk.oldLines;\n  }\n  if (newLines !== undefined) {\n    hunk.newLines = newLines;\n  } else {\n    delete hunk.newLines;\n  }\n}\nfunction merge(mine, theirs, base) {\n  mine = loadPatch(mine, base);\n  theirs = loadPatch(theirs, base);\n  var ret = {}; // For index we just let it pass through as it doesn't have any necessary meaning.\n  // Leaving sanity checks on this to the API consumer that may know more about the\n  // meaning in their own context.\n\n  if (mine.index || theirs.index) {\n    ret.index = mine.index || theirs.index;\n  }\n  if (mine.newFileName || theirs.newFileName) {\n    if (!fileNameChanged(mine)) {\n      // No header or no change in ours, use theirs (and ours if theirs does not exist)\n      ret.oldFileName = theirs.oldFileName || mine.oldFileName;\n      ret.newFileName = theirs.newFileName || mine.newFileName;\n      ret.oldHeader = theirs.oldHeader || mine.oldHeader;\n      ret.newHeader = theirs.newHeader || mine.newHeader;\n    } else if (!fileNameChanged(theirs)) {\n      // No header or no change in theirs, use ours\n      ret.oldFileName = mine.oldFileName;\n      ret.newFileName = mine.newFileName;\n      ret.oldHeader = mine.oldHeader;\n      ret.newHeader = mine.newHeader;\n    } else {\n      // Both changed... figure it out\n      ret.oldFileName = selectField(ret, mine.oldFileName, theirs.oldFileName);\n      ret.newFileName = selectField(ret, mine.newFileName, theirs.newFileName);\n      ret.oldHeader = selectField(ret, mine.oldHeader, theirs.oldHeader);\n      ret.newHeader = selectField(ret, mine.newHeader, theirs.newHeader);\n    }\n  }\n  ret.hunks = [];\n  var mineIndex = 0,\n    theirsIndex = 0,\n    mineOffset = 0,\n    theirsOffset = 0;\n  while (mineIndex < mine.hunks.length || theirsIndex < theirs.hunks.length) {\n    var mineCurrent = mine.hunks[mineIndex] || {\n        oldStart: Infinity\n      },\n      theirsCurrent = theirs.hunks[theirsIndex] || {\n        oldStart: Infinity\n      };\n    if (hunkBefore(mineCurrent, theirsCurrent)) {\n      // This patch does not overlap with any of the others, yay.\n      ret.hunks.push(cloneHunk(mineCurrent, mineOffset));\n      mineIndex++;\n      theirsOffset += mineCurrent.newLines - mineCurrent.oldLines;\n    } else if (hunkBefore(theirsCurrent, mineCurrent)) {\n      // This patch does not overlap with any of the others, yay.\n      ret.hunks.push(cloneHunk(theirsCurrent, theirsOffset));\n      theirsIndex++;\n      mineOffset += theirsCurrent.newLines - theirsCurrent.oldLines;\n    } else {\n      // Overlap, merge as best we can\n      var mergedHunk = {\n        oldStart: Math.min(mineCurrent.oldStart, theirsCurrent.oldStart),\n        oldLines: 0,\n        newStart: Math.min(mineCurrent.newStart + mineOffset, theirsCurrent.oldStart + theirsOffset),\n        newLines: 0,\n        lines: []\n      };\n      mergeLines(mergedHunk, mineCurrent.oldStart, mineCurrent.lines, theirsCurrent.oldStart, theirsCurrent.lines);\n      theirsIndex++;\n      mineIndex++;\n      ret.hunks.push(mergedHunk);\n    }\n  }\n  return ret;\n}\nfunction loadPatch(param, base) {\n  if (typeof param === 'string') {\n    if (/^@@/m.test(param) || /^Index:/m.test(param)) {\n      return (/*istanbul ignore start*/\n        (0, /*istanbul ignore end*/\n\n        /*istanbul ignore start*/\n        _parse\n        /*istanbul ignore end*/. /*istanbul ignore start*/\n        parsePatch\n        /*istanbul ignore end*/)(param)[0]\n      );\n    }\n    if (!base) {\n      throw new Error('Must provide a base reference or pass in a patch');\n    }\n    return (/*istanbul ignore start*/\n      (0, /*istanbul ignore end*/\n\n      /*istanbul ignore start*/\n      _create\n      /*istanbul ignore end*/. /*istanbul ignore start*/\n      structuredPatch\n      /*istanbul ignore end*/)(undefined, undefined, base, param)\n    );\n  }\n  return param;\n}\nfunction fileNameChanged(patch) {\n  return patch.newFileName && patch.newFileName !== patch.oldFileName;\n}\nfunction selectField(index, mine, theirs) {\n  if (mine === theirs) {\n    return mine;\n  } else {\n    index.conflict = true;\n    return {\n      mine: mine,\n      theirs: theirs\n    };\n  }\n}\nfunction hunkBefore(test, check) {\n  return test.oldStart < check.oldStart && test.oldStart + test.oldLines < check.oldStart;\n}\nfunction cloneHunk(hunk, offset) {\n  return {\n    oldStart: hunk.oldStart,\n    oldLines: hunk.oldLines,\n    newStart: hunk.newStart + offset,\n    newLines: hunk.newLines,\n    lines: hunk.lines\n  };\n}\nfunction mergeLines(hunk, mineOffset, mineLines, theirOffset, theirLines) {\n  // This will generally result in a conflicted hunk, but there are cases where the context\n  // is the only overlap where we can successfully merge the content here.\n  var mine = {\n      offset: mineOffset,\n      lines: mineLines,\n      index: 0\n    },\n    their = {\n      offset: theirOffset,\n      lines: theirLines,\n      index: 0\n    }; // Handle any leading content\n\n  insertLeading(hunk, mine, their);\n  insertLeading(hunk, their, mine); // Now in the overlap content. Scan through and select the best changes from each.\n\n  while (mine.index < mine.lines.length && their.index < their.lines.length) {\n    var mineCurrent = mine.lines[mine.index],\n      theirCurrent = their.lines[their.index];\n    if ((mineCurrent[0] === '-' || mineCurrent[0] === '+') && (theirCurrent[0] === '-' || theirCurrent[0] === '+')) {\n      // Both modified ...\n      mutualChange(hunk, mine, their);\n    } else if (mineCurrent[0] === '+' && theirCurrent[0] === ' ') {\n      /*istanbul ignore start*/\n      var _hunk$lines;\n\n      /*istanbul ignore end*/\n      // Mine inserted\n\n      /*istanbul ignore start*/\n\n      /*istanbul ignore end*/\n\n      /*istanbul ignore start*/\n      (_hunk$lines = /*istanbul ignore end*/\n      hunk.lines).push.apply( /*istanbul ignore start*/\n      _hunk$lines\n      /*istanbul ignore end*/, /*istanbul ignore start*/\n      _toConsumableArray( /*istanbul ignore end*/\n      collectChange(mine)));\n    } else if (theirCurrent[0] === '+' && mineCurrent[0] === ' ') {\n      /*istanbul ignore start*/\n      var _hunk$lines2;\n\n      /*istanbul ignore end*/\n      // Theirs inserted\n\n      /*istanbul ignore start*/\n\n      /*istanbul ignore end*/\n\n      /*istanbul ignore start*/\n      (_hunk$lines2 = /*istanbul ignore end*/\n      hunk.lines).push.apply( /*istanbul ignore start*/\n      _hunk$lines2\n      /*istanbul ignore end*/, /*istanbul ignore start*/\n      _toConsumableArray( /*istanbul ignore end*/\n      collectChange(their)));\n    } else if (mineCurrent[0] === '-' && theirCurrent[0] === ' ') {\n      // Mine removed or edited\n      removal(hunk, mine, their);\n    } else if (theirCurrent[0] === '-' && mineCurrent[0] === ' ') {\n      // Their removed or edited\n      removal(hunk, their, mine, true);\n    } else if (mineCurrent === theirCurrent) {\n      // Context identity\n      hunk.lines.push(mineCurrent);\n      mine.index++;\n      their.index++;\n    } else {\n      // Context mismatch\n      conflict(hunk, collectChange(mine), collectChange(their));\n    }\n  } // Now push anything that may be remaining\n\n  insertTrailing(hunk, mine);\n  insertTrailing(hunk, their);\n  calcLineCount(hunk);\n}\nfunction mutualChange(hunk, mine, their) {\n  var myChanges = collectChange(mine),\n    theirChanges = collectChange(their);\n  if (allRemoves(myChanges) && allRemoves(theirChanges)) {\n    // Special case for remove changes that are supersets of one another\n    if ( /*istanbul ignore start*/\n    (0, /*istanbul ignore end*/\n\n    /*istanbul ignore start*/\n    _array\n    /*istanbul ignore end*/. /*istanbul ignore start*/\n    arrayStartsWith\n    /*istanbul ignore end*/)(myChanges, theirChanges) && skipRemoveSuperset(their, myChanges, myChanges.length - theirChanges.length)) {\n      /*istanbul ignore start*/\n      var _hunk$lines3;\n\n      /*istanbul ignore end*/\n\n      /*istanbul ignore start*/\n\n      /*istanbul ignore end*/\n\n      /*istanbul ignore start*/\n      (_hunk$lines3 = /*istanbul ignore end*/\n      hunk.lines).push.apply( /*istanbul ignore start*/\n      _hunk$lines3\n      /*istanbul ignore end*/, /*istanbul ignore start*/\n      _toConsumableArray( /*istanbul ignore end*/\n      myChanges));\n      return;\n    } else if ( /*istanbul ignore start*/\n    (0, /*istanbul ignore end*/\n\n    /*istanbul ignore start*/\n    _array\n    /*istanbul ignore end*/. /*istanbul ignore start*/\n    arrayStartsWith\n    /*istanbul ignore end*/)(theirChanges, myChanges) && skipRemoveSuperset(mine, theirChanges, theirChanges.length - myChanges.length)) {\n      /*istanbul ignore start*/\n      var _hunk$lines4;\n\n      /*istanbul ignore end*/\n\n      /*istanbul ignore start*/\n\n      /*istanbul ignore end*/\n\n      /*istanbul ignore start*/\n      (_hunk$lines4 = /*istanbul ignore end*/\n      hunk.lines).push.apply( /*istanbul ignore start*/\n      _hunk$lines4\n      /*istanbul ignore end*/, /*istanbul ignore start*/\n      _toConsumableArray( /*istanbul ignore end*/\n      theirChanges));\n      return;\n    }\n  } else if ( /*istanbul ignore start*/\n  (0, /*istanbul ignore end*/\n\n  /*istanbul ignore start*/\n  _array\n  /*istanbul ignore end*/. /*istanbul ignore start*/\n  arrayEqual\n  /*istanbul ignore end*/)(myChanges, theirChanges)) {\n    /*istanbul ignore start*/\n    var _hunk$lines5;\n\n    /*istanbul ignore end*/\n\n    /*istanbul ignore start*/\n\n    /*istanbul ignore end*/\n\n    /*istanbul ignore start*/\n    (_hunk$lines5 = /*istanbul ignore end*/\n    hunk.lines).push.apply( /*istanbul ignore start*/\n    _hunk$lines5\n    /*istanbul ignore end*/, /*istanbul ignore start*/\n    _toConsumableArray( /*istanbul ignore end*/\n    myChanges));\n    return;\n  }\n  conflict(hunk, myChanges, theirChanges);\n}\nfunction removal(hunk, mine, their, swap) {\n  var myChanges = collectChange(mine),\n    theirChanges = collectContext(their, myChanges);\n  if (theirChanges.merged) {\n    /*istanbul ignore start*/\n    var _hunk$lines6;\n\n    /*istanbul ignore end*/\n\n    /*istanbul ignore start*/\n\n    /*istanbul ignore end*/\n\n    /*istanbul ignore start*/\n    (_hunk$lines6 = /*istanbul ignore end*/\n    hunk.lines).push.apply( /*istanbul ignore start*/\n    _hunk$lines6\n    /*istanbul ignore end*/, /*istanbul ignore start*/\n    _toConsumableArray( /*istanbul ignore end*/\n    theirChanges.merged));\n  } else {\n    conflict(hunk, swap ? theirChanges : myChanges, swap ? myChanges : theirChanges);\n  }\n}\nfunction conflict(hunk, mine, their) {\n  hunk.conflict = true;\n  hunk.lines.push({\n    conflict: true,\n    mine: mine,\n    theirs: their\n  });\n}\nfunction insertLeading(hunk, insert, their) {\n  while (insert.offset < their.offset && insert.index < insert.lines.length) {\n    var line = insert.lines[insert.index++];\n    hunk.lines.push(line);\n    insert.offset++;\n  }\n}\nfunction insertTrailing(hunk, insert) {\n  while (insert.index < insert.lines.length) {\n    var line = insert.lines[insert.index++];\n    hunk.lines.push(line);\n  }\n}\nfunction collectChange(state) {\n  var ret = [],\n    operation = state.lines[state.index][0];\n  while (state.index < state.lines.length) {\n    var line = state.lines[state.index]; // Group additions that are immediately after subtractions and treat them as one \"atomic\" modify change.\n\n    if (operation === '-' && line[0] === '+') {\n      operation = '+';\n    }\n    if (operation === line[0]) {\n      ret.push(line);\n      state.index++;\n    } else {\n      break;\n    }\n  }\n  return ret;\n}\nfunction collectContext(state, matchChanges) {\n  var changes = [],\n    merged = [],\n    matchIndex = 0,\n    contextChanges = false,\n    conflicted = false;\n  while (matchIndex < matchChanges.length && state.index < state.lines.length) {\n    var change = state.lines[state.index],\n      match = matchChanges[matchIndex]; // Once we've hit our add, then we are done\n\n    if (match[0] === '+') {\n      break;\n    }\n    contextChanges = contextChanges || change[0] !== ' ';\n    merged.push(match);\n    matchIndex++; // Consume any additions in the other block as a conflict to attempt\n    // to pull in the remaining context after this\n\n    if (change[0] === '+') {\n      conflicted = true;\n      while (change[0] === '+') {\n        changes.push(change);\n        change = state.lines[++state.index];\n      }\n    }\n    if (match.substr(1) === change.substr(1)) {\n      changes.push(change);\n      state.index++;\n    } else {\n      conflicted = true;\n    }\n  }\n  if ((matchChanges[matchIndex] || '')[0] === '+' && contextChanges) {\n    conflicted = true;\n  }\n  if (conflicted) {\n    return changes;\n  }\n  while (matchIndex < matchChanges.length) {\n    merged.push(matchChanges[matchIndex++]);\n  }\n  return {\n    merged: merged,\n    changes: changes\n  };\n}\nfunction allRemoves(changes) {\n  return changes.reduce(function (prev, change) {\n    return prev && change[0] === '-';\n  }, true);\n}\nfunction skipRemoveSuperset(state, removeChanges, delta) {\n  for (var i = 0; i < delta; i++) {\n    var changeContent = removeChanges[removeChanges.length - delta + i].substr(1);\n    if (state.lines[state.index + i] !== ' ' + changeContent) {\n      return false;\n    }\n  }\n  state.index += delta;\n  return true;\n}\nfunction calcOldNewLineCount(lines) {\n  var oldLines = 0;\n  var newLines = 0;\n  lines.forEach(function (line) {\n    if (typeof line !== 'string') {\n      var myCount = calcOldNewLineCount(line.mine);\n      var theirCount = calcOldNewLineCount(line.theirs);\n      if (oldLines !== undefined) {\n        if (myCount.oldLines === theirCount.oldLines) {\n          oldLines += myCount.oldLines;\n        } else {\n          oldLines = undefined;\n        }\n      }\n      if (newLines !== undefined) {\n        if (myCount.newLines === theirCount.newLines) {\n          newLines += myCount.newLines;\n        } else {\n          newLines = undefined;\n        }\n      }\n    } else {\n      if (newLines !== undefined && (line[0] === '+' || line[0] === ' ')) {\n        newLines++;\n      }\n      if (oldLines !== undefined && (line[0] === '-' || line[0] === ' ')) {\n        oldLines++;\n      }\n    }\n  });\n  return {\n    oldLines: oldLines,\n    newLines: newLines\n  };\n}","map":{"version":3,"mappings":"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","names":["_create","_parse","_array","calcLineCount","hunk","calcOldNewLineCount","lines","oldLines","newLines","undefined","merge","mine","theirs","base","loadPatch","ret","index","newFileName","fileNameChanged","oldFileName","oldHeader","newHeader","selectField","hunks","mineIndex","theirsIndex","mineOffset","theirsOffset","length","mineCurrent","oldStart","Infinity","theirsCurrent","hunkBefore","push","cloneHunk","mergedHunk","Math","min","newStart","mergeLines","param","test","parsePatch","Error","structuredPatch","patch","conflict","check","offset","mineLines","theirOffset","theirLines","their","insertLeading","theirCurrent","mutualChange","_hunk$lines","_toConsumableArray","collectChange","_hunk$lines2","removal","insertTrailing","myChanges","theirChanges","allRemoves","arrayStartsWith","skipRemoveSuperset","_hunk$lines3","_hunk$lines4","arrayEqual","_hunk$lines5","swap","collectContext","merged","_hunk$lines6","insert","line","state","operation","matchChanges","changes","matchIndex","contextChanges","conflicted","change","match","substr","reduce","prev","removeChanges","delta","i","changeContent","forEach","myCount","theirCount"],"sources":["/Users/janrobel/Documents/PersonalProjekty/nftGenerateAi/clientAndContract/node_modules/diff/src/patch/merge.js"],"sourcesContent":["import {structuredPatch} from './create';\nimport {parsePatch} from './parse';\n\nimport {arrayEqual, arrayStartsWith} from '../util/array';\n\nexport function calcLineCount(hunk) {\n  const {oldLines, newLines} = calcOldNewLineCount(hunk.lines);\n\n  if (oldLines !== undefined) {\n    hunk.oldLines = oldLines;\n  } else {\n    delete hunk.oldLines;\n  }\n\n  if (newLines !== undefined) {\n    hunk.newLines = newLines;\n  } else {\n    delete hunk.newLines;\n  }\n}\n\nexport function merge(mine, theirs, base) {\n  mine = loadPatch(mine, base);\n  theirs = loadPatch(theirs, base);\n\n  let ret = {};\n\n  // For index we just let it pass through as it doesn't have any necessary meaning.\n  // Leaving sanity checks on this to the API consumer that may know more about the\n  // meaning in their own context.\n  if (mine.index || theirs.index) {\n    ret.index = mine.index || theirs.index;\n  }\n\n  if (mine.newFileName || theirs.newFileName) {\n    if (!fileNameChanged(mine)) {\n      // No header or no change in ours, use theirs (and ours if theirs does not exist)\n      ret.oldFileName = theirs.oldFileName || mine.oldFileName;\n      ret.newFileName = theirs.newFileName || mine.newFileName;\n      ret.oldHeader = theirs.oldHeader || mine.oldHeader;\n      ret.newHeader = theirs.newHeader || mine.newHeader;\n    } else if (!fileNameChanged(theirs)) {\n      // No header or no change in theirs, use ours\n      ret.oldFileName = mine.oldFileName;\n      ret.newFileName = mine.newFileName;\n      ret.oldHeader = mine.oldHeader;\n      ret.newHeader = mine.newHeader;\n    } else {\n      // Both changed... figure it out\n      ret.oldFileName = selectField(ret, mine.oldFileName, theirs.oldFileName);\n      ret.newFileName = selectField(ret, mine.newFileName, theirs.newFileName);\n      ret.oldHeader = selectField(ret, mine.oldHeader, theirs.oldHeader);\n      ret.newHeader = selectField(ret, mine.newHeader, theirs.newHeader);\n    }\n  }\n\n  ret.hunks = [];\n\n  let mineIndex = 0,\n      theirsIndex = 0,\n      mineOffset = 0,\n      theirsOffset = 0;\n\n  while (mineIndex < mine.hunks.length || theirsIndex < theirs.hunks.length) {\n    let mineCurrent = mine.hunks[mineIndex] || {oldStart: Infinity},\n        theirsCurrent = theirs.hunks[theirsIndex] || {oldStart: Infinity};\n\n    if (hunkBefore(mineCurrent, theirsCurrent)) {\n      // This patch does not overlap with any of the others, yay.\n      ret.hunks.push(cloneHunk(mineCurrent, mineOffset));\n      mineIndex++;\n      theirsOffset += mineCurrent.newLines - mineCurrent.oldLines;\n    } else if (hunkBefore(theirsCurrent, mineCurrent)) {\n      // This patch does not overlap with any of the others, yay.\n      ret.hunks.push(cloneHunk(theirsCurrent, theirsOffset));\n      theirsIndex++;\n      mineOffset += theirsCurrent.newLines - theirsCurrent.oldLines;\n    } else {\n      // Overlap, merge as best we can\n      let mergedHunk = {\n        oldStart: Math.min(mineCurrent.oldStart, theirsCurrent.oldStart),\n        oldLines: 0,\n        newStart: Math.min(mineCurrent.newStart + mineOffset, theirsCurrent.oldStart + theirsOffset),\n        newLines: 0,\n        lines: []\n      };\n      mergeLines(mergedHunk, mineCurrent.oldStart, mineCurrent.lines, theirsCurrent.oldStart, theirsCurrent.lines);\n      theirsIndex++;\n      mineIndex++;\n\n      ret.hunks.push(mergedHunk);\n    }\n  }\n\n  return ret;\n}\n\nfunction loadPatch(param, base) {\n  if (typeof param === 'string') {\n    if ((/^@@/m).test(param) || ((/^Index:/m).test(param))) {\n      return parsePatch(param)[0];\n    }\n\n    if (!base) {\n      throw new Error('Must provide a base reference or pass in a patch');\n    }\n    return structuredPatch(undefined, undefined, base, param);\n  }\n\n  return param;\n}\n\nfunction fileNameChanged(patch) {\n  return patch.newFileName && patch.newFileName !== patch.oldFileName;\n}\n\nfunction selectField(index, mine, theirs) {\n  if (mine === theirs) {\n    return mine;\n  } else {\n    index.conflict = true;\n    return {mine, theirs};\n  }\n}\n\nfunction hunkBefore(test, check) {\n  return test.oldStart < check.oldStart\n    && (test.oldStart + test.oldLines) < check.oldStart;\n}\n\nfunction cloneHunk(hunk, offset) {\n  return {\n    oldStart: hunk.oldStart, oldLines: hunk.oldLines,\n    newStart: hunk.newStart + offset, newLines: hunk.newLines,\n    lines: hunk.lines\n  };\n}\n\nfunction mergeLines(hunk, mineOffset, mineLines, theirOffset, theirLines) {\n  // This will generally result in a conflicted hunk, but there are cases where the context\n  // is the only overlap where we can successfully merge the content here.\n  let mine = {offset: mineOffset, lines: mineLines, index: 0},\n      their = {offset: theirOffset, lines: theirLines, index: 0};\n\n  // Handle any leading content\n  insertLeading(hunk, mine, their);\n  insertLeading(hunk, their, mine);\n\n  // Now in the overlap content. Scan through and select the best changes from each.\n  while (mine.index < mine.lines.length && their.index < their.lines.length) {\n    let mineCurrent = mine.lines[mine.index],\n        theirCurrent = their.lines[their.index];\n\n    if ((mineCurrent[0] === '-' || mineCurrent[0] === '+')\n        && (theirCurrent[0] === '-' || theirCurrent[0] === '+')) {\n      // Both modified ...\n      mutualChange(hunk, mine, their);\n    } else if (mineCurrent[0] === '+' && theirCurrent[0] === ' ') {\n      // Mine inserted\n      hunk.lines.push(... collectChange(mine));\n    } else if (theirCurrent[0] === '+' && mineCurrent[0] === ' ') {\n      // Theirs inserted\n      hunk.lines.push(... collectChange(their));\n    } else if (mineCurrent[0] === '-' && theirCurrent[0] === ' ') {\n      // Mine removed or edited\n      removal(hunk, mine, their);\n    } else if (theirCurrent[0] === '-' && mineCurrent[0] === ' ') {\n      // Their removed or edited\n      removal(hunk, their, mine, true);\n    } else if (mineCurrent === theirCurrent) {\n      // Context identity\n      hunk.lines.push(mineCurrent);\n      mine.index++;\n      their.index++;\n    } else {\n      // Context mismatch\n      conflict(hunk, collectChange(mine), collectChange(their));\n    }\n  }\n\n  // Now push anything that may be remaining\n  insertTrailing(hunk, mine);\n  insertTrailing(hunk, their);\n\n  calcLineCount(hunk);\n}\n\nfunction mutualChange(hunk, mine, their) {\n  let myChanges = collectChange(mine),\n      theirChanges = collectChange(their);\n\n  if (allRemoves(myChanges) && allRemoves(theirChanges)) {\n    // Special case for remove changes that are supersets of one another\n    if (arrayStartsWith(myChanges, theirChanges)\n        && skipRemoveSuperset(their, myChanges, myChanges.length - theirChanges.length)) {\n      hunk.lines.push(... myChanges);\n      return;\n    } else if (arrayStartsWith(theirChanges, myChanges)\n        && skipRemoveSuperset(mine, theirChanges, theirChanges.length - myChanges.length)) {\n      hunk.lines.push(... theirChanges);\n      return;\n    }\n  } else if (arrayEqual(myChanges, theirChanges)) {\n    hunk.lines.push(... myChanges);\n    return;\n  }\n\n  conflict(hunk, myChanges, theirChanges);\n}\n\nfunction removal(hunk, mine, their, swap) {\n  let myChanges = collectChange(mine),\n      theirChanges = collectContext(their, myChanges);\n  if (theirChanges.merged) {\n    hunk.lines.push(... theirChanges.merged);\n  } else {\n    conflict(hunk, swap ? theirChanges : myChanges, swap ? myChanges : theirChanges);\n  }\n}\n\nfunction conflict(hunk, mine, their) {\n  hunk.conflict = true;\n  hunk.lines.push({\n    conflict: true,\n    mine: mine,\n    theirs: their\n  });\n}\n\nfunction insertLeading(hunk, insert, their) {\n  while (insert.offset < their.offset && insert.index < insert.lines.length) {\n    let line = insert.lines[insert.index++];\n    hunk.lines.push(line);\n    insert.offset++;\n  }\n}\nfunction insertTrailing(hunk, insert) {\n  while (insert.index < insert.lines.length) {\n    let line = insert.lines[insert.index++];\n    hunk.lines.push(line);\n  }\n}\n\nfunction collectChange(state) {\n  let ret = [],\n      operation = state.lines[state.index][0];\n  while (state.index < state.lines.length) {\n    let line = state.lines[state.index];\n\n    // Group additions that are immediately after subtractions and treat them as one \"atomic\" modify change.\n    if (operation === '-' && line[0] === '+') {\n      operation = '+';\n    }\n\n    if (operation === line[0]) {\n      ret.push(line);\n      state.index++;\n    } else {\n      break;\n    }\n  }\n\n  return ret;\n}\nfunction collectContext(state, matchChanges) {\n  let changes = [],\n      merged = [],\n      matchIndex = 0,\n      contextChanges = false,\n      conflicted = false;\n  while (matchIndex < matchChanges.length\n        && state.index < state.lines.length) {\n    let change = state.lines[state.index],\n        match = matchChanges[matchIndex];\n\n    // Once we've hit our add, then we are done\n    if (match[0] === '+') {\n      break;\n    }\n\n    contextChanges = contextChanges || change[0] !== ' ';\n\n    merged.push(match);\n    matchIndex++;\n\n    // Consume any additions in the other block as a conflict to attempt\n    // to pull in the remaining context after this\n    if (change[0] === '+') {\n      conflicted = true;\n\n      while (change[0] === '+') {\n        changes.push(change);\n        change = state.lines[++state.index];\n      }\n    }\n\n    if (match.substr(1) === change.substr(1)) {\n      changes.push(change);\n      state.index++;\n    } else {\n      conflicted = true;\n    }\n  }\n\n  if ((matchChanges[matchIndex] || '')[0] === '+'\n      && contextChanges) {\n    conflicted = true;\n  }\n\n  if (conflicted) {\n    return changes;\n  }\n\n  while (matchIndex < matchChanges.length) {\n    merged.push(matchChanges[matchIndex++]);\n  }\n\n  return {\n    merged,\n    changes\n  };\n}\n\nfunction allRemoves(changes) {\n  return changes.reduce(function(prev, change) {\n    return prev && change[0] === '-';\n  }, true);\n}\nfunction skipRemoveSuperset(state, removeChanges, delta) {\n  for (let i = 0; i < delta; i++) {\n    let changeContent = removeChanges[removeChanges.length - delta + i].substr(1);\n    if (state.lines[state.index + i] !== ' ' + changeContent) {\n      return false;\n    }\n  }\n\n  state.index += delta;\n  return true;\n}\n\nfunction calcOldNewLineCount(lines) {\n  let oldLines = 0;\n  let newLines = 0;\n\n  lines.forEach(function(line) {\n    if (typeof line !== 'string') {\n      let myCount = calcOldNewLineCount(line.mine);\n      let theirCount = calcOldNewLineCount(line.theirs);\n\n      if (oldLines !== undefined) {\n        if (myCount.oldLines === theirCount.oldLines) {\n          oldLines += myCount.oldLines;\n        } else {\n          oldLines = undefined;\n        }\n      }\n\n      if (newLines !== undefined) {\n        if (myCount.newLines === theirCount.newLines) {\n          newLines += myCount.newLines;\n        } else {\n          newLines = undefined;\n        }\n      }\n    } else {\n      if (newLines !== undefined && (line[0] === '+' || line[0] === ' ')) {\n        newLines++;\n      }\n      if (oldLines !== undefined && (line[0] === '-' || line[0] === ' ')) {\n        oldLines++;\n      }\n    }\n  });\n\n  return {oldLines, newLines};\n}\n"]},"metadata":{},"sourceType":"script","externalDependencies":[]}