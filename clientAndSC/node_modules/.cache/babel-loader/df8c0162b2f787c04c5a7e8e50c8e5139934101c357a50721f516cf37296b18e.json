{"ast":null,"code":"\"use strict\";\n\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  Object.defineProperty(o, k2, {\n    enumerable: true,\n    get: function () {\n      return m[k];\n    }\n  });\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, \"default\", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o[\"default\"] = v;\n});\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n  __setModuleDefault(result, mod);\n  return result;\n};\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.getSolidityFilesCachePath = exports.SolidityFilesCache = void 0;\nconst debug_1 = __importDefault(require(\"debug\"));\nconst fs_extra_1 = __importDefault(require(\"fs-extra\"));\nconst t = __importStar(require(\"io-ts\"));\nconst path = __importStar(require(\"path\"));\nconst constants_1 = require(\"../../internal/constants\");\nconst log = (0, debug_1.default)(\"hardhat:core:tasks:compile:cache\");\nconst FORMAT_VERSION = \"hh-sol-cache-2\";\nconst CacheEntryCodec = t.type({\n  lastModificationDate: t.number,\n  contentHash: t.string,\n  sourceName: t.string,\n  solcConfig: t.any,\n  imports: t.array(t.string),\n  versionPragmas: t.array(t.string),\n  artifacts: t.array(t.string)\n});\nconst CacheCodec = t.type({\n  _format: t.string,\n  files: t.record(t.string, CacheEntryCodec)\n});\nclass SolidityFilesCache {\n  constructor(_cache) {\n    this._cache = _cache;\n  }\n  static createEmpty() {\n    return new SolidityFilesCache({\n      _format: FORMAT_VERSION,\n      files: {}\n    });\n  }\n  static async readFromFile(solidityFilesCachePath) {\n    let cacheRaw = {\n      _format: FORMAT_VERSION,\n      files: {}\n    };\n    if (await fs_extra_1.default.pathExists(solidityFilesCachePath)) {\n      cacheRaw = await fs_extra_1.default.readJson(solidityFilesCachePath);\n    }\n    const result = CacheCodec.decode(cacheRaw);\n    if (result.isRight()) {\n      const solidityFilesCache = new SolidityFilesCache(result.value);\n      await solidityFilesCache.removeNonExistingFiles();\n      return solidityFilesCache;\n    }\n    log(\"There was a problem reading the cache\");\n    return new SolidityFilesCache({\n      _format: FORMAT_VERSION,\n      files: {}\n    });\n  }\n  async removeNonExistingFiles() {\n    await Promise.all(Object.keys(this._cache.files).map(async absolutePath => {\n      if (!(await fs_extra_1.default.pathExists(absolutePath))) {\n        this.removeEntry(absolutePath);\n      }\n    }));\n  }\n  async writeToFile(solidityFilesCachePath) {\n    await fs_extra_1.default.outputJson(solidityFilesCachePath, this._cache, {\n      spaces: 2\n    });\n  }\n  addFile(absolutePath, entry) {\n    this._cache.files[absolutePath] = entry;\n  }\n  getEntries() {\n    return Object.values(this._cache.files);\n  }\n  getEntry(file) {\n    return this._cache.files[file];\n  }\n  removeEntry(file) {\n    delete this._cache.files[file];\n  }\n  hasFileChanged(absolutePath, contentHash, solcConfig) {\n    const isEqual = require(\"lodash/isEqual\");\n    const cacheEntry = this.getEntry(absolutePath);\n    if (cacheEntry === undefined) {\n      // new file or no cache available, assume it's new\n      return true;\n    }\n    if (cacheEntry.contentHash !== contentHash) {\n      return true;\n    }\n    if (solcConfig !== undefined && !isEqual(solcConfig, cacheEntry.solcConfig)) {\n      return true;\n    }\n    return false;\n  }\n}\nexports.SolidityFilesCache = SolidityFilesCache;\nfunction getSolidityFilesCachePath(paths) {\n  return path.join(paths.cache, constants_1.SOLIDITY_FILES_CACHE_FILENAME);\n}\nexports.getSolidityFilesCachePath = getSolidityFilesCachePath;","map":{"version":3,"mappings":"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","names":["log","FORMAT_VERSION","CacheEntryCodec","t","type","lastModificationDate","number","contentHash","string","sourceName","solcConfig","any","imports","array","versionPragmas","artifacts","CacheCodec","_format","files","record","SolidityFilesCache","constructor","_cache","createEmpty","readFromFile","solidityFilesCachePath","cacheRaw","fs_extra_1","pathExists","readJson","result","decode","isRight","solidityFilesCache","value","removeNonExistingFiles","Promise","all","Object","keys","map","absolutePath","removeEntry","writeToFile","outputJson","spaces","addFile","entry","getEntries","values","getEntry","file","hasFileChanged","isEqual","require","cacheEntry","undefined","exports","getSolidityFilesCachePath","paths","path","join","cache","constants_1"],"sources":["/Users/janrobel/Documents/PersonalProjekty/nftGenerateAi/clientAndContract/node_modules/hardhat/src/builtin-tasks/utils/solidity-files-cache.ts"],"sourcesContent":["import type { LoDashStatic } from \"lodash\";\nimport type { ProjectPathsConfig, SolcConfig } from \"../../types\";\n\nimport debug from \"debug\";\nimport fsExtra from \"fs-extra\";\nimport * as t from \"io-ts\";\nimport * as path from \"path\";\n\nimport { SOLIDITY_FILES_CACHE_FILENAME } from \"../../internal/constants\";\n\nconst log = debug(\"hardhat:core:tasks:compile:cache\");\n\nconst FORMAT_VERSION = \"hh-sol-cache-2\";\n\nconst CacheEntryCodec = t.type({\n  lastModificationDate: t.number,\n  contentHash: t.string,\n  sourceName: t.string,\n  solcConfig: t.any,\n  imports: t.array(t.string),\n  versionPragmas: t.array(t.string),\n  artifacts: t.array(t.string),\n});\n\nconst CacheCodec = t.type({\n  _format: t.string,\n  files: t.record(t.string, CacheEntryCodec),\n});\n\nexport interface CacheEntry {\n  lastModificationDate: number;\n  contentHash: string;\n  sourceName: string;\n  solcConfig: SolcConfig;\n  imports: string[];\n  versionPragmas: string[];\n  artifacts: string[];\n}\n\nexport interface Cache {\n  _format: string;\n  files: Record<string, CacheEntry>;\n}\n\nexport class SolidityFilesCache {\n  public static createEmpty(): SolidityFilesCache {\n    return new SolidityFilesCache({\n      _format: FORMAT_VERSION,\n      files: {},\n    });\n  }\n\n  public static async readFromFile(\n    solidityFilesCachePath: string\n  ): Promise<SolidityFilesCache> {\n    let cacheRaw: Cache = {\n      _format: FORMAT_VERSION,\n      files: {},\n    };\n    if (await fsExtra.pathExists(solidityFilesCachePath)) {\n      cacheRaw = await fsExtra.readJson(solidityFilesCachePath);\n    }\n\n    const result = CacheCodec.decode(cacheRaw);\n\n    if (result.isRight()) {\n      const solidityFilesCache = new SolidityFilesCache(result.value);\n      await solidityFilesCache.removeNonExistingFiles();\n      return solidityFilesCache;\n    }\n\n    log(\"There was a problem reading the cache\");\n\n    return new SolidityFilesCache({\n      _format: FORMAT_VERSION,\n      files: {},\n    });\n  }\n\n  constructor(private _cache: Cache) {}\n\n  public async removeNonExistingFiles() {\n    await Promise.all(\n      Object.keys(this._cache.files).map(async (absolutePath) => {\n        if (!(await fsExtra.pathExists(absolutePath))) {\n          this.removeEntry(absolutePath);\n        }\n      })\n    );\n  }\n\n  public async writeToFile(solidityFilesCachePath: string) {\n    await fsExtra.outputJson(solidityFilesCachePath, this._cache, {\n      spaces: 2,\n    });\n  }\n\n  public addFile(absolutePath: string, entry: CacheEntry) {\n    this._cache.files[absolutePath] = entry;\n  }\n\n  public getEntries(): CacheEntry[] {\n    return Object.values(this._cache.files);\n  }\n\n  public getEntry(file: string): CacheEntry | undefined {\n    return this._cache.files[file];\n  }\n\n  public removeEntry(file: string) {\n    delete this._cache.files[file];\n  }\n\n  public hasFileChanged(\n    absolutePath: string,\n    contentHash: string,\n    solcConfig?: SolcConfig\n  ): boolean {\n    const isEqual = require(\"lodash/isEqual\") as LoDashStatic[\"isEqual\"];\n\n    const cacheEntry = this.getEntry(absolutePath);\n\n    if (cacheEntry === undefined) {\n      // new file or no cache available, assume it's new\n      return true;\n    }\n\n    if (cacheEntry.contentHash !== contentHash) {\n      return true;\n    }\n\n    if (\n      solcConfig !== undefined &&\n      !isEqual(solcConfig, cacheEntry.solcConfig)\n    ) {\n      return true;\n    }\n\n    return false;\n  }\n}\n\nexport function getSolidityFilesCachePath(paths: ProjectPathsConfig): string {\n  return path.join(paths.cache, SOLIDITY_FILES_CACHE_FILENAME);\n}\n"]},"metadata":{},"sourceType":"script","externalDependencies":[]}