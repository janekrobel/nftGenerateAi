{"ast":null,"code":"\"use strict\";\n\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  Object.defineProperty(o, k2, {\n    enumerable: true,\n    get: function () {\n      return m[k];\n    }\n  });\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, \"default\", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o[\"default\"] = v;\n});\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n  __setModuleDefault(result, mod);\n  return result;\n};\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.runScriptWithHardhat = exports.runScript = void 0;\nconst debug_1 = __importDefault(require(\"debug\"));\nconst path_1 = __importDefault(require(\"path\"));\nconst execution_mode_1 = require(\"../core/execution-mode\");\nconst env_variables_1 = require(\"../core/params/env-variables\");\nconst log = (0, debug_1.default)(\"hardhat:core:scripts-runner\");\nasync function runScript(scriptPath) {\n  let scriptArgs = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n  let extraNodeArgs = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];\n  let extraEnvVars = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n  const {\n    fork\n  } = await Promise.resolve().then(() => __importStar(require(\"child_process\")));\n  return new Promise((resolve, reject) => {\n    const processExecArgv = withFixedInspectArg(process.execArgv);\n    const nodeArgs = [...processExecArgv, ...getTsNodeArgsIfNeeded(scriptPath, extraEnvVars.HARDHAT_TYPECHECK === \"true\"), ...extraNodeArgs];\n    const envVars = {\n      ...process.env,\n      ...extraEnvVars\n    };\n    const childProcess = fork(scriptPath, scriptArgs, {\n      stdio: \"inherit\",\n      execArgv: nodeArgs,\n      env: envVars\n    });\n    childProcess.once(\"close\", status => {\n      log(`Script ${scriptPath} exited with status code ${status ?? \"null\"}`);\n      resolve(status);\n    });\n    childProcess.once(\"error\", reject);\n  });\n}\nexports.runScript = runScript;\nasync function runScriptWithHardhat(hardhatArguments, scriptPath) {\n  let scriptArgs = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];\n  let extraNodeArgs = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : [];\n  let extraEnvVars = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : {};\n  log(`Creating Hardhat subprocess to run ${scriptPath}`);\n  return runScript(scriptPath, scriptArgs, [...extraNodeArgs, \"--require\", path_1.default.join(__dirname, \"..\", \"..\", \"register\")], {\n    ...(0, env_variables_1.getEnvVariablesMap)(hardhatArguments),\n    ...extraEnvVars\n  });\n}\nexports.runScriptWithHardhat = runScriptWithHardhat;\n/**\n * Fix debugger \"inspect\" arg from process.argv, if present.\n *\n * When running this process with a debugger, a debugger port\n * is specified via the \"--inspect-brk=\" arg param in some IDEs/setups.\n *\n * This normally works, but if we do a fork afterwards, we'll get an error stating\n * that the port is already in use (since the fork would also use the same args,\n * therefore the same port number). To prevent this issue, we could replace the port number with\n * a different free one, or simply use the port-agnostic --inspect\" flag, and leave the debugger\n * port selection to the Node process itself, which will pick an empty AND valid one.\n *\n * This way, we can properly use the debugger for this process AND for the executed\n * script itself - even if it's compiled using ts-node.\n */\nfunction withFixedInspectArg(argv) {\n  const fixIfInspectArg = arg => {\n    if (arg.toLowerCase().includes(\"--inspect-brk=\")) {\n      return \"--inspect\";\n    }\n    return arg;\n  };\n  return argv.map(fixIfInspectArg);\n}\nfunction getTsNodeArgsIfNeeded(scriptPath, shouldTypecheck) {\n  if (process.execArgv.includes(\"ts-node/register\")) {\n    return [];\n  }\n  // if we are running the tests we only want to transpile, or these tests\n  // take forever\n  if ((0, execution_mode_1.isRunningHardhatCoreTests)()) {\n    return [\"--require\", \"ts-node/register/transpile-only\"];\n  }\n  // If the script we are going to run is .ts we need ts-node\n  if (/\\.tsx?$/i.test(scriptPath)) {\n    return [\"--require\", `ts-node/register${shouldTypecheck ? \"\" : \"/transpile-only\"}`];\n  }\n  return [];\n}","map":{"version":3,"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;AACA;AAGA;AACA;AAEA,MAAMA,GAAG,GAAG,mBAAK,EAAC,6BAA6B,CAAC;AAEzC,eAAeC,SAAS,CAC7BC,UAAkB,EAG2B;EAAA,IAF7CC,iFAAuB,EAAE;EAAA,IACzBC,oFAA0B,EAAE;EAAA,IAC5BC,mFAA2C,EAAE;EAE7C,MAAM;IAAEC;EAAI,CAAE,GAAG,wDAAa,eAAe,GAAC;EAE9C,OAAO,IAAIC,OAAO,CAAC,CAACC,OAAO,EAAEC,MAAM,KAAI;IACrC,MAAMC,eAAe,GAAGC,mBAAmB,CAACC,OAAO,CAACC,QAAQ,CAAC;IAE7D,MAAMC,QAAQ,GAAG,CACf,GAAGJ,eAAe,EAClB,GAAGK,qBAAqB,CACtBb,UAAU,EACVG,YAAY,CAACW,iBAAiB,KAAK,MAAM,CAC1C,EACD,GAAGZ,aAAa,CACjB;IAED,MAAMa,OAAO,GAAG;MAAE,GAAGL,OAAO,CAACM,GAAG;MAAE,GAAGb;IAAY,CAAE;IAEnD,MAAMc,YAAY,GAAGb,IAAI,CAACJ,UAAU,EAAEC,UAAU,EAAE;MAChDiB,KAAK,EAAE,SAAS;MAChBP,QAAQ,EAAEC,QAAQ;MAClBI,GAAG,EAAED;KACN,CAAC;IAEFE,YAAY,CAACE,IAAI,CAAC,OAAO,EAAGC,MAAM,IAAI;MACpCtB,GAAG,CAAC,UAAUE,UAAU,4BAA4BoB,MAAM,IAAI,MAAM,EAAE,CAAC;MAEvEd,OAAO,CAACc,MAAgB,CAAC;IAC3B,CAAC,CAAC;IACFH,YAAY,CAACE,IAAI,CAAC,OAAO,EAAEZ,MAAM,CAAC;EACpC,CAAC,CAAC;AACJ;AAnCAc;AAqCO,eAAeC,oBAAoB,CACxCC,gBAAkC,EAClCvB,UAAkB,EAG2B;EAAA,IAF7CC,iFAAuB,EAAE;EAAA,IACzBC,oFAA0B,EAAE;EAAA,IAC5BC,mFAA2C,EAAE;EAE7CL,GAAG,CAAC,sCAAsCE,UAAU,EAAE,CAAC;EAEvD,OAAOD,SAAS,CACdC,UAAU,EACVC,UAAU,EACV,CACE,GAAGC,aAAa,EAChB,WAAW,EACXsB,cAAI,CAACC,IAAI,CAACC,SAAS,EAAE,IAAI,EAAE,IAAI,EAAE,UAAU,CAAC,CAC7C,EACD;IACE,GAAG,sCAAkB,EAACH,gBAAgB,CAAC;IACvC,GAAGpB;GACJ,CACF;AACH;AAtBAkB;AAwBA;;;;;;;;;;;;;;;AAeA,SAASZ,mBAAmB,CAACkB,IAAc;EACzC,MAAMC,eAAe,GAAIC,GAAW,IAAI;IACtC,IAAIA,GAAG,CAACC,WAAW,EAAE,CAACC,QAAQ,CAAC,gBAAgB,CAAC,EAAE;MAChD,OAAO,WAAW;;IAEpB,OAAOF,GAAG;EACZ,CAAC;EACD,OAAOF,IAAI,CAACK,GAAG,CAACJ,eAAe,CAAC;AAClC;AAEA,SAASf,qBAAqB,CAC5Bb,UAAkB,EAClBiC,eAAwB;EAExB,IAAIvB,OAAO,CAACC,QAAQ,CAACoB,QAAQ,CAAC,kBAAkB,CAAC,EAAE;IACjD,OAAO,EAAE;;EAGX;EACA;EACA,IAAI,8CAAyB,GAAE,EAAE;IAC/B,OAAO,CAAC,WAAW,EAAE,iCAAiC,CAAC;;EAGzD;EACA,IAAI,UAAU,CAACG,IAAI,CAAClC,UAAU,CAAC,EAAE;IAC/B,OAAO,CACL,WAAW,EACX,mBAAmBiC,eAAe,GAAG,EAAE,GAAG,iBAAiB,EAAE,CAC9D;;EAGH,OAAO,EAAE;AACX","names":["log","runScript","scriptPath","scriptArgs","extraNodeArgs","extraEnvVars","fork","Promise","resolve","reject","processExecArgv","withFixedInspectArg","process","execArgv","nodeArgs","getTsNodeArgsIfNeeded","HARDHAT_TYPECHECK","envVars","env","childProcess","stdio","once","status","exports","runScriptWithHardhat","hardhatArguments","path_1","join","__dirname","argv","fixIfInspectArg","arg","toLowerCase","includes","map","shouldTypecheck","test"],"sources":["/Users/janrobel/Documents/PersonalProjekty/nftGenerateAi/clientAndContract/node_modules/hardhat/src/internal/util/scripts-runner.ts"],"sourcesContent":["import debug from \"debug\";\nimport path from \"path\";\n\nimport { HardhatArguments } from \"../../types\";\nimport { isRunningHardhatCoreTests } from \"../core/execution-mode\";\nimport { getEnvVariablesMap } from \"../core/params/env-variables\";\n\nconst log = debug(\"hardhat:core:scripts-runner\");\n\nexport async function runScript(\n  scriptPath: string,\n  scriptArgs: string[] = [],\n  extraNodeArgs: string[] = [],\n  extraEnvVars: { [name: string]: string } = {}\n): Promise<number> {\n  const { fork } = await import(\"child_process\");\n\n  return new Promise((resolve, reject) => {\n    const processExecArgv = withFixedInspectArg(process.execArgv);\n\n    const nodeArgs = [\n      ...processExecArgv,\n      ...getTsNodeArgsIfNeeded(\n        scriptPath,\n        extraEnvVars.HARDHAT_TYPECHECK === \"true\"\n      ),\n      ...extraNodeArgs,\n    ];\n\n    const envVars = { ...process.env, ...extraEnvVars };\n\n    const childProcess = fork(scriptPath, scriptArgs, {\n      stdio: \"inherit\",\n      execArgv: nodeArgs,\n      env: envVars,\n    });\n\n    childProcess.once(\"close\", (status) => {\n      log(`Script ${scriptPath} exited with status code ${status ?? \"null\"}`);\n\n      resolve(status as number);\n    });\n    childProcess.once(\"error\", reject);\n  });\n}\n\nexport async function runScriptWithHardhat(\n  hardhatArguments: HardhatArguments,\n  scriptPath: string,\n  scriptArgs: string[] = [],\n  extraNodeArgs: string[] = [],\n  extraEnvVars: { [name: string]: string } = {}\n): Promise<number> {\n  log(`Creating Hardhat subprocess to run ${scriptPath}`);\n\n  return runScript(\n    scriptPath,\n    scriptArgs,\n    [\n      ...extraNodeArgs,\n      \"--require\",\n      path.join(__dirname, \"..\", \"..\", \"register\"),\n    ],\n    {\n      ...getEnvVariablesMap(hardhatArguments),\n      ...extraEnvVars,\n    }\n  );\n}\n\n/**\n * Fix debugger \"inspect\" arg from process.argv, if present.\n *\n * When running this process with a debugger, a debugger port\n * is specified via the \"--inspect-brk=\" arg param in some IDEs/setups.\n *\n * This normally works, but if we do a fork afterwards, we'll get an error stating\n * that the port is already in use (since the fork would also use the same args,\n * therefore the same port number). To prevent this issue, we could replace the port number with\n * a different free one, or simply use the port-agnostic --inspect\" flag, and leave the debugger\n * port selection to the Node process itself, which will pick an empty AND valid one.\n *\n * This way, we can properly use the debugger for this process AND for the executed\n * script itself - even if it's compiled using ts-node.\n */\nfunction withFixedInspectArg(argv: string[]) {\n  const fixIfInspectArg = (arg: string) => {\n    if (arg.toLowerCase().includes(\"--inspect-brk=\")) {\n      return \"--inspect\";\n    }\n    return arg;\n  };\n  return argv.map(fixIfInspectArg);\n}\n\nfunction getTsNodeArgsIfNeeded(\n  scriptPath: string,\n  shouldTypecheck: boolean\n): string[] {\n  if (process.execArgv.includes(\"ts-node/register\")) {\n    return [];\n  }\n\n  // if we are running the tests we only want to transpile, or these tests\n  // take forever\n  if (isRunningHardhatCoreTests()) {\n    return [\"--require\", \"ts-node/register/transpile-only\"];\n  }\n\n  // If the script we are going to run is .ts we need ts-node\n  if (/\\.tsx?$/i.test(scriptPath)) {\n    return [\n      \"--require\",\n      `ts-node/register${shouldTypecheck ? \"\" : \"/transpile-only\"}`,\n    ];\n  }\n\n  return [];\n}\n"]},"metadata":{},"sourceType":"script","externalDependencies":[]}