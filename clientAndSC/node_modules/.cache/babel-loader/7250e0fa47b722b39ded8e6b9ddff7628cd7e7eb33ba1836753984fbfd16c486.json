{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.TypedDataEncoder = void 0;\n//import { TypedDataDomain, TypedDataField } from \"@ethersproject/providerabstract-signer\";\nconst index_js_1 = require(\"../address/index.js\");\nconst index_js_2 = require(\"../crypto/index.js\");\nconst index_js_3 = require(\"../utils/index.js\");\nconst id_js_1 = require(\"./id.js\");\nconst padding = new Uint8Array(32);\npadding.fill(0);\nconst BN__1 = BigInt(-1);\nconst BN_0 = BigInt(0);\nconst BN_1 = BigInt(1);\nconst BN_MAX_UINT256 = BigInt(\"0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\");\n;\n;\nfunction hexPadRight(value) {\n  const bytes = (0, index_js_3.getBytes)(value);\n  const padOffset = bytes.length % 32;\n  if (padOffset) {\n    return (0, index_js_3.concat)([bytes, padding.slice(padOffset)]);\n  }\n  return (0, index_js_3.hexlify)(bytes);\n}\nconst hexTrue = (0, index_js_3.toBeHex)(BN_1, 32);\nconst hexFalse = (0, index_js_3.toBeHex)(BN_0, 32);\nconst domainFieldTypes = {\n  name: \"string\",\n  version: \"string\",\n  chainId: \"uint256\",\n  verifyingContract: \"address\",\n  salt: \"bytes32\"\n};\nconst domainFieldNames = [\"name\", \"version\", \"chainId\", \"verifyingContract\", \"salt\"];\nfunction checkString(key) {\n  return function (value) {\n    (0, index_js_3.assertArgument)(typeof value === \"string\", `invalid domain value for ${JSON.stringify(key)}`, `domain.${key}`, value);\n    return value;\n  };\n}\nconst domainChecks = {\n  name: checkString(\"name\"),\n  version: checkString(\"version\"),\n  chainId: function (value) {\n    return (0, index_js_3.getBigInt)(value, \"domain.chainId\");\n  },\n  verifyingContract: function (value) {\n    try {\n      return (0, index_js_1.getAddress)(value).toLowerCase();\n    } catch (error) {}\n    (0, index_js_3.assertArgument)(false, `invalid domain value \"verifyingContract\"`, \"domain.verifyingContract\", value);\n  },\n  salt: function (value) {\n    const bytes = (0, index_js_3.getBytes)(value, \"domain.salt\");\n    (0, index_js_3.assertArgument)(bytes.length === 32, `invalid domain value \"salt\"`, \"domain.salt\", value);\n    return (0, index_js_3.hexlify)(bytes);\n  }\n};\nfunction getBaseEncoder(type) {\n  // intXX and uintXX\n  {\n    const match = type.match(/^(u?)int(\\d*)$/);\n    if (match) {\n      const signed = match[1] === \"\";\n      const width = parseInt(match[2] || \"256\");\n      (0, index_js_3.assertArgument)(width % 8 === 0 && width !== 0 && width <= 256 && (match[2] == null || match[2] === String(width)), \"invalid numeric width\", \"type\", type);\n      const boundsUpper = (0, index_js_3.mask)(BN_MAX_UINT256, signed ? width - 1 : width);\n      const boundsLower = signed ? (boundsUpper + BN_1) * BN__1 : BN_0;\n      return function (_value) {\n        const value = (0, index_js_3.getBigInt)(_value, \"value\");\n        (0, index_js_3.assertArgument)(value >= boundsLower && value <= boundsUpper, `value out-of-bounds for ${type}`, \"value\", value);\n        return (0, index_js_3.toBeHex)((0, index_js_3.toTwos)(value, 256), 32);\n      };\n    }\n  }\n  // bytesXX\n  {\n    const match = type.match(/^bytes(\\d+)$/);\n    if (match) {\n      const width = parseInt(match[1]);\n      (0, index_js_3.assertArgument)(width !== 0 && width <= 32 && match[1] === String(width), \"invalid bytes width\", \"type\", type);\n      return function (value) {\n        const bytes = (0, index_js_3.getBytes)(value);\n        (0, index_js_3.assertArgument)(bytes.length === width, `invalid length for ${type}`, \"value\", value);\n        return hexPadRight(value);\n      };\n    }\n  }\n  switch (type) {\n    case \"address\":\n      return function (value) {\n        return (0, index_js_3.zeroPadValue)((0, index_js_1.getAddress)(value), 32);\n      };\n    case \"bool\":\n      return function (value) {\n        return !value ? hexFalse : hexTrue;\n      };\n    case \"bytes\":\n      return function (value) {\n        return (0, index_js_2.keccak256)(value);\n      };\n    case \"string\":\n      return function (value) {\n        return (0, id_js_1.id)(value);\n      };\n  }\n  return null;\n}\nfunction encodeType(name, fields) {\n  return `${name}(${fields.map(_ref => {\n    let {\n      name,\n      type\n    } = _ref;\n    return type + \" \" + name;\n  }).join(\",\")})`;\n}\nclass TypedDataEncoder {\n  primaryType;\n  #types;\n  get types() {\n    return JSON.parse(this.#types);\n  }\n  #fullTypes;\n  #encoderCache;\n  constructor(types) {\n    this.#types = JSON.stringify(types);\n    this.#fullTypes = new Map();\n    this.#encoderCache = new Map();\n    // Link struct types to their direct child structs\n    const links = new Map();\n    // Link structs to structs which contain them as a child\n    const parents = new Map();\n    // Link all subtypes within a given struct\n    const subtypes = new Map();\n    Object.keys(types).forEach(type => {\n      links.set(type, new Set());\n      parents.set(type, []);\n      subtypes.set(type, new Set());\n    });\n    for (const name in types) {\n      const uniqueNames = new Set();\n      for (const field of types[name]) {\n        // Check each field has a unique name\n        (0, index_js_3.assertArgument)(!uniqueNames.has(field.name), `duplicate variable name ${JSON.stringify(field.name)} in ${JSON.stringify(name)}`, \"types\", types);\n        uniqueNames.add(field.name);\n        // Get the base type (drop any array specifiers)\n        const baseType = field.type.match(/^([^\\x5b]*)(\\x5b|$)/)[1] || null;\n        (0, index_js_3.assertArgument)(baseType !== name, `circular type reference to ${JSON.stringify(baseType)}`, \"types\", types);\n        // Is this a base encoding type?\n        const encoder = getBaseEncoder(baseType);\n        if (encoder) {\n          continue;\n        }\n        (0, index_js_3.assertArgument)(parents.has(baseType), `unknown type ${JSON.stringify(baseType)}`, \"types\", types);\n        // Add linkage\n        parents.get(baseType).push(name);\n        links.get(name).add(baseType);\n      }\n    }\n    // Deduce the primary type\n    const primaryTypes = Array.from(parents.keys()).filter(n => parents.get(n).length === 0);\n    (0, index_js_3.assertArgument)(primaryTypes.length !== 0, \"missing primary type\", \"types\", types);\n    (0, index_js_3.assertArgument)(primaryTypes.length === 1, `ambiguous primary types or unused types: ${primaryTypes.map(t => JSON.stringify(t)).join(\", \")}`, \"types\", types);\n    (0, index_js_3.defineProperties)(this, {\n      primaryType: primaryTypes[0]\n    });\n    // Check for circular type references\n    function checkCircular(type, found) {\n      (0, index_js_3.assertArgument)(!found.has(type), `circular type reference to ${JSON.stringify(type)}`, \"types\", types);\n      found.add(type);\n      for (const child of links.get(type)) {\n        if (!parents.has(child)) {\n          continue;\n        }\n        // Recursively check children\n        checkCircular(child, found);\n        // Mark all ancestors as having this decendant\n        for (const subtype of found) {\n          subtypes.get(subtype).add(child);\n        }\n      }\n      found.delete(type);\n    }\n    checkCircular(this.primaryType, new Set());\n    // Compute each fully describe type\n    for (const [name, set] of subtypes) {\n      const st = Array.from(set);\n      st.sort();\n      this.#fullTypes.set(name, encodeType(name, types[name]) + st.map(t => encodeType(t, types[t])).join(\"\"));\n    }\n  }\n  getEncoder(type) {\n    let encoder = this.#encoderCache.get(type);\n    if (!encoder) {\n      encoder = this.#getEncoder(type);\n      this.#encoderCache.set(type, encoder);\n    }\n    return encoder;\n  }\n  #getEncoder(type) {\n    // Basic encoder type (address, bool, uint256, etc)\n    {\n      const encoder = getBaseEncoder(type);\n      if (encoder) {\n        return encoder;\n      }\n    }\n    // Array\n    const match = type.match(/^(.*)(\\x5b(\\d*)\\x5d)$/);\n    if (match) {\n      const subtype = match[1];\n      const subEncoder = this.getEncoder(subtype);\n      return value => {\n        (0, index_js_3.assertArgument)(!match[3] || parseInt(match[3]) === value.length, `array length mismatch; expected length ${parseInt(match[3])}`, \"value\", value);\n        let result = value.map(subEncoder);\n        if (this.#fullTypes.has(subtype)) {\n          result = result.map(index_js_2.keccak256);\n        }\n        return (0, index_js_2.keccak256)((0, index_js_3.concat)(result));\n      };\n    }\n    // Struct\n    const fields = this.types[type];\n    if (fields) {\n      const encodedType = (0, id_js_1.id)(this.#fullTypes.get(type));\n      return value => {\n        const values = fields.map(_ref2 => {\n          let {\n            name,\n            type\n          } = _ref2;\n          const result = this.getEncoder(type)(value[name]);\n          if (this.#fullTypes.has(type)) {\n            return (0, index_js_2.keccak256)(result);\n          }\n          return result;\n        });\n        values.unshift(encodedType);\n        return (0, index_js_3.concat)(values);\n      };\n    }\n    (0, index_js_3.assertArgument)(false, `unknown type: ${type}`, \"type\", type);\n  }\n  encodeType(name) {\n    const result = this.#fullTypes.get(name);\n    (0, index_js_3.assertArgument)(result, `unknown type: ${JSON.stringify(name)}`, \"name\", name);\n    return result;\n  }\n  encodeData(type, value) {\n    return this.getEncoder(type)(value);\n  }\n  hashStruct(name, value) {\n    return (0, index_js_2.keccak256)(this.encodeData(name, value));\n  }\n  encode(value) {\n    return this.encodeData(this.primaryType, value);\n  }\n  hash(value) {\n    return this.hashStruct(this.primaryType, value);\n  }\n  _visit(type, value, callback) {\n    // Basic encoder type (address, bool, uint256, etc)\n    {\n      const encoder = getBaseEncoder(type);\n      if (encoder) {\n        return callback(type, value);\n      }\n    }\n    // Array\n    const match = type.match(/^(.*)(\\x5b(\\d*)\\x5d)$/);\n    if (match) {\n      (0, index_js_3.assertArgument)(!match[3] || parseInt(match[3]) === value.length, `array length mismatch; expected length ${parseInt(match[3])}`, \"value\", value);\n      return value.map(v => this._visit(match[1], v, callback));\n    }\n    // Struct\n    const fields = this.types[type];\n    if (fields) {\n      return fields.reduce((accum, _ref3) => {\n        let {\n          name,\n          type\n        } = _ref3;\n        accum[name] = this._visit(type, value[name], callback);\n        return accum;\n      }, {});\n    }\n    (0, index_js_3.assertArgument)(false, `unknown type: ${type}`, \"type\", type);\n  }\n  visit(value, callback) {\n    return this._visit(this.primaryType, value, callback);\n  }\n  static from(types) {\n    return new TypedDataEncoder(types);\n  }\n  static getPrimaryType(types) {\n    return TypedDataEncoder.from(types).primaryType;\n  }\n  static hashStruct(name, types, value) {\n    return TypedDataEncoder.from(types).hashStruct(name, value);\n  }\n  static hashDomain(domain) {\n    const domainFields = [];\n    for (const name in domain) {\n      const type = domainFieldTypes[name];\n      (0, index_js_3.assertArgument)(type, `invalid typed-data domain key: ${JSON.stringify(name)}`, \"domain\", domain);\n      domainFields.push({\n        name,\n        type\n      });\n    }\n    domainFields.sort((a, b) => {\n      return domainFieldNames.indexOf(a.name) - domainFieldNames.indexOf(b.name);\n    });\n    return TypedDataEncoder.hashStruct(\"EIP712Domain\", {\n      EIP712Domain: domainFields\n    }, domain);\n  }\n  static encode(domain, types, value) {\n    return (0, index_js_3.concat)([\"0x1901\", TypedDataEncoder.hashDomain(domain), TypedDataEncoder.from(types).hash(value)]);\n  }\n  static hash(domain, types, value) {\n    return (0, index_js_2.keccak256)(TypedDataEncoder.encode(domain, types, value));\n  }\n  // Replaces all address types with ENS names with their looked up address\n  static async resolveNames(domain, types, value, resolveName) {\n    // Make a copy to isolate it from the object passed in\n    domain = Object.assign({}, domain);\n    // Look up all ENS names\n    const ensCache = {};\n    // Do we need to look up the domain's verifyingContract?\n    if (domain.verifyingContract && !(0, index_js_3.isHexString)(domain.verifyingContract, 20)) {\n      ensCache[domain.verifyingContract] = \"0x\";\n    }\n    // We are going to use the encoder to visit all the base values\n    const encoder = TypedDataEncoder.from(types);\n    // Get a list of all the addresses\n    encoder.visit(value, (type, value) => {\n      if (type === \"address\" && !(0, index_js_3.isHexString)(value, 20)) {\n        ensCache[value] = \"0x\";\n      }\n      return value;\n    });\n    // Lookup each name\n    for (const name in ensCache) {\n      ensCache[name] = await resolveName(name);\n    }\n    // Replace the domain verifyingContract if needed\n    if (domain.verifyingContract && ensCache[domain.verifyingContract]) {\n      domain.verifyingContract = ensCache[domain.verifyingContract];\n    }\n    // Replace all ENS names with their address\n    value = encoder.visit(value, (type, value) => {\n      if (type === \"address\" && ensCache[value]) {\n        return ensCache[value];\n      }\n      return value;\n    });\n    return {\n      domain,\n      value\n    };\n  }\n  static getPayload(domain, types, value) {\n    // Validate the domain fields\n    TypedDataEncoder.hashDomain(domain);\n    // Derive the EIP712Domain Struct reference type\n    const domainValues = {};\n    const domainTypes = [];\n    domainFieldNames.forEach(name => {\n      const value = domain[name];\n      if (value == null) {\n        return;\n      }\n      domainValues[name] = domainChecks[name](value);\n      domainTypes.push({\n        name,\n        type: domainFieldTypes[name]\n      });\n    });\n    const encoder = TypedDataEncoder.from(types);\n    const typesWithDomain = Object.assign({}, types);\n    (0, index_js_3.assertArgument)(typesWithDomain.EIP712Domain == null, \"types must not contain EIP712Domain type\", \"types.EIP712Domain\", types);\n    typesWithDomain.EIP712Domain = domainTypes;\n    // Validate the data structures and types\n    encoder.encode(value);\n    return {\n      types: typesWithDomain,\n      domain: domainValues,\n      primaryType: encoder.primaryType,\n      message: encoder.visit(value, (type, value) => {\n        // bytes\n        if (type.match(/^bytes(\\d*)/)) {\n          return (0, index_js_3.hexlify)((0, index_js_3.getBytes)(value));\n        }\n        // uint or int\n        if (type.match(/^u?int/)) {\n          return (0, index_js_3.getBigInt)(value).toString();\n        }\n        switch (type) {\n          case \"address\":\n            return value.toLowerCase();\n          case \"bool\":\n            return !!value;\n          case \"string\":\n            (0, index_js_3.assertArgument)(typeof value === \"string\", \"invalid string\", \"value\", value);\n            return value;\n        }\n        (0, index_js_3.assertArgument)(false, \"unsupported type\", \"type\", type);\n      })\n    };\n  }\n}\nexports.TypedDataEncoder = TypedDataEncoder;","map":{"version":3,"mappings":"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","names":["padding","Uint8Array","fill","BN__1","BigInt","BN_0","BN_1","BN_MAX_UINT256","hexPadRight","value","bytes","padOffset","length","slice","hexTrue","hexFalse","domainFieldTypes","name","version","chainId","verifyingContract","salt","domainFieldNames","checkString","key","JSON","stringify","domainChecks","toLowerCase","error","getBaseEncoder","type","match","signed","width","parseInt","String","boundsUpper","boundsLower","_value","encodeType","fields","map","join","TypedDataEncoder","primaryType","types","parse","constructor","Map","links","parents","subtypes","Object","keys","forEach","set","Set","uniqueNames","field","has","add","baseType","encoder","get","push","primaryTypes","Array","from","filter","n","t","checkCircular","found","child","subtype","delete","st","sort","getEncoder","subEncoder","result","index_js_2","encodedType","values","unshift","encodeData","hashStruct","encode","hash","_visit","callback","v","reduce","accum","visit","getPrimaryType","hashDomain","domain","domainFields","a","b","indexOf","EIP712Domain","resolveNames","resolveName","assign","ensCache","getPayload","domainValues","domainTypes","typesWithDomain","message","toString","exports"],"sources":["/Users/janrobel/Documents/PersonalProjekty/nftGenerateAi/clientAndContract/node_modules/ethers/src.ts/hash/typed-data.ts"],"sourcesContent":["//import { TypedDataDomain, TypedDataField } from \"@ethersproject/providerabstract-signer\";\nimport { getAddress } from \"../address/index.js\";\nimport { keccak256 } from \"../crypto/index.js\";\nimport {\n    concat, defineProperties, getBigInt, getBytes, hexlify, isHexString, mask, toBeHex, toTwos, zeroPadValue,\n    assertArgument\n} from \"../utils/index.js\";\n\nimport { id } from \"./id.js\";\n\nimport type { BigNumberish, BytesLike } from \"../utils/index.js\";\n\n\nconst padding = new Uint8Array(32);\npadding.fill(0);\n\nconst BN__1 = BigInt(-1);\nconst BN_0 = BigInt(0);\nconst BN_1 = BigInt(1);\nconst BN_MAX_UINT256 = BigInt(\"0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\");\n\nexport interface TypedDataDomain {\n    name?: string;\n    version?: string;\n    chainId?: BigNumberish;\n    verifyingContract?: string;\n    salt?: BytesLike;\n};\n\nexport interface TypedDataField {\n    name: string;\n    type: string;\n};\n\nfunction hexPadRight(value: BytesLike): string {\n    const bytes = getBytes(value);\n    const padOffset = bytes.length % 32\n    if (padOffset) {\n        return concat([ bytes, padding.slice(padOffset) ]);\n    }\n    return hexlify(bytes);\n}\n\nconst hexTrue = toBeHex(BN_1, 32);\nconst hexFalse = toBeHex(BN_0, 32);\n\nconst domainFieldTypes: Record<string, string> = {\n    name: \"string\",\n    version: \"string\",\n    chainId: \"uint256\",\n    verifyingContract: \"address\",\n    salt: \"bytes32\"\n};\n\nconst domainFieldNames: Array<string> = [\n    \"name\", \"version\", \"chainId\", \"verifyingContract\", \"salt\"\n];\n\nfunction checkString(key: string): (value: any) => string {\n    return function (value: any){\n        assertArgument(typeof(value) === \"string\", `invalid domain value for ${ JSON.stringify(key) }`, `domain.${ key }`, value);\n        return value;\n    }\n}\n\nconst domainChecks: Record<string, (value: any) => any> = {\n    name: checkString(\"name\"),\n    version: checkString(\"version\"),\n    chainId: function(value: any) {\n        return getBigInt(value, \"domain.chainId\");\n    },\n    verifyingContract: function(value: any) {\n        try {\n            return getAddress(value).toLowerCase();\n        } catch (error) { }\n        assertArgument(false, `invalid domain value \"verifyingContract\"`, \"domain.verifyingContract\", value);\n    },\n    salt: function(value: any) {\n        const bytes = getBytes(value, \"domain.salt\");\n        assertArgument(bytes.length === 32, `invalid domain value \"salt\"`, \"domain.salt\", value);\n        return hexlify(bytes);\n    }\n}\n\nfunction getBaseEncoder(type: string): null | ((value: any) => string) {\n    // intXX and uintXX\n    {\n        const match = type.match(/^(u?)int(\\d*)$/);\n        if (match) {\n            const signed = (match[1] === \"\");\n\n            const width = parseInt(match[2] || \"256\");\n            assertArgument(width % 8 === 0 && width !== 0 && width <= 256 && (match[2] == null || match[2] === String(width)), \"invalid numeric width\", \"type\", type);\n\n            const boundsUpper = mask(BN_MAX_UINT256, signed ? (width - 1): width);\n            const boundsLower = signed ? ((boundsUpper + BN_1) * BN__1): BN_0;\n\n            return function(_value: BigNumberish) {\n                const value = getBigInt(_value, \"value\");\n\n                assertArgument(value >= boundsLower && value <= boundsUpper, `value out-of-bounds for ${ type }`, \"value\", value);\n\n                return toBeHex(toTwos(value, 256), 32);\n            };\n        }\n    }\n\n    // bytesXX\n    {\n        const match = type.match(/^bytes(\\d+)$/);\n        if (match) {\n            const width = parseInt(match[1]);\n            assertArgument(width !== 0 && width <= 32 && match[1] === String(width), \"invalid bytes width\", \"type\", type);\n\n            return function(value: BytesLike) {\n                const bytes = getBytes(value);\n                assertArgument(bytes.length === width, `invalid length for ${ type }`, \"value\", value);\n                return hexPadRight(value);\n            };\n        }\n    }\n\n    switch (type) {\n        case \"address\": return function(value: string) {\n            return zeroPadValue(getAddress(value), 32);\n        };\n        case \"bool\": return function(value: boolean) {\n            return ((!value) ? hexFalse: hexTrue);\n        };\n        case \"bytes\": return function(value: BytesLike) {\n            return keccak256(value);\n        };\n        case \"string\": return function(value: string) {\n            return id(value);\n        };\n    }\n\n    return null;\n}\n\nfunction encodeType(name: string, fields: Array<TypedDataField>): string {\n    return `${ name }(${ fields.map(({ name, type }) => (type + \" \" + name)).join(\",\") })`;\n}\n\nexport class TypedDataEncoder {\n    readonly primaryType!: string;\n\n    readonly #types: string;\n    get types(): Record<string, Array<TypedDataField>> {\n        return JSON.parse(this.#types);\n    }\n\n    readonly #fullTypes: Map<string, string>\n\n    readonly #encoderCache: Map<string, (value: any) => string>;\n\n    constructor(types: Record<string, Array<TypedDataField>>) {\n        this.#types = JSON.stringify(types);\n        this.#fullTypes = new Map();\n        this.#encoderCache = new Map();\n\n        // Link struct types to their direct child structs\n        const links: Map<string, Set<string>> = new Map();\n\n        // Link structs to structs which contain them as a child\n        const parents: Map<string, Array<string>> = new Map();\n\n        // Link all subtypes within a given struct\n        const subtypes: Map<string, Set<string>> = new Map();\n\n        Object.keys(types).forEach((type) => {\n            links.set(type, new Set());\n            parents.set(type, [ ]);\n            subtypes.set(type, new Set());\n        });\n\n        for (const name in types) {\n            const uniqueNames: Set<string> = new Set();\n\n            for (const field of types[name]) {\n\n                // Check each field has a unique name\n                assertArgument(!uniqueNames.has(field.name), `duplicate variable name ${ JSON.stringify(field.name) } in ${ JSON.stringify(name) }`, \"types\", types);\n                uniqueNames.add(field.name);\n\n                // Get the base type (drop any array specifiers)\n                const baseType = (<any>(field.type.match(/^([^\\x5b]*)(\\x5b|$)/)))[1] || null;\n                assertArgument(baseType !== name, `circular type reference to ${ JSON.stringify(baseType) }`, \"types\", types);\n\n                // Is this a base encoding type?\n                const encoder = getBaseEncoder(baseType);\n                if (encoder) { continue; }\n\n                assertArgument(parents.has(baseType), `unknown type ${ JSON.stringify(baseType) }`, \"types\", types);\n\n                // Add linkage\n                (parents.get(baseType) as Array<string>).push(name);\n                (links.get(name) as Set<string>).add(baseType);\n            }\n        }\n\n        // Deduce the primary type\n        const primaryTypes = Array.from(parents.keys()).filter((n) => ((parents.get(n) as Array<string>).length === 0));\n        assertArgument(primaryTypes.length !== 0, \"missing primary type\", \"types\", types);\n        assertArgument(primaryTypes.length === 1, `ambiguous primary types or unused types: ${ primaryTypes.map((t) => (JSON.stringify(t))).join(\", \") }`, \"types\", types);\n\n        defineProperties<TypedDataEncoder>(this, { primaryType: primaryTypes[0] });\n\n        // Check for circular type references\n        function checkCircular(type: string, found: Set<string>) {\n            assertArgument(!found.has(type), `circular type reference to ${ JSON.stringify(type) }`, \"types\", types);\n\n            found.add(type);\n\n            for (const child of (links.get(type) as Set<string>)) {\n                if (!parents.has(child)) { continue; }\n\n                // Recursively check children\n                checkCircular(child, found);\n\n                // Mark all ancestors as having this decendant\n                for (const subtype of found) {\n                    (subtypes.get(subtype) as Set<string>).add(child);\n                }\n            }\n\n            found.delete(type);\n        }\n        checkCircular(this.primaryType, new Set());\n\n        // Compute each fully describe type\n        for (const [ name, set ] of subtypes) {\n            const st = Array.from(set);\n            st.sort();\n            this.#fullTypes.set(name, encodeType(name, types[name]) + st.map((t) => encodeType(t, types[t])).join(\"\"));\n        }\n    }\n\n    getEncoder(type: string): (value: any) => string {\n        let encoder = this.#encoderCache.get(type);\n        if (!encoder) {\n            encoder = this.#getEncoder(type);\n            this.#encoderCache.set(type, encoder);\n        }\n        return encoder;\n    }\n\n    #getEncoder(type: string): (value: any) => string {\n\n        // Basic encoder type (address, bool, uint256, etc)\n        {\n            const encoder = getBaseEncoder(type);\n            if (encoder) { return encoder; }\n        }\n\n        // Array\n        const match = type.match(/^(.*)(\\x5b(\\d*)\\x5d)$/);\n        if (match) {\n            const subtype = match[1];\n            const subEncoder = this.getEncoder(subtype);\n            return (value: Array<any>) => {\n                assertArgument(!match[3] || parseInt(match[3]) === value.length, `array length mismatch; expected length ${ parseInt(match[3]) }`, \"value\", value);\n\n                let result = value.map(subEncoder);\n                if (this.#fullTypes.has(subtype)) {\n                    result = result.map(keccak256);\n                }\n\n                return keccak256(concat(result));\n            };\n        }\n\n        // Struct\n        const fields = this.types[type];\n        if (fields) {\n            const encodedType = id(this.#fullTypes.get(type) as string);\n            return (value: Record<string, any>) => {\n                const values = fields.map(({ name, type }) => {\n                    const result = this.getEncoder(type)(value[name]);\n                    if (this.#fullTypes.has(type)) { return keccak256(result); }\n                    return result;\n                });\n                values.unshift(encodedType);\n                return concat(values);\n            }\n        }\n\n        assertArgument(false, `unknown type: ${ type }`, \"type\", type);\n    }\n\n    encodeType(name: string): string {\n        const result = this.#fullTypes.get(name);\n        assertArgument(result, `unknown type: ${ JSON.stringify(name) }`, \"name\", name);\n        return result;\n    }\n\n    encodeData(type: string, value: any): string {\n        return this.getEncoder(type)(value);\n    }\n\n    hashStruct(name: string, value: Record<string, any>): string {\n        return keccak256(this.encodeData(name, value));\n    }\n\n    encode(value: Record<string, any>): string {\n        return this.encodeData(this.primaryType, value);\n    }\n\n    hash(value: Record<string, any>): string {\n        return this.hashStruct(this.primaryType, value);\n    }\n\n    _visit(type: string, value: any, callback: (type: string, data: any) => any): any {\n        // Basic encoder type (address, bool, uint256, etc)\n        {\n            const encoder = getBaseEncoder(type);\n            if (encoder) { return callback(type, value); }\n        }\n\n        // Array\n        const match = type.match(/^(.*)(\\x5b(\\d*)\\x5d)$/);\n        if (match) {\n            assertArgument(!match[3] || parseInt(match[3]) === value.length, `array length mismatch; expected length ${ parseInt(match[3]) }`, \"value\", value);\n            return value.map((v: any) => this._visit(match[1], v, callback));\n        }\n\n        // Struct\n        const fields = this.types[type];\n        if (fields) {\n            return fields.reduce((accum, { name, type }) => {\n                accum[name] = this._visit(type, value[name], callback);\n                return accum;\n            }, <Record<string, any>>{});\n        }\n\n        assertArgument(false, `unknown type: ${ type }`, \"type\", type);\n    }\n\n    visit(value: Record<string, any>, callback: (type: string, data: any) => any): any {\n        return this._visit(this.primaryType, value, callback);\n    }\n\n    static from(types: Record<string, Array<TypedDataField>>): TypedDataEncoder {\n        return new TypedDataEncoder(types);\n    }\n\n    static getPrimaryType(types: Record<string, Array<TypedDataField>>): string {\n        return TypedDataEncoder.from(types).primaryType;\n    }\n\n    static hashStruct(name: string, types: Record<string, Array<TypedDataField>>, value: Record<string, any>): string {\n        return TypedDataEncoder.from(types).hashStruct(name, value);\n    }\n\n    static hashDomain(domain: TypedDataDomain): string {\n        const domainFields: Array<TypedDataField> = [ ];\n        for (const name in domain) {\n            const type = domainFieldTypes[name];\n            assertArgument(type, `invalid typed-data domain key: ${ JSON.stringify(name) }`, \"domain\", domain);\n            domainFields.push({ name, type });\n        }\n\n        domainFields.sort((a, b) => {\n            return domainFieldNames.indexOf(a.name) - domainFieldNames.indexOf(b.name);\n        });\n\n        return TypedDataEncoder.hashStruct(\"EIP712Domain\", { EIP712Domain: domainFields }, domain);\n    }\n\n    static encode(domain: TypedDataDomain, types: Record<string, Array<TypedDataField>>, value: Record<string, any>): string {\n        return concat([\n            \"0x1901\",\n            TypedDataEncoder.hashDomain(domain),\n            TypedDataEncoder.from(types).hash(value)\n        ]);\n    }\n\n    static hash(domain: TypedDataDomain, types: Record<string, Array<TypedDataField>>, value: Record<string, any>): string {\n        return keccak256(TypedDataEncoder.encode(domain, types, value));\n    }\n\n    // Replaces all address types with ENS names with their looked up address\n    static async resolveNames(domain: TypedDataDomain, types: Record<string, Array<TypedDataField>>, value: Record<string, any>, resolveName: (name: string) => Promise<string>): Promise<{ domain: TypedDataDomain, value: any }> {\n        // Make a copy to isolate it from the object passed in\n        domain = Object.assign({ }, domain);\n\n        // Look up all ENS names\n        const ensCache: Record<string, string> = { };\n\n        // Do we need to look up the domain's verifyingContract?\n        if (domain.verifyingContract && !isHexString(domain.verifyingContract, 20)) {\n            ensCache[domain.verifyingContract] = \"0x\";\n        }\n\n        // We are going to use the encoder to visit all the base values\n        const encoder = TypedDataEncoder.from(types);\n\n        // Get a list of all the addresses\n        encoder.visit(value, (type: string, value: any) => {\n            if (type === \"address\" && !isHexString(value, 20)) {\n                ensCache[value] = \"0x\";\n            }\n            return value;\n        });\n\n        // Lookup each name\n        for (const name in ensCache) {\n            ensCache[name] = await resolveName(name);\n        }\n\n        // Replace the domain verifyingContract if needed\n        if (domain.verifyingContract && ensCache[domain.verifyingContract]) {\n            domain.verifyingContract = ensCache[domain.verifyingContract];\n        }\n\n        // Replace all ENS names with their address\n        value = encoder.visit(value, (type: string, value: any) => {\n            if (type === \"address\" && ensCache[value]) { return ensCache[value]; }\n            return value;\n        });\n\n        return { domain, value };\n    }\n\n    static getPayload(domain: TypedDataDomain, types: Record<string, Array<TypedDataField>>, value: Record<string, any>): any {\n        // Validate the domain fields\n        TypedDataEncoder.hashDomain(domain);\n\n        // Derive the EIP712Domain Struct reference type\n        const domainValues: Record<string, any> = { };\n        const domainTypes: Array<{ name: string, type:string }> = [ ];\n\n        domainFieldNames.forEach((name) => {\n            const value = (<any>domain)[name];\n            if (value == null) { return; }\n            domainValues[name] = domainChecks[name](value);\n            domainTypes.push({ name, type: domainFieldTypes[name] });\n        });\n\n        const encoder = TypedDataEncoder.from(types);\n\n        const typesWithDomain = Object.assign({ }, types);\n        assertArgument(typesWithDomain.EIP712Domain == null, \"types must not contain EIP712Domain type\", \"types.EIP712Domain\", types);\n\n        typesWithDomain.EIP712Domain = domainTypes;\n\n        // Validate the data structures and types\n        encoder.encode(value);\n\n        return {\n            types: typesWithDomain,\n            domain: domainValues,\n            primaryType: encoder.primaryType,\n            message: encoder.visit(value, (type: string, value: any) => {\n\n                // bytes\n                if (type.match(/^bytes(\\d*)/)) {\n                    return hexlify(getBytes(value));\n                }\n\n                // uint or int\n                if (type.match(/^u?int/)) {\n                    return getBigInt(value).toString();\n                }\n\n                switch (type) {\n                    case \"address\":\n                        return value.toLowerCase();\n                    case \"bool\":\n                        return !!value;\n                    case \"string\":\n                        assertArgument(typeof(value) === \"string\", \"invalid string\", \"value\", value);\n                        return value;\n                }\n\n                assertArgument(false, \"unsupported type\", \"type\", type);\n            })\n        };\n    }\n}\n\n"]},"metadata":{},"sourceType":"script","externalDependencies":[]}