{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.PollingEventSubscriber = exports.PollingTransactionSubscriber = exports.PollingOrphanSubscriber = exports.OnBlockSubscriber = exports.PollingBlockSubscriber = exports.getPollingSubscriber = void 0;\nconst index_js_1 = require(\"../utils/index.js\");\nfunction copy(obj) {\n  return JSON.parse(JSON.stringify(obj));\n}\n/**\n *  @TODO\n *\n *  @_docloc: api/providers/abstract-provider\n */\nfunction getPollingSubscriber(provider, event) {\n  if (event === \"block\") {\n    return new PollingBlockSubscriber(provider);\n  }\n  if ((0, index_js_1.isHexString)(event, 32)) {\n    return new PollingTransactionSubscriber(provider, event);\n  }\n  (0, index_js_1.assert)(false, \"unsupported polling event\", \"UNSUPPORTED_OPERATION\", {\n    operation: \"getPollingSubscriber\",\n    info: {\n      event\n    }\n  });\n}\nexports.getPollingSubscriber = getPollingSubscriber;\n// @TODO: refactor this\n/**\n *  @TODO\n *\n *  @_docloc: api/providers/abstract-provider\n */\nclass PollingBlockSubscriber {\n  #provider;\n  #poller;\n  #interval;\n  // The most recent block we have scanned for events. The value -2\n  // indicates we still need to fetch an initial block number\n  #blockNumber;\n  constructor(provider) {\n    this.#provider = provider;\n    this.#poller = null;\n    this.#interval = 4000;\n    this.#blockNumber = -2;\n  }\n  get pollingInterval() {\n    return this.#interval;\n  }\n  set pollingInterval(value) {\n    this.#interval = value;\n  }\n  async #poll() {\n    const blockNumber = await this.#provider.getBlockNumber();\n    if (this.#blockNumber === -2) {\n      this.#blockNumber = blockNumber;\n      return;\n    }\n    // @TODO: Put a cap on the maximum number of events per loop?\n    if (blockNumber !== this.#blockNumber) {\n      for (let b = this.#blockNumber + 1; b <= blockNumber; b++) {\n        // We have been stopped\n        if (this.#poller == null) {\n          return;\n        }\n        await this.#provider.emit(\"block\", b);\n      }\n      this.#blockNumber = blockNumber;\n    }\n    // We have been stopped\n    if (this.#poller == null) {\n      return;\n    }\n    this.#poller = this.#provider._setTimeout(this.#poll.bind(this), this.#interval);\n  }\n  start() {\n    if (this.#poller) {\n      return;\n    }\n    this.#poller = this.#provider._setTimeout(this.#poll.bind(this), this.#interval);\n    this.#poll();\n  }\n  stop() {\n    if (!this.#poller) {\n      return;\n    }\n    this.#provider._clearTimeout(this.#poller);\n    this.#poller = null;\n  }\n  pause(dropWhilePaused) {\n    this.stop();\n    if (dropWhilePaused) {\n      this.#blockNumber = -2;\n    }\n  }\n  resume() {\n    this.start();\n  }\n}\nexports.PollingBlockSubscriber = PollingBlockSubscriber;\n/**\n *  @TODO\n *\n *  @_docloc: api/providers/abstract-provider\n */\nclass OnBlockSubscriber {\n  #provider;\n  #poll;\n  #running;\n  constructor(provider) {\n    this.#provider = provider;\n    this.#running = false;\n    this.#poll = blockNumber => {\n      this._poll(blockNumber, this.#provider);\n    };\n  }\n  async _poll(blockNumber, provider) {\n    throw new Error(\"sub-classes must override this\");\n  }\n  start() {\n    if (this.#running) {\n      return;\n    }\n    this.#running = true;\n    this.#poll(-2);\n    this.#provider.on(\"block\", this.#poll);\n  }\n  stop() {\n    if (!this.#running) {\n      return;\n    }\n    this.#running = false;\n    this.#provider.off(\"block\", this.#poll);\n  }\n  pause(dropWhilePaused) {\n    this.stop();\n  }\n  resume() {\n    this.start();\n  }\n}\nexports.OnBlockSubscriber = OnBlockSubscriber;\n/**\n *  @TODO\n *\n *  @_docloc: api/providers/abstract-provider\n */\nclass PollingOrphanSubscriber extends OnBlockSubscriber {\n  #filter;\n  constructor(provider, filter) {\n    super(provider);\n    this.#filter = copy(filter);\n  }\n  async _poll(blockNumber, provider) {\n    throw new Error(\"@TODO\");\n    console.log(this.#filter);\n  }\n}\nexports.PollingOrphanSubscriber = PollingOrphanSubscriber;\n/**\n *  @TODO\n *\n *  @_docloc: api/providers/abstract-provider\n */\nclass PollingTransactionSubscriber extends OnBlockSubscriber {\n  #hash;\n  constructor(provider, hash) {\n    super(provider);\n    this.#hash = hash;\n  }\n  async _poll(blockNumber, provider) {\n    const tx = await provider.getTransactionReceipt(this.#hash);\n    if (tx) {\n      provider.emit(this.#hash, tx);\n    }\n  }\n}\nexports.PollingTransactionSubscriber = PollingTransactionSubscriber;\n/**\n *  @TODO\n *\n *  @_docloc: api/providers/abstract-provider\n */\nclass PollingEventSubscriber {\n  #provider;\n  #filter;\n  #poller;\n  #running;\n  // The most recent block we have scanned for events. The value -2\n  // indicates we still need to fetch an initial block number\n  #blockNumber;\n  constructor(provider, filter) {\n    this.#provider = provider;\n    this.#filter = copy(filter);\n    this.#poller = this.#poll.bind(this);\n    this.#running = false;\n    this.#blockNumber = -2;\n  }\n  async #poll(blockNumber) {\n    // The initial block hasn't been determined yet\n    if (this.#blockNumber === -2) {\n      return;\n    }\n    const filter = copy(this.#filter);\n    filter.fromBlock = this.#blockNumber + 1;\n    filter.toBlock = blockNumber;\n    const logs = await this.#provider.getLogs(filter);\n    // No logs could just mean the node has not indexed them yet,\n    // so we keep a sliding window of 60 blocks to keep scanning\n    if (logs.length === 0) {\n      if (this.#blockNumber < blockNumber - 60) {\n        this.#blockNumber = blockNumber - 60;\n      }\n      return;\n    }\n    this.#blockNumber = blockNumber;\n    for (const log of logs) {\n      this.#provider.emit(this.#filter, log);\n    }\n  }\n  start() {\n    if (this.#running) {\n      return;\n    }\n    this.#running = true;\n    if (this.#blockNumber === -2) {\n      this.#provider.getBlockNumber().then(blockNumber => {\n        this.#blockNumber = blockNumber;\n      });\n    }\n    this.#provider.on(\"block\", this.#poller);\n  }\n  stop() {\n    if (!this.#running) {\n      return;\n    }\n    this.#running = false;\n    this.#provider.off(\"block\", this.#poller);\n  }\n  pause(dropWhilePaused) {\n    this.stop();\n    if (dropWhilePaused) {\n      this.#blockNumber = -2;\n    }\n  }\n  resume() {\n    this.start();\n  }\n}\nexports.PollingEventSubscriber = PollingEventSubscriber;","map":{"version":3,"mappings":"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","names":["copy","obj","JSON","parse","stringify","getPollingSubscriber","provider","event","PollingBlockSubscriber","PollingTransactionSubscriber","operation","info","exports","constructor","pollingInterval","value","blockNumber","getBlockNumber","b","emit","_setTimeout","bind","start","stop","_clearTimeout","pause","dropWhilePaused","resume","OnBlockSubscriber","_poll","Error","on","off","PollingOrphanSubscriber","filter","console","log","hash","tx","getTransactionReceipt","PollingEventSubscriber","fromBlock","toBlock","logs","getLogs","length","then"],"sources":["/Users/janrobel/Documents/PersonalProjekty/nftGenerateAi/clientAndContract/node_modules/ethers/src.ts/providers/subscriber-polling.ts"],"sourcesContent":["import { assert, isHexString } from \"../utils/index.js\";\n\nimport type { AbstractProvider, Subscriber } from \"./abstract-provider.js\";\nimport type { EventFilter, OrphanFilter, ProviderEvent } from \"./provider.js\";\n\nfunction copy(obj: any): any {\n    return JSON.parse(JSON.stringify(obj));\n}\n\n/**\n *  @TODO\n *\n *  @_docloc: api/providers/abstract-provider\n */\nexport function getPollingSubscriber(provider: AbstractProvider, event: ProviderEvent): Subscriber {\n    if (event === \"block\") { return new PollingBlockSubscriber(provider); }\n    if (isHexString(event, 32)) { return new PollingTransactionSubscriber(provider, event); }\n\n    assert(false, \"unsupported polling event\", \"UNSUPPORTED_OPERATION\", {\n        operation: \"getPollingSubscriber\", info: { event }\n    });\n}\n\n// @TODO: refactor this\n\n/**\n *  @TODO\n *\n *  @_docloc: api/providers/abstract-provider\n */\nexport class PollingBlockSubscriber implements Subscriber {\n    #provider: AbstractProvider;\n    #poller: null | number;\n\n    #interval: number;\n\n    // The most recent block we have scanned for events. The value -2\n    // indicates we still need to fetch an initial block number\n    #blockNumber: number;\n\n    constructor(provider: AbstractProvider) {\n        this.#provider = provider;\n        this.#poller = null;\n        this.#interval = 4000;\n\n        this.#blockNumber = -2;\n    }\n\n    get pollingInterval(): number { return this.#interval; }\n    set pollingInterval(value: number) { this.#interval = value; }\n\n    async #poll(): Promise<void> {\n        const blockNumber = await this.#provider.getBlockNumber();\n        if (this.#blockNumber === -2) {\n            this.#blockNumber = blockNumber;\n            return;\n        }\n\n        // @TODO: Put a cap on the maximum number of events per loop?\n\n        if (blockNumber !== this.#blockNumber) {\n            for (let b = this.#blockNumber + 1; b <= blockNumber; b++) {\n                // We have been stopped\n                if (this.#poller == null) { return; }\n\n                await this.#provider.emit(\"block\", b);\n            }\n\n            this.#blockNumber = blockNumber;\n        }\n\n        // We have been stopped\n        if (this.#poller == null) { return; }\n\n        this.#poller = this.#provider._setTimeout(this.#poll.bind(this), this.#interval);\n    }\n\n    start(): void {\n        if (this.#poller) { return; }\n        this.#poller = this.#provider._setTimeout(this.#poll.bind(this), this.#interval);\n        this.#poll();\n    }\n\n    stop(): void {\n        if (!this.#poller) { return; }\n        this.#provider._clearTimeout(this.#poller);\n        this.#poller = null;\n    }\n\n    pause(dropWhilePaused?: boolean): void {\n        this.stop();\n        if (dropWhilePaused) { this.#blockNumber = -2; }\n    }\n\n    resume(): void {\n        this.start();\n    }\n}\n\n/**\n *  @TODO\n *\n *  @_docloc: api/providers/abstract-provider\n */\nexport class OnBlockSubscriber implements Subscriber {\n    #provider: AbstractProvider;\n    #poll: (b: number) => void;\n    #running: boolean;\n\n    constructor(provider: AbstractProvider) {\n        this.#provider = provider;\n        this.#running = false;\n        this.#poll = (blockNumber: number) => {\n            this._poll(blockNumber, this.#provider);\n        }\n    }\n\n    async _poll(blockNumber: number, provider: AbstractProvider): Promise<void> {\n        throw new Error(\"sub-classes must override this\");\n    }\n\n    start(): void {\n        if (this.#running) { return; }\n        this.#running = true;\n\n        this.#poll(-2);\n        this.#provider.on(\"block\", this.#poll);\n    }\n\n    stop(): void {\n        if (!this.#running) { return; }\n        this.#running = false;\n\n        this.#provider.off(\"block\", this.#poll);\n    }\n\n    pause(dropWhilePaused?: boolean): void { this.stop(); }\n    resume(): void { this.start(); }\n}\n\n/**\n *  @TODO\n *\n *  @_docloc: api/providers/abstract-provider\n */\nexport class PollingOrphanSubscriber extends OnBlockSubscriber {\n    #filter: OrphanFilter;\n\n    constructor(provider: AbstractProvider, filter: OrphanFilter) {\n        super(provider);\n        this.#filter = copy(filter);\n    }\n\n    async _poll(blockNumber: number, provider: AbstractProvider): Promise<void> {\n        throw new Error(\"@TODO\");\n        console.log(this.#filter);\n    }\n}\n\n/**\n *  @TODO\n *\n *  @_docloc: api/providers/abstract-provider\n */\nexport class PollingTransactionSubscriber extends OnBlockSubscriber {\n    #hash: string;\n\n    constructor(provider: AbstractProvider, hash: string) {\n        super(provider);\n        this.#hash = hash;\n    }\n\n    async _poll(blockNumber: number, provider: AbstractProvider): Promise<void> {\n        const tx = await provider.getTransactionReceipt(this.#hash);\n        if (tx) { provider.emit(this.#hash, tx); }\n    }\n}\n\n/**\n *  @TODO\n *\n *  @_docloc: api/providers/abstract-provider\n */\nexport class PollingEventSubscriber implements Subscriber {\n    #provider: AbstractProvider;\n    #filter: EventFilter;\n    #poller: (b: number) => void;\n\n    #running: boolean;\n\n    // The most recent block we have scanned for events. The value -2\n    // indicates we still need to fetch an initial block number\n    #blockNumber: number;\n\n    constructor(provider: AbstractProvider, filter: EventFilter) {\n        this.#provider = provider;\n        this.#filter = copy(filter);\n        this.#poller = this.#poll.bind(this);\n        this.#running = false;\n        this.#blockNumber = -2;\n    }\n\n    async #poll(blockNumber: number): Promise<void> {\n        // The initial block hasn't been determined yet\n        if (this.#blockNumber === -2) { return; }\n\n        const filter = copy(this.#filter);\n        filter.fromBlock = this.#blockNumber + 1;\n        filter.toBlock = blockNumber;\n        const logs = await this.#provider.getLogs(filter);\n\n        // No logs could just mean the node has not indexed them yet,\n        // so we keep a sliding window of 60 blocks to keep scanning\n        if (logs.length === 0) {\n            if (this.#blockNumber < blockNumber - 60) {\n                this.#blockNumber = blockNumber - 60;\n            }\n            return;\n        }\n\n        this.#blockNumber = blockNumber;\n\n        for (const log of logs) {\n            this.#provider.emit(this.#filter, log);\n        }\n    }\n\n    start(): void {\n        if (this.#running) { return; }\n        this.#running = true;\n\n        if (this.#blockNumber === -2) {\n            this.#provider.getBlockNumber().then((blockNumber) => {\n                this.#blockNumber = blockNumber;\n            });\n        }\n        this.#provider.on(\"block\", this.#poller);\n    }\n\n    stop(): void {\n        if (!this.#running) { return; }\n        this.#running = false;\n\n        this.#provider.off(\"block\", this.#poller);\n    }\n\n    pause(dropWhilePaused?: boolean): void {\n        this.stop();\n        if (dropWhilePaused) { this.#blockNumber = -2; }\n    }\n\n    resume(): void {\n        this.start();\n    }\n}\n"]},"metadata":{},"sourceType":"script","externalDependencies":[]}