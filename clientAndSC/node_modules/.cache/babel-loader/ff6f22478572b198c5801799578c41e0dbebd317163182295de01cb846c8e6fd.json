{"ast":null,"code":"// copied from https://github.com/nodejs/node/blob/88799930794045795e8abac874730f9eba7e2300/lib/internal/repl/await.js\n'use strict';\n\nconst {\n  ArrayFrom,\n  ArrayPrototypeForEach,\n  ArrayPrototypeIncludes,\n  ArrayPrototypeJoin,\n  ArrayPrototypePop,\n  ArrayPrototypePush,\n  FunctionPrototype,\n  ObjectKeys,\n  RegExpPrototypeSymbolReplace,\n  StringPrototypeEndsWith,\n  StringPrototypeIncludes,\n  StringPrototypeIndexOf,\n  StringPrototypeRepeat,\n  StringPrototypeSplit,\n  StringPrototypeStartsWith,\n  SyntaxError\n} = require('./node-primordials');\nconst parser = require('acorn').Parser;\nconst walk = require('acorn-walk');\nconst {\n  Recoverable\n} = require('repl');\nfunction isTopLevelDeclaration(state) {\n  return state.ancestors[state.ancestors.length - 2] === state.body;\n}\nconst noop = FunctionPrototype;\nconst visitorsWithoutAncestors = {\n  ClassDeclaration(node, state, c) {\n    if (isTopLevelDeclaration(state)) {\n      state.prepend(node, `${node.id.name}=`);\n      ArrayPrototypePush(state.hoistedDeclarationStatements, `let ${node.id.name}; `);\n    }\n    walk.base.ClassDeclaration(node, state, c);\n  },\n  ForOfStatement(node, state, c) {\n    if (node.await === true) {\n      state.containsAwait = true;\n    }\n    walk.base.ForOfStatement(node, state, c);\n  },\n  FunctionDeclaration(node, state, c) {\n    state.prepend(node, `${node.id.name}=`);\n    ArrayPrototypePush(state.hoistedDeclarationStatements, `var ${node.id.name}; `);\n  },\n  FunctionExpression: noop,\n  ArrowFunctionExpression: noop,\n  MethodDefinition: noop,\n  AwaitExpression(node, state, c) {\n    state.containsAwait = true;\n    walk.base.AwaitExpression(node, state, c);\n  },\n  ReturnStatement(node, state, c) {\n    state.containsReturn = true;\n    walk.base.ReturnStatement(node, state, c);\n  },\n  VariableDeclaration(node, state, c) {\n    const variableKind = node.kind;\n    const isIterableForDeclaration = ArrayPrototypeIncludes(['ForOfStatement', 'ForInStatement'], state.ancestors[state.ancestors.length - 2].type);\n    if (variableKind === 'var' || isTopLevelDeclaration(state)) {\n      state.replace(node.start, node.start + variableKind.length + (isIterableForDeclaration ? 1 : 0), variableKind === 'var' && isIterableForDeclaration ? '' : 'void' + (node.declarations.length === 1 ? '' : ' ('));\n      if (!isIterableForDeclaration) {\n        ArrayPrototypeForEach(node.declarations, decl => {\n          state.prepend(decl, '(');\n          state.append(decl, decl.init ? ')' : '=undefined)');\n        });\n        if (node.declarations.length !== 1) {\n          state.append(node.declarations[node.declarations.length - 1], ')');\n        }\n      }\n      const variableIdentifiersToHoist = [['var', []], ['let', []]];\n      function registerVariableDeclarationIdentifiers(node) {\n        switch (node.type) {\n          case 'Identifier':\n            ArrayPrototypePush(variableIdentifiersToHoist[variableKind === 'var' ? 0 : 1][1], node.name);\n            break;\n          case 'ObjectPattern':\n            ArrayPrototypeForEach(node.properties, property => {\n              registerVariableDeclarationIdentifiers(property.value);\n            });\n            break;\n          case 'ArrayPattern':\n            ArrayPrototypeForEach(node.elements, element => {\n              registerVariableDeclarationIdentifiers(element);\n            });\n            break;\n        }\n      }\n      ArrayPrototypeForEach(node.declarations, decl => {\n        registerVariableDeclarationIdentifiers(decl.id);\n      });\n      ArrayPrototypeForEach(variableIdentifiersToHoist, _ref => {\n        let {\n          0: kind,\n          1: identifiers\n        } = _ref;\n        if (identifiers.length > 0) {\n          ArrayPrototypePush(state.hoistedDeclarationStatements, `${kind} ${ArrayPrototypeJoin(identifiers, ', ')}; `);\n        }\n      });\n    }\n    walk.base.VariableDeclaration(node, state, c);\n  }\n};\nconst visitors = {};\nfor (const nodeType of ObjectKeys(walk.base)) {\n  const callback = visitorsWithoutAncestors[nodeType] || walk.base[nodeType];\n  visitors[nodeType] = (node, state, c) => {\n    const isNew = node !== state.ancestors[state.ancestors.length - 1];\n    if (isNew) {\n      ArrayPrototypePush(state.ancestors, node);\n    }\n    callback(node, state, c);\n    if (isNew) {\n      ArrayPrototypePop(state.ancestors);\n    }\n  };\n}\nfunction processTopLevelAwait(src) {\n  const wrapPrefix = '(async () => { ';\n  const wrapped = `${wrapPrefix}${src} })()`;\n  const wrappedArray = ArrayFrom(wrapped);\n  let root;\n  try {\n    root = parser.parse(wrapped, {\n      ecmaVersion: 'latest'\n    });\n  } catch (e) {\n    if (StringPrototypeStartsWith(e.message, 'Unterminated ')) throw new Recoverable(e);\n    // If the parse error is before the first \"await\", then use the execution\n    // error. Otherwise we must emit this parse error, making it look like a\n    // proper syntax error.\n    const awaitPos = StringPrototypeIndexOf(src, 'await');\n    const errPos = e.pos - wrapPrefix.length;\n    if (awaitPos > errPos) return null;\n    // Convert keyword parse errors on await into their original errors when\n    // possible.\n    if (errPos === awaitPos + 6 && StringPrototypeIncludes(e.message, 'Expecting Unicode escape sequence')) return null;\n    if (errPos === awaitPos + 7 && StringPrototypeIncludes(e.message, 'Unexpected token')) return null;\n    const line = e.loc.line;\n    const column = line === 1 ? e.loc.column - wrapPrefix.length : e.loc.column;\n    let message = '\\n' + StringPrototypeSplit(src, '\\n')[line - 1] + '\\n' + StringPrototypeRepeat(' ', column) + '^\\n\\n' + RegExpPrototypeSymbolReplace(/ \\([^)]+\\)/, e.message, '');\n    // V8 unexpected token errors include the token string.\n    if (StringPrototypeEndsWith(message, 'Unexpected token')) message += \" '\" + (\n    // Wrapper end may cause acorn to report error position after the source\n    src.length - 1 >= e.pos - wrapPrefix.length ? src[e.pos - wrapPrefix.length] : src[src.length - 1]) + \"'\";\n    // eslint-disable-next-line no-restricted-syntax\n    throw new SyntaxError(message);\n  }\n  const body = root.body[0].expression.callee.body;\n  const state = {\n    body,\n    ancestors: [],\n    hoistedDeclarationStatements: [],\n    replace(from, to, str) {\n      for (let i = from; i < to; i++) {\n        wrappedArray[i] = '';\n      }\n      if (from === to) str += wrappedArray[from];\n      wrappedArray[from] = str;\n    },\n    prepend(node, str) {\n      wrappedArray[node.start] = str + wrappedArray[node.start];\n    },\n    append(node, str) {\n      wrappedArray[node.end - 1] += str;\n    },\n    containsAwait: false,\n    containsReturn: false\n  };\n  walk.recursive(body, state, visitors);\n\n  // Do not transform if\n  // 1. False alarm: there isn't actually an await expression.\n  // 2. There is a top-level return, which is not allowed.\n  if (!state.containsAwait || state.containsReturn) {\n    return null;\n  }\n  const last = body.body[body.body.length - 1];\n  if (last.type === 'ExpressionStatement') {\n    // For an expression statement of the form\n    // ( expr ) ;\n    // ^^^^^^^^^^   // last\n    //   ^^^^       // last.expression\n    //\n    // We do not want the left parenthesis before the `return` keyword;\n    // therefore we prepend the `return (` to `last`.\n    //\n    // On the other hand, we do not want the right parenthesis after the\n    // semicolon. Since there can only be more right parentheses between\n    // last.expression.end and the semicolon, appending one more to\n    // last.expression should be fine.\n    state.prepend(last, 'return (');\n    state.append(last.expression, ')');\n  }\n  return ArrayPrototypeJoin(state.hoistedDeclarationStatements, '') + ArrayPrototypeJoin(wrappedArray, '');\n}\nmodule.exports = {\n  processTopLevelAwait\n};","map":{"version":3,"names":["ArrayFrom","ArrayPrototypeForEach","ArrayPrototypeIncludes","ArrayPrototypeJoin","ArrayPrototypePop","ArrayPrototypePush","FunctionPrototype","ObjectKeys","RegExpPrototypeSymbolReplace","StringPrototypeEndsWith","StringPrototypeIncludes","StringPrototypeIndexOf","StringPrototypeRepeat","StringPrototypeSplit","StringPrototypeStartsWith","SyntaxError","require","parser","Parser","walk","Recoverable","isTopLevelDeclaration","state","ancestors","length","body","noop","visitorsWithoutAncestors","ClassDeclaration","node","c","prepend","id","name","hoistedDeclarationStatements","base","ForOfStatement","await","containsAwait","FunctionDeclaration","FunctionExpression","ArrowFunctionExpression","MethodDefinition","AwaitExpression","ReturnStatement","containsReturn","VariableDeclaration","variableKind","kind","isIterableForDeclaration","type","replace","start","declarations","decl","append","init","variableIdentifiersToHoist","registerVariableDeclarationIdentifiers","properties","property","value","elements","element","identifiers","visitors","nodeType","callback","isNew","processTopLevelAwait","src","wrapPrefix","wrapped","wrappedArray","root","parse","ecmaVersion","e","message","awaitPos","errPos","pos","line","loc","column","expression","callee","from","to","str","i","end","recursive","last","module","exports"],"sources":["/Users/janrobel/Documents/PersonalProjekty/nftGenerateAi/clientAndContract/node_modules/ts-node/dist-raw/node-internal-repl-await.js"],"sourcesContent":["// copied from https://github.com/nodejs/node/blob/88799930794045795e8abac874730f9eba7e2300/lib/internal/repl/await.js\n'use strict';\n\nconst {\n  ArrayFrom,\n  ArrayPrototypeForEach,\n  ArrayPrototypeIncludes,\n  ArrayPrototypeJoin,\n  ArrayPrototypePop,\n  ArrayPrototypePush,\n  FunctionPrototype,\n  ObjectKeys,\n  RegExpPrototypeSymbolReplace,\n  StringPrototypeEndsWith,\n  StringPrototypeIncludes,\n  StringPrototypeIndexOf,\n  StringPrototypeRepeat,\n  StringPrototypeSplit,\n  StringPrototypeStartsWith,\n  SyntaxError,\n} = require('./node-primordials');\n\nconst parser = require('acorn').Parser;\nconst walk = require('acorn-walk');\nconst { Recoverable } = require('repl');\n\nfunction isTopLevelDeclaration(state) {\n  return state.ancestors[state.ancestors.length - 2] === state.body;\n}\n\nconst noop = FunctionPrototype;\nconst visitorsWithoutAncestors = {\n  ClassDeclaration(node, state, c) {\n    if (isTopLevelDeclaration(state)) {\n      state.prepend(node, `${node.id.name}=`);\n      ArrayPrototypePush(\n        state.hoistedDeclarationStatements,\n        `let ${node.id.name}; `\n      );\n    }\n\n    walk.base.ClassDeclaration(node, state, c);\n  },\n  ForOfStatement(node, state, c) {\n    if (node.await === true) {\n      state.containsAwait = true;\n    }\n    walk.base.ForOfStatement(node, state, c);\n  },\n  FunctionDeclaration(node, state, c) {\n    state.prepend(node, `${node.id.name}=`);\n    ArrayPrototypePush(\n      state.hoistedDeclarationStatements,\n      `var ${node.id.name}; `\n    );\n  },\n  FunctionExpression: noop,\n  ArrowFunctionExpression: noop,\n  MethodDefinition: noop,\n  AwaitExpression(node, state, c) {\n    state.containsAwait = true;\n    walk.base.AwaitExpression(node, state, c);\n  },\n  ReturnStatement(node, state, c) {\n    state.containsReturn = true;\n    walk.base.ReturnStatement(node, state, c);\n  },\n  VariableDeclaration(node, state, c) {\n    const variableKind = node.kind;\n    const isIterableForDeclaration = ArrayPrototypeIncludes(\n      ['ForOfStatement', 'ForInStatement'],\n      state.ancestors[state.ancestors.length - 2].type\n    );\n\n    if (variableKind === 'var' || isTopLevelDeclaration(state)) {\n      state.replace(\n        node.start,\n        node.start + variableKind.length + (isIterableForDeclaration ? 1 : 0),\n        variableKind === 'var' && isIterableForDeclaration ?\n          '' :\n          'void' + (node.declarations.length === 1 ? '' : ' (')\n      );\n\n      if (!isIterableForDeclaration) {\n        ArrayPrototypeForEach(node.declarations, (decl) => {\n          state.prepend(decl, '(');\n          state.append(decl, decl.init ? ')' : '=undefined)');\n        });\n\n        if (node.declarations.length !== 1) {\n          state.append(node.declarations[node.declarations.length - 1], ')');\n        }\n      }\n\n      const variableIdentifiersToHoist = [\n        ['var', []],\n        ['let', []],\n      ];\n      function registerVariableDeclarationIdentifiers(node) {\n        switch (node.type) {\n          case 'Identifier':\n            ArrayPrototypePush(\n              variableIdentifiersToHoist[variableKind === 'var' ? 0 : 1][1],\n              node.name\n            );\n            break;\n          case 'ObjectPattern':\n            ArrayPrototypeForEach(node.properties, (property) => {\n              registerVariableDeclarationIdentifiers(property.value);\n            });\n            break;\n          case 'ArrayPattern':\n            ArrayPrototypeForEach(node.elements, (element) => {\n              registerVariableDeclarationIdentifiers(element);\n            });\n            break;\n        }\n      }\n\n      ArrayPrototypeForEach(node.declarations, (decl) => {\n        registerVariableDeclarationIdentifiers(decl.id);\n      });\n\n      ArrayPrototypeForEach(\n        variableIdentifiersToHoist,\n        ({ 0: kind, 1: identifiers }) => {\n          if (identifiers.length > 0) {\n            ArrayPrototypePush(\n              state.hoistedDeclarationStatements,\n              `${kind} ${ArrayPrototypeJoin(identifiers, ', ')}; `\n            );\n          }\n        }\n      );\n    }\n\n    walk.base.VariableDeclaration(node, state, c);\n  }\n};\n\nconst visitors = {};\nfor (const nodeType of ObjectKeys(walk.base)) {\n  const callback = visitorsWithoutAncestors[nodeType] || walk.base[nodeType];\n  visitors[nodeType] = (node, state, c) => {\n    const isNew = node !== state.ancestors[state.ancestors.length - 1];\n    if (isNew) {\n      ArrayPrototypePush(state.ancestors, node);\n    }\n    callback(node, state, c);\n    if (isNew) {\n      ArrayPrototypePop(state.ancestors);\n    }\n  };\n}\n\nfunction processTopLevelAwait(src) {\n  const wrapPrefix = '(async () => { ';\n  const wrapped = `${wrapPrefix}${src} })()`;\n  const wrappedArray = ArrayFrom(wrapped);\n  let root;\n  try {\n    root = parser.parse(wrapped, { ecmaVersion: 'latest' });\n  } catch (e) {\n    if (StringPrototypeStartsWith(e.message, 'Unterminated '))\n      throw new Recoverable(e);\n    // If the parse error is before the first \"await\", then use the execution\n    // error. Otherwise we must emit this parse error, making it look like a\n    // proper syntax error.\n    const awaitPos = StringPrototypeIndexOf(src, 'await');\n    const errPos = e.pos - wrapPrefix.length;\n    if (awaitPos > errPos)\n      return null;\n    // Convert keyword parse errors on await into their original errors when\n    // possible.\n    if (errPos === awaitPos + 6 &&\n        StringPrototypeIncludes(e.message, 'Expecting Unicode escape sequence'))\n      return null;\n    if (errPos === awaitPos + 7 &&\n        StringPrototypeIncludes(e.message, 'Unexpected token'))\n      return null;\n    const line = e.loc.line;\n    const column = line === 1 ? e.loc.column - wrapPrefix.length : e.loc.column;\n    let message = '\\n' + StringPrototypeSplit(src, '\\n')[line - 1] + '\\n' +\n        StringPrototypeRepeat(' ', column) +\n        '^\\n\\n' + RegExpPrototypeSymbolReplace(/ \\([^)]+\\)/, e.message, '');\n    // V8 unexpected token errors include the token string.\n    if (StringPrototypeEndsWith(message, 'Unexpected token'))\n      message += \" '\" +\n        // Wrapper end may cause acorn to report error position after the source\n        ((src.length - 1) >= (e.pos - wrapPrefix.length)\n          ? src[e.pos - wrapPrefix.length]\n          : src[src.length - 1]) +\n        \"'\";\n    // eslint-disable-next-line no-restricted-syntax\n    throw new SyntaxError(message);\n  }\n  const body = root.body[0].expression.callee.body;\n  const state = {\n    body,\n    ancestors: [],\n    hoistedDeclarationStatements: [],\n    replace(from, to, str) {\n      for (let i = from; i < to; i++) {\n        wrappedArray[i] = '';\n      }\n      if (from === to) str += wrappedArray[from];\n      wrappedArray[from] = str;\n    },\n    prepend(node, str) {\n      wrappedArray[node.start] = str + wrappedArray[node.start];\n    },\n    append(node, str) {\n      wrappedArray[node.end - 1] += str;\n    },\n    containsAwait: false,\n    containsReturn: false\n  };\n\n  walk.recursive(body, state, visitors);\n\n  // Do not transform if\n  // 1. False alarm: there isn't actually an await expression.\n  // 2. There is a top-level return, which is not allowed.\n  if (!state.containsAwait || state.containsReturn) {\n    return null;\n  }\n\n  const last = body.body[body.body.length - 1];\n  if (last.type === 'ExpressionStatement') {\n    // For an expression statement of the form\n    // ( expr ) ;\n    // ^^^^^^^^^^   // last\n    //   ^^^^       // last.expression\n    //\n    // We do not want the left parenthesis before the `return` keyword;\n    // therefore we prepend the `return (` to `last`.\n    //\n    // On the other hand, we do not want the right parenthesis after the\n    // semicolon. Since there can only be more right parentheses between\n    // last.expression.end and the semicolon, appending one more to\n    // last.expression should be fine.\n    state.prepend(last, 'return (');\n    state.append(last.expression, ')');\n  }\n\n  return (\n    ArrayPrototypeJoin(state.hoistedDeclarationStatements, '') +\n    ArrayPrototypeJoin(wrappedArray, '')\n  );\n}\n\nmodule.exports = {\n  processTopLevelAwait\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}