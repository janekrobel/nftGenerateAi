{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.hardforkGte = exports.getHardforkName = exports.HardforkName = void 0;\nconst errors_1 = require(\"../core/errors\");\nvar HardforkName;\n(function (HardforkName) {\n  HardforkName[\"FRONTIER\"] = \"chainstart\";\n  HardforkName[\"HOMESTEAD\"] = \"homestead\";\n  HardforkName[\"DAO\"] = \"dao\";\n  HardforkName[\"TANGERINE_WHISTLE\"] = \"tangerineWhistle\";\n  HardforkName[\"SPURIOUS_DRAGON\"] = \"spuriousDragon\";\n  HardforkName[\"BYZANTIUM\"] = \"byzantium\";\n  HardforkName[\"CONSTANTINOPLE\"] = \"constantinople\";\n  HardforkName[\"PETERSBURG\"] = \"petersburg\";\n  HardforkName[\"ISTANBUL\"] = \"istanbul\";\n  HardforkName[\"MUIR_GLACIER\"] = \"muirGlacier\";\n  HardforkName[\"BERLIN\"] = \"berlin\";\n  HardforkName[\"LONDON\"] = \"london\";\n  HardforkName[\"ARROW_GLACIER\"] = \"arrowGlacier\";\n  HardforkName[\"GRAY_GLACIER\"] = \"grayGlacier\";\n  HardforkName[\"MERGE\"] = \"merge\";\n})(HardforkName = exports.HardforkName || (exports.HardforkName = {}));\nconst HARDFORKS_ORDER = [HardforkName.FRONTIER, HardforkName.HOMESTEAD, HardforkName.DAO, HardforkName.TANGERINE_WHISTLE, HardforkName.SPURIOUS_DRAGON, HardforkName.BYZANTIUM, HardforkName.CONSTANTINOPLE, HardforkName.PETERSBURG, HardforkName.ISTANBUL, HardforkName.MUIR_GLACIER, HardforkName.BERLIN, HardforkName.LONDON, HardforkName.ARROW_GLACIER, HardforkName.GRAY_GLACIER, HardforkName.MERGE];\nfunction getHardforkName(name) {\n  const hardforkName = Object.values(HardforkName)[Object.values(HardforkName).indexOf(name)];\n  (0, errors_1.assertHardhatInvariant)(hardforkName !== undefined, `Invalid harfork name ${name}`);\n  return hardforkName;\n}\nexports.getHardforkName = getHardforkName;\n/**\n * Check if `hardforkA` is greater than or equal to `hardforkB`,\n * that is, if it includes all its changes.\n */\nfunction hardforkGte(hardforkA, hardforkB) {\n  // This function should not load any ethereumjs library, as it's used during\n  // the Hardhat initialization, and that would make it too slow.\n  const indexA = HARDFORKS_ORDER.lastIndexOf(hardforkA);\n  const indexB = HARDFORKS_ORDER.lastIndexOf(hardforkB);\n  return indexA >= indexB;\n}\nexports.hardforkGte = hardforkGte;","map":{"version":3,"mappings":";;;;;;AAAA;AAEA,IAAYA,YAgBX;AAhBD,WAAYA,YAAY;EACtBA,uCAAuB;EACvBA,uCAAuB;EACvBA,2BAAW;EACXA,sDAAsC;EACtCA,kDAAkC;EAClCA,uCAAuB;EACvBA,iDAAiC;EACjCA,yCAAyB;EACzBA,qCAAqB;EACrBA,4CAA4B;EAC5BA,iCAAiB;EACjBA,iCAAiB;EACjBA,8CAA8B;EAC9BA,4CAA4B;EAC5BA,+BAAe;AACjB,CAAC,EAhBWA,YAAY,GAAZC,oBAAY,KAAZA,oBAAY;AAkBxB,MAAMC,eAAe,GAAmB,CACtCF,YAAY,CAACG,QAAQ,EACrBH,YAAY,CAACI,SAAS,EACtBJ,YAAY,CAACK,GAAG,EAChBL,YAAY,CAACM,iBAAiB,EAC9BN,YAAY,CAACO,eAAe,EAC5BP,YAAY,CAACQ,SAAS,EACtBR,YAAY,CAACS,cAAc,EAC3BT,YAAY,CAACU,UAAU,EACvBV,YAAY,CAACW,QAAQ,EACrBX,YAAY,CAACY,YAAY,EACzBZ,YAAY,CAACa,MAAM,EACnBb,YAAY,CAACc,MAAM,EACnBd,YAAY,CAACe,aAAa,EAC1Bf,YAAY,CAACgB,YAAY,EACzBhB,YAAY,CAACiB,KAAK,CACnB;AAED,SAAgBC,eAAe,CAACC,IAAY;EAC1C,MAAMC,YAAY,GAChBC,MAAM,CAACC,MAAM,CAACtB,YAAY,CAAC,CACzBqB,MAAM,CAACC,MAAM,CAAStB,YAAY,CAAC,CAACuB,OAAO,CAACJ,IAAI,CAAC,CAClD;EAEH,mCAAsB,EACpBC,YAAY,KAAKI,SAAS,EAC1B,wBAAwBL,IAAI,EAAE,CAC/B;EAED,OAAOC,YAAY;AACrB;AAZAnB;AAcA;;;;AAIA,SAAgBwB,WAAW,CACzBC,SAAuB,EACvBC,SAAuB;EAEvB;EACA;EACA,MAAMC,MAAM,GAAG1B,eAAe,CAAC2B,WAAW,CAACH,SAAS,CAAC;EACrD,MAAMI,MAAM,GAAG5B,eAAe,CAAC2B,WAAW,CAACF,SAAS,CAAC;EAErD,OAAOC,MAAM,IAAIE,MAAM;AACzB;AAVA7B","names":["HardforkName","exports","HARDFORKS_ORDER","FRONTIER","HOMESTEAD","DAO","TANGERINE_WHISTLE","SPURIOUS_DRAGON","BYZANTIUM","CONSTANTINOPLE","PETERSBURG","ISTANBUL","MUIR_GLACIER","BERLIN","LONDON","ARROW_GLACIER","GRAY_GLACIER","MERGE","getHardforkName","name","hardforkName","Object","values","indexOf","undefined","hardforkGte","hardforkA","hardforkB","indexA","lastIndexOf","indexB"],"sources":["/Users/janrobel/Documents/PersonalProjekty/nftGenerateAi/clientAndContract/node_modules/hardhat/src/internal/util/hardforks.ts"],"sourcesContent":["import { assertHardhatInvariant } from \"../core/errors\";\n\nexport enum HardforkName {\n  FRONTIER = \"chainstart\",\n  HOMESTEAD = \"homestead\",\n  DAO = \"dao\",\n  TANGERINE_WHISTLE = \"tangerineWhistle\",\n  SPURIOUS_DRAGON = \"spuriousDragon\",\n  BYZANTIUM = \"byzantium\",\n  CONSTANTINOPLE = \"constantinople\",\n  PETERSBURG = \"petersburg\",\n  ISTANBUL = \"istanbul\",\n  MUIR_GLACIER = \"muirGlacier\",\n  BERLIN = \"berlin\",\n  LONDON = \"london\",\n  ARROW_GLACIER = \"arrowGlacier\",\n  GRAY_GLACIER = \"grayGlacier\",\n  MERGE = \"merge\",\n}\n\nconst HARDFORKS_ORDER: HardforkName[] = [\n  HardforkName.FRONTIER,\n  HardforkName.HOMESTEAD,\n  HardforkName.DAO,\n  HardforkName.TANGERINE_WHISTLE,\n  HardforkName.SPURIOUS_DRAGON,\n  HardforkName.BYZANTIUM,\n  HardforkName.CONSTANTINOPLE,\n  HardforkName.PETERSBURG,\n  HardforkName.ISTANBUL,\n  HardforkName.MUIR_GLACIER,\n  HardforkName.BERLIN,\n  HardforkName.LONDON,\n  HardforkName.ARROW_GLACIER,\n  HardforkName.GRAY_GLACIER,\n  HardforkName.MERGE,\n];\n\nexport function getHardforkName(name: string): HardforkName {\n  const hardforkName =\n    Object.values(HardforkName)[\n      Object.values<string>(HardforkName).indexOf(name)\n    ];\n\n  assertHardhatInvariant(\n    hardforkName !== undefined,\n    `Invalid harfork name ${name}`\n  );\n\n  return hardforkName;\n}\n\n/**\n * Check if `hardforkA` is greater than or equal to `hardforkB`,\n * that is, if it includes all its changes.\n */\nexport function hardforkGte(\n  hardforkA: HardforkName,\n  hardforkB: HardforkName\n): boolean {\n  // This function should not load any ethereumjs library, as it's used during\n  // the Hardhat initialization, and that would make it too slow.\n  const indexA = HARDFORKS_ORDER.lastIndexOf(hardforkA);\n  const indexB = HARDFORKS_ORDER.lastIndexOf(hardforkB);\n\n  return indexA >= indexB;\n}\n"]},"metadata":{},"sourceType":"script","externalDependencies":[]}