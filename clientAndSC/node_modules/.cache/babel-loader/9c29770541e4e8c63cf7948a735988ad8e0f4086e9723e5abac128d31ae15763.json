{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Parser = void 0;\nconst solidity_files_cache_1 = require(\"../../builtin-tasks/utils/solidity-files-cache\");\nconst errors_1 = require(\"../core/errors\");\nconst errors_list_1 = require(\"../core/errors-list\");\nclass Parser {\n  constructor(_solidityFilesCache) {\n    this._cache = new Map();\n    this._solidityFilesCache = _solidityFilesCache ?? solidity_files_cache_1.SolidityFilesCache.createEmpty();\n  }\n  parse(fileContent, absolutePath, contentHash) {\n    const cacheResult = this._getFromCache(absolutePath, contentHash);\n    if (cacheResult !== null) {\n      return cacheResult;\n    }\n    try {\n      const {\n        analyze\n      } = require(\"@nomicfoundation/solidity-analyzer\");\n      const result = analyze(fileContent);\n      this._cache.set(contentHash, result);\n      return result;\n    } catch (e) {\n      if (e.code === \"MODULE_NOT_FOUND\") {\n        throw new errors_1.HardhatError(errors_list_1.ERRORS.GENERAL.CORRUPTED_LOCKFILE);\n      }\n      // eslint-disable-next-line @nomiclabs/hardhat-internal-rules/only-hardhat-error\n      throw e;\n    }\n  }\n  /**\n   * Get parsed data from the internal cache, or from the solidity files cache.\n   *\n   * Returns null if cannot find it in either one.\n   */\n  _getFromCache(absolutePath, contentHash) {\n    const internalCacheEntry = this._cache.get(contentHash);\n    if (internalCacheEntry !== undefined) {\n      return internalCacheEntry;\n    }\n    const solidityFilesCacheEntry = this._solidityFilesCache.getEntry(absolutePath);\n    if (solidityFilesCacheEntry === undefined) {\n      return null;\n    }\n    const {\n      imports,\n      versionPragmas\n    } = solidityFilesCacheEntry;\n    if (solidityFilesCacheEntry.contentHash !== contentHash) {\n      return null;\n    }\n    return {\n      imports,\n      versionPragmas\n    };\n  }\n}\nexports.Parser = Parser;","map":{"version":3,"mappings":";;;;;;AAEA;AACA;AACA;AAOA,MAAaA,MAAM;EAIjBC,YAAYC,mBAAwC;IAH5C,WAAM,GAAG,IAAIC,GAAG,EAAsB;IAI5C,IAAI,CAACD,mBAAmB,GACtBA,mBAAmB,IAAIE,yCAAkB,CAACC,WAAW,EAAE;EAC3D;EAEOC,KAAK,CACVC,WAAmB,EACnBC,YAAoB,EACpBC,WAAmB;IAEnB,MAAMC,WAAW,GAAG,IAAI,CAACC,aAAa,CAACH,YAAY,EAAEC,WAAW,CAAC;IAEjE,IAAIC,WAAW,KAAK,IAAI,EAAE;MACxB,OAAOA,WAAW;;IAGpB,IAAI;MACF,MAAM;QAAEE;MAAO,CAAE,GACfC,OAAO,CAAC,oCAAoC,CAA6B;MAC3E,MAAMC,MAAM,GAAGF,OAAO,CAACL,WAAW,CAAC;MAEnC,IAAI,CAACQ,MAAM,CAACC,GAAG,CAACP,WAAW,EAAEK,MAAM,CAAC;MAEpC,OAAOA,MAAM;KACd,CAAC,OAAOG,CAAM,EAAE;MACf,IAAIA,CAAC,CAACC,IAAI,KAAK,kBAAkB,EAAE;QACjC,MAAM,IAAIC,qBAAY,CAACC,oBAAM,CAACC,OAAO,CAACC,kBAAkB,CAAC;;MAG3D;MACA,MAAML,CAAC;;EAEX;EAEA;;;;;EAKQN,aAAa,CACnBH,YAAoB,EACpBC,WAAmB;IAEnB,MAAMc,kBAAkB,GAAG,IAAI,CAACR,MAAM,CAACS,GAAG,CAACf,WAAW,CAAC;IAEvD,IAAIc,kBAAkB,KAAKE,SAAS,EAAE;MACpC,OAAOF,kBAAkB;;IAG3B,MAAMG,uBAAuB,GAC3B,IAAI,CAACxB,mBAAmB,CAACyB,QAAQ,CAACnB,YAAY,CAAC;IAEjD,IAAIkB,uBAAuB,KAAKD,SAAS,EAAE;MACzC,OAAO,IAAI;;IAGb,MAAM;MAAEG,OAAO;MAAEC;IAAc,CAAE,GAAGH,uBAAuB;IAE3D,IAAIA,uBAAuB,CAACjB,WAAW,KAAKA,WAAW,EAAE;MACvD,OAAO,IAAI;;IAGb,OAAO;MAAEmB,OAAO;MAAEC;IAAc,CAAE;EACpC;;AAnEFC","names":["Parser","constructor","_solidityFilesCache","Map","solidity_files_cache_1","createEmpty","parse","fileContent","absolutePath","contentHash","cacheResult","_getFromCache","analyze","require","result","_cache","set","e","code","errors_1","errors_list_1","GENERAL","CORRUPTED_LOCKFILE","internalCacheEntry","get","undefined","solidityFilesCacheEntry","getEntry","imports","versionPragmas","exports"],"sources":["/Users/janrobel/Documents/PersonalProjekty/nftGenerateAi/clientAndContract/node_modules/hardhat/src/internal/solidity/parse.ts"],"sourcesContent":["import type SolidityAnalyzerT from \"@nomicfoundation/solidity-analyzer\";\n\nimport { SolidityFilesCache } from \"../../builtin-tasks/utils/solidity-files-cache\";\nimport { HardhatError } from \"../core/errors\";\nimport { ERRORS } from \"../core/errors-list\";\n\ninterface ParsedData {\n  imports: string[];\n  versionPragmas: string[];\n}\n\nexport class Parser {\n  private _cache = new Map<string, ParsedData>();\n  private _solidityFilesCache: SolidityFilesCache;\n\n  constructor(_solidityFilesCache?: SolidityFilesCache) {\n    this._solidityFilesCache =\n      _solidityFilesCache ?? SolidityFilesCache.createEmpty();\n  }\n\n  public parse(\n    fileContent: string,\n    absolutePath: string,\n    contentHash: string\n  ): ParsedData {\n    const cacheResult = this._getFromCache(absolutePath, contentHash);\n\n    if (cacheResult !== null) {\n      return cacheResult;\n    }\n\n    try {\n      const { analyze } =\n        require(\"@nomicfoundation/solidity-analyzer\") as typeof SolidityAnalyzerT;\n      const result = analyze(fileContent);\n\n      this._cache.set(contentHash, result);\n\n      return result;\n    } catch (e: any) {\n      if (e.code === \"MODULE_NOT_FOUND\") {\n        throw new HardhatError(ERRORS.GENERAL.CORRUPTED_LOCKFILE);\n      }\n\n      // eslint-disable-next-line @nomiclabs/hardhat-internal-rules/only-hardhat-error\n      throw e;\n    }\n  }\n\n  /**\n   * Get parsed data from the internal cache, or from the solidity files cache.\n   *\n   * Returns null if cannot find it in either one.\n   */\n  private _getFromCache(\n    absolutePath: string,\n    contentHash: string\n  ): ParsedData | null {\n    const internalCacheEntry = this._cache.get(contentHash);\n\n    if (internalCacheEntry !== undefined) {\n      return internalCacheEntry;\n    }\n\n    const solidityFilesCacheEntry =\n      this._solidityFilesCache.getEntry(absolutePath);\n\n    if (solidityFilesCacheEntry === undefined) {\n      return null;\n    }\n\n    const { imports, versionPragmas } = solidityFilesCacheEntry;\n\n    if (solidityFilesCacheEntry.contentHash !== contentHash) {\n      return null;\n    }\n\n    return { imports, versionPragmas };\n  }\n}\n"]},"metadata":{},"sourceType":"script","externalDependencies":[]}