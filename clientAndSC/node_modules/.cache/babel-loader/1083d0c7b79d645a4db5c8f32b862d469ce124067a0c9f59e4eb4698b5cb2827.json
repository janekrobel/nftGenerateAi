{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.getPatternFromSpec = exports.createTsInternals = void 0;\nconst path_1 = require(\"path\");\nconst util_1 = require(\"./util\");\n/** @internal */\nexports.createTsInternals = (0, util_1.cachedLookup)(createTsInternalsUncached);\n/**\n * Given a reference to the TS compiler, return some TS internal functions that we\n * could not or did not want to grab off the `ts` object.\n * These have been copy-pasted from TS's source and tweaked as necessary.\n *\n * NOTE: This factory returns *only* functions which need a reference to the TS\n * compiler.  Other functions do not need a reference to the TS compiler so are\n * exported directly from this file.\n */\nfunction createTsInternalsUncached(_ts) {\n  const ts = _ts;\n  /**\n   * Copied from:\n   * https://github.com/microsoft/TypeScript/blob/v4.3.2/src/compiler/commandLineParser.ts#L2821-L2846\n   */\n  function getExtendsConfigPath(extendedConfig, host, basePath, errors, createDiagnostic) {\n    extendedConfig = (0, util_1.normalizeSlashes)(extendedConfig);\n    if (isRootedDiskPath(extendedConfig) || startsWith(extendedConfig, './') || startsWith(extendedConfig, '../')) {\n      let extendedConfigPath = getNormalizedAbsolutePath(extendedConfig, basePath);\n      if (!host.fileExists(extendedConfigPath) && !endsWith(extendedConfigPath, ts.Extension.Json)) {\n        extendedConfigPath = `${extendedConfigPath}.json`;\n        if (!host.fileExists(extendedConfigPath)) {\n          errors.push(createDiagnostic(ts.Diagnostics.File_0_not_found, extendedConfig));\n          return undefined;\n        }\n      }\n      return extendedConfigPath;\n    }\n    // If the path isn't a rooted or relative path, resolve like a module\n    const resolved = ts.nodeModuleNameResolver(extendedConfig, combinePaths(basePath, 'tsconfig.json'), {\n      moduleResolution: ts.ModuleResolutionKind.NodeJs\n    }, host, /*cache*/undefined, /*projectRefs*/undefined, /*lookupConfig*/true);\n    if (resolved.resolvedModule) {\n      return resolved.resolvedModule.resolvedFileName;\n    }\n    errors.push(createDiagnostic(ts.Diagnostics.File_0_not_found, extendedConfig));\n    return undefined;\n  }\n  return {\n    getExtendsConfigPath\n  };\n}\n// These functions have alternative implementation to avoid copying too much from TS\nfunction isRootedDiskPath(path) {\n  return (0, path_1.isAbsolute)(path);\n}\nfunction combinePaths(path) {\n  for (var _len = arguments.length, paths = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n    paths[_key - 1] = arguments[_key];\n  }\n  return (0, util_1.normalizeSlashes)((0, path_1.resolve)(path, ...paths.filter(path => path)));\n}\nfunction getNormalizedAbsolutePath(fileName, currentDirectory) {\n  return (0, util_1.normalizeSlashes)(currentDirectory != null ? (0, path_1.resolve)(currentDirectory, fileName) : (0, path_1.resolve)(fileName));\n}\nfunction startsWith(str, prefix) {\n  return str.lastIndexOf(prefix, 0) === 0;\n}\nfunction endsWith(str, suffix) {\n  const expectedPos = str.length - suffix.length;\n  return expectedPos >= 0 && str.indexOf(suffix, expectedPos) === expectedPos;\n}\n// Reserved characters, forces escaping of any non-word (or digit), non-whitespace character.\n// It may be inefficient (we could just match (/[-[\\]{}()*+?.,\\\\^$|#\\s]/g), but this is future\n// proof.\nconst reservedCharacterPattern = /[^\\w\\s\\/]/g;\n/**\n * @internal\n * See also: getRegularExpressionForWildcard, which seems to do almost the same thing\n */\nfunction getPatternFromSpec(spec, basePath) {\n  const pattern = spec && getSubPatternFromSpec(spec, basePath, excludeMatcher);\n  return pattern && `^(${pattern})${'($|/)'}`;\n}\nexports.getPatternFromSpec = getPatternFromSpec;\nfunction getSubPatternFromSpec(spec, basePath, _ref) {\n  let {\n    singleAsteriskRegexFragment,\n    doubleAsteriskRegexFragment,\n    replaceWildcardCharacter\n  } = _ref;\n  let subpattern = '';\n  let hasWrittenComponent = false;\n  const components = getNormalizedPathComponents(spec, basePath);\n  const lastComponent = last(components);\n  // getNormalizedPathComponents includes the separator for the root component.\n  // We need to remove to create our regex correctly.\n  components[0] = removeTrailingDirectorySeparator(components[0]);\n  if (isImplicitGlob(lastComponent)) {\n    components.push('**', '*');\n  }\n  let optionalCount = 0;\n  for (let component of components) {\n    if (component === '**') {\n      subpattern += doubleAsteriskRegexFragment;\n    } else {\n      if (hasWrittenComponent) {\n        subpattern += directorySeparator;\n      }\n      subpattern += component.replace(reservedCharacterPattern, replaceWildcardCharacter);\n    }\n    hasWrittenComponent = true;\n  }\n  while (optionalCount > 0) {\n    subpattern += ')?';\n    optionalCount--;\n  }\n  return subpattern;\n}\nconst directoriesMatcher = {\n  singleAsteriskRegexFragment: '[^/]*',\n  /**\n   * Regex for the ** wildcard. Matches any num of subdirectories. When used for including\n   * files or directories, does not match subdirectories that start with a . character\n   */\n  doubleAsteriskRegexFragment: `(/[^/.][^/]*)*?`,\n  replaceWildcardCharacter: match => replaceWildcardCharacter(match, directoriesMatcher.singleAsteriskRegexFragment)\n};\nconst excludeMatcher = {\n  singleAsteriskRegexFragment: '[^/]*',\n  doubleAsteriskRegexFragment: '(/.+?)?',\n  replaceWildcardCharacter: match => replaceWildcardCharacter(match, excludeMatcher.singleAsteriskRegexFragment)\n};\nfunction getNormalizedPathComponents(path, currentDirectory) {\n  return reducePathComponents(getPathComponents(path, currentDirectory));\n}\nfunction getPathComponents(path) {\n  let currentDirectory = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';\n  path = combinePaths(currentDirectory, path);\n  return pathComponents(path, getRootLength(path));\n}\nfunction reducePathComponents(components) {\n  if (!some(components)) return [];\n  const reduced = [components[0]];\n  for (let i = 1; i < components.length; i++) {\n    const component = components[i];\n    if (!component) continue;\n    if (component === '.') continue;\n    if (component === '..') {\n      if (reduced.length > 1) {\n        if (reduced[reduced.length - 1] !== '..') {\n          reduced.pop();\n          continue;\n        }\n      } else if (reduced[0]) continue;\n    }\n    reduced.push(component);\n  }\n  return reduced;\n}\nfunction getRootLength(path) {\n  const rootLength = getEncodedRootLength(path);\n  return rootLength < 0 ? ~rootLength : rootLength;\n}\nfunction getEncodedRootLength(path) {\n  if (!path) return 0;\n  const ch0 = path.charCodeAt(0);\n  // POSIX or UNC\n  if (ch0 === 47 /* CharacterCodes.slash */ || ch0 === 92 /* CharacterCodes.backslash */) {\n    if (path.charCodeAt(1) !== ch0) return 1; // POSIX: \"/\" (or non-normalized \"\\\")\n    const p1 = path.indexOf(ch0 === 47 /* CharacterCodes.slash */ ? directorySeparator : altDirectorySeparator, 2);\n    if (p1 < 0) return path.length; // UNC: \"//server\" or \"\\\\server\"\n    return p1 + 1; // UNC: \"//server/\" or \"\\\\server\\\"\n  }\n  // DOS\n  if (isVolumeCharacter(ch0) && path.charCodeAt(1) === 58 /* CharacterCodes.colon */) {\n    const ch2 = path.charCodeAt(2);\n    if (ch2 === 47 /* CharacterCodes.slash */ || ch2 === 92 /* CharacterCodes.backslash */) return 3; // DOS: \"c:/\" or \"c:\\\"\n    if (path.length === 2) return 2; // DOS: \"c:\" (but not \"c:d\")\n  }\n  // URL\n  const schemeEnd = path.indexOf(urlSchemeSeparator);\n  if (schemeEnd !== -1) {\n    const authorityStart = schemeEnd + urlSchemeSeparator.length;\n    const authorityEnd = path.indexOf(directorySeparator, authorityStart);\n    if (authorityEnd !== -1) {\n      // URL: \"file:///\", \"file://server/\", \"file://server/path\"\n      // For local \"file\" URLs, include the leading DOS volume (if present).\n      // Per https://www.ietf.org/rfc/rfc1738.txt, a host of \"\" or \"localhost\" is a\n      // special case interpreted as \"the machine from which the URL is being interpreted\".\n      const scheme = path.slice(0, schemeEnd);\n      const authority = path.slice(authorityStart, authorityEnd);\n      if (scheme === 'file' && (authority === '' || authority === 'localhost') && isVolumeCharacter(path.charCodeAt(authorityEnd + 1))) {\n        const volumeSeparatorEnd = getFileUrlVolumeSeparatorEnd(path, authorityEnd + 2);\n        if (volumeSeparatorEnd !== -1) {\n          if (path.charCodeAt(volumeSeparatorEnd) === 47 /* CharacterCodes.slash */) {\n            // URL: \"file:///c:/\", \"file://localhost/c:/\", \"file:///c%3a/\", \"file://localhost/c%3a/\"\n            return ~(volumeSeparatorEnd + 1);\n          }\n          if (volumeSeparatorEnd === path.length) {\n            // URL: \"file:///c:\", \"file://localhost/c:\", \"file:///c$3a\", \"file://localhost/c%3a\"\n            // but not \"file:///c:d\" or \"file:///c%3ad\"\n            return ~volumeSeparatorEnd;\n          }\n        }\n      }\n      return ~(authorityEnd + 1); // URL: \"file://server/\", \"http://server/\"\n    }\n\n    return ~path.length; // URL: \"file://server\", \"http://server\"\n  }\n  // relative\n  return 0;\n}\nfunction ensureTrailingDirectorySeparator(path) {\n  if (!hasTrailingDirectorySeparator(path)) {\n    return path + directorySeparator;\n  }\n  return path;\n}\nfunction hasTrailingDirectorySeparator(path) {\n  return path.length > 0 && isAnyDirectorySeparator(path.charCodeAt(path.length - 1));\n}\nfunction isAnyDirectorySeparator(charCode) {\n  return charCode === 47 /* CharacterCodes.slash */ || charCode === 92 /* CharacterCodes.backslash */;\n}\n\nfunction removeTrailingDirectorySeparator(path) {\n  if (hasTrailingDirectorySeparator(path)) {\n    return path.substr(0, path.length - 1);\n  }\n  return path;\n}\nconst directorySeparator = '/';\nconst altDirectorySeparator = '\\\\';\nconst urlSchemeSeparator = '://';\nfunction isVolumeCharacter(charCode) {\n  return charCode >= 97 /* CharacterCodes.a */ && charCode <= 122 /* CharacterCodes.z */ || charCode >= 65 /* CharacterCodes.A */ && charCode <= 90 /* CharacterCodes.Z */;\n}\n\nfunction getFileUrlVolumeSeparatorEnd(url, start) {\n  const ch0 = url.charCodeAt(start);\n  if (ch0 === 58 /* CharacterCodes.colon */) return start + 1;\n  if (ch0 === 37 /* CharacterCodes.percent */ && url.charCodeAt(start + 1) === 51 /* CharacterCodes._3 */) {\n    const ch2 = url.charCodeAt(start + 2);\n    if (ch2 === 97 /* CharacterCodes.a */ || ch2 === 65 /* CharacterCodes.A */) return start + 3;\n  }\n  return -1;\n}\nfunction some(array, predicate) {\n  if (array) {\n    if (predicate) {\n      for (const v of array) {\n        if (predicate(v)) {\n          return true;\n        }\n      }\n    } else {\n      return array.length > 0;\n    }\n  }\n  return false;\n}\nfunction pathComponents(path, rootLength) {\n  const root = path.substring(0, rootLength);\n  const rest = path.substring(rootLength).split(directorySeparator);\n  if (rest.length && !lastOrUndefined(rest)) rest.pop();\n  return [root, ...rest];\n}\nfunction lastOrUndefined(array) {\n  return array.length === 0 ? undefined : array[array.length - 1];\n}\nfunction last(array) {\n  // Debug.assert(array.length !== 0);\n  return array[array.length - 1];\n}\nfunction replaceWildcardCharacter(match, singleAsteriskRegexFragment) {\n  return match === '*' ? singleAsteriskRegexFragment : match === '?' ? '[^/]' : '\\\\' + match;\n}\n/**\n * An \"includes\" path \"foo\" is implicitly a glob \"foo/** /*\" (without the space) if its last component has no extension,\n * and does not contain any glob characters itself.\n */\nfunction isImplicitGlob(lastPathComponent) {\n  return !/[.*?]/.test(lastPathComponent);\n}","map":{"version":3,"mappings":"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","names":["exports","createTsInternalsUncached","_ts","ts","getExtendsConfigPath","extendedConfig","host","basePath","errors","createDiagnostic","isRootedDiskPath","startsWith","extendedConfigPath","getNormalizedAbsolutePath","fileExists","endsWith","Extension","Json","push","Diagnostics","File_0_not_found","undefined","resolved","nodeModuleNameResolver","combinePaths","moduleResolution","ModuleResolutionKind","NodeJs","resolvedModule","resolvedFileName","path","paths","filter","fileName","currentDirectory","str","prefix","lastIndexOf","suffix","expectedPos","length","indexOf","reservedCharacterPattern","getPatternFromSpec","spec","pattern","getSubPatternFromSpec","excludeMatcher","singleAsteriskRegexFragment","doubleAsteriskRegexFragment","replaceWildcardCharacter","subpattern","hasWrittenComponent","components","getNormalizedPathComponents","lastComponent","last","removeTrailingDirectorySeparator","isImplicitGlob","optionalCount","component","directorySeparator","replace","directoriesMatcher","match","reducePathComponents","getPathComponents","pathComponents","getRootLength","some","reduced","i","pop","rootLength","getEncodedRootLength","ch0","charCodeAt","p1","altDirectorySeparator","isVolumeCharacter","ch2","schemeEnd","urlSchemeSeparator","authorityStart","authorityEnd","scheme","slice","authority","volumeSeparatorEnd","getFileUrlVolumeSeparatorEnd","ensureTrailingDirectorySeparator","hasTrailingDirectorySeparator","isAnyDirectorySeparator","charCode","substr","url","start","array","predicate","v","root","substring","rest","split","lastOrUndefined","lastPathComponent","test"],"sources":["/Users/janrobel/Documents/PersonalProjekty/nftGenerateAi/clientAndContract/node_modules/ts-node/src/ts-internals.ts"],"sourcesContent":["import { isAbsolute, resolve } from 'path';\nimport { cachedLookup, normalizeSlashes } from './util';\nimport type * as _ts from 'typescript';\nimport type { TSCommon, TSInternal } from './ts-compiler-types';\n\n/** @internal */\nexport const createTsInternals = cachedLookup(createTsInternalsUncached);\n/**\n * Given a reference to the TS compiler, return some TS internal functions that we\n * could not or did not want to grab off the `ts` object.\n * These have been copy-pasted from TS's source and tweaked as necessary.\n *\n * NOTE: This factory returns *only* functions which need a reference to the TS\n * compiler.  Other functions do not need a reference to the TS compiler so are\n * exported directly from this file.\n */\nfunction createTsInternalsUncached(_ts: TSCommon) {\n  const ts = _ts as TSCommon & TSInternal;\n  /**\n   * Copied from:\n   * https://github.com/microsoft/TypeScript/blob/v4.3.2/src/compiler/commandLineParser.ts#L2821-L2846\n   */\n  function getExtendsConfigPath(\n    extendedConfig: string,\n    host: _ts.ParseConfigHost,\n    basePath: string,\n    errors: _ts.Push<_ts.Diagnostic>,\n    createDiagnostic: (\n      message: _ts.DiagnosticMessage,\n      arg1?: string\n    ) => _ts.Diagnostic\n  ) {\n    extendedConfig = normalizeSlashes(extendedConfig);\n    if (\n      isRootedDiskPath(extendedConfig) ||\n      startsWith(extendedConfig, './') ||\n      startsWith(extendedConfig, '../')\n    ) {\n      let extendedConfigPath = getNormalizedAbsolutePath(\n        extendedConfig,\n        basePath\n      );\n      if (\n        !host.fileExists(extendedConfigPath) &&\n        !endsWith(extendedConfigPath, ts.Extension.Json)\n      ) {\n        extendedConfigPath = `${extendedConfigPath}.json`;\n        if (!host.fileExists(extendedConfigPath)) {\n          errors.push(\n            createDiagnostic(ts.Diagnostics.File_0_not_found, extendedConfig)\n          );\n          return undefined;\n        }\n      }\n      return extendedConfigPath;\n    }\n    // If the path isn't a rooted or relative path, resolve like a module\n    const resolved = ts.nodeModuleNameResolver(\n      extendedConfig,\n      combinePaths(basePath, 'tsconfig.json'),\n      { moduleResolution: ts.ModuleResolutionKind.NodeJs },\n      host,\n      /*cache*/ undefined,\n      /*projectRefs*/ undefined,\n      /*lookupConfig*/ true\n    );\n    if (resolved.resolvedModule) {\n      return resolved.resolvedModule.resolvedFileName;\n    }\n    errors.push(\n      createDiagnostic(ts.Diagnostics.File_0_not_found, extendedConfig)\n    );\n    return undefined;\n  }\n\n  return { getExtendsConfigPath };\n}\n\n// These functions have alternative implementation to avoid copying too much from TS\nfunction isRootedDiskPath(path: string) {\n  return isAbsolute(path);\n}\nfunction combinePaths(path: string, ...paths: (string | undefined)[]): string {\n  return normalizeSlashes(\n    resolve(path, ...(paths.filter((path) => path) as string[]))\n  );\n}\nfunction getNormalizedAbsolutePath(\n  fileName: string,\n  currentDirectory: string | undefined\n) {\n  return normalizeSlashes(\n    currentDirectory != null\n      ? resolve(currentDirectory!, fileName)\n      : resolve(fileName)\n  );\n}\n\nfunction startsWith(str: string, prefix: string): boolean {\n  return str.lastIndexOf(prefix, 0) === 0;\n}\n\nfunction endsWith(str: string, suffix: string): boolean {\n  const expectedPos = str.length - suffix.length;\n  return expectedPos >= 0 && str.indexOf(suffix, expectedPos) === expectedPos;\n}\n// Reserved characters, forces escaping of any non-word (or digit), non-whitespace character.\n// It may be inefficient (we could just match (/[-[\\]{}()*+?.,\\\\^$|#\\s]/g), but this is future\n// proof.\nconst reservedCharacterPattern = /[^\\w\\s\\/]/g;\n\n/**\n * @internal\n * See also: getRegularExpressionForWildcard, which seems to do almost the same thing\n */\nexport function getPatternFromSpec(spec: string, basePath: string) {\n  const pattern = spec && getSubPatternFromSpec(spec, basePath, excludeMatcher);\n  return pattern && `^(${pattern})${'($|/)'}`;\n}\nfunction getSubPatternFromSpec(\n  spec: string,\n  basePath: string,\n  {\n    singleAsteriskRegexFragment,\n    doubleAsteriskRegexFragment,\n    replaceWildcardCharacter,\n  }: WildcardMatcher\n): string {\n  let subpattern = '';\n  let hasWrittenComponent = false;\n  const components = getNormalizedPathComponents(spec, basePath);\n  const lastComponent = last(components);\n\n  // getNormalizedPathComponents includes the separator for the root component.\n  // We need to remove to create our regex correctly.\n  components[0] = removeTrailingDirectorySeparator(components[0]);\n\n  if (isImplicitGlob(lastComponent)) {\n    components.push('**', '*');\n  }\n\n  let optionalCount = 0;\n  for (let component of components) {\n    if (component === '**') {\n      subpattern += doubleAsteriskRegexFragment;\n    } else {\n      if (hasWrittenComponent) {\n        subpattern += directorySeparator;\n      }\n      subpattern += component.replace(\n        reservedCharacterPattern,\n        replaceWildcardCharacter\n      );\n    }\n\n    hasWrittenComponent = true;\n  }\n\n  while (optionalCount > 0) {\n    subpattern += ')?';\n    optionalCount--;\n  }\n\n  return subpattern;\n}\ninterface WildcardMatcher {\n  singleAsteriskRegexFragment: string;\n  doubleAsteriskRegexFragment: string;\n  replaceWildcardCharacter: (match: string) => string;\n}\nconst directoriesMatcher: WildcardMatcher = {\n  singleAsteriskRegexFragment: '[^/]*',\n  /**\n   * Regex for the ** wildcard. Matches any num of subdirectories. When used for including\n   * files or directories, does not match subdirectories that start with a . character\n   */\n  doubleAsteriskRegexFragment: `(/[^/.][^/]*)*?`,\n  replaceWildcardCharacter: (match) =>\n    replaceWildcardCharacter(\n      match,\n      directoriesMatcher.singleAsteriskRegexFragment\n    ),\n};\nconst excludeMatcher: WildcardMatcher = {\n  singleAsteriskRegexFragment: '[^/]*',\n  doubleAsteriskRegexFragment: '(/.+?)?',\n  replaceWildcardCharacter: (match) =>\n    replaceWildcardCharacter(match, excludeMatcher.singleAsteriskRegexFragment),\n};\nfunction getNormalizedPathComponents(\n  path: string,\n  currentDirectory: string | undefined\n) {\n  return reducePathComponents(getPathComponents(path, currentDirectory));\n}\nfunction getPathComponents(path: string, currentDirectory = '') {\n  path = combinePaths(currentDirectory, path);\n  return pathComponents(path, getRootLength(path));\n}\nfunction reducePathComponents(components: readonly string[]) {\n  if (!some(components)) return [];\n  const reduced = [components[0]];\n  for (let i = 1; i < components.length; i++) {\n    const component = components[i];\n    if (!component) continue;\n    if (component === '.') continue;\n    if (component === '..') {\n      if (reduced.length > 1) {\n        if (reduced[reduced.length - 1] !== '..') {\n          reduced.pop();\n          continue;\n        }\n      } else if (reduced[0]) continue;\n    }\n    reduced.push(component);\n  }\n  return reduced;\n}\nfunction getRootLength(path: string) {\n  const rootLength = getEncodedRootLength(path);\n  return rootLength < 0 ? ~rootLength : rootLength;\n}\nfunction getEncodedRootLength(path: string): number {\n  if (!path) return 0;\n  const ch0 = path.charCodeAt(0);\n\n  // POSIX or UNC\n  if (ch0 === CharacterCodes.slash || ch0 === CharacterCodes.backslash) {\n    if (path.charCodeAt(1) !== ch0) return 1; // POSIX: \"/\" (or non-normalized \"\\\")\n\n    const p1 = path.indexOf(\n      ch0 === CharacterCodes.slash ? directorySeparator : altDirectorySeparator,\n      2\n    );\n    if (p1 < 0) return path.length; // UNC: \"//server\" or \"\\\\server\"\n\n    return p1 + 1; // UNC: \"//server/\" or \"\\\\server\\\"\n  }\n\n  // DOS\n  if (isVolumeCharacter(ch0) && path.charCodeAt(1) === CharacterCodes.colon) {\n    const ch2 = path.charCodeAt(2);\n    if (ch2 === CharacterCodes.slash || ch2 === CharacterCodes.backslash)\n      return 3; // DOS: \"c:/\" or \"c:\\\"\n    if (path.length === 2) return 2; // DOS: \"c:\" (but not \"c:d\")\n  }\n\n  // URL\n  const schemeEnd = path.indexOf(urlSchemeSeparator);\n  if (schemeEnd !== -1) {\n    const authorityStart = schemeEnd + urlSchemeSeparator.length;\n    const authorityEnd = path.indexOf(directorySeparator, authorityStart);\n    if (authorityEnd !== -1) {\n      // URL: \"file:///\", \"file://server/\", \"file://server/path\"\n      // For local \"file\" URLs, include the leading DOS volume (if present).\n      // Per https://www.ietf.org/rfc/rfc1738.txt, a host of \"\" or \"localhost\" is a\n      // special case interpreted as \"the machine from which the URL is being interpreted\".\n      const scheme = path.slice(0, schemeEnd);\n      const authority = path.slice(authorityStart, authorityEnd);\n      if (\n        scheme === 'file' &&\n        (authority === '' || authority === 'localhost') &&\n        isVolumeCharacter(path.charCodeAt(authorityEnd + 1))\n      ) {\n        const volumeSeparatorEnd = getFileUrlVolumeSeparatorEnd(\n          path,\n          authorityEnd + 2\n        );\n        if (volumeSeparatorEnd !== -1) {\n          if (path.charCodeAt(volumeSeparatorEnd) === CharacterCodes.slash) {\n            // URL: \"file:///c:/\", \"file://localhost/c:/\", \"file:///c%3a/\", \"file://localhost/c%3a/\"\n            return ~(volumeSeparatorEnd + 1);\n          }\n          if (volumeSeparatorEnd === path.length) {\n            // URL: \"file:///c:\", \"file://localhost/c:\", \"file:///c$3a\", \"file://localhost/c%3a\"\n            // but not \"file:///c:d\" or \"file:///c%3ad\"\n            return ~volumeSeparatorEnd;\n          }\n        }\n      }\n      return ~(authorityEnd + 1); // URL: \"file://server/\", \"http://server/\"\n    }\n    return ~path.length; // URL: \"file://server\", \"http://server\"\n  }\n\n  // relative\n  return 0;\n}\nfunction ensureTrailingDirectorySeparator(path: string) {\n  if (!hasTrailingDirectorySeparator(path)) {\n    return path + directorySeparator;\n  }\n\n  return path;\n}\nfunction hasTrailingDirectorySeparator(path: string) {\n  return (\n    path.length > 0 && isAnyDirectorySeparator(path.charCodeAt(path.length - 1))\n  );\n}\nfunction isAnyDirectorySeparator(charCode: number): boolean {\n  return (\n    charCode === CharacterCodes.slash || charCode === CharacterCodes.backslash\n  );\n}\nfunction removeTrailingDirectorySeparator(path: string) {\n  if (hasTrailingDirectorySeparator(path)) {\n    return path.substr(0, path.length - 1);\n  }\n\n  return path;\n}\nconst directorySeparator = '/';\nconst altDirectorySeparator = '\\\\';\nconst urlSchemeSeparator = '://';\nfunction isVolumeCharacter(charCode: number) {\n  return (\n    (charCode >= CharacterCodes.a && charCode <= CharacterCodes.z) ||\n    (charCode >= CharacterCodes.A && charCode <= CharacterCodes.Z)\n  );\n}\nfunction getFileUrlVolumeSeparatorEnd(url: string, start: number) {\n  const ch0 = url.charCodeAt(start);\n  if (ch0 === CharacterCodes.colon) return start + 1;\n  if (\n    ch0 === CharacterCodes.percent &&\n    url.charCodeAt(start + 1) === CharacterCodes._3\n  ) {\n    const ch2 = url.charCodeAt(start + 2);\n    if (ch2 === CharacterCodes.a || ch2 === CharacterCodes.A) return start + 3;\n  }\n  return -1;\n}\nfunction some<T>(array: readonly T[] | undefined): array is readonly T[];\nfunction some<T>(\n  array: readonly T[] | undefined,\n  predicate: (value: T) => boolean\n): boolean;\nfunction some<T>(\n  array: readonly T[] | undefined,\n  predicate?: (value: T) => boolean\n): boolean {\n  if (array) {\n    if (predicate) {\n      for (const v of array) {\n        if (predicate(v)) {\n          return true;\n        }\n      }\n    } else {\n      return array.length > 0;\n    }\n  }\n  return false;\n}\n/* @internal */\nconst enum CharacterCodes {\n  _3 = 0x33,\n  a = 0x61,\n  z = 0x7a,\n  A = 0x41,\n  Z = 0x5a,\n  asterisk = 0x2a, // *\n  backslash = 0x5c, // \\\n  colon = 0x3a, // :\n  percent = 0x25, // %\n  question = 0x3f, // ?\n  slash = 0x2f, // /\n}\nfunction pathComponents(path: string, rootLength: number) {\n  const root = path.substring(0, rootLength);\n  const rest = path.substring(rootLength).split(directorySeparator);\n  if (rest.length && !lastOrUndefined(rest)) rest.pop();\n  return [root, ...rest];\n}\nfunction lastOrUndefined<T>(array: readonly T[]): T | undefined {\n  return array.length === 0 ? undefined : array[array.length - 1];\n}\nfunction last<T>(array: readonly T[]): T {\n  // Debug.assert(array.length !== 0);\n  return array[array.length - 1];\n}\nfunction replaceWildcardCharacter(\n  match: string,\n  singleAsteriskRegexFragment: string\n) {\n  return match === '*'\n    ? singleAsteriskRegexFragment\n    : match === '?'\n    ? '[^/]'\n    : '\\\\' + match;\n}\n/**\n * An \"includes\" path \"foo\" is implicitly a glob \"foo/** /*\" (without the space) if its last component has no extension,\n * and does not contain any glob characters itself.\n */\nfunction isImplicitGlob(lastPathComponent: string): boolean {\n  return !/[.*?]/.test(lastPathComponent);\n}\n"]},"metadata":{},"sourceType":"script","externalDependencies":[]}