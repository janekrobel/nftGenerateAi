{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.normalizeHardhatNetworkAccountsConfig = exports.derivePrivateKeys = void 0;\nconst keys_derivation_1 = require(\"../../util/keys-derivation\");\nconst default_config_1 = require(\"../config/default-config\");\nconst errors_1 = require(\"../errors\");\nconst errors_list_1 = require(\"../errors-list\");\nconst HD_PATH_REGEX = /^m(:?\\/\\d+'?)+\\/?$/;\nfunction derivePrivateKeys(mnemonic, hdpath, initialIndex, count, passphrase) {\n  if (hdpath.match(HD_PATH_REGEX) === null) {\n    throw new errors_1.HardhatError(errors_list_1.ERRORS.NETWORK.INVALID_HD_PATH, {\n      path: hdpath\n    });\n  }\n  if (!hdpath.endsWith(\"/\")) {\n    hdpath += \"/\";\n  }\n  const privateKeys = [];\n  for (let i = initialIndex; i < initialIndex + count; i++) {\n    const privateKey = (0, keys_derivation_1.deriveKeyFromMnemonicAndPath)(mnemonic, hdpath + i.toString(), passphrase);\n    if (privateKey === undefined) {\n      throw new errors_1.HardhatError(errors_list_1.ERRORS.NETWORK.CANT_DERIVE_KEY, {\n        mnemonic,\n        path: hdpath\n      });\n    }\n    privateKeys.push(privateKey);\n  }\n  return privateKeys;\n}\nexports.derivePrivateKeys = derivePrivateKeys;\nfunction normalizeHardhatNetworkAccountsConfig(accountsConfig) {\n  if (Array.isArray(accountsConfig)) {\n    return accountsConfig;\n  }\n  const {\n    bufferToHex\n  } = require(\"@nomicfoundation/ethereumjs-util\");\n  return derivePrivateKeys(accountsConfig.mnemonic, accountsConfig.path, accountsConfig.initialIndex, accountsConfig.count, accountsConfig.passphrase).map(pk => ({\n    privateKey: bufferToHex(pk),\n    balance: accountsConfig.accountsBalance ?? default_config_1.DEFAULT_HARDHAT_NETWORK_BALANCE\n  }));\n}\nexports.normalizeHardhatNetworkAccountsConfig = normalizeHardhatNetworkAccountsConfig;","map":{"version":3,"mappings":";;;;;;AAIA;AACA;AACA;AACA;AAEA,MAAMA,aAAa,GAAG,oBAAoB;AAE1C,SAAgBC,iBAAiB,CAC/BC,QAAgB,EAChBC,MAAc,EACdC,YAAoB,EACpBC,KAAa,EACbC,UAAkB;EAElB,IAAIH,MAAM,CAACI,KAAK,CAACP,aAAa,CAAC,KAAK,IAAI,EAAE;IACxC,MAAM,IAAIQ,qBAAY,CAACC,oBAAM,CAACC,OAAO,CAACC,eAAe,EAAE;MAAEC,IAAI,EAAET;IAAM,CAAE,CAAC;;EAG1E,IAAI,CAACA,MAAM,CAACU,QAAQ,CAAC,GAAG,CAAC,EAAE;IACzBV,MAAM,IAAI,GAAG;;EAGf,MAAMW,WAAW,GAAa,EAAE;EAEhC,KAAK,IAAIC,CAAC,GAAGX,YAAY,EAAEW,CAAC,GAAGX,YAAY,GAAGC,KAAK,EAAEU,CAAC,EAAE,EAAE;IACxD,MAAMC,UAAU,GAAG,kDAA4B,EAC7Cd,QAAQ,EACRC,MAAM,GAAGY,CAAC,CAACE,QAAQ,EAAE,EACrBX,UAAU,CACX;IAED,IAAIU,UAAU,KAAKE,SAAS,EAAE;MAC5B,MAAM,IAAIV,qBAAY,CAACC,oBAAM,CAACC,OAAO,CAACS,eAAe,EAAE;QACrDjB,QAAQ;QACRU,IAAI,EAAET;OACP,CAAC;;IAGJW,WAAW,CAACM,IAAI,CAACJ,UAAU,CAAC;;EAG9B,OAAOF,WAAW;AACpB;AAnCAO;AAqCA,SAAgBC,qCAAqC,CACnDC,cAA4C;EAE5C,IAAIC,KAAK,CAACC,OAAO,CAACF,cAAc,CAAC,EAAE;IACjC,OAAOA,cAAc;;EAGvB,MAAM;IAAEG;EAAW,CAAE,GAAGC,OAAO,CAAC,kCAAkC,CAAC;EAEnE,OAAO1B,iBAAiB,CACtBsB,cAAc,CAACrB,QAAQ,EACvBqB,cAAc,CAACX,IAAI,EACnBW,cAAc,CAACnB,YAAY,EAC3BmB,cAAc,CAAClB,KAAK,EACpBkB,cAAc,CAACjB,UAAU,CAC1B,CAACsB,GAAG,CAAEC,EAAE,KAAM;IACbb,UAAU,EAAEU,WAAW,CAACG,EAAE,CAAC;IAC3BC,OAAO,EAAEP,cAAc,CAACQ,eAAe,IAAIC;GAC5C,CAAC,CAAC;AACL;AAnBAX","names":["HD_PATH_REGEX","derivePrivateKeys","mnemonic","hdpath","initialIndex","count","passphrase","match","errors_1","errors_list_1","NETWORK","INVALID_HD_PATH","path","endsWith","privateKeys","i","privateKey","toString","undefined","CANT_DERIVE_KEY","push","exports","normalizeHardhatNetworkAccountsConfig","accountsConfig","Array","isArray","bufferToHex","require","map","pk","balance","accountsBalance","default_config_1"],"sources":["/Users/janrobel/Documents/PersonalProjekty/nftGenerateAi/clientAndContract/node_modules/hardhat/src/internal/core/providers/util.ts"],"sourcesContent":["import {\n  HardhatNetworkAccountConfig,\n  HardhatNetworkAccountsConfig,\n} from \"../../../types\";\nimport { deriveKeyFromMnemonicAndPath } from \"../../util/keys-derivation\";\nimport { DEFAULT_HARDHAT_NETWORK_BALANCE } from \"../config/default-config\";\nimport { HardhatError } from \"../errors\";\nimport { ERRORS } from \"../errors-list\";\n\nconst HD_PATH_REGEX = /^m(:?\\/\\d+'?)+\\/?$/;\n\nexport function derivePrivateKeys(\n  mnemonic: string,\n  hdpath: string,\n  initialIndex: number,\n  count: number,\n  passphrase: string\n): Buffer[] {\n  if (hdpath.match(HD_PATH_REGEX) === null) {\n    throw new HardhatError(ERRORS.NETWORK.INVALID_HD_PATH, { path: hdpath });\n  }\n\n  if (!hdpath.endsWith(\"/\")) {\n    hdpath += \"/\";\n  }\n\n  const privateKeys: Buffer[] = [];\n\n  for (let i = initialIndex; i < initialIndex + count; i++) {\n    const privateKey = deriveKeyFromMnemonicAndPath(\n      mnemonic,\n      hdpath + i.toString(),\n      passphrase\n    );\n\n    if (privateKey === undefined) {\n      throw new HardhatError(ERRORS.NETWORK.CANT_DERIVE_KEY, {\n        mnemonic,\n        path: hdpath,\n      });\n    }\n\n    privateKeys.push(privateKey);\n  }\n\n  return privateKeys;\n}\n\nexport function normalizeHardhatNetworkAccountsConfig(\n  accountsConfig: HardhatNetworkAccountsConfig\n): HardhatNetworkAccountConfig[] {\n  if (Array.isArray(accountsConfig)) {\n    return accountsConfig;\n  }\n\n  const { bufferToHex } = require(\"@nomicfoundation/ethereumjs-util\");\n\n  return derivePrivateKeys(\n    accountsConfig.mnemonic,\n    accountsConfig.path,\n    accountsConfig.initialIndex,\n    accountsConfig.count,\n    accountsConfig.passphrase\n  ).map((pk) => ({\n    privateKey: bufferToHex(pk),\n    balance: accountsConfig.accountsBalance ?? DEFAULT_HARDHAT_NETWORK_BALANCE,\n  }));\n}\n"]},"metadata":{},"sourceType":"script","externalDependencies":[]}