{"ast":null,"code":"\"use strict\";\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Environment = void 0;\nconst debug_1 = __importDefault(require(\"debug\"));\nconst artifacts_1 = require(\"../artifacts\");\nconst lazy_1 = require(\"../util/lazy\");\nconst packageInfo_1 = require(\"../util/packageInfo\");\nconst config_loading_1 = require(\"./config/config-loading\");\nconst errors_1 = require(\"./errors\");\nconst errors_list_1 = require(\"./errors-list\");\nconst construction_1 = require(\"./providers/construction\");\nconst task_definitions_1 = require(\"./tasks/task-definitions\");\nconst task_profiling_1 = require(\"./task-profiling\");\nconst log = (0, debug_1.default)(\"hardhat:core:hre\");\nclass Environment {\n  /**\n   * Initializes the Hardhat Runtime Environment and the given\n   * extender functions.\n   *\n   * @remarks The extenders' execution order is given by the order\n   * of the requires in the hardhat's config file and its plugins.\n   *\n   * @param config The hardhat's config object.\n   * @param hardhatArguments The parsed hardhat's arguments.\n   * @param tasks A map of tasks.\n   * @param extenders A list of extenders.\n   */\n  constructor(config, hardhatArguments, tasks) {\n    var _this = this;\n    let extenders = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : [];\n    let experimentalHardhatNetworkMessageTraceHooks = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : [];\n    let userConfig = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : {};\n    this.config = config;\n    this.hardhatArguments = hardhatArguments;\n    this.tasks = tasks;\n    this.userConfig = userConfig;\n    this.version = (0, packageInfo_1.getHardhatVersion)();\n    /**\n     * Executes the task with the given name.\n     *\n     * @param name The task's name.\n     * @param taskArguments A map of task's arguments.\n     *\n     * @throws a HH303 if there aren't any defined tasks with the given name.\n     * @returns a promise with the task's execution result.\n     */\n    this.run = async function (name) {\n      let taskArguments = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      let callerTaskProfile = arguments.length > 2 ? arguments[2] : undefined;\n      const taskDefinition = _this.tasks[name];\n      log(\"Running task %s\", name);\n      if (taskDefinition === undefined) {\n        throw new errors_1.HardhatError(errors_list_1.ERRORS.ARGUMENTS.UNRECOGNIZED_TASK, {\n          task: name\n        });\n      }\n      const resolvedTaskArguments = _this._resolveValidTaskArguments(taskDefinition, taskArguments);\n      let taskProfile;\n      if (_this.hardhatArguments.flamegraph === true) {\n        taskProfile = (0, task_profiling_1.createTaskProfile)(name);\n        if (callerTaskProfile !== undefined) {\n          callerTaskProfile.children.push(taskProfile);\n        } else {\n          _this.entryTaskProfile = taskProfile;\n        }\n      }\n      try {\n        return await _this._runTaskDefinition(taskDefinition, resolvedTaskArguments, taskProfile);\n      } catch (e) {\n        (0, config_loading_1.analyzeModuleNotFoundError)(e, _this.config.paths.configFile);\n        // eslint-disable-next-line @nomiclabs/hardhat-internal-rules/only-hardhat-error\n        throw e;\n      } finally {\n        if (taskProfile !== undefined) {\n          (0, task_profiling_1.completeTaskProfile)(taskProfile);\n        }\n      }\n    };\n    log(\"Creating HardhatRuntimeEnvironment\");\n    const networkName = hardhatArguments.network !== undefined ? hardhatArguments.network : config.defaultNetwork;\n    const networkConfig = config.networks[networkName];\n    if (networkConfig === undefined) {\n      throw new errors_1.HardhatError(errors_list_1.ERRORS.NETWORK.CONFIG_NOT_FOUND, {\n        network: networkName\n      });\n    }\n    this.artifacts = new artifacts_1.Artifacts(config.paths.artifacts);\n    const provider = (0, lazy_1.lazyObject)(() => {\n      log(`Creating provider for network ${networkName}`);\n      return (0, construction_1.createProvider)(networkName, networkConfig, this.config.paths, this.artifacts, experimentalHardhatNetworkMessageTraceHooks.map(hook => (trace, isCallMessageTrace) => hook(this, trace, isCallMessageTrace)));\n    });\n    this.network = {\n      name: networkName,\n      config: config.networks[networkName],\n      provider\n    };\n    this._extenders = extenders;\n    extenders.forEach(extender => extender(this));\n  }\n  /**\n   * Injects the properties of `this` (the Hardhat Runtime Environment) into the global scope.\n   *\n   * @param blacklist a list of property names that won't be injected.\n   *\n   * @returns a function that restores the previous environment.\n   */\n  injectToGlobal() {\n    let blacklist = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : Environment._BLACKLISTED_PROPERTIES;\n    const globalAsAny = global;\n    const previousValues = {};\n    const previousHre = globalAsAny.hre;\n    globalAsAny.hre = this;\n    for (const [key, value] of Object.entries(this)) {\n      if (blacklist.includes(key)) {\n        continue;\n      }\n      previousValues[key] = globalAsAny[key];\n      globalAsAny[key] = value;\n    }\n    return () => {\n      for (const [key, _] of Object.entries(this)) {\n        if (blacklist.includes(key)) {\n          continue;\n        }\n        globalAsAny.hre = previousHre;\n        globalAsAny[key] = previousValues[key];\n      }\n    };\n  }\n  /**\n   * @param taskProfile Undefined if we aren't computing task profiles\n   * @private\n   */\n  async _runTaskDefinition(taskDefinition, taskArguments, taskProfile) {\n    var _this2 = this;\n    let runSuperFunction;\n    if (taskDefinition instanceof task_definitions_1.OverriddenTaskDefinition) {\n      runSuperFunction = async function () {\n        let _taskArguments = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : taskArguments;\n        log(\"Running %s's super\", taskDefinition.name);\n        if (taskProfile === undefined) {\n          return _this2._runTaskDefinition(taskDefinition.parentTaskDefinition, _taskArguments);\n        }\n        const parentTaskProfile = (0, task_profiling_1.createParentTaskProfile)(taskProfile);\n        taskProfile.children.push(parentTaskProfile);\n        try {\n          return await _this2._runTaskDefinition(taskDefinition.parentTaskDefinition, _taskArguments, parentTaskProfile);\n        } finally {\n          (0, task_profiling_1.completeTaskProfile)(parentTaskProfile);\n        }\n      };\n      runSuperFunction.isDefined = true;\n    } else {\n      runSuperFunction = async () => {\n        throw new errors_1.HardhatError(errors_list_1.ERRORS.TASK_DEFINITIONS.RUNSUPER_NOT_AVAILABLE, {\n          taskName: taskDefinition.name\n        });\n      };\n      runSuperFunction.isDefined = false;\n    }\n    const runSuper = runSuperFunction;\n    const globalAsAny = global;\n    const previousRunSuper = globalAsAny.runSuper;\n    globalAsAny.runSuper = runSuper;\n    let modifiedHreWithParentTaskProfile;\n    if (this.hardhatArguments.flamegraph === true) {\n      // We create a modified version of `this`, as we want to keep track of the\n      // `taskProfile` and use it as `callerTaskProfile` if the action calls\n      // `run`, and add a few utility methods.\n      //\n      // Note that for this to work we need to set the prototype later\n      modifiedHreWithParentTaskProfile = {\n        ...this,\n        run: (_name, _taskArguments) => this.run(_name, _taskArguments, taskProfile),\n        adhocProfile: async (_name, f) => {\n          const adhocProfile = (0, task_profiling_1.createTaskProfile)(_name);\n          taskProfile.children.push(adhocProfile);\n          try {\n            return await f();\n          } finally {\n            (0, task_profiling_1.completeTaskProfile)(adhocProfile);\n          }\n        },\n        adhocProfileSync: (_name, f) => {\n          const adhocProfile = (0, task_profiling_1.createTaskProfile)(_name);\n          taskProfile.children.push(adhocProfile);\n          try {\n            return f();\n          } finally {\n            (0, task_profiling_1.completeTaskProfile)(adhocProfile);\n          }\n        }\n      };\n      Object.setPrototypeOf(modifiedHreWithParentTaskProfile, Object.getPrototypeOf(this));\n    }\n    const uninjectFromGlobal = modifiedHreWithParentTaskProfile?.injectToGlobal() ?? this.injectToGlobal();\n    try {\n      return await taskDefinition.action(taskArguments, modifiedHreWithParentTaskProfile ?? this, runSuper);\n    } finally {\n      uninjectFromGlobal();\n      globalAsAny.runSuper = previousRunSuper;\n    }\n  }\n  /**\n   * Check that task arguments are within TaskDefinition defined params constraints.\n   * Also, populate missing, non-mandatory arguments with default param values (if any).\n   *\n   * @private\n   * @throws HardhatError if any of the following are true:\n   *  > a required argument is missing\n   *  > an argument's value's type doesn't match the defined param type\n   *\n   * @param taskDefinition\n   * @param taskArguments\n   * @returns resolvedTaskArguments\n   */\n  _resolveValidTaskArguments(taskDefinition, taskArguments) {\n    const {\n      paramDefinitions,\n      positionalParamDefinitions\n    } = taskDefinition;\n    const nonPositionalParamDefinitions = Object.values(paramDefinitions);\n    // gather all task param definitions\n    const allTaskParamDefinitions = [...nonPositionalParamDefinitions, ...positionalParamDefinitions];\n    const initResolvedArguments = {\n      errors: [],\n      values: {}\n    };\n    const resolvedArguments = allTaskParamDefinitions.reduce((_ref, paramDefinition) => {\n      let {\n        errors,\n        values\n      } = _ref;\n      try {\n        const paramName = paramDefinition.name;\n        const argumentValue = taskArguments[paramName];\n        const resolvedArgumentValue = this._resolveArgument(paramDefinition, argumentValue, taskDefinition.name);\n        if (resolvedArgumentValue !== undefined) {\n          values[paramName] = resolvedArgumentValue;\n        }\n      } catch (error) {\n        if (errors_1.HardhatError.isHardhatError(error)) {\n          errors.push(error);\n        }\n      }\n      return {\n        errors,\n        values\n      };\n    }, initResolvedArguments);\n    const {\n      errors: resolveErrors,\n      values: resolvedValues\n    } = resolvedArguments;\n    // if has argument errors, throw the first one\n    if (resolveErrors.length > 0) {\n      throw resolveErrors[0];\n    }\n    // append the rest of arguments that where not in the task param definitions\n    const resolvedTaskArguments = {\n      ...taskArguments,\n      ...resolvedValues\n    };\n    return resolvedTaskArguments;\n  }\n  /**\n   * Resolves an argument according to a ParamDefinition rules.\n   *\n   * @param paramDefinition\n   * @param argumentValue\n   * @private\n   */\n  _resolveArgument(paramDefinition, argumentValue, taskName) {\n    const {\n      name,\n      isOptional,\n      defaultValue\n    } = paramDefinition;\n    if (argumentValue === undefined) {\n      if (isOptional) {\n        // undefined & optional argument -> return defaultValue\n        return defaultValue;\n      }\n      // undefined & mandatory argument -> error\n      throw new errors_1.HardhatError(errors_list_1.ERRORS.ARGUMENTS.MISSING_TASK_ARGUMENT, {\n        param: name,\n        task: taskName\n      });\n    }\n    // arg was present -> validate type, if applicable\n    this._checkTypeValidation(paramDefinition, argumentValue);\n    return argumentValue;\n  }\n  /**\n   * Checks if value is valid for the specified param definition.\n   *\n   * @param paramDefinition {ParamDefinition} - the param definition for validation\n   * @param argumentValue - the value to be validated\n   * @private\n   * @throws HH301 if value is not valid for the param type\n   */\n  _checkTypeValidation(paramDefinition, argumentValue) {\n    const {\n      name: paramName,\n      type,\n      isVariadic\n    } = paramDefinition;\n    // in case of variadic param, argValue is an array and the type validation must pass for all values.\n    // otherwise, it's a single value that is to be validated\n    const argumentValueContainer = isVariadic ? argumentValue : [argumentValue];\n    for (const value of argumentValueContainer) {\n      type.validate(paramName, value);\n    }\n  }\n}\nexports.Environment = Environment;\nEnvironment._BLACKLISTED_PROPERTIES = [\"injectToGlobal\", \"entryTaskProfile\", \"_runTaskDefinition\", \"_extenders\"];","map":{"version":3,"mappings":"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","names":["log","Environment","constructor","config","hardhatArguments","tasks","extenders","experimentalHardhatNetworkMessageTraceHooks","userConfig","name","taskArguments","callerTaskProfile","taskDefinition","undefined","errors_1","errors_list_1","ARGUMENTS","UNRECOGNIZED_TASK","task","resolvedTaskArguments","_resolveValidTaskArguments","taskProfile","flamegraph","children","push","entryTaskProfile","_runTaskDefinition","e","paths","configFile","networkName","network","defaultNetwork","networkConfig","networks","NETWORK","CONFIG_NOT_FOUND","artifacts","artifacts_1","provider","map","hook","trace","isCallMessageTrace","_extenders","forEach","extender","injectToGlobal","blacklist","_BLACKLISTED_PROPERTIES","globalAsAny","global","previousValues","previousHre","hre","key","value","Object","entries","includes","_","runSuperFunction","task_definitions_1","_taskArguments","parentTaskDefinition","parentTaskProfile","isDefined","TASK_DEFINITIONS","RUNSUPER_NOT_AVAILABLE","taskName","runSuper","previousRunSuper","modifiedHreWithParentTaskProfile","run","_name","adhocProfile","f","adhocProfileSync","setPrototypeOf","getPrototypeOf","uninjectFromGlobal","action","paramDefinitions","positionalParamDefinitions","nonPositionalParamDefinitions","values","allTaskParamDefinitions","initResolvedArguments","errors","resolvedArguments","reduce","paramDefinition","paramName","argumentValue","resolvedArgumentValue","_resolveArgument","error","isHardhatError","resolveErrors","resolvedValues","length","isOptional","defaultValue","MISSING_TASK_ARGUMENT","param","_checkTypeValidation","type","isVariadic","argumentValueContainer","validate","exports"],"sources":["/Users/janrobel/Documents/PersonalProjekty/nftGenerateAi/clientAndContract/node_modules/hardhat/src/internal/core/runtime-environment.ts"],"sourcesContent":["import debug from \"debug\";\n\nimport {\n  Artifacts as IArtifacts,\n  EnvironmentExtender,\n  ExperimentalHardhatNetworkMessageTraceHook,\n  HardhatArguments,\n  HardhatConfig,\n  HardhatRuntimeEnvironment,\n  HardhatUserConfig,\n  Network,\n  ParamDefinition,\n  RunSuperFunction,\n  RunTaskFunction,\n  TaskArguments,\n  TaskDefinition,\n  TasksMap,\n} from \"../../types\";\nimport { Artifacts } from \"../artifacts\";\nimport { MessageTrace } from \"../hardhat-network/stack-traces/message-trace\";\nimport { lazyObject } from \"../util/lazy\";\n\nimport { getHardhatVersion } from \"../util/packageInfo\";\nimport { analyzeModuleNotFoundError } from \"./config/config-loading\";\nimport { HardhatError } from \"./errors\";\nimport { ERRORS } from \"./errors-list\";\nimport { createProvider } from \"./providers/construction\";\nimport { OverriddenTaskDefinition } from \"./tasks/task-definitions\";\nimport {\n  completeTaskProfile,\n  createParentTaskProfile,\n  createTaskProfile,\n  TaskProfile,\n} from \"./task-profiling\";\n\nconst log = debug(\"hardhat:core:hre\");\n\nexport class Environment implements HardhatRuntimeEnvironment {\n  private static readonly _BLACKLISTED_PROPERTIES: string[] = [\n    \"injectToGlobal\",\n    \"entryTaskProfile\",\n    \"_runTaskDefinition\",\n    \"_extenders\",\n  ];\n\n  public network: Network;\n\n  public artifacts: IArtifacts;\n\n  private readonly _extenders: EnvironmentExtender[];\n\n  public entryTaskProfile?: TaskProfile;\n\n  public version: string = getHardhatVersion();\n\n  /**\n   * Initializes the Hardhat Runtime Environment and the given\n   * extender functions.\n   *\n   * @remarks The extenders' execution order is given by the order\n   * of the requires in the hardhat's config file and its plugins.\n   *\n   * @param config The hardhat's config object.\n   * @param hardhatArguments The parsed hardhat's arguments.\n   * @param tasks A map of tasks.\n   * @param extenders A list of extenders.\n   */\n  constructor(\n    public readonly config: HardhatConfig,\n    public readonly hardhatArguments: HardhatArguments,\n    public readonly tasks: TasksMap,\n    extenders: EnvironmentExtender[] = [],\n    experimentalHardhatNetworkMessageTraceHooks: ExperimentalHardhatNetworkMessageTraceHook[] = [],\n    public readonly userConfig: HardhatUserConfig = {}\n  ) {\n    log(\"Creating HardhatRuntimeEnvironment\");\n\n    const networkName =\n      hardhatArguments.network !== undefined\n        ? hardhatArguments.network\n        : config.defaultNetwork;\n\n    const networkConfig = config.networks[networkName];\n\n    if (networkConfig === undefined) {\n      throw new HardhatError(ERRORS.NETWORK.CONFIG_NOT_FOUND, {\n        network: networkName,\n      });\n    }\n\n    this.artifacts = new Artifacts(config.paths.artifacts);\n\n    const provider = lazyObject(() => {\n      log(`Creating provider for network ${networkName}`);\n      return createProvider(\n        networkName,\n        networkConfig,\n        this.config.paths,\n        this.artifacts,\n        experimentalHardhatNetworkMessageTraceHooks.map(\n          (hook) => (trace: MessageTrace, isCallMessageTrace: boolean) =>\n            hook(this, trace, isCallMessageTrace)\n        )\n      );\n    });\n\n    this.network = {\n      name: networkName,\n      config: config.networks[networkName],\n      provider,\n    };\n\n    this._extenders = extenders;\n\n    extenders.forEach((extender) => extender(this));\n  }\n\n  /**\n   * Executes the task with the given name.\n   *\n   * @param name The task's name.\n   * @param taskArguments A map of task's arguments.\n   *\n   * @throws a HH303 if there aren't any defined tasks with the given name.\n   * @returns a promise with the task's execution result.\n   */\n  public readonly run: RunTaskFunction = async (\n    name,\n    taskArguments = {},\n    callerTaskProfile?: TaskProfile\n  ) => {\n    const taskDefinition = this.tasks[name];\n\n    log(\"Running task %s\", name);\n\n    if (taskDefinition === undefined) {\n      throw new HardhatError(ERRORS.ARGUMENTS.UNRECOGNIZED_TASK, {\n        task: name,\n      });\n    }\n\n    const resolvedTaskArguments = this._resolveValidTaskArguments(\n      taskDefinition,\n      taskArguments\n    );\n\n    let taskProfile: TaskProfile | undefined;\n    if (this.hardhatArguments.flamegraph === true) {\n      taskProfile = createTaskProfile(name);\n\n      if (callerTaskProfile !== undefined) {\n        callerTaskProfile.children.push(taskProfile);\n      } else {\n        this.entryTaskProfile = taskProfile;\n      }\n    }\n\n    try {\n      return await this._runTaskDefinition(\n        taskDefinition,\n        resolvedTaskArguments,\n        taskProfile\n      );\n    } catch (e) {\n      analyzeModuleNotFoundError(e, this.config.paths.configFile);\n\n      // eslint-disable-next-line @nomiclabs/hardhat-internal-rules/only-hardhat-error\n      throw e;\n    } finally {\n      if (taskProfile !== undefined) {\n        completeTaskProfile(taskProfile);\n      }\n    }\n  };\n\n  /**\n   * Injects the properties of `this` (the Hardhat Runtime Environment) into the global scope.\n   *\n   * @param blacklist a list of property names that won't be injected.\n   *\n   * @returns a function that restores the previous environment.\n   */\n  public injectToGlobal(\n    blacklist: string[] = Environment._BLACKLISTED_PROPERTIES\n  ): () => void {\n    const globalAsAny = global as any;\n\n    const previousValues: { [name: string]: any } = {};\n    const previousHre = globalAsAny.hre;\n\n    globalAsAny.hre = this;\n\n    for (const [key, value] of Object.entries(this)) {\n      if (blacklist.includes(key)) {\n        continue;\n      }\n\n      previousValues[key] = globalAsAny[key];\n      globalAsAny[key] = value;\n    }\n\n    return () => {\n      for (const [key, _] of Object.entries(this)) {\n        if (blacklist.includes(key)) {\n          continue;\n        }\n\n        globalAsAny.hre = previousHre;\n        globalAsAny[key] = previousValues[key];\n      }\n    };\n  }\n\n  /**\n   * @param taskProfile Undefined if we aren't computing task profiles\n   * @private\n   */\n  private async _runTaskDefinition(\n    taskDefinition: TaskDefinition,\n    taskArguments: TaskArguments,\n    taskProfile?: TaskProfile\n  ): Promise<any> {\n    let runSuperFunction: any;\n\n    if (taskDefinition instanceof OverriddenTaskDefinition) {\n      runSuperFunction = async (\n        _taskArguments: TaskArguments = taskArguments\n      ) => {\n        log(\"Running %s's super\", taskDefinition.name);\n\n        if (taskProfile === undefined) {\n          return this._runTaskDefinition(\n            taskDefinition.parentTaskDefinition,\n            _taskArguments\n          );\n        }\n\n        const parentTaskProfile = createParentTaskProfile(taskProfile);\n        taskProfile.children.push(parentTaskProfile);\n\n        try {\n          return await this._runTaskDefinition(\n            taskDefinition.parentTaskDefinition,\n            _taskArguments,\n            parentTaskProfile\n          );\n        } finally {\n          completeTaskProfile(parentTaskProfile);\n        }\n      };\n\n      runSuperFunction.isDefined = true;\n    } else {\n      runSuperFunction = async () => {\n        throw new HardhatError(ERRORS.TASK_DEFINITIONS.RUNSUPER_NOT_AVAILABLE, {\n          taskName: taskDefinition.name,\n        });\n      };\n\n      runSuperFunction.isDefined = false;\n    }\n\n    const runSuper: RunSuperFunction<TaskArguments> = runSuperFunction;\n\n    const globalAsAny = global as any;\n    const previousRunSuper: any = globalAsAny.runSuper;\n    globalAsAny.runSuper = runSuper;\n\n    let modifiedHreWithParentTaskProfile: any | undefined;\n    if (this.hardhatArguments.flamegraph === true) {\n      // We create a modified version of `this`, as we want to keep track of the\n      // `taskProfile` and use it as `callerTaskProfile` if the action calls\n      // `run`, and add a few utility methods.\n      //\n      // Note that for this to work we need to set the prototype later\n      modifiedHreWithParentTaskProfile = {\n        ...this,\n        run: (_name: string, _taskArguments: TaskArguments) =>\n          (this as any).run(_name, _taskArguments, taskProfile),\n        adhocProfile: async (_name: string, f: () => Promise<any>) => {\n          const adhocProfile = createTaskProfile(_name);\n          taskProfile!.children.push(adhocProfile);\n          try {\n            return await f();\n          } finally {\n            completeTaskProfile(adhocProfile);\n          }\n        },\n        adhocProfileSync: (_name: string, f: () => any) => {\n          const adhocProfile = createTaskProfile(_name);\n          taskProfile!.children.push(adhocProfile);\n          try {\n            return f();\n          } finally {\n            completeTaskProfile(adhocProfile);\n          }\n        },\n      };\n\n      Object.setPrototypeOf(\n        modifiedHreWithParentTaskProfile,\n        Object.getPrototypeOf(this)\n      );\n    }\n\n    const uninjectFromGlobal =\n      modifiedHreWithParentTaskProfile?.injectToGlobal() ??\n      this.injectToGlobal();\n\n    try {\n      return await taskDefinition.action(\n        taskArguments,\n        modifiedHreWithParentTaskProfile ?? this,\n        runSuper\n      );\n    } finally {\n      uninjectFromGlobal();\n      globalAsAny.runSuper = previousRunSuper;\n    }\n  }\n\n  /**\n   * Check that task arguments are within TaskDefinition defined params constraints.\n   * Also, populate missing, non-mandatory arguments with default param values (if any).\n   *\n   * @private\n   * @throws HardhatError if any of the following are true:\n   *  > a required argument is missing\n   *  > an argument's value's type doesn't match the defined param type\n   *\n   * @param taskDefinition\n   * @param taskArguments\n   * @returns resolvedTaskArguments\n   */\n  private _resolveValidTaskArguments(\n    taskDefinition: TaskDefinition,\n    taskArguments: TaskArguments\n  ): TaskArguments {\n    const { paramDefinitions, positionalParamDefinitions } = taskDefinition;\n\n    const nonPositionalParamDefinitions = Object.values(paramDefinitions);\n\n    // gather all task param definitions\n    const allTaskParamDefinitions = [\n      ...nonPositionalParamDefinitions,\n      ...positionalParamDefinitions,\n    ];\n\n    const initResolvedArguments: {\n      errors: HardhatError[];\n      values: TaskArguments;\n    } = { errors: [], values: {} };\n\n    const resolvedArguments = allTaskParamDefinitions.reduce(\n      ({ errors, values }, paramDefinition) => {\n        try {\n          const paramName = paramDefinition.name;\n          const argumentValue = taskArguments[paramName];\n          const resolvedArgumentValue = this._resolveArgument(\n            paramDefinition,\n            argumentValue,\n            taskDefinition.name\n          );\n          if (resolvedArgumentValue !== undefined) {\n            values[paramName] = resolvedArgumentValue;\n          }\n        } catch (error) {\n          if (HardhatError.isHardhatError(error)) {\n            errors.push(error);\n          }\n        }\n        return { errors, values };\n      },\n      initResolvedArguments\n    );\n\n    const { errors: resolveErrors, values: resolvedValues } = resolvedArguments;\n\n    // if has argument errors, throw the first one\n    if (resolveErrors.length > 0) {\n      throw resolveErrors[0];\n    }\n\n    // append the rest of arguments that where not in the task param definitions\n    const resolvedTaskArguments = { ...taskArguments, ...resolvedValues };\n\n    return resolvedTaskArguments;\n  }\n\n  /**\n   * Resolves an argument according to a ParamDefinition rules.\n   *\n   * @param paramDefinition\n   * @param argumentValue\n   * @private\n   */\n  private _resolveArgument(\n    paramDefinition: ParamDefinition<any>,\n    argumentValue: any,\n    taskName: string\n  ) {\n    const { name, isOptional, defaultValue } = paramDefinition;\n\n    if (argumentValue === undefined) {\n      if (isOptional) {\n        // undefined & optional argument -> return defaultValue\n        return defaultValue;\n      }\n\n      // undefined & mandatory argument -> error\n      throw new HardhatError(ERRORS.ARGUMENTS.MISSING_TASK_ARGUMENT, {\n        param: name,\n        task: taskName,\n      });\n    }\n\n    // arg was present -> validate type, if applicable\n    this._checkTypeValidation(paramDefinition, argumentValue);\n\n    return argumentValue;\n  }\n\n  /**\n   * Checks if value is valid for the specified param definition.\n   *\n   * @param paramDefinition {ParamDefinition} - the param definition for validation\n   * @param argumentValue - the value to be validated\n   * @private\n   * @throws HH301 if value is not valid for the param type\n   */\n  private _checkTypeValidation(\n    paramDefinition: ParamDefinition<any>,\n    argumentValue: any\n  ) {\n    const { name: paramName, type, isVariadic } = paramDefinition;\n\n    // in case of variadic param, argValue is an array and the type validation must pass for all values.\n    // otherwise, it's a single value that is to be validated\n    const argumentValueContainer = isVariadic ? argumentValue : [argumentValue];\n\n    for (const value of argumentValueContainer) {\n      type.validate(paramName, value);\n    }\n  }\n}\n"]},"metadata":{},"sourceType":"script","externalDependencies":[]}