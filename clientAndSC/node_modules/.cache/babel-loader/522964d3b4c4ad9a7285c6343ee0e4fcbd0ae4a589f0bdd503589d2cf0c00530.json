{"ast":null,"code":"\"use strict\";\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.mergeCompilationJobsWithoutBug = exports.mergeCompilationJobsWithBug = exports.createCompilationJobFromFile = exports.createCompilationJobsFromConnectedComponent = exports.CompilationJob = void 0;\nconst debug_1 = __importDefault(require(\"debug\"));\nconst semver_1 = __importDefault(require(\"semver\"));\nconst builtin_tasks_1 = require(\"../../types/builtin-tasks\");\nconst errors_1 = require(\"../core/errors\");\nconst log = (0, debug_1.default)(\"hardhat:core:compilation-job\");\n// this should have a proper version range when it's fixed\nconst SOLC_BUG_9573_VERSIONS = \"<0.8.0\";\nfunction isCompilationJobCreationError(x) {\n  return \"reason\" in x;\n}\nclass CompilationJob {\n  constructor(solidityConfig) {\n    this.solidityConfig = solidityConfig;\n    this._filesToCompile = new Map();\n  }\n  addFileToCompile(file, emitsArtifacts) {\n    const fileToCompile = this._filesToCompile.get(file.sourceName);\n    // if the file doesn't exist, we add it\n    // we also add it if emitsArtifacts is true, to override it in case it was\n    // previously added but with a false emitsArtifacts\n    if (fileToCompile === undefined || emitsArtifacts) {\n      this._filesToCompile.set(file.sourceName, {\n        file,\n        emitsArtifacts\n      });\n    }\n  }\n  hasSolc9573Bug() {\n    return this.solidityConfig?.settings?.optimizer?.enabled === true && semver_1.default.satisfies(this.solidityConfig.version, SOLC_BUG_9573_VERSIONS);\n  }\n  merge(job) {\n    const isEqual = require(\"lodash/isEqual\");\n    (0, errors_1.assertHardhatInvariant)(isEqual(this.solidityConfig, job.getSolcConfig()), \"Merging jobs with different solidity configurations\");\n    const mergedJobs = new CompilationJob(job.getSolcConfig());\n    for (const file of this.getResolvedFiles()) {\n      mergedJobs.addFileToCompile(file, this.emitsArtifacts(file));\n    }\n    for (const file of job.getResolvedFiles()) {\n      mergedJobs.addFileToCompile(file, job.emitsArtifacts(file));\n    }\n    return mergedJobs;\n  }\n  getSolcConfig() {\n    return this.solidityConfig;\n  }\n  isEmpty() {\n    return this._filesToCompile.size === 0;\n  }\n  getResolvedFiles() {\n    return [...this._filesToCompile.values()].map(x => x.file);\n  }\n  /**\n   * Check if the given file emits artifacts.\n   *\n   * If no file is given, check if *some* file in the job emits artifacts.\n   */\n  emitsArtifacts(file) {\n    const fileToCompile = this._filesToCompile.get(file.sourceName);\n    (0, errors_1.assertHardhatInvariant)(fileToCompile !== undefined, `File '${file.sourceName}' does not exist in this compilation job`);\n    return fileToCompile.emitsArtifacts;\n  }\n}\nexports.CompilationJob = CompilationJob;\nfunction mergeCompilationJobs(jobs, isMergeable) {\n  const jobsMap = new Map();\n  for (const job of jobs) {\n    const mergedJobs = jobsMap.get(job.getSolcConfig());\n    if (isMergeable(job)) {\n      if (mergedJobs === undefined) {\n        jobsMap.set(job.getSolcConfig(), [job]);\n      } else if (mergedJobs.length === 1) {\n        const newJob = mergedJobs[0].merge(job);\n        jobsMap.set(job.getSolcConfig(), [newJob]);\n      } else {\n        (0, errors_1.assertHardhatInvariant)(false, \"More than one mergeable job was added for the same configuration\");\n      }\n    } else {\n      if (mergedJobs === undefined) {\n        jobsMap.set(job.getSolcConfig(), [job]);\n      } else {\n        jobsMap.set(job.getSolcConfig(), [...mergedJobs, job]);\n      }\n    }\n  }\n  // Array#flat This method defaults to depth limit 1\n  return [...jobsMap.values()].flat(1000000);\n}\n/**\n * Creates a list of compilation jobs from a dependency graph. *This function\n * assumes that the given graph is a connected component*.\n * Returns the list of compilation jobs on success, and a list of\n * non-compilable files on failure.\n */\nasync function createCompilationJobsFromConnectedComponent(connectedComponent, getFromFile) {\n  const compilationJobs = [];\n  const errors = [];\n  for (const file of connectedComponent.getResolvedFiles()) {\n    const compilationJobOrError = await getFromFile(file);\n    if (isCompilationJobCreationError(compilationJobOrError)) {\n      log(`'${file.absolutePath}' couldn't be compiled. Reason: '${compilationJobOrError}'`);\n      errors.push(compilationJobOrError);\n      continue;\n    }\n    compilationJobs.push(compilationJobOrError);\n  }\n  const jobs = mergeCompilationJobsWithBug(compilationJobs);\n  return {\n    jobs,\n    errors\n  };\n}\nexports.createCompilationJobsFromConnectedComponent = createCompilationJobsFromConnectedComponent;\nasync function createCompilationJobFromFile(dependencyGraph, file, solidityConfig) {\n  const directDependencies = dependencyGraph.getDependencies(file);\n  const transitiveDependencies = dependencyGraph.getTransitiveDependencies(file);\n  const compilerConfig = getCompilerConfigForFile(file, directDependencies, transitiveDependencies, solidityConfig);\n  // if the config cannot be obtained, we just return the failure\n  if (isCompilationJobCreationError(compilerConfig)) {\n    return compilerConfig;\n  }\n  log(`File '${file.absolutePath}' will be compiled with version '${compilerConfig.version}'`);\n  const compilationJob = new CompilationJob(compilerConfig);\n  compilationJob.addFileToCompile(file, true);\n  for (const {\n    dependency\n  } of transitiveDependencies) {\n    log(`File '${dependency.absolutePath}' added as dependency of '${file.absolutePath}'`);\n    compilationJob.addFileToCompile(dependency, false);\n  }\n  return compilationJob;\n}\nexports.createCompilationJobFromFile = createCompilationJobFromFile;\n/**\n * Merge compilation jobs affected by the solc #9573 bug\n */\nfunction mergeCompilationJobsWithBug(compilationJobs) {\n  return mergeCompilationJobs(compilationJobs, job => job.hasSolc9573Bug());\n}\nexports.mergeCompilationJobsWithBug = mergeCompilationJobsWithBug;\n/**\n * Merge compilation jobs not affected by the solc #9573 bug\n */\nfunction mergeCompilationJobsWithoutBug(compilationJobs) {\n  return mergeCompilationJobs(compilationJobs, job => !job.hasSolc9573Bug());\n}\nexports.mergeCompilationJobsWithoutBug = mergeCompilationJobsWithoutBug;\n/**\n * Return the compiler config with the newest version that satisfies the given\n * version ranges, or a value indicating why the compiler couldn't be obtained.\n */\nfunction getCompilerConfigForFile(file, directDependencies, transitiveDependencies, solidityConfig) {\n  const transitiveDependenciesVersionPragmas = transitiveDependencies.map(_ref => {\n    let {\n      dependency\n    } = _ref;\n    return dependency.content.versionPragmas;\n  });\n  const versionRange = Array.from(new Set([...file.content.versionPragmas, ...transitiveDependenciesVersionPragmas])).join(\" \");\n  const overrides = solidityConfig.overrides ?? {};\n  const overriddenCompiler = overrides[file.sourceName];\n  // if there's an override, we only check that\n  if (overriddenCompiler !== undefined) {\n    if (!semver_1.default.satisfies(overriddenCompiler.version, versionRange)) {\n      return getCompilationJobCreationError(file, directDependencies, transitiveDependencies, [overriddenCompiler.version], true);\n    }\n    return overriddenCompiler;\n  }\n  // if there's no override, we find a compiler that matches the version range\n  const compilerVersions = solidityConfig.compilers.map(x => x.version);\n  const matchingVersion = semver_1.default.maxSatisfying(compilerVersions, versionRange);\n  if (matchingVersion === null) {\n    return getCompilationJobCreationError(file, directDependencies, transitiveDependencies, compilerVersions, false);\n  }\n  const matchingConfig = solidityConfig.compilers.find(x => x.version === matchingVersion);\n  return matchingConfig;\n}\nfunction getCompilationJobCreationError(file, directDependencies, transitiveDependencies, compilerVersions, overriden) {\n  const fileVersionRange = file.content.versionPragmas.join(\" \");\n  if (semver_1.default.maxSatisfying(compilerVersions, fileVersionRange) === null) {\n    const reason = overriden ? builtin_tasks_1.CompilationJobCreationErrorReason.INCOMPATIBLE_OVERRIDEN_SOLC_VERSION : builtin_tasks_1.CompilationJobCreationErrorReason.NO_COMPATIBLE_SOLC_VERSION_FOUND;\n    return {\n      reason,\n      file\n    };\n  }\n  const incompatibleDirectImports = [];\n  for (const dependency of directDependencies) {\n    const dependencyVersionRange = dependency.content.versionPragmas.join(\" \");\n    if (!semver_1.default.intersects(fileVersionRange, dependencyVersionRange)) {\n      incompatibleDirectImports.push(dependency);\n    }\n  }\n  if (incompatibleDirectImports.length > 0) {\n    return {\n      reason: builtin_tasks_1.CompilationJobCreationErrorReason.DIRECTLY_IMPORTS_INCOMPATIBLE_FILE,\n      file,\n      extra: {\n        incompatibleDirectImports\n      }\n    };\n  }\n  const incompatibleIndirectImports = [];\n  for (const transitiveDependency of transitiveDependencies) {\n    const {\n      dependency\n    } = transitiveDependency;\n    const dependencyVersionRange = dependency.content.versionPragmas.join(\" \");\n    if (!semver_1.default.intersects(fileVersionRange, dependencyVersionRange)) {\n      incompatibleIndirectImports.push(transitiveDependency);\n    }\n  }\n  if (incompatibleIndirectImports.length > 0) {\n    return {\n      reason: builtin_tasks_1.CompilationJobCreationErrorReason.INDIRECTLY_IMPORTS_INCOMPATIBLE_FILE,\n      file,\n      extra: {\n        incompatibleIndirectImports\n      }\n    };\n  }\n  return {\n    reason: builtin_tasks_1.CompilationJobCreationErrorReason.OTHER_ERROR,\n    file\n  };\n}","map":{"version":3,"mappings":"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","names":["log","SOLC_BUG_9573_VERSIONS","isCompilationJobCreationError","x","CompilationJob","constructor","solidityConfig","Map","addFileToCompile","file","emitsArtifacts","fileToCompile","_filesToCompile","get","sourceName","undefined","set","hasSolc9573Bug","settings","optimizer","enabled","semver_1","satisfies","version","merge","job","isEqual","require","getSolcConfig","mergedJobs","getResolvedFiles","isEmpty","size","values","map","exports","mergeCompilationJobs","jobs","isMergeable","jobsMap","length","newJob","flat","createCompilationJobsFromConnectedComponent","connectedComponent","getFromFile","compilationJobs","errors","compilationJobOrError","absolutePath","push","mergeCompilationJobsWithBug","createCompilationJobFromFile","dependencyGraph","directDependencies","getDependencies","transitiveDependencies","getTransitiveDependencies","compilerConfig","getCompilerConfigForFile","compilationJob","dependency","mergeCompilationJobsWithoutBug","transitiveDependenciesVersionPragmas","content","versionPragmas","versionRange","Array","from","Set","join","overrides","overriddenCompiler","getCompilationJobCreationError","compilerVersions","compilers","matchingVersion","maxSatisfying","matchingConfig","find","overriden","fileVersionRange","reason","builtin_tasks_1","INCOMPATIBLE_OVERRIDEN_SOLC_VERSION","NO_COMPATIBLE_SOLC_VERSION_FOUND","incompatibleDirectImports","dependencyVersionRange","intersects","DIRECTLY_IMPORTS_INCOMPATIBLE_FILE","extra","incompatibleIndirectImports","transitiveDependency","INDIRECTLY_IMPORTS_INCOMPATIBLE_FILE","OTHER_ERROR"],"sources":["/Users/janrobel/Documents/PersonalProjekty/nftGenerateAi/clientAndContract/node_modules/hardhat/src/internal/solidity/compilation-job.ts"],"sourcesContent":["import type { LoDashStatic } from \"lodash\";\n\nimport debug from \"debug\";\nimport semver from \"semver\";\n\nimport { SolcConfig, SolidityConfig } from \"../../types\";\nimport * as taskTypes from \"../../types/builtin-tasks\";\nimport {\n  CompilationJobCreationError,\n  CompilationJobCreationErrorReason,\n  CompilationJobsCreationResult,\n} from \"../../types/builtin-tasks\";\nimport { assertHardhatInvariant } from \"../core/errors\";\n\nimport { ResolvedFile } from \"./resolver\";\n\nconst log = debug(\"hardhat:core:compilation-job\");\n\n// this should have a proper version range when it's fixed\nconst SOLC_BUG_9573_VERSIONS = \"<0.8.0\";\n\nfunction isCompilationJobCreationError(\n  x:\n    | taskTypes.CompilationJob\n    | taskTypes.CompilationJobCreationError\n    | SolcConfig\n): x is CompilationJobCreationError {\n  return \"reason\" in x;\n}\n\nexport class CompilationJob implements taskTypes.CompilationJob {\n  private _filesToCompile: Map<\n    string,\n    { file: ResolvedFile; emitsArtifacts: boolean }\n  > = new Map();\n\n  constructor(public solidityConfig: SolcConfig) {}\n\n  public addFileToCompile(file: ResolvedFile, emitsArtifacts: boolean) {\n    const fileToCompile = this._filesToCompile.get(file.sourceName);\n\n    // if the file doesn't exist, we add it\n    // we also add it if emitsArtifacts is true, to override it in case it was\n    // previously added but with a false emitsArtifacts\n    if (fileToCompile === undefined || emitsArtifacts) {\n      this._filesToCompile.set(file.sourceName, { file, emitsArtifacts });\n    }\n  }\n\n  public hasSolc9573Bug(): boolean {\n    return (\n      this.solidityConfig?.settings?.optimizer?.enabled === true &&\n      semver.satisfies(this.solidityConfig.version, SOLC_BUG_9573_VERSIONS)\n    );\n  }\n\n  public merge(job: taskTypes.CompilationJob): CompilationJob {\n    const isEqual = require(\"lodash/isEqual\") as LoDashStatic[\"isEqual\"];\n\n    assertHardhatInvariant(\n      isEqual(this.solidityConfig, job.getSolcConfig()),\n      \"Merging jobs with different solidity configurations\"\n    );\n    const mergedJobs = new CompilationJob(job.getSolcConfig());\n    for (const file of this.getResolvedFiles()) {\n      mergedJobs.addFileToCompile(file, this.emitsArtifacts(file));\n    }\n    for (const file of job.getResolvedFiles()) {\n      mergedJobs.addFileToCompile(file, job.emitsArtifacts(file));\n    }\n    return mergedJobs;\n  }\n\n  public getSolcConfig(): SolcConfig {\n    return this.solidityConfig;\n  }\n\n  public isEmpty() {\n    return this._filesToCompile.size === 0;\n  }\n\n  public getResolvedFiles(): ResolvedFile[] {\n    return [...this._filesToCompile.values()].map((x) => x.file);\n  }\n\n  /**\n   * Check if the given file emits artifacts.\n   *\n   * If no file is given, check if *some* file in the job emits artifacts.\n   */\n  public emitsArtifacts(file: ResolvedFile): boolean {\n    const fileToCompile = this._filesToCompile.get(file.sourceName);\n\n    assertHardhatInvariant(\n      fileToCompile !== undefined,\n      `File '${file.sourceName}' does not exist in this compilation job`\n    );\n\n    return fileToCompile.emitsArtifacts;\n  }\n}\n\nfunction mergeCompilationJobs(\n  jobs: taskTypes.CompilationJob[],\n  isMergeable: (job: taskTypes.CompilationJob) => boolean\n): taskTypes.CompilationJob[] {\n  const jobsMap: Map<SolcConfig, taskTypes.CompilationJob[]> = new Map();\n\n  for (const job of jobs) {\n    const mergedJobs = jobsMap.get(job.getSolcConfig());\n    if (isMergeable(job)) {\n      if (mergedJobs === undefined) {\n        jobsMap.set(job.getSolcConfig(), [job]);\n      } else if (mergedJobs.length === 1) {\n        const newJob = mergedJobs[0].merge(job);\n        jobsMap.set(job.getSolcConfig(), [newJob]);\n      } else {\n        assertHardhatInvariant(\n          false,\n          \"More than one mergeable job was added for the same configuration\"\n        );\n      }\n    } else {\n      if (mergedJobs === undefined) {\n        jobsMap.set(job.getSolcConfig(), [job]);\n      } else {\n        jobsMap.set(job.getSolcConfig(), [...mergedJobs, job]);\n      }\n    }\n  }\n\n  // Array#flat This method defaults to depth limit 1\n  return [...jobsMap.values()].flat(1_000_000);\n}\n\n/**\n * Creates a list of compilation jobs from a dependency graph. *This function\n * assumes that the given graph is a connected component*.\n * Returns the list of compilation jobs on success, and a list of\n * non-compilable files on failure.\n */\nexport async function createCompilationJobsFromConnectedComponent(\n  connectedComponent: taskTypes.DependencyGraph,\n  getFromFile: (\n    file: ResolvedFile\n  ) => Promise<taskTypes.CompilationJob | CompilationJobCreationError>\n): Promise<CompilationJobsCreationResult> {\n  const compilationJobs: taskTypes.CompilationJob[] = [];\n  const errors: CompilationJobCreationError[] = [];\n\n  for (const file of connectedComponent.getResolvedFiles()) {\n    const compilationJobOrError = await getFromFile(file);\n\n    if (isCompilationJobCreationError(compilationJobOrError)) {\n      log(\n        `'${file.absolutePath}' couldn't be compiled. Reason: '${\n          compilationJobOrError as any\n        }'`\n      );\n      errors.push(compilationJobOrError);\n      continue;\n    }\n\n    compilationJobs.push(compilationJobOrError);\n  }\n\n  const jobs = mergeCompilationJobsWithBug(compilationJobs);\n\n  return { jobs, errors };\n}\n\nexport async function createCompilationJobFromFile(\n  dependencyGraph: taskTypes.DependencyGraph,\n  file: ResolvedFile,\n  solidityConfig: SolidityConfig\n): Promise<CompilationJob | CompilationJobCreationError> {\n  const directDependencies = dependencyGraph.getDependencies(file);\n  const transitiveDependencies =\n    dependencyGraph.getTransitiveDependencies(file);\n\n  const compilerConfig = getCompilerConfigForFile(\n    file,\n    directDependencies,\n    transitiveDependencies,\n    solidityConfig\n  );\n\n  // if the config cannot be obtained, we just return the failure\n  if (isCompilationJobCreationError(compilerConfig)) {\n    return compilerConfig;\n  }\n  log(\n    `File '${file.absolutePath}' will be compiled with version '${compilerConfig.version}'`\n  );\n\n  const compilationJob = new CompilationJob(compilerConfig);\n\n  compilationJob.addFileToCompile(file, true);\n  for (const { dependency } of transitiveDependencies) {\n    log(\n      `File '${dependency.absolutePath}' added as dependency of '${file.absolutePath}'`\n    );\n    compilationJob.addFileToCompile(dependency, false);\n  }\n\n  return compilationJob;\n}\n\n/**\n * Merge compilation jobs affected by the solc #9573 bug\n */\nexport function mergeCompilationJobsWithBug(\n  compilationJobs: taskTypes.CompilationJob[]\n): taskTypes.CompilationJob[] {\n  return mergeCompilationJobs(compilationJobs, (job) => job.hasSolc9573Bug());\n}\n\n/**\n * Merge compilation jobs not affected by the solc #9573 bug\n */\nexport function mergeCompilationJobsWithoutBug(\n  compilationJobs: taskTypes.CompilationJob[]\n): taskTypes.CompilationJob[] {\n  return mergeCompilationJobs(compilationJobs, (job) => !job.hasSolc9573Bug());\n}\n\n/**\n * Return the compiler config with the newest version that satisfies the given\n * version ranges, or a value indicating why the compiler couldn't be obtained.\n */\nfunction getCompilerConfigForFile(\n  file: ResolvedFile,\n  directDependencies: ResolvedFile[],\n  transitiveDependencies: taskTypes.TransitiveDependency[],\n  solidityConfig: SolidityConfig\n): SolcConfig | CompilationJobCreationError {\n  const transitiveDependenciesVersionPragmas = transitiveDependencies.map(\n    ({ dependency }) => dependency.content.versionPragmas\n  );\n  const versionRange = Array.from(\n    new Set([\n      ...file.content.versionPragmas,\n      ...transitiveDependenciesVersionPragmas,\n    ])\n  ).join(\" \");\n\n  const overrides = solidityConfig.overrides ?? {};\n\n  const overriddenCompiler = overrides[file.sourceName];\n\n  // if there's an override, we only check that\n  if (overriddenCompiler !== undefined) {\n    if (!semver.satisfies(overriddenCompiler.version, versionRange)) {\n      return getCompilationJobCreationError(\n        file,\n        directDependencies,\n        transitiveDependencies,\n        [overriddenCompiler.version],\n        true\n      );\n    }\n\n    return overriddenCompiler;\n  }\n\n  // if there's no override, we find a compiler that matches the version range\n  const compilerVersions = solidityConfig.compilers.map((x) => x.version);\n  const matchingVersion = semver.maxSatisfying(compilerVersions, versionRange);\n\n  if (matchingVersion === null) {\n    return getCompilationJobCreationError(\n      file,\n      directDependencies,\n      transitiveDependencies,\n      compilerVersions,\n      false\n    );\n  }\n\n  const matchingConfig = solidityConfig.compilers.find(\n    (x) => x.version === matchingVersion\n  )!;\n\n  return matchingConfig;\n}\n\nfunction getCompilationJobCreationError(\n  file: ResolvedFile,\n  directDependencies: ResolvedFile[],\n  transitiveDependencies: taskTypes.TransitiveDependency[],\n  compilerVersions: string[],\n  overriden: boolean\n): CompilationJobCreationError {\n  const fileVersionRange = file.content.versionPragmas.join(\" \");\n  if (semver.maxSatisfying(compilerVersions, fileVersionRange) === null) {\n    const reason = overriden\n      ? CompilationJobCreationErrorReason.INCOMPATIBLE_OVERRIDEN_SOLC_VERSION\n      : CompilationJobCreationErrorReason.NO_COMPATIBLE_SOLC_VERSION_FOUND;\n    return { reason, file };\n  }\n\n  const incompatibleDirectImports: ResolvedFile[] = [];\n  for (const dependency of directDependencies) {\n    const dependencyVersionRange = dependency.content.versionPragmas.join(\" \");\n    if (!semver.intersects(fileVersionRange, dependencyVersionRange)) {\n      incompatibleDirectImports.push(dependency);\n    }\n  }\n\n  if (incompatibleDirectImports.length > 0) {\n    return {\n      reason:\n        CompilationJobCreationErrorReason.DIRECTLY_IMPORTS_INCOMPATIBLE_FILE,\n      file,\n      extra: {\n        incompatibleDirectImports,\n      },\n    };\n  }\n\n  const incompatibleIndirectImports: taskTypes.TransitiveDependency[] = [];\n  for (const transitiveDependency of transitiveDependencies) {\n    const { dependency } = transitiveDependency;\n    const dependencyVersionRange = dependency.content.versionPragmas.join(\" \");\n    if (!semver.intersects(fileVersionRange, dependencyVersionRange)) {\n      incompatibleIndirectImports.push(transitiveDependency);\n    }\n  }\n\n  if (incompatibleIndirectImports.length > 0) {\n    return {\n      reason:\n        CompilationJobCreationErrorReason.INDIRECTLY_IMPORTS_INCOMPATIBLE_FILE,\n      file,\n      extra: {\n        incompatibleIndirectImports,\n      },\n    };\n  }\n\n  return { reason: CompilationJobCreationErrorReason.OTHER_ERROR, file };\n}\n"]},"metadata":{},"sourceType":"script","externalDependencies":[]}