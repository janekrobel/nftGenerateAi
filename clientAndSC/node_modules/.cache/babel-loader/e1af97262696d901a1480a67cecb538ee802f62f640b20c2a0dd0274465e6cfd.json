{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.getExtensions = void 0;\nconst util_1 = require(\"./util\");\nconst nodeEquivalents = new Map([['.ts', '.js'], ['.tsx', '.js'], ['.jsx', '.js'], ['.mts', '.mjs'], ['.cts', '.cjs']]);\nconst tsResolverEquivalents = new Map([['.ts', ['.js']], ['.tsx', ['.js', '.jsx']], ['.mts', ['.mjs']], ['.cts', ['.cjs']]]);\n// All extensions understood by vanilla node\nconst vanillaNodeExtensions = ['.js', '.json', '.node', '.mjs', '.cjs'];\n// Extensions added by vanilla node's require() if you omit them:\n// js, json, node\n// Extensions added by vanilla node if you omit them with --experimental-specifier-resolution=node\n// js, json, node, mjs\n// Extensions added by ESM codepath's legacy package.json \"main\" resolver\n// js, json, node (not mjs!)\nconst nodeDoesNotUnderstand = ['.ts', '.tsx', '.jsx', '.cts', '.mts'];\n/**\n * [MUST_UPDATE_FOR_NEW_FILE_EXTENSIONS]\n * @internal\n */\nfunction getExtensions(config, options, tsVersion) {\n  // TS 4.5 is first version to understand .cts, .mts, .cjs, and .mjs extensions\n  const tsSupportsMtsCtsExts = (0, util_1.versionGteLt)(tsVersion, '4.5.0');\n  const requiresHigherTypescriptVersion = [];\n  if (!tsSupportsMtsCtsExts) requiresHigherTypescriptVersion.push('.cts', '.cjs', '.mts', '.mjs');\n  const allPossibleExtensionsSortedByPreference = Array.from(new Set([...(options.preferTsExts ? nodeDoesNotUnderstand : []), ...vanillaNodeExtensions, ...nodeDoesNotUnderstand]));\n  const compiledJsUnsorted = ['.ts'];\n  const compiledJsxUnsorted = [];\n  if (config.options.jsx) compiledJsxUnsorted.push('.tsx');\n  if (tsSupportsMtsCtsExts) compiledJsUnsorted.push('.mts', '.cts');\n  if (config.options.allowJs) {\n    compiledJsUnsorted.push('.js');\n    if (config.options.jsx) compiledJsxUnsorted.push('.jsx');\n    if (tsSupportsMtsCtsExts) compiledJsUnsorted.push('.mjs', '.cjs');\n  }\n  const compiledUnsorted = [...compiledJsUnsorted, ...compiledJsxUnsorted];\n  const compiled = allPossibleExtensionsSortedByPreference.filter(ext => compiledUnsorted.includes(ext));\n  const compiledNodeDoesNotUnderstand = nodeDoesNotUnderstand.filter(ext => compiled.includes(ext));\n  /**\n   * TS's resolver can resolve foo.js to foo.ts, by replacing .js extension with several source extensions.\n   * IMPORTANT: Must preserve ordering according to preferTsExts!\n   *            Must include the .js/.mjs/.cjs extension in the array!\n   *            This affects resolution behavior!\n   * [MUST_UPDATE_FOR_NEW_FILE_EXTENSIONS]\n   */\n  const r = allPossibleExtensionsSortedByPreference.filter(ext => [...compiledUnsorted, '.js', '.mjs', '.cjs', '.mts', '.cts'].includes(ext));\n  const replacementsForJs = r.filter(ext => ['.js', '.jsx', '.ts', '.tsx'].includes(ext));\n  const replacementsForJsx = r.filter(ext => ['.jsx', '.tsx'].includes(ext));\n  const replacementsForMjs = r.filter(ext => ['.mjs', '.mts'].includes(ext));\n  const replacementsForCjs = r.filter(ext => ['.cjs', '.cts'].includes(ext));\n  const replacementsForJsOrMjs = r.filter(ext => ['.js', '.jsx', '.ts', '.tsx', '.mjs', '.mts'].includes(ext));\n  // Node allows omitting .js or .mjs extension in certain situations (CJS, ESM w/experimental flag)\n  // So anything that compiles to .js or .mjs can also be omitted.\n  const experimentalSpecifierResolutionAddsIfOmitted = Array.from(new Set([...replacementsForJsOrMjs, '.json', '.node']));\n  // Same as above, except node curiuosly doesn't do .mjs here\n  const legacyMainResolveAddsIfOmitted = Array.from(new Set([...replacementsForJs, '.json', '.node']));\n  return {\n    /** All file extensions we transform, ordered by resolution preference according to preferTsExts */\n    compiled,\n    /** Resolved extensions that vanilla node will not understand; we should handle them */\n    nodeDoesNotUnderstand,\n    /** Like the above, but only the ones we're compiling */\n    compiledNodeDoesNotUnderstand,\n    /**\n     * Mapping from extensions understood by tsc to the equivalent for node,\n     * as far as getFormat is concerned.\n     */\n    nodeEquivalents,\n    /**\n     * Mapping from extensions rejected by TSC in import specifiers, to the\n     * possible alternatives that TS's resolver will accept.\n     *\n     * When we allow users to opt-in to .ts extensions in import specifiers, TS's\n     * resolver requires us to replace the .ts extensions with .js alternatives.\n     * Otherwise, resolution fails.\n     *\n     * Note TS's resolver is only used by, and only required for, typechecking.\n     * This is separate from node's resolver, which we hook separately and which\n     * does not require this mapping.\n     */\n    tsResolverEquivalents,\n    /**\n     * Extensions that we can support if the user upgrades their typescript version.\n     * Used when raising hints.\n     */\n    requiresHigherTypescriptVersion,\n    /**\n     * --experimental-specifier-resolution=node will add these extensions.\n     */\n    experimentalSpecifierResolutionAddsIfOmitted,\n    /**\n     * ESM loader will add these extensions to package.json \"main\" field\n     */\n    legacyMainResolveAddsIfOmitted,\n    replacementsForMjs,\n    replacementsForCjs,\n    replacementsForJsx,\n    replacementsForJs\n  };\n}\nexports.getExtensions = getExtensions;","map":{"version":3,"mappings":"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","names":["nodeEquivalents","Map","tsResolverEquivalents","vanillaNodeExtensions","nodeDoesNotUnderstand","getExtensions","config","options","tsVersion","tsSupportsMtsCtsExts","requiresHigherTypescriptVersion","push","allPossibleExtensionsSortedByPreference","Array","from","Set","preferTsExts","compiledJsUnsorted","compiledJsxUnsorted","jsx","allowJs","compiledUnsorted","compiled","filter","ext","includes","compiledNodeDoesNotUnderstand","r","replacementsForJs","replacementsForJsx","replacementsForMjs","replacementsForCjs","replacementsForJsOrMjs","experimentalSpecifierResolutionAddsIfOmitted","legacyMainResolveAddsIfOmitted","exports"],"sources":["/Users/janrobel/Documents/PersonalProjekty/nftGenerateAi/clientAndContract/node_modules/ts-node/src/file-extensions.ts"],"sourcesContent":["import type * as _ts from 'typescript';\nimport type { RegisterOptions } from '.';\nimport { versionGteLt } from './util';\n\n/**\n * Centralized specification of how we deal with file extensions based on\n * project options:\n * which ones we do/don't support, in what situations, etc.  These rules drive\n * logic elsewhere.\n * @internal\n * */\nexport type Extensions = ReturnType<typeof getExtensions>;\n\nconst nodeEquivalents = new Map<string, string>([\n  ['.ts', '.js'],\n  ['.tsx', '.js'],\n  ['.jsx', '.js'],\n  ['.mts', '.mjs'],\n  ['.cts', '.cjs'],\n]);\n\nconst tsResolverEquivalents = new Map<string, readonly string[]>([\n  ['.ts', ['.js']],\n  ['.tsx', ['.js', '.jsx']],\n  ['.mts', ['.mjs']],\n  ['.cts', ['.cjs']],\n]);\n\n// All extensions understood by vanilla node\nconst vanillaNodeExtensions: readonly string[] = [\n  '.js',\n  '.json',\n  '.node',\n  '.mjs',\n  '.cjs',\n];\n\n// Extensions added by vanilla node's require() if you omit them:\n// js, json, node\n// Extensions added by vanilla node if you omit them with --experimental-specifier-resolution=node\n// js, json, node, mjs\n// Extensions added by ESM codepath's legacy package.json \"main\" resolver\n// js, json, node (not mjs!)\n\nconst nodeDoesNotUnderstand: readonly string[] = [\n  '.ts',\n  '.tsx',\n  '.jsx',\n  '.cts',\n  '.mts',\n];\n\n/**\n * [MUST_UPDATE_FOR_NEW_FILE_EXTENSIONS]\n * @internal\n */\nexport function getExtensions(\n  config: _ts.ParsedCommandLine,\n  options: RegisterOptions,\n  tsVersion: string\n) {\n  // TS 4.5 is first version to understand .cts, .mts, .cjs, and .mjs extensions\n  const tsSupportsMtsCtsExts = versionGteLt(tsVersion, '4.5.0');\n\n  const requiresHigherTypescriptVersion: string[] = [];\n  if (!tsSupportsMtsCtsExts)\n    requiresHigherTypescriptVersion.push('.cts', '.cjs', '.mts', '.mjs');\n\n  const allPossibleExtensionsSortedByPreference = Array.from(\n    new Set([\n      ...(options.preferTsExts ? nodeDoesNotUnderstand : []),\n      ...vanillaNodeExtensions,\n      ...nodeDoesNotUnderstand,\n    ])\n  );\n\n  const compiledJsUnsorted: string[] = ['.ts'];\n  const compiledJsxUnsorted: string[] = [];\n\n  if (config.options.jsx) compiledJsxUnsorted.push('.tsx');\n  if (tsSupportsMtsCtsExts) compiledJsUnsorted.push('.mts', '.cts');\n  if (config.options.allowJs) {\n    compiledJsUnsorted.push('.js');\n    if (config.options.jsx) compiledJsxUnsorted.push('.jsx');\n    if (tsSupportsMtsCtsExts) compiledJsUnsorted.push('.mjs', '.cjs');\n  }\n\n  const compiledUnsorted = [...compiledJsUnsorted, ...compiledJsxUnsorted];\n  const compiled = allPossibleExtensionsSortedByPreference.filter((ext) =>\n    compiledUnsorted.includes(ext)\n  );\n\n  const compiledNodeDoesNotUnderstand = nodeDoesNotUnderstand.filter((ext) =>\n    compiled.includes(ext)\n  );\n\n  /**\n   * TS's resolver can resolve foo.js to foo.ts, by replacing .js extension with several source extensions.\n   * IMPORTANT: Must preserve ordering according to preferTsExts!\n   *            Must include the .js/.mjs/.cjs extension in the array!\n   *            This affects resolution behavior!\n   * [MUST_UPDATE_FOR_NEW_FILE_EXTENSIONS]\n   */\n  const r = allPossibleExtensionsSortedByPreference.filter((ext) =>\n    [...compiledUnsorted, '.js', '.mjs', '.cjs', '.mts', '.cts'].includes(ext)\n  );\n  const replacementsForJs = r.filter((ext) =>\n    ['.js', '.jsx', '.ts', '.tsx'].includes(ext)\n  );\n  const replacementsForJsx = r.filter((ext) => ['.jsx', '.tsx'].includes(ext));\n  const replacementsForMjs = r.filter((ext) => ['.mjs', '.mts'].includes(ext));\n  const replacementsForCjs = r.filter((ext) => ['.cjs', '.cts'].includes(ext));\n  const replacementsForJsOrMjs = r.filter((ext) =>\n    ['.js', '.jsx', '.ts', '.tsx', '.mjs', '.mts'].includes(ext)\n  );\n\n  // Node allows omitting .js or .mjs extension in certain situations (CJS, ESM w/experimental flag)\n  // So anything that compiles to .js or .mjs can also be omitted.\n  const experimentalSpecifierResolutionAddsIfOmitted = Array.from(\n    new Set([...replacementsForJsOrMjs, '.json', '.node'])\n  );\n  // Same as above, except node curiuosly doesn't do .mjs here\n  const legacyMainResolveAddsIfOmitted = Array.from(\n    new Set([...replacementsForJs, '.json', '.node'])\n  );\n\n  return {\n    /** All file extensions we transform, ordered by resolution preference according to preferTsExts */\n    compiled,\n    /** Resolved extensions that vanilla node will not understand; we should handle them */\n    nodeDoesNotUnderstand,\n    /** Like the above, but only the ones we're compiling */\n    compiledNodeDoesNotUnderstand,\n    /**\n     * Mapping from extensions understood by tsc to the equivalent for node,\n     * as far as getFormat is concerned.\n     */\n    nodeEquivalents,\n    /**\n     * Mapping from extensions rejected by TSC in import specifiers, to the\n     * possible alternatives that TS's resolver will accept.\n     *\n     * When we allow users to opt-in to .ts extensions in import specifiers, TS's\n     * resolver requires us to replace the .ts extensions with .js alternatives.\n     * Otherwise, resolution fails.\n     *\n     * Note TS's resolver is only used by, and only required for, typechecking.\n     * This is separate from node's resolver, which we hook separately and which\n     * does not require this mapping.\n     */\n    tsResolverEquivalents,\n    /**\n     * Extensions that we can support if the user upgrades their typescript version.\n     * Used when raising hints.\n     */\n    requiresHigherTypescriptVersion,\n    /**\n     * --experimental-specifier-resolution=node will add these extensions.\n     */\n    experimentalSpecifierResolutionAddsIfOmitted,\n    /**\n     * ESM loader will add these extensions to package.json \"main\" field\n     */\n    legacyMainResolveAddsIfOmitted,\n    replacementsForMjs,\n    replacementsForCjs,\n    replacementsForJsx,\n    replacementsForJs,\n  };\n}\n"]},"metadata":{},"sourceType":"script","externalDependencies":[]}