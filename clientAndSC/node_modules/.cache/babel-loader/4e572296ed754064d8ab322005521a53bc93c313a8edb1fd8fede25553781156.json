{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.createTsTranspileModule = void 0;\n/** @internal */\nfunction createTsTranspileModule(ts, transpileOptions) {\n  const {\n    createProgram,\n    createSourceFile,\n    getDefaultCompilerOptions,\n    getImpliedNodeFormatForFile,\n    fixupCompilerOptions,\n    transpileOptionValueCompilerOptions,\n    getNewLineCharacter,\n    fileExtensionIs,\n    normalizePath,\n    Debug,\n    toPath,\n    getSetExternalModuleIndicator,\n    getEntries,\n    addRange,\n    hasProperty,\n    getEmitScriptTarget,\n    getDirectoryPath\n  } = ts;\n  const compilerOptionsDiagnostics = [];\n  const options = transpileOptions.compilerOptions ? fixupCompilerOptions(transpileOptions.compilerOptions, compilerOptionsDiagnostics) : {};\n  // mix in default options\n  const defaultOptions = getDefaultCompilerOptions();\n  for (const key in defaultOptions) {\n    if (hasProperty(defaultOptions, key) && options[key] === undefined) {\n      options[key] = defaultOptions[key];\n    }\n  }\n  for (const option of transpileOptionValueCompilerOptions) {\n    options[option.name] = option.transpileOptionValue;\n  }\n  // transpileModule does not write anything to disk so there is no need to verify that there are no conflicts between input and output paths.\n  options.suppressOutputPathCheck = true;\n  // Filename can be non-ts file.\n  options.allowNonTsExtensions = true;\n  const newLine = getNewLineCharacter(options);\n  // Create a compilerHost object to allow the compiler to read and write files\n  const compilerHost = {\n    getSourceFile: fileName => fileName === normalizePath(inputFileName) ? sourceFile : undefined,\n    writeFile: (name, text) => {\n      if (fileExtensionIs(name, '.map')) {\n        Debug.assertEqual(sourceMapText, undefined, 'Unexpected multiple source map outputs, file:', name);\n        sourceMapText = text;\n      } else {\n        Debug.assertEqual(outputText, undefined, 'Unexpected multiple outputs, file:', name);\n        outputText = text;\n      }\n    },\n    getDefaultLibFileName: () => 'lib.d.ts',\n    useCaseSensitiveFileNames: () => true,\n    getCanonicalFileName: fileName => fileName,\n    getCurrentDirectory: () => '',\n    getNewLine: () => newLine,\n    fileExists: fileName => fileName === inputFileName || fileName === packageJsonFileName,\n    readFile: fileName => fileName === packageJsonFileName ? `{\"type\": \"${_packageJsonType}\"}` : '',\n    directoryExists: () => true,\n    getDirectories: () => []\n  };\n  let inputFileName;\n  let packageJsonFileName;\n  let _packageJsonType;\n  let sourceFile;\n  let outputText;\n  let sourceMapText;\n  return transpileModule;\n  function transpileModule(input, transpileOptions2) {\n    let packageJsonType = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'commonjs';\n    // if jsx is specified then treat file as .tsx\n    inputFileName = transpileOptions2.fileName || (transpileOptions.compilerOptions && transpileOptions.compilerOptions.jsx ? 'module.tsx' : 'module.ts');\n    packageJsonFileName = getDirectoryPath(inputFileName) + '/package.json';\n    _packageJsonType = packageJsonType;\n    sourceFile = createSourceFile(inputFileName, input, {\n      languageVersion: getEmitScriptTarget(options),\n      impliedNodeFormat: getImpliedNodeFormatForFile(toPath(inputFileName, '', compilerHost.getCanonicalFileName), /*cache*/undefined, compilerHost, options),\n      setExternalModuleIndicator: getSetExternalModuleIndicator(options)\n    });\n    if (transpileOptions2.moduleName) {\n      sourceFile.moduleName = transpileOptions2.moduleName;\n    }\n    if (transpileOptions2.renamedDependencies) {\n      sourceFile.renamedDependencies = new Map(getEntries(transpileOptions2.renamedDependencies));\n    }\n    // Output\n    outputText = undefined;\n    sourceMapText = undefined;\n    const program = createProgram([inputFileName], options, compilerHost);\n    const diagnostics = compilerOptionsDiagnostics.slice();\n    if (transpileOptions.reportDiagnostics) {\n      addRange( /*to*/diagnostics, /*from*/program.getSyntacticDiagnostics(sourceFile));\n      addRange( /*to*/diagnostics, /*from*/program.getOptionsDiagnostics());\n    }\n    // Emit\n    program.emit( /*targetSourceFile*/undefined, /*writeFile*/undefined, /*cancellationToken*/undefined, /*emitOnlyDtsFiles*/undefined, transpileOptions.transformers);\n    if (outputText === undefined) return Debug.fail('Output generation failed');\n    return {\n      outputText,\n      diagnostics,\n      sourceMapText\n    };\n  }\n}\nexports.createTsTranspileModule = createTsTranspileModule;","map":{"version":3,"mappings":"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","names":["createTsTranspileModule","ts","transpileOptions","createProgram","createSourceFile","getDefaultCompilerOptions","getImpliedNodeFormatForFile","fixupCompilerOptions","transpileOptionValueCompilerOptions","getNewLineCharacter","fileExtensionIs","normalizePath","Debug","toPath","getSetExternalModuleIndicator","getEntries","addRange","hasProperty","getEmitScriptTarget","getDirectoryPath","compilerOptionsDiagnostics","options","compilerOptions","defaultOptions","key","undefined","option","name","transpileOptionValue","suppressOutputPathCheck","allowNonTsExtensions","newLine","compilerHost","getSourceFile","fileName","inputFileName","sourceFile","writeFile","text","assertEqual","sourceMapText","outputText","getDefaultLibFileName","useCaseSensitiveFileNames","getCanonicalFileName","getCurrentDirectory","getNewLine","fileExists","packageJsonFileName","readFile","_packageJsonType","directoryExists","getDirectories","transpileModule","input","transpileOptions2","packageJsonType","jsx","languageVersion","impliedNodeFormat","setExternalModuleIndicator","moduleName","renamedDependencies","Map","program","diagnostics","slice","reportDiagnostics","getSyntacticDiagnostics","getOptionsDiagnostics","emit","transformers","fail","exports"],"sources":["/Users/janrobel/Documents/PersonalProjekty/nftGenerateAi/clientAndContract/node_modules/ts-node/src/ts-transpile-module.ts"],"sourcesContent":["import type {\n  CompilerHost,\n  CompilerOptions,\n  Diagnostic,\n  SourceFile,\n  TranspileOptions,\n  TranspileOutput,\n} from 'typescript';\nimport type { TSCommon } from './ts-compiler-types';\n\n/** @internal */\nexport function createTsTranspileModule(\n  ts: TSCommon,\n  transpileOptions: Pick<\n    TranspileOptions,\n    'compilerOptions' | 'reportDiagnostics' | 'transformers'\n  >\n) {\n  const {\n    createProgram,\n    createSourceFile,\n    getDefaultCompilerOptions,\n    getImpliedNodeFormatForFile,\n    fixupCompilerOptions,\n    transpileOptionValueCompilerOptions,\n    getNewLineCharacter,\n    fileExtensionIs,\n    normalizePath,\n    Debug,\n    toPath,\n    getSetExternalModuleIndicator,\n    getEntries,\n    addRange,\n    hasProperty,\n    getEmitScriptTarget,\n    getDirectoryPath,\n  } = ts as any;\n\n  const compilerOptionsDiagnostics: Diagnostic[] = [];\n\n  const options: CompilerOptions = transpileOptions.compilerOptions\n    ? fixupCompilerOptions(\n        transpileOptions.compilerOptions,\n        compilerOptionsDiagnostics\n      )\n    : {};\n\n  // mix in default options\n  const defaultOptions = getDefaultCompilerOptions();\n  for (const key in defaultOptions) {\n    if (hasProperty(defaultOptions, key) && options[key] === undefined) {\n      options[key] = defaultOptions[key];\n    }\n  }\n\n  for (const option of transpileOptionValueCompilerOptions) {\n    options[option.name] = option.transpileOptionValue;\n  }\n\n  // transpileModule does not write anything to disk so there is no need to verify that there are no conflicts between input and output paths.\n  options.suppressOutputPathCheck = true;\n\n  // Filename can be non-ts file.\n  options.allowNonTsExtensions = true;\n\n  const newLine = getNewLineCharacter(options);\n  // Create a compilerHost object to allow the compiler to read and write files\n  const compilerHost: CompilerHost = {\n    getSourceFile: (fileName) =>\n      fileName === normalizePath(inputFileName) ? sourceFile : undefined,\n    writeFile: (name, text) => {\n      if (fileExtensionIs(name, '.map')) {\n        Debug.assertEqual(\n          sourceMapText,\n          undefined,\n          'Unexpected multiple source map outputs, file:',\n          name\n        );\n        sourceMapText = text;\n      } else {\n        Debug.assertEqual(\n          outputText,\n          undefined,\n          'Unexpected multiple outputs, file:',\n          name\n        );\n        outputText = text;\n      }\n    },\n    getDefaultLibFileName: () => 'lib.d.ts',\n    useCaseSensitiveFileNames: () => true,\n    getCanonicalFileName: (fileName) => fileName,\n    getCurrentDirectory: () => '',\n    getNewLine: () => newLine,\n    fileExists: (fileName): boolean =>\n      fileName === inputFileName || fileName === packageJsonFileName,\n    readFile: (fileName) =>\n      fileName === packageJsonFileName ? `{\"type\": \"${_packageJsonType}\"}` : '',\n    directoryExists: () => true,\n    getDirectories: () => [],\n  };\n\n  let inputFileName: string;\n  let packageJsonFileName: string;\n  let _packageJsonType: 'module' | 'commonjs';\n  let sourceFile: SourceFile;\n  let outputText: string | undefined;\n  let sourceMapText: string | undefined;\n\n  return transpileModule;\n\n  function transpileModule(\n    input: string,\n    transpileOptions2: Pick<\n      TranspileOptions,\n      'fileName' | 'moduleName' | 'renamedDependencies'\n    >,\n    packageJsonType: 'module' | 'commonjs' = 'commonjs'\n  ): TranspileOutput {\n    // if jsx is specified then treat file as .tsx\n    inputFileName =\n      transpileOptions2.fileName ||\n      (transpileOptions.compilerOptions && transpileOptions.compilerOptions.jsx\n        ? 'module.tsx'\n        : 'module.ts');\n    packageJsonFileName = getDirectoryPath(inputFileName) + '/package.json';\n    _packageJsonType = packageJsonType;\n\n    sourceFile = createSourceFile(inputFileName, input, {\n      languageVersion: getEmitScriptTarget(options),\n      impliedNodeFormat: getImpliedNodeFormatForFile(\n        toPath(inputFileName, '', compilerHost.getCanonicalFileName),\n        /*cache*/ undefined,\n        compilerHost,\n        options\n      ),\n      setExternalModuleIndicator: getSetExternalModuleIndicator(options),\n    });\n    if (transpileOptions2.moduleName) {\n      sourceFile.moduleName = transpileOptions2.moduleName;\n    }\n\n    if (transpileOptions2.renamedDependencies) {\n      (sourceFile as any).renamedDependencies = new Map(\n        getEntries(transpileOptions2.renamedDependencies)\n      );\n    }\n\n    // Output\n    outputText = undefined;\n    sourceMapText = undefined;\n\n    const program = createProgram([inputFileName], options, compilerHost);\n\n    const diagnostics = compilerOptionsDiagnostics.slice();\n\n    if (transpileOptions.reportDiagnostics) {\n      addRange(\n        /*to*/ diagnostics,\n        /*from*/ program.getSyntacticDiagnostics(sourceFile)\n      );\n      addRange(/*to*/ diagnostics, /*from*/ program.getOptionsDiagnostics());\n    }\n    // Emit\n    program.emit(\n      /*targetSourceFile*/ undefined,\n      /*writeFile*/ undefined,\n      /*cancellationToken*/ undefined,\n      /*emitOnlyDtsFiles*/ undefined,\n      transpileOptions.transformers\n    );\n\n    if (outputText === undefined) return Debug.fail('Output generation failed');\n\n    return { outputText, diagnostics, sourceMapText };\n  }\n}\n"]},"metadata":{},"sourceType":"script","externalDependencies":[]}