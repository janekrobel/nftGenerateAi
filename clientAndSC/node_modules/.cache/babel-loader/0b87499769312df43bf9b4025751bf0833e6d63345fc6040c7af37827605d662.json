{"ast":null,"code":"// Copied from several files in node's source code.\n// https://github.com/nodejs/node/blob/2d5d77306f6dff9110c1f77fefab25f973415770/lib/internal/modules/cjs/loader.js\n// Each function and variable below must have a comment linking to the source in node's github repo.\n\n'use strict';\n\nconst {\n  ArrayIsArray,\n  ArrayPrototypeIncludes,\n  ArrayPrototypeJoin,\n  ArrayPrototypePush,\n  JSONParse,\n  ObjectKeys,\n  RegExpPrototypeTest,\n  SafeMap,\n  SafeWeakMap,\n  StringPrototypeCharCodeAt,\n  StringPrototypeEndsWith,\n  StringPrototypeLastIndexOf,\n  StringPrototypeIndexOf,\n  StringPrototypeMatch,\n  StringPrototypeSlice,\n  StringPrototypeStartsWith\n} = require('./node-primordials');\nconst {\n  NativeModule\n} = require('./node-nativemodule');\nconst {\n  pathToFileURL,\n  fileURLToPath\n} = require('url');\nconst fs = require('fs');\nconst path = require('path');\nconst {\n  sep\n} = path;\nconst {\n  internalModuleStat\n} = require('./node-internalBinding-fs');\nconst packageJsonReader = require('./node-internal-modules-package_json_reader');\nconst {\n  cjsConditions\n} = require('./node-internal-modules-cjs-helpers');\nconst {\n  getOptionValue\n} = require('./node-options');\nconst preserveSymlinks = getOptionValue('--preserve-symlinks');\nconst preserveSymlinksMain = getOptionValue('--preserve-symlinks-main');\nconst {\n  normalizeSlashes\n} = require('../dist/util');\nconst {\n  createErrRequireEsm\n} = require('./node-internal-errors');\nconst {\n  codes: {\n    ERR_INVALID_MODULE_SPECIFIER\n  }\n} = require('./node-internal-errors');\nconst {\n  CHAR_FORWARD_SLASH\n} = require('./node-internal-constants');\nconst Module = require('module');\nconst isWindows = process.platform === 'win32';\nlet statCache = null;\nfunction stat(filename) {\n  filename = path.toNamespacedPath(filename);\n  if (statCache !== null) {\n    const result = statCache.get(filename);\n    if (result !== undefined) return result;\n  }\n  const result = internalModuleStat(filename);\n  if (statCache !== null && result >= 0) {\n    // Only set cache when `internalModuleStat(filename)` succeeds.\n    statCache.set(filename, result);\n  }\n  return result;\n}\n\n// Note:\n// we cannot get access to node's internal cache, which is populated from\n// within node's Module constructor.  So the cache here will always be empty.\n// It's possible we could approximate our own cache by building it up with\n// hacky workarounds, but it's not worth the complexity and flakiness.\nconst moduleParentCache = new SafeWeakMap();\n\n// Given a module name, and a list of paths to test, returns the first\n// matching file in the following precedence.\n//\n// require(\"a.<ext>\")\n//   -> a.<ext>\n//\n// require(\"a\")\n//   -> a\n//   -> a.<ext>\n//   -> a/index.<ext>\n\nconst packageJsonCache = new SafeMap();\nfunction readPackage(requestPath) {\n  const jsonPath = path.resolve(requestPath, 'package.json');\n  const existing = packageJsonCache.get(jsonPath);\n  if (existing !== undefined) return existing;\n  const result = packageJsonReader.read(jsonPath);\n  const json = result.containsKeys === false ? '{}' : result.string;\n  if (json === undefined) {\n    packageJsonCache.set(jsonPath, false);\n    return false;\n  }\n  try {\n    const parsed = JSONParse(json);\n    const filtered = {\n      name: parsed.name,\n      main: parsed.main,\n      exports: parsed.exports,\n      imports: parsed.imports,\n      type: parsed.type\n    };\n    packageJsonCache.set(jsonPath, filtered);\n    return filtered;\n  } catch (e) {\n    e.path = jsonPath;\n    e.message = 'Error parsing ' + jsonPath + ': ' + e.message;\n    throw e;\n  }\n}\nfunction readPackageScope(checkPath) {\n  const rootSeparatorIndex = StringPrototypeIndexOf(checkPath, sep);\n  let separatorIndex;\n  do {\n    separatorIndex = StringPrototypeLastIndexOf(checkPath, sep);\n    checkPath = StringPrototypeSlice(checkPath, 0, separatorIndex);\n    if (StringPrototypeEndsWith(checkPath, sep + 'node_modules')) return false;\n    const pjson = readPackage(checkPath + sep);\n    if (pjson) return {\n      data: pjson,\n      path: checkPath\n    };\n  } while (separatorIndex > rootSeparatorIndex);\n  return false;\n}\n\n/**\n * @param {{\n *   nodeEsmResolver: ReturnType<typeof import('./node-internal-modules-esm-resolve').createResolve>,\n *   extensions: import('../src/file-extensions').Extensions,\n *   preferTsExts\n * }} opts\n */\nfunction createCjsLoader(opts) {\n  const {\n    nodeEsmResolver,\n    preferTsExts\n  } = opts;\n  const {\n    replacementsForCjs,\n    replacementsForJs,\n    replacementsForMjs,\n    replacementsForJsx\n  } = opts.extensions;\n  const {\n    encodedSepRegEx,\n    packageExportsResolve,\n    packageImportsResolve\n  } = nodeEsmResolver;\n  function tryPackage(requestPath, exts, isMain, originalPath) {\n    // const pkg = readPackage(requestPath)?.main;\n    const tmp = readPackage(requestPath);\n    const pkg = tmp != null ? tmp.main : undefined;\n    if (!pkg) {\n      return tryExtensions(path.resolve(requestPath, 'index'), exts, isMain);\n    }\n    const filename = path.resolve(requestPath, pkg);\n    let actual = tryReplacementExtensions(filename, isMain) || tryFile(filename, isMain) || tryExtensions(filename, exts, isMain) || tryExtensions(path.resolve(filename, 'index'), exts, isMain);\n    if (actual === false) {\n      actual = tryExtensions(path.resolve(requestPath, 'index'), exts, isMain);\n      if (!actual) {\n        // eslint-disable-next-line no-restricted-syntax\n        const err = new Error(`Cannot find module '${filename}'. ` + 'Please verify that the package.json has a valid \"main\" entry');\n        err.code = 'MODULE_NOT_FOUND';\n        err.path = path.resolve(requestPath, 'package.json');\n        err.requestPath = originalPath;\n        // TODO(BridgeAR): Add the requireStack as well.\n        throw err;\n      } else {\n        const jsonPath = path.resolve(requestPath, 'package.json');\n        process.emitWarning(`Invalid 'main' field in '${jsonPath}' of '${pkg}'. ` + 'Please either fix that or report it to the module author', 'DeprecationWarning', 'DEP0128');\n      }\n    }\n    return actual;\n  }\n\n  // In order to minimize unnecessary lstat() calls,\n  // this cache is a list of known-real paths.\n  // Set to an empty Map to reset.\n  const realpathCache = new SafeMap();\n\n  // Check if the file exists and is not a directory\n  // if using --preserve-symlinks and isMain is false,\n  // keep symlinks intact, otherwise resolve to the\n  // absolute realpath.\n  function tryFile(requestPath, isMain) {\n    const rc = stat(requestPath);\n    if (rc !== 0) return;\n    if (preserveSymlinks && !isMain) {\n      return path.resolve(requestPath);\n    }\n    return toRealPath(requestPath);\n  }\n  function toRealPath(requestPath) {\n    return fs.realpathSync(requestPath, {\n      // [internalFS.realpathCacheKey]: realpathCache\n    });\n  }\n  function statReplacementExtensions(p) {\n    const lastDotIndex = p.lastIndexOf('.');\n    if (lastDotIndex >= 0) {\n      const ext = p.slice(lastDotIndex);\n      if (ext === '.js' || ext === '.jsx' || ext === '.mjs' || ext === '.cjs') {\n        const pathnameWithoutExtension = p.slice(0, lastDotIndex);\n        const replacementExts = ext === '.js' ? replacementsForJs : ext === '.jsx' ? replacementsForJsx : ext === '.mjs' ? replacementsForMjs : replacementsForCjs;\n        for (let i = 0; i < replacementExts.length; i++) {\n          const filename = pathnameWithoutExtension + replacementExts[i];\n          const rc = stat(filename);\n          if (rc === 0) {\n            return [rc, filename];\n          }\n        }\n      }\n    }\n    return [stat(p), p];\n  }\n  function tryReplacementExtensions(p, isMain) {\n    const lastDotIndex = p.lastIndexOf('.');\n    if (lastDotIndex >= 0) {\n      const ext = p.slice(lastDotIndex);\n      if (ext === '.js' || ext === '.jsx' || ext === '.mjs' || ext === '.cjs') {\n        const pathnameWithoutExtension = p.slice(0, lastDotIndex);\n        const replacementExts = ext === '.js' ? replacementsForJs : ext === '.jsx' ? replacementsForJsx : ext === '.mjs' ? replacementsForMjs : replacementsForCjs;\n        for (let i = 0; i < replacementExts.length; i++) {\n          const filename = tryFile(pathnameWithoutExtension + replacementExts[i], isMain);\n          if (filename) {\n            return filename;\n          }\n        }\n      }\n    }\n    return false;\n  }\n\n  // Given a path, check if the file exists with any of the set extensions\n  function tryExtensions(p, exts, isMain) {\n    for (let i = 0; i < exts.length; i++) {\n      const filename = tryFile(p + exts[i], isMain);\n      if (filename) {\n        return filename;\n      }\n    }\n    return false;\n  }\n  function trySelfParentPath(parent) {\n    if (!parent) return false;\n    if (parent.filename) {\n      return parent.filename;\n    } else if (parent.id === '<repl>' || parent.id === 'internal/preload') {\n      try {\n        return process.cwd() + path.sep;\n      } catch {\n        return false;\n      }\n    }\n  }\n  function trySelf(parentPath, request) {\n    if (!parentPath) return false;\n    const {\n      data: pkg,\n      path: pkgPath\n    } = readPackageScope(parentPath) || {};\n    if (!pkg || pkg.exports === undefined) return false;\n    if (typeof pkg.name !== 'string') return false;\n    let expansion;\n    if (request === pkg.name) {\n      expansion = '.';\n    } else if (StringPrototypeStartsWith(request, `${pkg.name}/`)) {\n      expansion = '.' + StringPrototypeSlice(request, pkg.name.length);\n    } else {\n      return false;\n    }\n    try {\n      return finalizeEsmResolution(packageExportsResolve(pathToFileURL(pkgPath + '/package.json'), expansion, pkg, pathToFileURL(parentPath), cjsConditions).resolved, parentPath, pkgPath);\n    } catch (e) {\n      if (e.code === 'ERR_MODULE_NOT_FOUND') throw createEsmNotFoundErr(request, pkgPath + '/package.json');\n      throw e;\n    }\n  }\n\n  // This only applies to requests of a specific form:\n  // 1. name/.*\n  // 2. @scope/name/.*\n  const EXPORTS_PATTERN = /^((?:@[^/\\\\%]+\\/)?[^./\\\\%][^/\\\\%]*)(\\/.*)?$/;\n  function resolveExports(nmPath, request) {\n    // The implementation's behavior is meant to mirror resolution in ESM.\n    const {\n      1: name,\n      2: expansion = ''\n    } = StringPrototypeMatch(request, EXPORTS_PATTERN) || [];\n    if (!name) return;\n    const pkgPath = path.resolve(nmPath, name);\n    const pkg = readPackage(pkgPath);\n    // if (pkg?.exports != null) {\n    if (pkg != null && pkg.exports != null) {\n      try {\n        return finalizeEsmResolution(packageExportsResolve(pathToFileURL(pkgPath + '/package.json'), '.' + expansion, pkg, null, cjsConditions).resolved, null, pkgPath);\n      } catch (e) {\n        if (e.code === 'ERR_MODULE_NOT_FOUND') throw createEsmNotFoundErr(request, pkgPath + '/package.json');\n        throw e;\n      }\n    }\n  }\n\n  // Backwards compat for old node versions\n  const hasModulePathCache = !!require('module')._pathCache;\n  const Module_pathCache = Object.create(null);\n  const Module_pathCache_get = hasModulePathCache ? cacheKey => Module._pathCache[cacheKey] : cacheKey => Module_pathCache[cacheKey];\n  const Module_pathCache_set = hasModulePathCache ? (cacheKey, value) => Module._pathCache[cacheKey] = value : cacheKey => Module_pathCache[cacheKey] = value;\n  const trailingSlashRegex = /(?:^|\\/)\\.?\\.$/;\n  const Module_findPath = function _findPath(request, paths, isMain) {\n    const absoluteRequest = path.isAbsolute(request);\n    if (absoluteRequest) {\n      paths = [''];\n    } else if (!paths || paths.length === 0) {\n      return false;\n    }\n    const cacheKey = request + '\\x00' + ArrayPrototypeJoin(paths, '\\x00');\n    const entry = Module_pathCache_get(cacheKey);\n    if (entry) return entry;\n    let exts;\n    let trailingSlash = request.length > 0 && StringPrototypeCharCodeAt(request, request.length - 1) === CHAR_FORWARD_SLASH;\n    if (!trailingSlash) {\n      trailingSlash = RegExpPrototypeTest(trailingSlashRegex, request);\n    }\n\n    // For each path\n    for (let i = 0; i < paths.length; i++) {\n      // Don't search further if path doesn't exist\n      const curPath = paths[i];\n      if (curPath && stat(curPath) < 1) continue;\n      if (!absoluteRequest) {\n        const exportsResolved = resolveExports(curPath, request);\n        if (exportsResolved) return exportsResolved;\n      }\n      const _basePath = path.resolve(curPath, request);\n      let filename;\n      const [rc, basePath] = statReplacementExtensions(_basePath);\n      if (!trailingSlash) {\n        if (rc === 0) {\n          // File.\n          if (!isMain) {\n            if (preserveSymlinks) {\n              filename = path.resolve(basePath);\n            } else {\n              filename = toRealPath(basePath);\n            }\n          } else if (preserveSymlinksMain) {\n            // For the main module, we use the preserveSymlinksMain flag instead\n            // mainly for backward compatibility, as the preserveSymlinks flag\n            // historically has not applied to the main module.  Most likely this\n            // was intended to keep .bin/ binaries working, as following those\n            // symlinks is usually required for the imports in the corresponding\n            // files to resolve; that said, in some use cases following symlinks\n            // causes bigger problems which is why the preserveSymlinksMain option\n            // is needed.\n            filename = path.resolve(basePath);\n          } else {\n            filename = toRealPath(basePath);\n          }\n        }\n        if (!filename) {\n          // Try it with each of the extensions\n          if (exts === undefined) exts = ObjectKeys(Module._extensions);\n          filename = tryExtensions(basePath, exts, isMain);\n        }\n      }\n      if (!filename && rc === 1) {\n        // Directory.\n        // try it with each of the extensions at \"index\"\n        if (exts === undefined) exts = ObjectKeys(Module._extensions);\n        filename = tryPackage(basePath, exts, isMain, request);\n      }\n      if (filename) {\n        Module_pathCache_set(cacheKey, filename);\n        return filename;\n      }\n    }\n    return false;\n  };\n  const Module_resolveFilename = function _resolveFilename(request, parent, isMain, options) {\n    if (StringPrototypeStartsWith(request, 'node:') || NativeModule.canBeRequiredByUsers(request)) {\n      return request;\n    }\n    let paths;\n    if (typeof options === 'object' && options !== null) {\n      if (ArrayIsArray(options.paths)) {\n        const isRelative = StringPrototypeStartsWith(request, './') || StringPrototypeStartsWith(request, '../') || isWindows && StringPrototypeStartsWith(request, '.\\\\') || StringPrototypeStartsWith(request, '..\\\\');\n        if (isRelative) {\n          paths = options.paths;\n        } else {\n          const fakeParent = new Module('', null);\n          paths = [];\n          for (let i = 0; i < options.paths.length; i++) {\n            const path = options.paths[i];\n            fakeParent.paths = Module._nodeModulePaths(path);\n            const lookupPaths = Module._resolveLookupPaths(request, fakeParent);\n            for (let j = 0; j < lookupPaths.length; j++) {\n              if (!ArrayPrototypeIncludes(paths, lookupPaths[j])) ArrayPrototypePush(paths, lookupPaths[j]);\n            }\n          }\n        }\n      } else if (options.paths === undefined) {\n        paths = Module._resolveLookupPaths(request, parent);\n      } else {\n        throw new ERR_INVALID_ARG_VALUE('options.paths', options.paths);\n      }\n    } else {\n      paths = Module._resolveLookupPaths(request, parent);\n    }\n\n    // if (parent?.filename) {\n    // node 12 hack\n    if (parent != null && parent.filename) {\n      if (request[0] === '#') {\n        const pkg = readPackageScope(parent.filename) || {};\n\n        // if (pkg.data?.imports != null) {\n        // node 12 hack\n        if (pkg.data != null && pkg.data.imports != null) {\n          try {\n            return finalizeEsmResolution(packageImportsResolve(request, pathToFileURL(parent.filename), cjsConditions), parent.filename, pkg.path);\n          } catch (e) {\n            if (e.code === 'ERR_MODULE_NOT_FOUND') throw createEsmNotFoundErr(request);\n            throw e;\n          }\n        }\n      }\n    }\n\n    // Try module self resolution first\n    const parentPath = trySelfParentPath(parent);\n    const selfResolved = trySelf(parentPath, request);\n    if (selfResolved) {\n      const cacheKey = request + '\\x00' + (paths.length === 1 ? paths[0] : ArrayPrototypeJoin(paths, '\\x00'));\n      Module._pathCache[cacheKey] = selfResolved;\n      return selfResolved;\n    }\n\n    // Look up the filename first, since that's the cache key.\n    const filename = Module._findPath(request, paths, isMain, false);\n    if (filename) return filename;\n    const requireStack = [];\n    for (let cursor = parent; cursor; cursor = moduleParentCache.get(cursor)) {\n      ArrayPrototypePush(requireStack, cursor.filename || cursor.id);\n    }\n    let message = `Cannot find module '${request}'`;\n    if (requireStack.length > 0) {\n      message = message + '\\nRequire stack:\\n- ' + ArrayPrototypeJoin(requireStack, '\\n- ');\n    }\n    // eslint-disable-next-line no-restricted-syntax\n    const err = new Error(message);\n    err.code = 'MODULE_NOT_FOUND';\n    err.requireStack = requireStack;\n    throw err;\n  };\n  function finalizeEsmResolution(resolved, parentPath, pkgPath) {\n    if (RegExpPrototypeTest(encodedSepRegEx, resolved)) throw new ERR_INVALID_MODULE_SPECIFIER(resolved, 'must not include encoded \"/\" or \"\\\\\" characters', parentPath);\n    const filename = fileURLToPath(resolved);\n    const actual = tryReplacementExtensions(filename) || tryFile(filename);\n    if (actual) return actual;\n    const err = createEsmNotFoundErr(filename, path.resolve(pkgPath, 'package.json'));\n    throw err;\n  }\n  function createEsmNotFoundErr(request, path) {\n    // eslint-disable-next-line no-restricted-syntax\n    const err = new Error(`Cannot find module '${request}'`);\n    err.code = 'MODULE_NOT_FOUND';\n    if (path) err.path = path;\n    // TODO(BridgeAR): Add the requireStack as well.\n    return err;\n  }\n  return {\n    Module_findPath,\n    Module_resolveFilename\n  };\n}\n\n/**\n * copied from Module._extensions['.js']\n * https://github.com/nodejs/node/blob/v15.3.0/lib/internal/modules/cjs/loader.js#L1113-L1120\n * @param {import('../src/index').Service} service\n * @param {NodeJS.Module} module\n * @param {string} filename\n */\nfunction assertScriptCanLoadAsCJSImpl(service, module, filename) {\n  const pkg = readPackageScope(filename);\n\n  // ts-node modification: allow our configuration to override\n  const tsNodeClassification = service.moduleTypeClassifier.classifyModuleByModuleTypeOverrides(normalizeSlashes(filename));\n  if (tsNodeClassification.moduleType === 'cjs') return;\n\n  // ignore package.json when file extension is ESM-only or CJS-only\n  // [MUST_UPDATE_FOR_NEW_FILE_EXTENSIONS]\n  const lastDotIndex = filename.lastIndexOf('.');\n  const ext = lastDotIndex >= 0 ? filename.slice(lastDotIndex) : '';\n  if ((ext === '.cts' || ext === '.cjs') && tsNodeClassification.moduleType === 'auto') return;\n\n  // Function require shouldn't be used in ES modules.\n  if (ext === '.mts' || ext === '.mjs' || tsNodeClassification.moduleType === 'esm' || pkg && pkg.data && pkg.data.type === 'module') {\n    const parentPath = module.parent && module.parent.filename;\n    const packageJsonPath = pkg ? path.resolve(pkg.path, 'package.json') : null;\n    throw createErrRequireEsm(filename, parentPath, packageJsonPath);\n  }\n}\nmodule.exports = {\n  createCjsLoader,\n  assertScriptCanLoadAsCJSImpl,\n  readPackageScope\n};","map":{"version":3,"names":["ArrayIsArray","ArrayPrototypeIncludes","ArrayPrototypeJoin","ArrayPrototypePush","JSONParse","ObjectKeys","RegExpPrototypeTest","SafeMap","SafeWeakMap","StringPrototypeCharCodeAt","StringPrototypeEndsWith","StringPrototypeLastIndexOf","StringPrototypeIndexOf","StringPrototypeMatch","StringPrototypeSlice","StringPrototypeStartsWith","require","NativeModule","pathToFileURL","fileURLToPath","fs","path","sep","internalModuleStat","packageJsonReader","cjsConditions","getOptionValue","preserveSymlinks","preserveSymlinksMain","normalizeSlashes","createErrRequireEsm","codes","ERR_INVALID_MODULE_SPECIFIER","CHAR_FORWARD_SLASH","Module","isWindows","process","platform","statCache","stat","filename","toNamespacedPath","result","get","undefined","set","moduleParentCache","packageJsonCache","readPackage","requestPath","jsonPath","resolve","existing","read","json","containsKeys","string","parsed","filtered","name","main","exports","imports","type","e","message","readPackageScope","checkPath","rootSeparatorIndex","separatorIndex","pjson","data","createCjsLoader","opts","nodeEsmResolver","preferTsExts","replacementsForCjs","replacementsForJs","replacementsForMjs","replacementsForJsx","extensions","encodedSepRegEx","packageExportsResolve","packageImportsResolve","tryPackage","exts","isMain","originalPath","tmp","pkg","tryExtensions","actual","tryReplacementExtensions","tryFile","err","Error","code","emitWarning","realpathCache","rc","toRealPath","realpathSync","statReplacementExtensions","p","lastDotIndex","lastIndexOf","ext","slice","pathnameWithoutExtension","replacementExts","i","length","trySelfParentPath","parent","id","cwd","trySelf","parentPath","request","pkgPath","expansion","finalizeEsmResolution","resolved","createEsmNotFoundErr","EXPORTS_PATTERN","resolveExports","nmPath","hasModulePathCache","_pathCache","Module_pathCache","Object","create","Module_pathCache_get","cacheKey","Module_pathCache_set","value","trailingSlashRegex","Module_findPath","_findPath","paths","absoluteRequest","isAbsolute","entry","trailingSlash","curPath","exportsResolved","_basePath","basePath","_extensions","Module_resolveFilename","_resolveFilename","options","canBeRequiredByUsers","isRelative","fakeParent","_nodeModulePaths","lookupPaths","_resolveLookupPaths","j","ERR_INVALID_ARG_VALUE","selfResolved","requireStack","cursor","assertScriptCanLoadAsCJSImpl","service","module","tsNodeClassification","moduleTypeClassifier","classifyModuleByModuleTypeOverrides","moduleType","packageJsonPath"],"sources":["/Users/janrobel/Documents/PersonalProjekty/nftGenerateAi/clientAndContract/node_modules/ts-node/dist-raw/node-internal-modules-cjs-loader.js"],"sourcesContent":["// Copied from several files in node's source code.\n// https://github.com/nodejs/node/blob/2d5d77306f6dff9110c1f77fefab25f973415770/lib/internal/modules/cjs/loader.js\n// Each function and variable below must have a comment linking to the source in node's github repo.\n\n'use strict';\n\nconst {\n  ArrayIsArray,\n  ArrayPrototypeIncludes,\n  ArrayPrototypeJoin,\n  ArrayPrototypePush,\n  JSONParse,\n  ObjectKeys,\n  RegExpPrototypeTest,\n  SafeMap,\n  SafeWeakMap,\n  StringPrototypeCharCodeAt,\n  StringPrototypeEndsWith,\n  StringPrototypeLastIndexOf,\n  StringPrototypeIndexOf,\n  StringPrototypeMatch,\n  StringPrototypeSlice,\n  StringPrototypeStartsWith,\n} = require('./node-primordials');\nconst { NativeModule } = require('./node-nativemodule');\nconst { pathToFileURL, fileURLToPath } = require('url');\nconst fs = require('fs');\nconst path = require('path');\nconst { sep } = path;\nconst { internalModuleStat } = require('./node-internalBinding-fs');\nconst packageJsonReader = require('./node-internal-modules-package_json_reader');\nconst {\n  cjsConditions,\n} = require('./node-internal-modules-cjs-helpers');\nconst { getOptionValue } = require('./node-options');\nconst preserveSymlinks = getOptionValue('--preserve-symlinks');\nconst preserveSymlinksMain = getOptionValue('--preserve-symlinks-main');\nconst {normalizeSlashes} = require('../dist/util');\nconst {createErrRequireEsm} = require('./node-internal-errors');\nconst {\n  codes: {\n    ERR_INVALID_MODULE_SPECIFIER,\n  },\n} = require('./node-internal-errors');\n\nconst {\n  CHAR_FORWARD_SLASH,\n} = require('./node-internal-constants');\n\nconst Module = require('module');\n\nconst isWindows = process.platform === 'win32';\n\nlet statCache = null;\n\nfunction stat(filename) {\n  filename = path.toNamespacedPath(filename);\n  if (statCache !== null) {\n    const result = statCache.get(filename);\n    if (result !== undefined) return result;\n  }\n  const result = internalModuleStat(filename);\n  if (statCache !== null && result >= 0) {\n    // Only set cache when `internalModuleStat(filename)` succeeds.\n    statCache.set(filename, result);\n  }\n  return result;\n}\n\n// Note:\n// we cannot get access to node's internal cache, which is populated from\n// within node's Module constructor.  So the cache here will always be empty.\n// It's possible we could approximate our own cache by building it up with\n// hacky workarounds, but it's not worth the complexity and flakiness.\nconst moduleParentCache = new SafeWeakMap();\n\n// Given a module name, and a list of paths to test, returns the first\n// matching file in the following precedence.\n//\n// require(\"a.<ext>\")\n//   -> a.<ext>\n//\n// require(\"a\")\n//   -> a\n//   -> a.<ext>\n//   -> a/index.<ext>\n\nconst packageJsonCache = new SafeMap();\n\nfunction readPackage(requestPath) {\n  const jsonPath = path.resolve(requestPath, 'package.json');\n\n  const existing = packageJsonCache.get(jsonPath);\n  if (existing !== undefined) return existing;\n\n  const result = packageJsonReader.read(jsonPath);\n  const json = result.containsKeys === false ? '{}' : result.string;\n  if (json === undefined) {\n    packageJsonCache.set(jsonPath, false);\n    return false;\n  }\n\n  try {\n    const parsed = JSONParse(json);\n    const filtered = {\n      name: parsed.name,\n      main: parsed.main,\n      exports: parsed.exports,\n      imports: parsed.imports,\n      type: parsed.type\n    };\n    packageJsonCache.set(jsonPath, filtered);\n    return filtered;\n  } catch (e) {\n    e.path = jsonPath;\n    e.message = 'Error parsing ' + jsonPath + ': ' + e.message;\n    throw e;\n  }\n}\n\nfunction readPackageScope(checkPath) {\n  const rootSeparatorIndex = StringPrototypeIndexOf(checkPath, sep);\n  let separatorIndex;\n  do {\n    separatorIndex = StringPrototypeLastIndexOf(checkPath, sep);\n    checkPath = StringPrototypeSlice(checkPath, 0, separatorIndex);\n    if (StringPrototypeEndsWith(checkPath, sep + 'node_modules'))\n      return false;\n    const pjson = readPackage(checkPath + sep);\n    if (pjson) return {\n      data: pjson,\n      path: checkPath,\n    };\n  } while (separatorIndex > rootSeparatorIndex);\n  return false;\n}\n\n/**\n * @param {{\n *   nodeEsmResolver: ReturnType<typeof import('./node-internal-modules-esm-resolve').createResolve>,\n *   extensions: import('../src/file-extensions').Extensions,\n *   preferTsExts\n * }} opts\n */\nfunction createCjsLoader(opts) {\nconst {nodeEsmResolver, preferTsExts} = opts;\nconst {replacementsForCjs, replacementsForJs, replacementsForMjs, replacementsForJsx} = opts.extensions;\nconst {\n  encodedSepRegEx,\n  packageExportsResolve,\n  packageImportsResolve\n} = nodeEsmResolver;\n\nfunction tryPackage(requestPath, exts, isMain, originalPath) {\n  // const pkg = readPackage(requestPath)?.main;\n  const tmp = readPackage(requestPath)\n  const pkg = tmp != null ? tmp.main : undefined;\n\n  if (!pkg) {\n    return tryExtensions(path.resolve(requestPath, 'index'), exts, isMain);\n  }\n\n  const filename = path.resolve(requestPath, pkg);\n  let actual = tryReplacementExtensions(filename, isMain) ||\n    tryFile(filename, isMain) ||\n    tryExtensions(filename, exts, isMain) ||\n    tryExtensions(path.resolve(filename, 'index'), exts, isMain);\n  if (actual === false) {\n    actual = tryExtensions(path.resolve(requestPath, 'index'), exts, isMain);\n    if (!actual) {\n      // eslint-disable-next-line no-restricted-syntax\n      const err = new Error(\n        `Cannot find module '${filename}'. ` +\n        'Please verify that the package.json has a valid \"main\" entry'\n      );\n      err.code = 'MODULE_NOT_FOUND';\n      err.path = path.resolve(requestPath, 'package.json');\n      err.requestPath = originalPath;\n      // TODO(BridgeAR): Add the requireStack as well.\n      throw err;\n    } else {\n      const jsonPath = path.resolve(requestPath, 'package.json');\n      process.emitWarning(\n        `Invalid 'main' field in '${jsonPath}' of '${pkg}'. ` +\n          'Please either fix that or report it to the module author',\n        'DeprecationWarning',\n        'DEP0128'\n      );\n    }\n  }\n  return actual;\n}\n\n// In order to minimize unnecessary lstat() calls,\n// this cache is a list of known-real paths.\n// Set to an empty Map to reset.\nconst realpathCache = new SafeMap();\n\n// Check if the file exists and is not a directory\n// if using --preserve-symlinks and isMain is false,\n// keep symlinks intact, otherwise resolve to the\n// absolute realpath.\nfunction tryFile(requestPath, isMain) {\n  const rc = stat(requestPath);\n  if (rc !== 0) return;\n  if (preserveSymlinks && !isMain) {\n    return path.resolve(requestPath);\n  }\n  return toRealPath(requestPath);\n}\n\nfunction toRealPath(requestPath) {\n  return fs.realpathSync(requestPath, {\n    // [internalFS.realpathCacheKey]: realpathCache\n  });\n}\n\nfunction statReplacementExtensions(p) {\n  const lastDotIndex = p.lastIndexOf('.');\n  if(lastDotIndex >= 0) {\n    const ext = p.slice(lastDotIndex);\n    if (ext === '.js' || ext === '.jsx' || ext === '.mjs' || ext === '.cjs') {\n      const pathnameWithoutExtension = p.slice(0, lastDotIndex);\n      const replacementExts =\n        ext === '.js' ? replacementsForJs\n        : ext === '.jsx' ? replacementsForJsx\n        : ext === '.mjs' ? replacementsForMjs\n        : replacementsForCjs;\n      for (let i = 0; i < replacementExts.length; i++) {\n        const filename = pathnameWithoutExtension + replacementExts[i];\n        const rc = stat(filename);\n        if (rc === 0) {\n          return [rc, filename];\n        }\n      }\n    }\n  }\n  return [stat(p), p];\n}\nfunction tryReplacementExtensions(p, isMain) {\n  const lastDotIndex = p.lastIndexOf('.');\n  if(lastDotIndex >= 0) {\n    const ext = p.slice(lastDotIndex);\n    if (ext === '.js' || ext === '.jsx' || ext === '.mjs' || ext === '.cjs') {\n      const pathnameWithoutExtension = p.slice(0, lastDotIndex);\n      const replacementExts =\n        ext === '.js' ? replacementsForJs\n        : ext === '.jsx' ? replacementsForJsx\n        : ext === '.mjs' ? replacementsForMjs\n        : replacementsForCjs;\n      for (let i = 0; i < replacementExts.length; i++) {\n        const filename = tryFile(pathnameWithoutExtension + replacementExts[i], isMain);\n        if (filename) {\n          return filename;\n        }\n      }\n    }\n  }\n  return false;\n}\n\n// Given a path, check if the file exists with any of the set extensions\nfunction tryExtensions(p, exts, isMain) {\n  for (let i = 0; i < exts.length; i++) {\n    const filename = tryFile(p + exts[i], isMain);\n\n    if (filename) {\n      return filename;\n    }\n  }\n  return false;\n}\n\nfunction trySelfParentPath(parent) {\n  if (!parent) return false;\n\n  if (parent.filename) {\n    return parent.filename;\n  } else if (parent.id === '<repl>' || parent.id === 'internal/preload') {\n    try {\n      return process.cwd() + path.sep;\n    } catch {\n      return false;\n    }\n  }\n}\n\nfunction trySelf(parentPath, request) {\n  if (!parentPath) return false;\n\n  const { data: pkg, path: pkgPath } = readPackageScope(parentPath) || {};\n  if (!pkg || pkg.exports === undefined) return false;\n  if (typeof pkg.name !== 'string') return false;\n\n  let expansion;\n  if (request === pkg.name) {\n    expansion = '.';\n  } else if (StringPrototypeStartsWith(request, `${pkg.name}/`)) {\n    expansion = '.' + StringPrototypeSlice(request, pkg.name.length);\n  } else {\n    return false;\n  }\n\n  try {\n    return finalizeEsmResolution(packageExportsResolve(\n      pathToFileURL(pkgPath + '/package.json'), expansion, pkg,\n      pathToFileURL(parentPath), cjsConditions).resolved, parentPath, pkgPath);\n  } catch (e) {\n    if (e.code === 'ERR_MODULE_NOT_FOUND')\n      throw createEsmNotFoundErr(request, pkgPath + '/package.json');\n    throw e;\n  }\n}\n\n// This only applies to requests of a specific form:\n// 1. name/.*\n// 2. @scope/name/.*\nconst EXPORTS_PATTERN = /^((?:@[^/\\\\%]+\\/)?[^./\\\\%][^/\\\\%]*)(\\/.*)?$/;\nfunction resolveExports(nmPath, request) {\n  // The implementation's behavior is meant to mirror resolution in ESM.\n  const { 1: name, 2: expansion = '' } =\n    StringPrototypeMatch(request, EXPORTS_PATTERN) || [];\n  if (!name)\n    return;\n  const pkgPath = path.resolve(nmPath, name);\n  const pkg = readPackage(pkgPath);\n  // if (pkg?.exports != null) {\n  if (pkg != null && pkg.exports != null) {\n    try {\n      return finalizeEsmResolution(packageExportsResolve(\n        pathToFileURL(pkgPath + '/package.json'), '.' + expansion, pkg, null,\n        cjsConditions).resolved, null, pkgPath);\n    } catch (e) {\n      if (e.code === 'ERR_MODULE_NOT_FOUND')\n        throw createEsmNotFoundErr(request, pkgPath + '/package.json');\n      throw e;\n    }\n  }\n}\n\n// Backwards compat for old node versions\nconst hasModulePathCache = !!require('module')._pathCache;\nconst Module_pathCache = Object.create(null);\nconst Module_pathCache_get = hasModulePathCache ? (cacheKey) => Module._pathCache[cacheKey] : (cacheKey) => Module_pathCache[cacheKey];\nconst Module_pathCache_set = hasModulePathCache ? (cacheKey, value) => (Module._pathCache[cacheKey] = value) : (cacheKey) => (Module_pathCache[cacheKey] = value);\n\nconst trailingSlashRegex = /(?:^|\\/)\\.?\\.$/;\nconst Module_findPath = function _findPath(request, paths, isMain) {\n  const absoluteRequest = path.isAbsolute(request);\n  if (absoluteRequest) {\n    paths = [''];\n  } else if (!paths || paths.length === 0) {\n    return false;\n  }\n\n  const cacheKey = request + '\\x00' + ArrayPrototypeJoin(paths, '\\x00');\n  const entry = Module_pathCache_get(cacheKey);\n  if (entry)\n    return entry;\n\n  let exts;\n  let trailingSlash = request.length > 0 &&\n    StringPrototypeCharCodeAt(request, request.length - 1) ===\n    CHAR_FORWARD_SLASH;\n  if (!trailingSlash) {\n    trailingSlash = RegExpPrototypeTest(trailingSlashRegex, request);\n  }\n\n  // For each path\n  for (let i = 0; i < paths.length; i++) {\n    // Don't search further if path doesn't exist\n    const curPath = paths[i];\n    if (curPath && stat(curPath) < 1) continue;\n\n    if (!absoluteRequest) {\n      const exportsResolved = resolveExports(curPath, request);\n      if (exportsResolved)\n        return exportsResolved;\n    }\n\n    const _basePath = path.resolve(curPath, request);\n    let filename;\n\n    const [rc, basePath] = statReplacementExtensions(_basePath);\n    if (!trailingSlash) {\n      if (rc === 0) {  // File.\n        if (!isMain) {\n          if (preserveSymlinks) {\n            filename = path.resolve(basePath);\n          } else {\n            filename = toRealPath(basePath);\n          }\n        } else if (preserveSymlinksMain) {\n          // For the main module, we use the preserveSymlinksMain flag instead\n          // mainly for backward compatibility, as the preserveSymlinks flag\n          // historically has not applied to the main module.  Most likely this\n          // was intended to keep .bin/ binaries working, as following those\n          // symlinks is usually required for the imports in the corresponding\n          // files to resolve; that said, in some use cases following symlinks\n          // causes bigger problems which is why the preserveSymlinksMain option\n          // is needed.\n          filename = path.resolve(basePath);\n        } else {\n          filename = toRealPath(basePath);\n        }\n      }\n\n      if (!filename) {\n        // Try it with each of the extensions\n        if (exts === undefined)\n          exts = ObjectKeys(Module._extensions);\n        filename = tryExtensions(basePath, exts, isMain);\n      }\n    }\n\n    if (!filename && rc === 1) {  // Directory.\n      // try it with each of the extensions at \"index\"\n      if (exts === undefined)\n        exts = ObjectKeys(Module._extensions);\n      filename = tryPackage(basePath, exts, isMain, request);\n    }\n\n    if (filename) {\n      Module_pathCache_set(cacheKey, filename);\n      return filename;\n    }\n  }\n\n  return false;\n};\n\nconst Module_resolveFilename = function _resolveFilename(request, parent, isMain, options) {\n  if (StringPrototypeStartsWith(request, 'node:') ||\n      NativeModule.canBeRequiredByUsers(request)) {\n    return request;\n  }\n\n  let paths;\n\n  if (typeof options === 'object' && options !== null) {\n    if (ArrayIsArray(options.paths)) {\n      const isRelative = StringPrototypeStartsWith(request, './') ||\n          StringPrototypeStartsWith(request, '../') ||\n          ((isWindows && StringPrototypeStartsWith(request, '.\\\\')) ||\n          StringPrototypeStartsWith(request, '..\\\\'));\n\n      if (isRelative) {\n        paths = options.paths;\n      } else {\n        const fakeParent = new Module('', null);\n\n        paths = [];\n\n        for (let i = 0; i < options.paths.length; i++) {\n          const path = options.paths[i];\n          fakeParent.paths = Module._nodeModulePaths(path);\n          const lookupPaths = Module._resolveLookupPaths(request, fakeParent);\n\n          for (let j = 0; j < lookupPaths.length; j++) {\n            if (!ArrayPrototypeIncludes(paths, lookupPaths[j]))\n              ArrayPrototypePush(paths, lookupPaths[j]);\n          }\n        }\n      }\n    } else if (options.paths === undefined) {\n      paths = Module._resolveLookupPaths(request, parent);\n    } else {\n      throw new ERR_INVALID_ARG_VALUE('options.paths', options.paths);\n    }\n  } else {\n    paths = Module._resolveLookupPaths(request, parent);\n  }\n\n  // if (parent?.filename) {\n  // node 12 hack\n  if (parent != null && parent.filename) {\n    if (request[0] === '#') {\n      const pkg = readPackageScope(parent.filename) || {};\n\n      // if (pkg.data?.imports != null) {\n      // node 12 hack\n      if (pkg.data != null && pkg.data.imports != null) {\n        try {\n          return finalizeEsmResolution(\n            packageImportsResolve(request, pathToFileURL(parent.filename),\n                                  cjsConditions), parent.filename,\n            pkg.path);\n        } catch (e) {\n          if (e.code === 'ERR_MODULE_NOT_FOUND')\n            throw createEsmNotFoundErr(request);\n          throw e;\n        }\n      }\n    }\n  }\n\n  // Try module self resolution first\n  const parentPath = trySelfParentPath(parent);\n  const selfResolved = trySelf(parentPath, request);\n  if (selfResolved) {\n    const cacheKey = request + '\\x00' +\n         (paths.length === 1 ? paths[0] : ArrayPrototypeJoin(paths, '\\x00'));\n    Module._pathCache[cacheKey] = selfResolved;\n    return selfResolved;\n  }\n\n  // Look up the filename first, since that's the cache key.\n  const filename = Module._findPath(request, paths, isMain, false);\n  if (filename) return filename;\n  const requireStack = [];\n  for (let cursor = parent;\n    cursor;\n    cursor = moduleParentCache.get(cursor)) {\n    ArrayPrototypePush(requireStack, cursor.filename || cursor.id);\n  }\n  let message = `Cannot find module '${request}'`;\n  if (requireStack.length > 0) {\n    message = message + '\\nRequire stack:\\n- ' +\n              ArrayPrototypeJoin(requireStack, '\\n- ');\n  }\n  // eslint-disable-next-line no-restricted-syntax\n  const err = new Error(message);\n  err.code = 'MODULE_NOT_FOUND';\n  err.requireStack = requireStack;\n  throw err;\n};\n\nfunction finalizeEsmResolution(resolved, parentPath, pkgPath) {\n  if (RegExpPrototypeTest(encodedSepRegEx, resolved))\n    throw new ERR_INVALID_MODULE_SPECIFIER(\n      resolved, 'must not include encoded \"/\" or \"\\\\\" characters', parentPath);\n  const filename = fileURLToPath(resolved);\n  const actual = tryReplacementExtensions(filename) || tryFile(filename);\n  if (actual)\n    return actual;\n  const err = createEsmNotFoundErr(filename,\n                                   path.resolve(pkgPath, 'package.json'));\n  throw err;\n}\n\nfunction createEsmNotFoundErr(request, path) {\n  // eslint-disable-next-line no-restricted-syntax\n  const err = new Error(`Cannot find module '${request}'`);\n  err.code = 'MODULE_NOT_FOUND';\n  if (path)\n    err.path = path;\n  // TODO(BridgeAR): Add the requireStack as well.\n  return err;\n}\n\n\nreturn {\n  Module_findPath,\n  Module_resolveFilename\n}\n\n}\n\n/**\n * copied from Module._extensions['.js']\n * https://github.com/nodejs/node/blob/v15.3.0/lib/internal/modules/cjs/loader.js#L1113-L1120\n * @param {import('../src/index').Service} service\n * @param {NodeJS.Module} module\n * @param {string} filename\n */\nfunction assertScriptCanLoadAsCJSImpl(service, module, filename) {\n  const pkg = readPackageScope(filename);\n\n  // ts-node modification: allow our configuration to override\n  const tsNodeClassification = service.moduleTypeClassifier.classifyModuleByModuleTypeOverrides(normalizeSlashes(filename));\n  if(tsNodeClassification.moduleType === 'cjs') return;\n\n  // ignore package.json when file extension is ESM-only or CJS-only\n  // [MUST_UPDATE_FOR_NEW_FILE_EXTENSIONS]\n  const lastDotIndex = filename.lastIndexOf('.');\n  const ext = lastDotIndex >= 0 ? filename.slice(lastDotIndex) : '';\n\n  if((ext === '.cts' || ext === '.cjs') && tsNodeClassification.moduleType === 'auto') return;\n\n  // Function require shouldn't be used in ES modules.\n  if (ext === '.mts' || ext === '.mjs' || tsNodeClassification.moduleType === 'esm' || (pkg && pkg.data && pkg.data.type === 'module')) {\n    const parentPath = module.parent && module.parent.filename;\n    const packageJsonPath = pkg ? path.resolve(pkg.path, 'package.json') : null;\n    throw createErrRequireEsm(filename, parentPath, packageJsonPath);\n  }\n}\n\n\nmodule.exports = {\n  createCjsLoader,\n  assertScriptCanLoadAsCJSImpl,\n  readPackageScope\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}