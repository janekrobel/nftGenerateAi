{"ast":null,"code":"'use strict';\n\n/* global WebAssembly */\nconst assert = require('assert');\nconst net = require('net');\nconst util = require('./core/util');\nconst timers = require('./timers');\nconst Request = require('./core/request');\nconst DispatcherBase = require('./dispatcher-base');\nconst {\n  RequestContentLengthMismatchError,\n  ResponseContentLengthMismatchError,\n  InvalidArgumentError,\n  RequestAbortedError,\n  HeadersTimeoutError,\n  HeadersOverflowError,\n  SocketError,\n  InformationalError,\n  BodyTimeoutError,\n  HTTPParserError,\n  ResponseExceededMaxSizeError\n} = require('./core/errors');\nconst buildConnector = require('./core/connect');\nconst {\n  kUrl,\n  kReset,\n  kServerName,\n  kClient,\n  kBusy,\n  kParser,\n  kConnect,\n  kBlocking,\n  kResuming,\n  kRunning,\n  kPending,\n  kSize,\n  kWriting,\n  kQueue,\n  kConnected,\n  kConnecting,\n  kNeedDrain,\n  kNoRef,\n  kKeepAliveDefaultTimeout,\n  kHostHeader,\n  kPendingIdx,\n  kRunningIdx,\n  kError,\n  kPipelining,\n  kSocket,\n  kKeepAliveTimeoutValue,\n  kMaxHeadersSize,\n  kKeepAliveMaxTimeout,\n  kKeepAliveTimeoutThreshold,\n  kHeadersTimeout,\n  kBodyTimeout,\n  kStrictContentLength,\n  kConnector,\n  kMaxRedirections,\n  kMaxRequests,\n  kCounter,\n  kClose,\n  kDestroy,\n  kDispatch,\n  kInterceptors,\n  kLocalAddress,\n  kMaxResponseSize\n} = require('./core/symbols');\nconst FastBuffer = Buffer[Symbol.species];\nconst kClosedResolve = Symbol('kClosedResolve');\nconst channels = {};\ntry {\n  const diagnosticsChannel = require('diagnostics_channel');\n  channels.sendHeaders = diagnosticsChannel.channel('undici:client:sendHeaders');\n  channels.beforeConnect = diagnosticsChannel.channel('undici:client:beforeConnect');\n  channels.connectError = diagnosticsChannel.channel('undici:client:connectError');\n  channels.connected = diagnosticsChannel.channel('undici:client:connected');\n} catch {\n  channels.sendHeaders = {\n    hasSubscribers: false\n  };\n  channels.beforeConnect = {\n    hasSubscribers: false\n  };\n  channels.connectError = {\n    hasSubscribers: false\n  };\n  channels.connected = {\n    hasSubscribers: false\n  };\n}\nclass Client extends DispatcherBase {\n  constructor(url) {\n    let {\n      interceptors,\n      maxHeaderSize,\n      headersTimeout,\n      socketTimeout,\n      requestTimeout,\n      connectTimeout,\n      bodyTimeout,\n      idleTimeout,\n      keepAlive,\n      keepAliveTimeout,\n      maxKeepAliveTimeout,\n      keepAliveMaxTimeout,\n      keepAliveTimeoutThreshold,\n      socketPath,\n      pipelining,\n      tls,\n      strictContentLength,\n      maxCachedSessions,\n      maxRedirections,\n      connect,\n      maxRequestsPerClient,\n      localAddress,\n      maxResponseSize,\n      autoSelectFamily,\n      autoSelectFamilyAttemptTimeout\n    } = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    super();\n    if (keepAlive !== undefined) {\n      throw new InvalidArgumentError('unsupported keepAlive, use pipelining=0 instead');\n    }\n    if (socketTimeout !== undefined) {\n      throw new InvalidArgumentError('unsupported socketTimeout, use headersTimeout & bodyTimeout instead');\n    }\n    if (requestTimeout !== undefined) {\n      throw new InvalidArgumentError('unsupported requestTimeout, use headersTimeout & bodyTimeout instead');\n    }\n    if (idleTimeout !== undefined) {\n      throw new InvalidArgumentError('unsupported idleTimeout, use keepAliveTimeout instead');\n    }\n    if (maxKeepAliveTimeout !== undefined) {\n      throw new InvalidArgumentError('unsupported maxKeepAliveTimeout, use keepAliveMaxTimeout instead');\n    }\n    if (maxHeaderSize != null && !Number.isFinite(maxHeaderSize)) {\n      throw new InvalidArgumentError('invalid maxHeaderSize');\n    }\n    if (socketPath != null && typeof socketPath !== 'string') {\n      throw new InvalidArgumentError('invalid socketPath');\n    }\n    if (connectTimeout != null && (!Number.isFinite(connectTimeout) || connectTimeout < 0)) {\n      throw new InvalidArgumentError('invalid connectTimeout');\n    }\n    if (keepAliveTimeout != null && (!Number.isFinite(keepAliveTimeout) || keepAliveTimeout <= 0)) {\n      throw new InvalidArgumentError('invalid keepAliveTimeout');\n    }\n    if (keepAliveMaxTimeout != null && (!Number.isFinite(keepAliveMaxTimeout) || keepAliveMaxTimeout <= 0)) {\n      throw new InvalidArgumentError('invalid keepAliveMaxTimeout');\n    }\n    if (keepAliveTimeoutThreshold != null && !Number.isFinite(keepAliveTimeoutThreshold)) {\n      throw new InvalidArgumentError('invalid keepAliveTimeoutThreshold');\n    }\n    if (headersTimeout != null && (!Number.isInteger(headersTimeout) || headersTimeout < 0)) {\n      throw new InvalidArgumentError('headersTimeout must be a positive integer or zero');\n    }\n    if (bodyTimeout != null && (!Number.isInteger(bodyTimeout) || bodyTimeout < 0)) {\n      throw new InvalidArgumentError('bodyTimeout must be a positive integer or zero');\n    }\n    if (connect != null && typeof connect !== 'function' && typeof connect !== 'object') {\n      throw new InvalidArgumentError('connect must be a function or an object');\n    }\n    if (maxRedirections != null && (!Number.isInteger(maxRedirections) || maxRedirections < 0)) {\n      throw new InvalidArgumentError('maxRedirections must be a positive number');\n    }\n    if (maxRequestsPerClient != null && (!Number.isInteger(maxRequestsPerClient) || maxRequestsPerClient < 0)) {\n      throw new InvalidArgumentError('maxRequestsPerClient must be a positive number');\n    }\n    if (localAddress != null && (typeof localAddress !== 'string' || net.isIP(localAddress) === 0)) {\n      throw new InvalidArgumentError('localAddress must be valid string IP address');\n    }\n    if (maxResponseSize != null && (!Number.isInteger(maxResponseSize) || maxResponseSize < -1)) {\n      throw new InvalidArgumentError('maxResponseSize must be a positive number');\n    }\n    if (autoSelectFamilyAttemptTimeout != null && (!Number.isInteger(autoSelectFamilyAttemptTimeout) || autoSelectFamilyAttemptTimeout < -1)) {\n      throw new InvalidArgumentError('autoSelectFamilyAttemptTimeout must be a positive number');\n    }\n    if (typeof connect !== 'function') {\n      connect = buildConnector({\n        ...tls,\n        maxCachedSessions,\n        socketPath,\n        timeout: connectTimeout,\n        ...(util.nodeHasAutoSelectFamily && autoSelectFamily ? {\n          autoSelectFamily,\n          autoSelectFamilyAttemptTimeout\n        } : undefined),\n        ...connect\n      });\n    }\n    this[kInterceptors] = interceptors && interceptors.Client && Array.isArray(interceptors.Client) ? interceptors.Client : [createRedirectInterceptor({\n      maxRedirections\n    })];\n    this[kUrl] = util.parseOrigin(url);\n    this[kConnector] = connect;\n    this[kSocket] = null;\n    this[kPipelining] = pipelining != null ? pipelining : 1;\n    this[kMaxHeadersSize] = maxHeaderSize || 16384;\n    this[kKeepAliveDefaultTimeout] = keepAliveTimeout == null ? 4e3 : keepAliveTimeout;\n    this[kKeepAliveMaxTimeout] = keepAliveMaxTimeout == null ? 600e3 : keepAliveMaxTimeout;\n    this[kKeepAliveTimeoutThreshold] = keepAliveTimeoutThreshold == null ? 1e3 : keepAliveTimeoutThreshold;\n    this[kKeepAliveTimeoutValue] = this[kKeepAliveDefaultTimeout];\n    this[kServerName] = null;\n    this[kLocalAddress] = localAddress != null ? localAddress : null;\n    this[kResuming] = 0; // 0, idle, 1, scheduled, 2 resuming\n    this[kNeedDrain] = 0; // 0, idle, 1, scheduled, 2 resuming\n    this[kHostHeader] = `host: ${this[kUrl].hostname}${this[kUrl].port ? `:${this[kUrl].port}` : ''}\\r\\n`;\n    this[kBodyTimeout] = bodyTimeout != null ? bodyTimeout : 300e3;\n    this[kHeadersTimeout] = headersTimeout != null ? headersTimeout : 300e3;\n    this[kStrictContentLength] = strictContentLength == null ? true : strictContentLength;\n    this[kMaxRedirections] = maxRedirections;\n    this[kMaxRequests] = maxRequestsPerClient;\n    this[kClosedResolve] = null;\n    this[kMaxResponseSize] = maxResponseSize > -1 ? maxResponseSize : -1;\n\n    // kQueue is built up of 3 sections separated by\n    // the kRunningIdx and kPendingIdx indices.\n    // |   complete   |   running   |   pending   |\n    //                ^ kRunningIdx ^ kPendingIdx ^ kQueue.length\n    // kRunningIdx points to the first running element.\n    // kPendingIdx points to the first pending element.\n    // This implements a fast queue with an amortized\n    // time of O(1).\n\n    this[kQueue] = [];\n    this[kRunningIdx] = 0;\n    this[kPendingIdx] = 0;\n  }\n  get pipelining() {\n    return this[kPipelining];\n  }\n  set pipelining(value) {\n    this[kPipelining] = value;\n    resume(this, true);\n  }\n  get [kPending]() {\n    return this[kQueue].length - this[kPendingIdx];\n  }\n  get [kRunning]() {\n    return this[kPendingIdx] - this[kRunningIdx];\n  }\n  get [kSize]() {\n    return this[kQueue].length - this[kRunningIdx];\n  }\n  get [kConnected]() {\n    return !!this[kSocket] && !this[kConnecting] && !this[kSocket].destroyed;\n  }\n  get [kBusy]() {\n    const socket = this[kSocket];\n    return socket && (socket[kReset] || socket[kWriting] || socket[kBlocking]) || this[kSize] >= (this[kPipelining] || 1) || this[kPending] > 0;\n  }\n\n  /* istanbul ignore: only used for test */\n  [kConnect](cb) {\n    connect(this);\n    this.once('connect', cb);\n  }\n  [kDispatch](opts, handler) {\n    const origin = opts.origin || this[kUrl].origin;\n    const request = new Request(origin, opts, handler);\n    this[kQueue].push(request);\n    if (this[kResuming]) {\n      // Do nothing.\n    } else if (util.bodyLength(request.body) == null && util.isIterable(request.body)) {\n      // Wait a tick in case stream/iterator is ended in the same tick.\n      this[kResuming] = 1;\n      process.nextTick(resume, this);\n    } else {\n      resume(this, true);\n    }\n    if (this[kResuming] && this[kNeedDrain] !== 2 && this[kBusy]) {\n      this[kNeedDrain] = 2;\n    }\n    return this[kNeedDrain] < 2;\n  }\n  async [kClose]() {\n    return new Promise(resolve => {\n      if (!this[kSize]) {\n        this.destroy(resolve);\n      } else {\n        this[kClosedResolve] = resolve;\n      }\n    });\n  }\n  async [kDestroy](err) {\n    return new Promise(resolve => {\n      const requests = this[kQueue].splice(this[kPendingIdx]);\n      for (let i = 0; i < requests.length; i++) {\n        const request = requests[i];\n        errorRequest(this, request, err);\n      }\n      const callback = () => {\n        if (this[kClosedResolve]) {\n          this[kClosedResolve]();\n          this[kClosedResolve] = null;\n        }\n        resolve();\n      };\n      if (!this[kSocket]) {\n        queueMicrotask(callback);\n      } else {\n        util.destroy(this[kSocket].on('close', callback), err);\n      }\n      resume(this);\n    });\n  }\n}\nconst constants = require('./llhttp/constants');\nconst createRedirectInterceptor = require('./interceptor/redirectInterceptor');\nconst EMPTY_BUF = Buffer.alloc(0);\nasync function lazyllhttp() {\n  const llhttpWasmData = process.env.JEST_WORKER_ID ? require('./llhttp/llhttp.wasm.js') : undefined;\n  let mod;\n  try {\n    mod = await WebAssembly.compile(Buffer.from(require('./llhttp/llhttp_simd.wasm.js'), 'base64'));\n  } catch (e) {\n    /* istanbul ignore next */\n\n    // We could check if the error was caused by the simd option not\n    // being enabled, but the occurring of this other error\n    // * https://github.com/emscripten-core/emscripten/issues/11495\n    // got me to remove that check to avoid breaking Node 12.\n    mod = await WebAssembly.compile(Buffer.from(llhttpWasmData || require('./llhttp/llhttp.wasm.js'), 'base64'));\n  }\n  return await WebAssembly.instantiate(mod, {\n    env: {\n      /* eslint-disable camelcase */\n\n      wasm_on_url: (p, at, len) => {\n        /* istanbul ignore next */\n        return 0;\n      },\n      wasm_on_status: (p, at, len) => {\n        assert.strictEqual(currentParser.ptr, p);\n        const start = at - currentBufferPtr + currentBufferRef.byteOffset;\n        return currentParser.onStatus(new FastBuffer(currentBufferRef.buffer, start, len)) || 0;\n      },\n      wasm_on_message_begin: p => {\n        assert.strictEqual(currentParser.ptr, p);\n        return currentParser.onMessageBegin() || 0;\n      },\n      wasm_on_header_field: (p, at, len) => {\n        assert.strictEqual(currentParser.ptr, p);\n        const start = at - currentBufferPtr + currentBufferRef.byteOffset;\n        return currentParser.onHeaderField(new FastBuffer(currentBufferRef.buffer, start, len)) || 0;\n      },\n      wasm_on_header_value: (p, at, len) => {\n        assert.strictEqual(currentParser.ptr, p);\n        const start = at - currentBufferPtr + currentBufferRef.byteOffset;\n        return currentParser.onHeaderValue(new FastBuffer(currentBufferRef.buffer, start, len)) || 0;\n      },\n      wasm_on_headers_complete: (p, statusCode, upgrade, shouldKeepAlive) => {\n        assert.strictEqual(currentParser.ptr, p);\n        return currentParser.onHeadersComplete(statusCode, Boolean(upgrade), Boolean(shouldKeepAlive)) || 0;\n      },\n      wasm_on_body: (p, at, len) => {\n        assert.strictEqual(currentParser.ptr, p);\n        const start = at - currentBufferPtr + currentBufferRef.byteOffset;\n        return currentParser.onBody(new FastBuffer(currentBufferRef.buffer, start, len)) || 0;\n      },\n      wasm_on_message_complete: p => {\n        assert.strictEqual(currentParser.ptr, p);\n        return currentParser.onMessageComplete() || 0;\n      }\n\n      /* eslint-enable camelcase */\n    }\n  });\n}\n\nlet llhttpInstance = null;\nlet llhttpPromise = lazyllhttp();\nllhttpPromise.catch();\nlet currentParser = null;\nlet currentBufferRef = null;\nlet currentBufferSize = 0;\nlet currentBufferPtr = null;\nconst TIMEOUT_HEADERS = 1;\nconst TIMEOUT_BODY = 2;\nconst TIMEOUT_IDLE = 3;\nclass Parser {\n  constructor(client, socket, _ref) {\n    let {\n      exports\n    } = _ref;\n    assert(Number.isFinite(client[kMaxHeadersSize]) && client[kMaxHeadersSize] > 0);\n    this.llhttp = exports;\n    this.ptr = this.llhttp.llhttp_alloc(constants.TYPE.RESPONSE);\n    this.client = client;\n    this.socket = socket;\n    this.timeout = null;\n    this.timeoutValue = null;\n    this.timeoutType = null;\n    this.statusCode = null;\n    this.statusText = '';\n    this.upgrade = false;\n    this.headers = [];\n    this.headersSize = 0;\n    this.headersMaxSize = client[kMaxHeadersSize];\n    this.shouldKeepAlive = false;\n    this.paused = false;\n    this.resume = this.resume.bind(this);\n    this.bytesRead = 0;\n    this.keepAlive = '';\n    this.contentLength = '';\n    this.connection = '';\n    this.maxResponseSize = client[kMaxResponseSize];\n  }\n  setTimeout(value, type) {\n    this.timeoutType = type;\n    if (value !== this.timeoutValue) {\n      timers.clearTimeout(this.timeout);\n      if (value) {\n        this.timeout = timers.setTimeout(onParserTimeout, value, this);\n        // istanbul ignore else: only for jest\n        if (this.timeout.unref) {\n          this.timeout.unref();\n        }\n      } else {\n        this.timeout = null;\n      }\n      this.timeoutValue = value;\n    } else if (this.timeout) {\n      // istanbul ignore else: only for jest\n      if (this.timeout.refresh) {\n        this.timeout.refresh();\n      }\n    }\n  }\n  resume() {\n    if (this.socket.destroyed || !this.paused) {\n      return;\n    }\n    assert(this.ptr != null);\n    assert(currentParser == null);\n    this.llhttp.llhttp_resume(this.ptr);\n    assert(this.timeoutType === TIMEOUT_BODY);\n    if (this.timeout) {\n      // istanbul ignore else: only for jest\n      if (this.timeout.refresh) {\n        this.timeout.refresh();\n      }\n    }\n    this.paused = false;\n    this.execute(this.socket.read() || EMPTY_BUF); // Flush parser.\n    this.readMore();\n  }\n  readMore() {\n    while (!this.paused && this.ptr) {\n      const chunk = this.socket.read();\n      if (chunk === null) {\n        break;\n      }\n      this.execute(chunk);\n    }\n  }\n  execute(data) {\n    assert(this.ptr != null);\n    assert(currentParser == null);\n    assert(!this.paused);\n    const {\n      socket,\n      llhttp\n    } = this;\n    if (data.length > currentBufferSize) {\n      if (currentBufferPtr) {\n        llhttp.free(currentBufferPtr);\n      }\n      currentBufferSize = Math.ceil(data.length / 4096) * 4096;\n      currentBufferPtr = llhttp.malloc(currentBufferSize);\n    }\n    new Uint8Array(llhttp.memory.buffer, currentBufferPtr, currentBufferSize).set(data);\n\n    // Call `execute` on the wasm parser.\n    // We pass the `llhttp_parser` pointer address, the pointer address of buffer view data,\n    // and finally the length of bytes to parse.\n    // The return value is an error code or `constants.ERROR.OK`.\n    try {\n      let ret;\n      try {\n        currentBufferRef = data;\n        currentParser = this;\n        ret = llhttp.llhttp_execute(this.ptr, currentBufferPtr, data.length);\n        /* eslint-disable-next-line no-useless-catch */\n      } catch (err) {\n        /* istanbul ignore next: difficult to make a test case for */\n        throw err;\n      } finally {\n        currentParser = null;\n        currentBufferRef = null;\n      }\n      const offset = llhttp.llhttp_get_error_pos(this.ptr) - currentBufferPtr;\n      if (ret === constants.ERROR.PAUSED_UPGRADE) {\n        this.onUpgrade(data.slice(offset));\n      } else if (ret === constants.ERROR.PAUSED) {\n        this.paused = true;\n        socket.unshift(data.slice(offset));\n      } else if (ret !== constants.ERROR.OK) {\n        const ptr = llhttp.llhttp_get_error_reason(this.ptr);\n        let message = '';\n        /* istanbul ignore else: difficult to make a test case for */\n        if (ptr) {\n          const len = new Uint8Array(llhttp.memory.buffer, ptr).indexOf(0);\n          message = Buffer.from(llhttp.memory.buffer, ptr, len).toString();\n        }\n        throw new HTTPParserError(message, constants.ERROR[ret], data.slice(offset));\n      }\n    } catch (err) {\n      util.destroy(socket, err);\n    }\n  }\n  destroy() {\n    assert(this.ptr != null);\n    assert(currentParser == null);\n    this.llhttp.llhttp_free(this.ptr);\n    this.ptr = null;\n    timers.clearTimeout(this.timeout);\n    this.timeout = null;\n    this.timeoutValue = null;\n    this.timeoutType = null;\n    this.paused = false;\n  }\n  onStatus(buf) {\n    this.statusText = buf.toString();\n  }\n  onMessageBegin() {\n    const {\n      socket,\n      client\n    } = this;\n\n    /* istanbul ignore next: difficult to make a test case for */\n    if (socket.destroyed) {\n      return -1;\n    }\n    const request = client[kQueue][client[kRunningIdx]];\n    if (!request) {\n      return -1;\n    }\n  }\n  onHeaderField(buf) {\n    const len = this.headers.length;\n    if ((len & 1) === 0) {\n      this.headers.push(buf);\n    } else {\n      this.headers[len - 1] = Buffer.concat([this.headers[len - 1], buf]);\n    }\n    this.trackHeader(buf.length);\n  }\n  onHeaderValue(buf) {\n    let len = this.headers.length;\n    if ((len & 1) === 1) {\n      this.headers.push(buf);\n      len += 1;\n    } else {\n      this.headers[len - 1] = Buffer.concat([this.headers[len - 1], buf]);\n    }\n    const key = this.headers[len - 2];\n    if (key.length === 10 && key.toString().toLowerCase() === 'keep-alive') {\n      this.keepAlive += buf.toString();\n    } else if (key.length === 10 && key.toString().toLowerCase() === 'connection') {\n      this.connection += buf.toString();\n    } else if (key.length === 14 && key.toString().toLowerCase() === 'content-length') {\n      this.contentLength += buf.toString();\n    }\n    this.trackHeader(buf.length);\n  }\n  trackHeader(len) {\n    this.headersSize += len;\n    if (this.headersSize >= this.headersMaxSize) {\n      util.destroy(this.socket, new HeadersOverflowError());\n    }\n  }\n  onUpgrade(head) {\n    const {\n      upgrade,\n      client,\n      socket,\n      headers,\n      statusCode\n    } = this;\n    assert(upgrade);\n    const request = client[kQueue][client[kRunningIdx]];\n    assert(request);\n    assert(!socket.destroyed);\n    assert(socket === client[kSocket]);\n    assert(!this.paused);\n    assert(request.upgrade || request.method === 'CONNECT');\n    this.statusCode = null;\n    this.statusText = '';\n    this.shouldKeepAlive = null;\n    assert(this.headers.length % 2 === 0);\n    this.headers = [];\n    this.headersSize = 0;\n    socket.unshift(head);\n    socket[kParser].destroy();\n    socket[kParser] = null;\n    socket[kClient] = null;\n    socket[kError] = null;\n    socket.removeListener('error', onSocketError).removeListener('readable', onSocketReadable).removeListener('end', onSocketEnd).removeListener('close', onSocketClose);\n    client[kSocket] = null;\n    client[kQueue][client[kRunningIdx]++] = null;\n    client.emit('disconnect', client[kUrl], [client], new InformationalError('upgrade'));\n    try {\n      request.onUpgrade(statusCode, headers, socket);\n    } catch (err) {\n      util.destroy(socket, err);\n    }\n    resume(client);\n  }\n  onHeadersComplete(statusCode, upgrade, shouldKeepAlive) {\n    const {\n      client,\n      socket,\n      headers,\n      statusText\n    } = this;\n\n    /* istanbul ignore next: difficult to make a test case for */\n    if (socket.destroyed) {\n      return -1;\n    }\n    const request = client[kQueue][client[kRunningIdx]];\n\n    /* istanbul ignore next: difficult to make a test case for */\n    if (!request) {\n      return -1;\n    }\n    assert(!this.upgrade);\n    assert(this.statusCode < 200);\n    if (statusCode === 100) {\n      util.destroy(socket, new SocketError('bad response', util.getSocketInfo(socket)));\n      return -1;\n    }\n\n    /* this can only happen if server is misbehaving */\n    if (upgrade && !request.upgrade) {\n      util.destroy(socket, new SocketError('bad upgrade', util.getSocketInfo(socket)));\n      return -1;\n    }\n    assert.strictEqual(this.timeoutType, TIMEOUT_HEADERS);\n    this.statusCode = statusCode;\n    this.shouldKeepAlive = shouldKeepAlive ||\n    // Override llhttp value which does not allow keepAlive for HEAD.\n    request.method === 'HEAD' && !socket[kReset] && this.connection.toLowerCase() === 'keep-alive';\n    if (this.statusCode >= 200) {\n      const bodyTimeout = request.bodyTimeout != null ? request.bodyTimeout : client[kBodyTimeout];\n      this.setTimeout(bodyTimeout, TIMEOUT_BODY);\n    } else if (this.timeout) {\n      // istanbul ignore else: only for jest\n      if (this.timeout.refresh) {\n        this.timeout.refresh();\n      }\n    }\n    if (request.method === 'CONNECT') {\n      assert(client[kRunning] === 1);\n      this.upgrade = true;\n      return 2;\n    }\n    if (upgrade) {\n      assert(client[kRunning] === 1);\n      this.upgrade = true;\n      return 2;\n    }\n    assert(this.headers.length % 2 === 0);\n    this.headers = [];\n    this.headersSize = 0;\n    if (this.shouldKeepAlive && client[kPipelining]) {\n      const keepAliveTimeout = this.keepAlive ? util.parseKeepAliveTimeout(this.keepAlive) : null;\n      if (keepAliveTimeout != null) {\n        const timeout = Math.min(keepAliveTimeout - client[kKeepAliveTimeoutThreshold], client[kKeepAliveMaxTimeout]);\n        if (timeout <= 0) {\n          socket[kReset] = true;\n        } else {\n          client[kKeepAliveTimeoutValue] = timeout;\n        }\n      } else {\n        client[kKeepAliveTimeoutValue] = client[kKeepAliveDefaultTimeout];\n      }\n    } else {\n      // Stop more requests from being dispatched.\n      socket[kReset] = true;\n    }\n    let pause;\n    try {\n      pause = request.onHeaders(statusCode, headers, this.resume, statusText) === false;\n    } catch (err) {\n      util.destroy(socket, err);\n      return -1;\n    }\n    if (request.method === 'HEAD') {\n      return 1;\n    }\n    if (statusCode < 200) {\n      return 1;\n    }\n    if (socket[kBlocking]) {\n      socket[kBlocking] = false;\n      resume(client);\n    }\n    return pause ? constants.ERROR.PAUSED : 0;\n  }\n  onBody(buf) {\n    const {\n      client,\n      socket,\n      statusCode,\n      maxResponseSize\n    } = this;\n    if (socket.destroyed) {\n      return -1;\n    }\n    const request = client[kQueue][client[kRunningIdx]];\n    assert(request);\n    assert.strictEqual(this.timeoutType, TIMEOUT_BODY);\n    if (this.timeout) {\n      // istanbul ignore else: only for jest\n      if (this.timeout.refresh) {\n        this.timeout.refresh();\n      }\n    }\n    assert(statusCode >= 200);\n    if (maxResponseSize > -1 && this.bytesRead + buf.length > maxResponseSize) {\n      util.destroy(socket, new ResponseExceededMaxSizeError());\n      return -1;\n    }\n    this.bytesRead += buf.length;\n    try {\n      if (request.onData(buf) === false) {\n        return constants.ERROR.PAUSED;\n      }\n    } catch (err) {\n      util.destroy(socket, err);\n      return -1;\n    }\n  }\n  onMessageComplete() {\n    const {\n      client,\n      socket,\n      statusCode,\n      upgrade,\n      headers,\n      contentLength,\n      bytesRead,\n      shouldKeepAlive\n    } = this;\n    if (socket.destroyed && (!statusCode || shouldKeepAlive)) {\n      return -1;\n    }\n    if (upgrade) {\n      return;\n    }\n    const request = client[kQueue][client[kRunningIdx]];\n    assert(request);\n    assert(statusCode >= 100);\n    this.statusCode = null;\n    this.statusText = '';\n    this.bytesRead = 0;\n    this.contentLength = '';\n    this.keepAlive = '';\n    this.connection = '';\n    assert(this.headers.length % 2 === 0);\n    this.headers = [];\n    this.headersSize = 0;\n    if (statusCode < 200) {\n      return;\n    }\n\n    /* istanbul ignore next: should be handled by llhttp? */\n    if (request.method !== 'HEAD' && contentLength && bytesRead !== parseInt(contentLength, 10)) {\n      util.destroy(socket, new ResponseContentLengthMismatchError());\n      return -1;\n    }\n    try {\n      request.onComplete(headers);\n    } catch (err) {\n      errorRequest(client, request, err);\n    }\n    client[kQueue][client[kRunningIdx]++] = null;\n    if (socket[kWriting]) {\n      assert.strictEqual(client[kRunning], 0);\n      // Response completed before request.\n      util.destroy(socket, new InformationalError('reset'));\n      return constants.ERROR.PAUSED;\n    } else if (!shouldKeepAlive) {\n      util.destroy(socket, new InformationalError('reset'));\n      return constants.ERROR.PAUSED;\n    } else if (socket[kReset] && client[kRunning] === 0) {\n      // Destroy socket once all requests have completed.\n      // The request at the tail of the pipeline is the one\n      // that requested reset and no further requests should\n      // have been queued since then.\n      util.destroy(socket, new InformationalError('reset'));\n      return constants.ERROR.PAUSED;\n    } else if (client[kPipelining] === 1) {\n      // We must wait a full event loop cycle to reuse this socket to make sure\n      // that non-spec compliant servers are not closing the connection even if they\n      // said they won't.\n      setImmediate(resume, client);\n    } else {\n      resume(client);\n    }\n  }\n}\nfunction onParserTimeout(parser) {\n  const {\n    socket,\n    timeoutType,\n    client\n  } = parser;\n\n  /* istanbul ignore else */\n  if (timeoutType === TIMEOUT_HEADERS) {\n    if (!socket[kWriting] || socket.writableNeedDrain || client[kRunning] > 1) {\n      assert(!parser.paused, 'cannot be paused while waiting for headers');\n      util.destroy(socket, new HeadersTimeoutError());\n    }\n  } else if (timeoutType === TIMEOUT_BODY) {\n    if (!parser.paused) {\n      util.destroy(socket, new BodyTimeoutError());\n    }\n  } else if (timeoutType === TIMEOUT_IDLE) {\n    assert(client[kRunning] === 0 && client[kKeepAliveTimeoutValue]);\n    util.destroy(socket, new InformationalError('socket idle timeout'));\n  }\n}\nfunction onSocketReadable() {\n  const {\n    [kParser]: parser\n  } = this;\n  parser.readMore();\n}\nfunction onSocketError(err) {\n  const {\n    [kParser]: parser\n  } = this;\n  assert(err.code !== 'ERR_TLS_CERT_ALTNAME_INVALID');\n\n  // On Mac OS, we get an ECONNRESET even if there is a full body to be forwarded\n  // to the user.\n  if (err.code === 'ECONNRESET' && parser.statusCode && !parser.shouldKeepAlive) {\n    // We treat all incoming data so for as a valid response.\n    parser.onMessageComplete();\n    return;\n  }\n  this[kError] = err;\n  onError(this[kClient], err);\n}\nfunction onError(client, err) {\n  if (client[kRunning] === 0 && err.code !== 'UND_ERR_INFO' && err.code !== 'UND_ERR_SOCKET') {\n    // Error is not caused by running request and not a recoverable\n    // socket error.\n\n    assert(client[kPendingIdx] === client[kRunningIdx]);\n    const requests = client[kQueue].splice(client[kRunningIdx]);\n    for (let i = 0; i < requests.length; i++) {\n      const request = requests[i];\n      errorRequest(client, request, err);\n    }\n    assert(client[kSize] === 0);\n  }\n}\nfunction onSocketEnd() {\n  const {\n    [kParser]: parser\n  } = this;\n  if (parser.statusCode && !parser.shouldKeepAlive) {\n    // We treat all incoming data so far as a valid response.\n    parser.onMessageComplete();\n    return;\n  }\n  util.destroy(this, new SocketError('other side closed', util.getSocketInfo(this)));\n}\nfunction onSocketClose() {\n  const {\n    [kClient]: client\n  } = this;\n  if (!this[kError] && this[kParser].statusCode && !this[kParser].shouldKeepAlive) {\n    // We treat all incoming data so far as a valid response.\n    this[kParser].onMessageComplete();\n  }\n  this[kParser].destroy();\n  this[kParser] = null;\n  const err = this[kError] || new SocketError('closed', util.getSocketInfo(this));\n  client[kSocket] = null;\n  if (client.destroyed) {\n    assert(client[kPending] === 0);\n\n    // Fail entire queue.\n    const requests = client[kQueue].splice(client[kRunningIdx]);\n    for (let i = 0; i < requests.length; i++) {\n      const request = requests[i];\n      errorRequest(client, request, err);\n    }\n  } else if (client[kRunning] > 0 && err.code !== 'UND_ERR_INFO') {\n    // Fail head of pipeline.\n    const request = client[kQueue][client[kRunningIdx]];\n    client[kQueue][client[kRunningIdx]++] = null;\n    errorRequest(client, request, err);\n  }\n  client[kPendingIdx] = client[kRunningIdx];\n  assert(client[kRunning] === 0);\n  client.emit('disconnect', client[kUrl], [client], err);\n  resume(client);\n}\nasync function connect(client) {\n  assert(!client[kConnecting]);\n  assert(!client[kSocket]);\n  let {\n    host,\n    hostname,\n    protocol,\n    port\n  } = client[kUrl];\n\n  // Resolve ipv6\n  if (hostname[0] === '[') {\n    const idx = hostname.indexOf(']');\n    assert(idx !== -1);\n    const ip = hostname.substr(1, idx - 1);\n    assert(net.isIP(ip));\n    hostname = ip;\n  }\n  client[kConnecting] = true;\n  if (channels.beforeConnect.hasSubscribers) {\n    channels.beforeConnect.publish({\n      connectParams: {\n        host,\n        hostname,\n        protocol,\n        port,\n        servername: client[kServerName],\n        localAddress: client[kLocalAddress]\n      },\n      connector: client[kConnector]\n    });\n  }\n  try {\n    const socket = await new Promise((resolve, reject) => {\n      client[kConnector]({\n        host,\n        hostname,\n        protocol,\n        port,\n        servername: client[kServerName],\n        localAddress: client[kLocalAddress]\n      }, (err, socket) => {\n        if (err) {\n          reject(err);\n        } else {\n          resolve(socket);\n        }\n      });\n    });\n    if (!llhttpInstance) {\n      llhttpInstance = await llhttpPromise;\n      llhttpPromise = null;\n    }\n    client[kConnecting] = false;\n    assert(socket);\n    socket[kNoRef] = false;\n    socket[kWriting] = false;\n    socket[kReset] = false;\n    socket[kBlocking] = false;\n    socket[kError] = null;\n    socket[kParser] = new Parser(client, socket, llhttpInstance);\n    socket[kClient] = client;\n    socket[kCounter] = 0;\n    socket[kMaxRequests] = client[kMaxRequests];\n    socket.on('error', onSocketError).on('readable', onSocketReadable).on('end', onSocketEnd).on('close', onSocketClose);\n    client[kSocket] = socket;\n    if (channels.connected.hasSubscribers) {\n      channels.connected.publish({\n        connectParams: {\n          host,\n          hostname,\n          protocol,\n          port,\n          servername: client[kServerName],\n          localAddress: client[kLocalAddress]\n        },\n        connector: client[kConnector],\n        socket\n      });\n    }\n    client.emit('connect', client[kUrl], [client]);\n  } catch (err) {\n    client[kConnecting] = false;\n    if (channels.connectError.hasSubscribers) {\n      channels.connectError.publish({\n        connectParams: {\n          host,\n          hostname,\n          protocol,\n          port,\n          servername: client[kServerName],\n          localAddress: client[kLocalAddress]\n        },\n        connector: client[kConnector],\n        error: err\n      });\n    }\n    if (err.code === 'ERR_TLS_CERT_ALTNAME_INVALID') {\n      assert(client[kRunning] === 0);\n      while (client[kPending] > 0 && client[kQueue][client[kPendingIdx]].servername === client[kServerName]) {\n        const request = client[kQueue][client[kPendingIdx]++];\n        errorRequest(client, request, err);\n      }\n    } else {\n      onError(client, err);\n    }\n    client.emit('connectionError', client[kUrl], [client], err);\n  }\n  resume(client);\n}\nfunction emitDrain(client) {\n  client[kNeedDrain] = 0;\n  client.emit('drain', client[kUrl], [client]);\n}\nfunction resume(client, sync) {\n  if (client[kResuming] === 2) {\n    return;\n  }\n  client[kResuming] = 2;\n  _resume(client, sync);\n  client[kResuming] = 0;\n  if (client[kRunningIdx] > 256) {\n    client[kQueue].splice(0, client[kRunningIdx]);\n    client[kPendingIdx] -= client[kRunningIdx];\n    client[kRunningIdx] = 0;\n  }\n}\nfunction _resume(client, sync) {\n  while (true) {\n    if (client.destroyed) {\n      assert(client[kPending] === 0);\n      return;\n    }\n    if (client.closed && !client[kSize]) {\n      client.destroy();\n      return;\n    }\n    const socket = client[kSocket];\n    if (socket && !socket.destroyed) {\n      if (client[kSize] === 0) {\n        if (!socket[kNoRef] && socket.unref) {\n          socket.unref();\n          socket[kNoRef] = true;\n        }\n      } else if (socket[kNoRef] && socket.ref) {\n        socket.ref();\n        socket[kNoRef] = false;\n      }\n      if (client[kSize] === 0) {\n        if (socket[kParser].timeoutType !== TIMEOUT_IDLE) {\n          socket[kParser].setTimeout(client[kKeepAliveTimeoutValue], TIMEOUT_IDLE);\n        }\n      } else if (client[kRunning] > 0 && socket[kParser].statusCode < 200) {\n        if (socket[kParser].timeoutType !== TIMEOUT_HEADERS) {\n          const request = client[kQueue][client[kRunningIdx]];\n          const headersTimeout = request.headersTimeout != null ? request.headersTimeout : client[kHeadersTimeout];\n          socket[kParser].setTimeout(headersTimeout, TIMEOUT_HEADERS);\n        }\n      }\n    }\n    if (client[kBusy]) {\n      client[kNeedDrain] = 2;\n    } else if (client[kNeedDrain] === 2) {\n      if (sync) {\n        client[kNeedDrain] = 1;\n        process.nextTick(emitDrain, client);\n      } else {\n        emitDrain(client);\n      }\n      continue;\n    }\n    if (client[kPending] === 0) {\n      return;\n    }\n    if (client[kRunning] >= (client[kPipelining] || 1)) {\n      return;\n    }\n    const request = client[kQueue][client[kPendingIdx]];\n    if (client[kUrl].protocol === 'https:' && client[kServerName] !== request.servername) {\n      if (client[kRunning] > 0) {\n        return;\n      }\n      client[kServerName] = request.servername;\n      if (socket && socket.servername !== request.servername) {\n        util.destroy(socket, new InformationalError('servername changed'));\n        return;\n      }\n    }\n    if (client[kConnecting]) {\n      return;\n    }\n    if (!socket) {\n      connect(client);\n      return;\n    }\n    if (socket.destroyed || socket[kWriting] || socket[kReset] || socket[kBlocking]) {\n      return;\n    }\n    if (client[kRunning] > 0 && !request.idempotent) {\n      // Non-idempotent request cannot be retried.\n      // Ensure that no other requests are inflight and\n      // could cause failure.\n      return;\n    }\n    if (client[kRunning] > 0 && (request.upgrade || request.method === 'CONNECT')) {\n      // Don't dispatch an upgrade until all preceding requests have completed.\n      // A misbehaving server might upgrade the connection before all pipelined\n      // request has completed.\n      return;\n    }\n    if (util.isStream(request.body) && util.bodyLength(request.body) === 0) {\n      request.body.on('data', /* istanbul ignore next */function () {\n        /* istanbul ignore next */\n        assert(false);\n      }).on('error', function (err) {\n        errorRequest(client, request, err);\n      }).on('end', function () {\n        util.destroy(this);\n      });\n      request.body = null;\n    }\n    if (client[kRunning] > 0 && (util.isStream(request.body) || util.isAsyncIterable(request.body))) {\n      // Request with stream or iterator body can error while other requests\n      // are inflight and indirectly error those as well.\n      // Ensure this doesn't happen by waiting for inflight\n      // to complete before dispatching.\n\n      // Request with stream or iterator body cannot be retried.\n      // Ensure that no other requests are inflight and\n      // could cause failure.\n      return;\n    }\n    if (!request.aborted && write(client, request)) {\n      client[kPendingIdx]++;\n    } else {\n      client[kQueue].splice(client[kPendingIdx], 1);\n    }\n  }\n}\nfunction write(client, request) {\n  const {\n    body,\n    method,\n    path,\n    host,\n    upgrade,\n    headers,\n    blocking,\n    reset\n  } = request;\n\n  // https://tools.ietf.org/html/rfc7231#section-4.3.1\n  // https://tools.ietf.org/html/rfc7231#section-4.3.2\n  // https://tools.ietf.org/html/rfc7231#section-4.3.5\n\n  // Sending a payload body on a request that does not\n  // expect it can cause undefined behavior on some\n  // servers and corrupt connection state. Do not\n  // re-use the connection for further requests.\n\n  const expectsPayload = method === 'PUT' || method === 'POST' || method === 'PATCH';\n  if (body && typeof body.read === 'function') {\n    // Try to read EOF in order to get length.\n    body.read(0);\n  }\n  let contentLength = util.bodyLength(body);\n  if (contentLength === null) {\n    contentLength = request.contentLength;\n  }\n  if (contentLength === 0 && !expectsPayload) {\n    // https://tools.ietf.org/html/rfc7230#section-3.3.2\n    // A user agent SHOULD NOT send a Content-Length header field when\n    // the request message does not contain a payload body and the method\n    // semantics do not anticipate such a body.\n\n    contentLength = null;\n  }\n  if (request.contentLength !== null && request.contentLength !== contentLength) {\n    if (client[kStrictContentLength]) {\n      errorRequest(client, request, new RequestContentLengthMismatchError());\n      return false;\n    }\n    process.emitWarning(new RequestContentLengthMismatchError());\n  }\n  const socket = client[kSocket];\n  try {\n    request.onConnect(err => {\n      if (request.aborted || request.completed) {\n        return;\n      }\n      errorRequest(client, request, err || new RequestAbortedError());\n      util.destroy(socket, new InformationalError('aborted'));\n    });\n  } catch (err) {\n    errorRequest(client, request, err);\n  }\n  if (request.aborted) {\n    return false;\n  }\n  if (method === 'HEAD') {\n    // https://github.com/mcollina/undici/issues/258\n    // Close after a HEAD request to interop with misbehaving servers\n    // that may send a body in the response.\n\n    socket[kReset] = true;\n  }\n  if (upgrade || method === 'CONNECT') {\n    // On CONNECT or upgrade, block pipeline from dispatching further\n    // requests on this connection.\n\n    socket[kReset] = true;\n  }\n  if (reset != null) {\n    socket[kReset] = reset;\n  }\n  if (client[kMaxRequests] && socket[kCounter]++ >= client[kMaxRequests]) {\n    socket[kReset] = true;\n  }\n  if (blocking) {\n    socket[kBlocking] = true;\n  }\n  let header = `${method} ${path} HTTP/1.1\\r\\n`;\n  if (typeof host === 'string') {\n    header += `host: ${host}\\r\\n`;\n  } else {\n    header += client[kHostHeader];\n  }\n  if (upgrade) {\n    header += `connection: upgrade\\r\\nupgrade: ${upgrade}\\r\\n`;\n  } else if (client[kPipelining] && !socket[kReset]) {\n    header += 'connection: keep-alive\\r\\n';\n  } else {\n    header += 'connection: close\\r\\n';\n  }\n  if (headers) {\n    header += headers;\n  }\n  if (channels.sendHeaders.hasSubscribers) {\n    channels.sendHeaders.publish({\n      request,\n      headers: header,\n      socket\n    });\n  }\n\n  /* istanbul ignore else: assertion */\n  if (!body) {\n    if (contentLength === 0) {\n      socket.write(`${header}content-length: 0\\r\\n\\r\\n`, 'ascii');\n    } else {\n      assert(contentLength === null, 'no body must not have content length');\n      socket.write(`${header}\\r\\n`, 'ascii');\n    }\n    request.onRequestSent();\n  } else if (util.isBuffer(body)) {\n    assert(contentLength === body.byteLength, 'buffer body must have content length');\n    socket.cork();\n    socket.write(`${header}content-length: ${contentLength}\\r\\n\\r\\n`, 'ascii');\n    socket.write(body);\n    socket.uncork();\n    request.onBodySent(body);\n    request.onRequestSent();\n    if (!expectsPayload) {\n      socket[kReset] = true;\n    }\n  } else if (util.isBlobLike(body)) {\n    if (typeof body.stream === 'function') {\n      writeIterable({\n        body: body.stream(),\n        client,\n        request,\n        socket,\n        contentLength,\n        header,\n        expectsPayload\n      });\n    } else {\n      writeBlob({\n        body,\n        client,\n        request,\n        socket,\n        contentLength,\n        header,\n        expectsPayload\n      });\n    }\n  } else if (util.isStream(body)) {\n    writeStream({\n      body,\n      client,\n      request,\n      socket,\n      contentLength,\n      header,\n      expectsPayload\n    });\n  } else if (util.isIterable(body)) {\n    writeIterable({\n      body,\n      client,\n      request,\n      socket,\n      contentLength,\n      header,\n      expectsPayload\n    });\n  } else {\n    assert(false);\n  }\n  return true;\n}\nfunction writeStream(_ref2) {\n  let {\n    body,\n    client,\n    request,\n    socket,\n    contentLength,\n    header,\n    expectsPayload\n  } = _ref2;\n  assert(contentLength !== 0 || client[kRunning] === 0, 'stream body cannot be pipelined');\n  let finished = false;\n  const writer = new AsyncWriter({\n    socket,\n    request,\n    contentLength,\n    client,\n    expectsPayload,\n    header\n  });\n  const onData = function (chunk) {\n    try {\n      assert(!finished);\n      if (!writer.write(chunk) && this.pause) {\n        this.pause();\n      }\n    } catch (err) {\n      util.destroy(this, err);\n    }\n  };\n  const onDrain = function () {\n    assert(!finished);\n    if (body.resume) {\n      body.resume();\n    }\n  };\n  const onAbort = function () {\n    onFinished(new RequestAbortedError());\n  };\n  const onFinished = function (err) {\n    if (finished) {\n      return;\n    }\n    finished = true;\n    assert(socket.destroyed || socket[kWriting] && client[kRunning] <= 1);\n    socket.off('drain', onDrain).off('error', onFinished);\n    body.removeListener('data', onData).removeListener('end', onFinished).removeListener('error', onFinished).removeListener('close', onAbort);\n    if (!err) {\n      try {\n        writer.end();\n      } catch (er) {\n        err = er;\n      }\n    }\n    writer.destroy(err);\n    if (err && (err.code !== 'UND_ERR_INFO' || err.message !== 'reset')) {\n      util.destroy(body, err);\n    } else {\n      util.destroy(body);\n    }\n  };\n  body.on('data', onData).on('end', onFinished).on('error', onFinished).on('close', onAbort);\n  if (body.resume) {\n    body.resume();\n  }\n  socket.on('drain', onDrain).on('error', onFinished);\n}\nasync function writeBlob(_ref3) {\n  let {\n    body,\n    client,\n    request,\n    socket,\n    contentLength,\n    header,\n    expectsPayload\n  } = _ref3;\n  assert(contentLength === body.size, 'blob body must have content length');\n  try {\n    if (contentLength != null && contentLength !== body.size) {\n      throw new RequestContentLengthMismatchError();\n    }\n    const buffer = Buffer.from(await body.arrayBuffer());\n    socket.cork();\n    socket.write(`${header}content-length: ${contentLength}\\r\\n\\r\\n`, 'ascii');\n    socket.write(buffer);\n    socket.uncork();\n    request.onBodySent(buffer);\n    request.onRequestSent();\n    if (!expectsPayload) {\n      socket[kReset] = true;\n    }\n    resume(client);\n  } catch (err) {\n    util.destroy(socket, err);\n  }\n}\nasync function writeIterable(_ref4) {\n  let {\n    body,\n    client,\n    request,\n    socket,\n    contentLength,\n    header,\n    expectsPayload\n  } = _ref4;\n  assert(contentLength !== 0 || client[kRunning] === 0, 'iterator body cannot be pipelined');\n  let callback = null;\n  function onDrain() {\n    if (callback) {\n      const cb = callback;\n      callback = null;\n      cb();\n    }\n  }\n  const waitForDrain = () => new Promise((resolve, reject) => {\n    assert(callback === null);\n    if (socket[kError]) {\n      reject(socket[kError]);\n    } else {\n      callback = resolve;\n    }\n  });\n  socket.on('close', onDrain).on('drain', onDrain);\n  const writer = new AsyncWriter({\n    socket,\n    request,\n    contentLength,\n    client,\n    expectsPayload,\n    header\n  });\n  try {\n    // It's up to the user to somehow abort the async iterable.\n    for await (const chunk of body) {\n      if (socket[kError]) {\n        throw socket[kError];\n      }\n      if (!writer.write(chunk)) {\n        await waitForDrain();\n      }\n    }\n    writer.end();\n  } catch (err) {\n    writer.destroy(err);\n  } finally {\n    socket.off('close', onDrain).off('drain', onDrain);\n  }\n}\nclass AsyncWriter {\n  constructor(_ref5) {\n    let {\n      socket,\n      request,\n      contentLength,\n      client,\n      expectsPayload,\n      header\n    } = _ref5;\n    this.socket = socket;\n    this.request = request;\n    this.contentLength = contentLength;\n    this.client = client;\n    this.bytesWritten = 0;\n    this.expectsPayload = expectsPayload;\n    this.header = header;\n    socket[kWriting] = true;\n  }\n  write(chunk) {\n    const {\n      socket,\n      request,\n      contentLength,\n      client,\n      bytesWritten,\n      expectsPayload,\n      header\n    } = this;\n    if (socket[kError]) {\n      throw socket[kError];\n    }\n    if (socket.destroyed) {\n      return false;\n    }\n    const len = Buffer.byteLength(chunk);\n    if (!len) {\n      return true;\n    }\n\n    // We should defer writing chunks.\n    if (contentLength !== null && bytesWritten + len > contentLength) {\n      if (client[kStrictContentLength]) {\n        throw new RequestContentLengthMismatchError();\n      }\n      process.emitWarning(new RequestContentLengthMismatchError());\n    }\n    if (bytesWritten === 0) {\n      if (!expectsPayload) {\n        socket[kReset] = true;\n      }\n      if (contentLength === null) {\n        socket.write(`${header}transfer-encoding: chunked\\r\\n`, 'ascii');\n      } else {\n        socket.write(`${header}content-length: ${contentLength}\\r\\n\\r\\n`, 'ascii');\n      }\n    }\n    if (contentLength === null) {\n      socket.write(`\\r\\n${len.toString(16)}\\r\\n`, 'ascii');\n    }\n    this.bytesWritten += len;\n    const ret = socket.write(chunk);\n    request.onBodySent(chunk);\n    if (!ret) {\n      if (socket[kParser].timeout && socket[kParser].timeoutType === TIMEOUT_HEADERS) {\n        // istanbul ignore else: only for jest\n        if (socket[kParser].timeout.refresh) {\n          socket[kParser].timeout.refresh();\n        }\n      }\n    }\n    return ret;\n  }\n  end() {\n    const {\n      socket,\n      contentLength,\n      client,\n      bytesWritten,\n      expectsPayload,\n      header,\n      request\n    } = this;\n    request.onRequestSent();\n    socket[kWriting] = false;\n    if (socket[kError]) {\n      throw socket[kError];\n    }\n    if (socket.destroyed) {\n      return;\n    }\n    if (bytesWritten === 0) {\n      if (expectsPayload) {\n        // https://tools.ietf.org/html/rfc7230#section-3.3.2\n        // A user agent SHOULD send a Content-Length in a request message when\n        // no Transfer-Encoding is sent and the request method defines a meaning\n        // for an enclosed payload body.\n\n        socket.write(`${header}content-length: 0\\r\\n\\r\\n`, 'ascii');\n      } else {\n        socket.write(`${header}\\r\\n`, 'ascii');\n      }\n    } else if (contentLength === null) {\n      socket.write('\\r\\n0\\r\\n\\r\\n', 'ascii');\n    }\n    if (contentLength !== null && bytesWritten !== contentLength) {\n      if (client[kStrictContentLength]) {\n        throw new RequestContentLengthMismatchError();\n      } else {\n        process.emitWarning(new RequestContentLengthMismatchError());\n      }\n    }\n    if (socket[kParser].timeout && socket[kParser].timeoutType === TIMEOUT_HEADERS) {\n      // istanbul ignore else: only for jest\n      if (socket[kParser].timeout.refresh) {\n        socket[kParser].timeout.refresh();\n      }\n    }\n    resume(client);\n  }\n  destroy(err) {\n    const {\n      socket,\n      client\n    } = this;\n    socket[kWriting] = false;\n    if (err) {\n      assert(client[kRunning] <= 1, 'pipeline should only contain this request');\n      util.destroy(socket, err);\n    }\n  }\n}\nfunction errorRequest(client, request, err) {\n  try {\n    request.onError(err);\n    assert(request.aborted);\n  } catch (err) {\n    client.emit('error', err);\n  }\n}\nmodule.exports = Client;","map":{"version":3,"names":["assert","require","net","util","timers","Request","DispatcherBase","RequestContentLengthMismatchError","ResponseContentLengthMismatchError","InvalidArgumentError","RequestAbortedError","HeadersTimeoutError","HeadersOverflowError","SocketError","InformationalError","BodyTimeoutError","HTTPParserError","ResponseExceededMaxSizeError","buildConnector","kUrl","kReset","kServerName","kClient","kBusy","kParser","kConnect","kBlocking","kResuming","kRunning","kPending","kSize","kWriting","kQueue","kConnected","kConnecting","kNeedDrain","kNoRef","kKeepAliveDefaultTimeout","kHostHeader","kPendingIdx","kRunningIdx","kError","kPipelining","kSocket","kKeepAliveTimeoutValue","kMaxHeadersSize","kKeepAliveMaxTimeout","kKeepAliveTimeoutThreshold","kHeadersTimeout","kBodyTimeout","kStrictContentLength","kConnector","kMaxRedirections","kMaxRequests","kCounter","kClose","kDestroy","kDispatch","kInterceptors","kLocalAddress","kMaxResponseSize","FastBuffer","Buffer","Symbol","species","kClosedResolve","channels","diagnosticsChannel","sendHeaders","channel","beforeConnect","connectError","connected","hasSubscribers","Client","constructor","url","interceptors","maxHeaderSize","headersTimeout","socketTimeout","requestTimeout","connectTimeout","bodyTimeout","idleTimeout","keepAlive","keepAliveTimeout","maxKeepAliveTimeout","keepAliveMaxTimeout","keepAliveTimeoutThreshold","socketPath","pipelining","tls","strictContentLength","maxCachedSessions","maxRedirections","connect","maxRequestsPerClient","localAddress","maxResponseSize","autoSelectFamily","autoSelectFamilyAttemptTimeout","undefined","Number","isFinite","isInteger","isIP","timeout","nodeHasAutoSelectFamily","Array","isArray","createRedirectInterceptor","parseOrigin","hostname","port","value","resume","length","destroyed","socket","cb","once","opts","handler","origin","request","push","bodyLength","body","isIterable","process","nextTick","Promise","resolve","destroy","err","requests","splice","i","errorRequest","callback","queueMicrotask","on","constants","EMPTY_BUF","alloc","lazyllhttp","llhttpWasmData","env","JEST_WORKER_ID","mod","WebAssembly","compile","from","e","instantiate","wasm_on_url","p","at","len","wasm_on_status","strictEqual","currentParser","ptr","start","currentBufferPtr","currentBufferRef","byteOffset","onStatus","buffer","wasm_on_message_begin","onMessageBegin","wasm_on_header_field","onHeaderField","wasm_on_header_value","onHeaderValue","wasm_on_headers_complete","statusCode","upgrade","shouldKeepAlive","onHeadersComplete","Boolean","wasm_on_body","onBody","wasm_on_message_complete","onMessageComplete","llhttpInstance","llhttpPromise","catch","currentBufferSize","TIMEOUT_HEADERS","TIMEOUT_BODY","TIMEOUT_IDLE","Parser","client","exports","llhttp","llhttp_alloc","TYPE","RESPONSE","timeoutValue","timeoutType","statusText","headers","headersSize","headersMaxSize","paused","bind","bytesRead","contentLength","connection","setTimeout","type","clearTimeout","onParserTimeout","unref","refresh","llhttp_resume","execute","read","readMore","chunk","data","free","Math","ceil","malloc","Uint8Array","memory","set","ret","llhttp_execute","offset","llhttp_get_error_pos","ERROR","PAUSED_UPGRADE","onUpgrade","slice","PAUSED","unshift","OK","llhttp_get_error_reason","message","indexOf","toString","llhttp_free","buf","concat","trackHeader","key","toLowerCase","head","method","removeListener","onSocketError","onSocketReadable","onSocketEnd","onSocketClose","emit","getSocketInfo","parseKeepAliveTimeout","min","pause","onHeaders","onData","parseInt","onComplete","setImmediate","parser","writableNeedDrain","code","onError","host","protocol","idx","ip","substr","publish","connectParams","servername","connector","reject","error","emitDrain","sync","_resume","closed","ref","idempotent","isStream","isAsyncIterable","aborted","write","path","blocking","reset","expectsPayload","emitWarning","onConnect","completed","header","onRequestSent","isBuffer","byteLength","cork","uncork","onBodySent","isBlobLike","stream","writeIterable","writeBlob","writeStream","finished","writer","AsyncWriter","onDrain","onAbort","onFinished","off","end","er","size","arrayBuffer","waitForDrain","bytesWritten","module"],"sources":["/Users/janrobel/Documents/PersonalProjekty/nftGenerateAi/clientAndContract/node_modules/undici/lib/client.js"],"sourcesContent":["'use strict'\n\n/* global WebAssembly */\n\nconst assert = require('assert')\nconst net = require('net')\nconst util = require('./core/util')\nconst timers = require('./timers')\nconst Request = require('./core/request')\nconst DispatcherBase = require('./dispatcher-base')\nconst {\n  RequestContentLengthMismatchError,\n  ResponseContentLengthMismatchError,\n  InvalidArgumentError,\n  RequestAbortedError,\n  HeadersTimeoutError,\n  HeadersOverflowError,\n  SocketError,\n  InformationalError,\n  BodyTimeoutError,\n  HTTPParserError,\n  ResponseExceededMaxSizeError\n} = require('./core/errors')\nconst buildConnector = require('./core/connect')\nconst {\n  kUrl,\n  kReset,\n  kServerName,\n  kClient,\n  kBusy,\n  kParser,\n  kConnect,\n  kBlocking,\n  kResuming,\n  kRunning,\n  kPending,\n  kSize,\n  kWriting,\n  kQueue,\n  kConnected,\n  kConnecting,\n  kNeedDrain,\n  kNoRef,\n  kKeepAliveDefaultTimeout,\n  kHostHeader,\n  kPendingIdx,\n  kRunningIdx,\n  kError,\n  kPipelining,\n  kSocket,\n  kKeepAliveTimeoutValue,\n  kMaxHeadersSize,\n  kKeepAliveMaxTimeout,\n  kKeepAliveTimeoutThreshold,\n  kHeadersTimeout,\n  kBodyTimeout,\n  kStrictContentLength,\n  kConnector,\n  kMaxRedirections,\n  kMaxRequests,\n  kCounter,\n  kClose,\n  kDestroy,\n  kDispatch,\n  kInterceptors,\n  kLocalAddress,\n  kMaxResponseSize\n} = require('./core/symbols')\nconst FastBuffer = Buffer[Symbol.species]\n\nconst kClosedResolve = Symbol('kClosedResolve')\n\nconst channels = {}\n\ntry {\n  const diagnosticsChannel = require('diagnostics_channel')\n  channels.sendHeaders = diagnosticsChannel.channel('undici:client:sendHeaders')\n  channels.beforeConnect = diagnosticsChannel.channel('undici:client:beforeConnect')\n  channels.connectError = diagnosticsChannel.channel('undici:client:connectError')\n  channels.connected = diagnosticsChannel.channel('undici:client:connected')\n} catch {\n  channels.sendHeaders = { hasSubscribers: false }\n  channels.beforeConnect = { hasSubscribers: false }\n  channels.connectError = { hasSubscribers: false }\n  channels.connected = { hasSubscribers: false }\n}\n\nclass Client extends DispatcherBase {\n  constructor (url, {\n    interceptors,\n    maxHeaderSize,\n    headersTimeout,\n    socketTimeout,\n    requestTimeout,\n    connectTimeout,\n    bodyTimeout,\n    idleTimeout,\n    keepAlive,\n    keepAliveTimeout,\n    maxKeepAliveTimeout,\n    keepAliveMaxTimeout,\n    keepAliveTimeoutThreshold,\n    socketPath,\n    pipelining,\n    tls,\n    strictContentLength,\n    maxCachedSessions,\n    maxRedirections,\n    connect,\n    maxRequestsPerClient,\n    localAddress,\n    maxResponseSize,\n    autoSelectFamily,\n    autoSelectFamilyAttemptTimeout\n  } = {}) {\n    super()\n\n    if (keepAlive !== undefined) {\n      throw new InvalidArgumentError('unsupported keepAlive, use pipelining=0 instead')\n    }\n\n    if (socketTimeout !== undefined) {\n      throw new InvalidArgumentError('unsupported socketTimeout, use headersTimeout & bodyTimeout instead')\n    }\n\n    if (requestTimeout !== undefined) {\n      throw new InvalidArgumentError('unsupported requestTimeout, use headersTimeout & bodyTimeout instead')\n    }\n\n    if (idleTimeout !== undefined) {\n      throw new InvalidArgumentError('unsupported idleTimeout, use keepAliveTimeout instead')\n    }\n\n    if (maxKeepAliveTimeout !== undefined) {\n      throw new InvalidArgumentError('unsupported maxKeepAliveTimeout, use keepAliveMaxTimeout instead')\n    }\n\n    if (maxHeaderSize != null && !Number.isFinite(maxHeaderSize)) {\n      throw new InvalidArgumentError('invalid maxHeaderSize')\n    }\n\n    if (socketPath != null && typeof socketPath !== 'string') {\n      throw new InvalidArgumentError('invalid socketPath')\n    }\n\n    if (connectTimeout != null && (!Number.isFinite(connectTimeout) || connectTimeout < 0)) {\n      throw new InvalidArgumentError('invalid connectTimeout')\n    }\n\n    if (keepAliveTimeout != null && (!Number.isFinite(keepAliveTimeout) || keepAliveTimeout <= 0)) {\n      throw new InvalidArgumentError('invalid keepAliveTimeout')\n    }\n\n    if (keepAliveMaxTimeout != null && (!Number.isFinite(keepAliveMaxTimeout) || keepAliveMaxTimeout <= 0)) {\n      throw new InvalidArgumentError('invalid keepAliveMaxTimeout')\n    }\n\n    if (keepAliveTimeoutThreshold != null && !Number.isFinite(keepAliveTimeoutThreshold)) {\n      throw new InvalidArgumentError('invalid keepAliveTimeoutThreshold')\n    }\n\n    if (headersTimeout != null && (!Number.isInteger(headersTimeout) || headersTimeout < 0)) {\n      throw new InvalidArgumentError('headersTimeout must be a positive integer or zero')\n    }\n\n    if (bodyTimeout != null && (!Number.isInteger(bodyTimeout) || bodyTimeout < 0)) {\n      throw new InvalidArgumentError('bodyTimeout must be a positive integer or zero')\n    }\n\n    if (connect != null && typeof connect !== 'function' && typeof connect !== 'object') {\n      throw new InvalidArgumentError('connect must be a function or an object')\n    }\n\n    if (maxRedirections != null && (!Number.isInteger(maxRedirections) || maxRedirections < 0)) {\n      throw new InvalidArgumentError('maxRedirections must be a positive number')\n    }\n\n    if (maxRequestsPerClient != null && (!Number.isInteger(maxRequestsPerClient) || maxRequestsPerClient < 0)) {\n      throw new InvalidArgumentError('maxRequestsPerClient must be a positive number')\n    }\n\n    if (localAddress != null && (typeof localAddress !== 'string' || net.isIP(localAddress) === 0)) {\n      throw new InvalidArgumentError('localAddress must be valid string IP address')\n    }\n\n    if (maxResponseSize != null && (!Number.isInteger(maxResponseSize) || maxResponseSize < -1)) {\n      throw new InvalidArgumentError('maxResponseSize must be a positive number')\n    }\n\n    if (\n      autoSelectFamilyAttemptTimeout != null &&\n      (!Number.isInteger(autoSelectFamilyAttemptTimeout) || autoSelectFamilyAttemptTimeout < -1)\n    ) {\n      throw new InvalidArgumentError('autoSelectFamilyAttemptTimeout must be a positive number')\n    }\n\n    if (typeof connect !== 'function') {\n      connect = buildConnector({\n        ...tls,\n        maxCachedSessions,\n        socketPath,\n        timeout: connectTimeout,\n        ...(util.nodeHasAutoSelectFamily && autoSelectFamily ? { autoSelectFamily, autoSelectFamilyAttemptTimeout } : undefined),\n        ...connect\n      })\n    }\n\n    this[kInterceptors] = interceptors && interceptors.Client && Array.isArray(interceptors.Client)\n      ? interceptors.Client\n      : [createRedirectInterceptor({ maxRedirections })]\n    this[kUrl] = util.parseOrigin(url)\n    this[kConnector] = connect\n    this[kSocket] = null\n    this[kPipelining] = pipelining != null ? pipelining : 1\n    this[kMaxHeadersSize] = maxHeaderSize || 16384\n    this[kKeepAliveDefaultTimeout] = keepAliveTimeout == null ? 4e3 : keepAliveTimeout\n    this[kKeepAliveMaxTimeout] = keepAliveMaxTimeout == null ? 600e3 : keepAliveMaxTimeout\n    this[kKeepAliveTimeoutThreshold] = keepAliveTimeoutThreshold == null ? 1e3 : keepAliveTimeoutThreshold\n    this[kKeepAliveTimeoutValue] = this[kKeepAliveDefaultTimeout]\n    this[kServerName] = null\n    this[kLocalAddress] = localAddress != null ? localAddress : null\n    this[kResuming] = 0 // 0, idle, 1, scheduled, 2 resuming\n    this[kNeedDrain] = 0 // 0, idle, 1, scheduled, 2 resuming\n    this[kHostHeader] = `host: ${this[kUrl].hostname}${this[kUrl].port ? `:${this[kUrl].port}` : ''}\\r\\n`\n    this[kBodyTimeout] = bodyTimeout != null ? bodyTimeout : 300e3\n    this[kHeadersTimeout] = headersTimeout != null ? headersTimeout : 300e3\n    this[kStrictContentLength] = strictContentLength == null ? true : strictContentLength\n    this[kMaxRedirections] = maxRedirections\n    this[kMaxRequests] = maxRequestsPerClient\n    this[kClosedResolve] = null\n    this[kMaxResponseSize] = maxResponseSize > -1 ? maxResponseSize : -1\n\n    // kQueue is built up of 3 sections separated by\n    // the kRunningIdx and kPendingIdx indices.\n    // |   complete   |   running   |   pending   |\n    //                ^ kRunningIdx ^ kPendingIdx ^ kQueue.length\n    // kRunningIdx points to the first running element.\n    // kPendingIdx points to the first pending element.\n    // This implements a fast queue with an amortized\n    // time of O(1).\n\n    this[kQueue] = []\n    this[kRunningIdx] = 0\n    this[kPendingIdx] = 0\n  }\n\n  get pipelining () {\n    return this[kPipelining]\n  }\n\n  set pipelining (value) {\n    this[kPipelining] = value\n    resume(this, true)\n  }\n\n  get [kPending] () {\n    return this[kQueue].length - this[kPendingIdx]\n  }\n\n  get [kRunning] () {\n    return this[kPendingIdx] - this[kRunningIdx]\n  }\n\n  get [kSize] () {\n    return this[kQueue].length - this[kRunningIdx]\n  }\n\n  get [kConnected] () {\n    return !!this[kSocket] && !this[kConnecting] && !this[kSocket].destroyed\n  }\n\n  get [kBusy] () {\n    const socket = this[kSocket]\n    return (\n      (socket && (socket[kReset] || socket[kWriting] || socket[kBlocking])) ||\n      (this[kSize] >= (this[kPipelining] || 1)) ||\n      this[kPending] > 0\n    )\n  }\n\n  /* istanbul ignore: only used for test */\n  [kConnect] (cb) {\n    connect(this)\n    this.once('connect', cb)\n  }\n\n  [kDispatch] (opts, handler) {\n    const origin = opts.origin || this[kUrl].origin\n\n    const request = new Request(origin, opts, handler)\n\n    this[kQueue].push(request)\n    if (this[kResuming]) {\n      // Do nothing.\n    } else if (util.bodyLength(request.body) == null && util.isIterable(request.body)) {\n      // Wait a tick in case stream/iterator is ended in the same tick.\n      this[kResuming] = 1\n      process.nextTick(resume, this)\n    } else {\n      resume(this, true)\n    }\n\n    if (this[kResuming] && this[kNeedDrain] !== 2 && this[kBusy]) {\n      this[kNeedDrain] = 2\n    }\n\n    return this[kNeedDrain] < 2\n  }\n\n  async [kClose] () {\n    return new Promise((resolve) => {\n      if (!this[kSize]) {\n        this.destroy(resolve)\n      } else {\n        this[kClosedResolve] = resolve\n      }\n    })\n  }\n\n  async [kDestroy] (err) {\n    return new Promise((resolve) => {\n      const requests = this[kQueue].splice(this[kPendingIdx])\n      for (let i = 0; i < requests.length; i++) {\n        const request = requests[i]\n        errorRequest(this, request, err)\n      }\n\n      const callback = () => {\n        if (this[kClosedResolve]) {\n          this[kClosedResolve]()\n          this[kClosedResolve] = null\n        }\n        resolve()\n      }\n\n      if (!this[kSocket]) {\n        queueMicrotask(callback)\n      } else {\n        util.destroy(this[kSocket].on('close', callback), err)\n      }\n\n      resume(this)\n    })\n  }\n}\n\nconst constants = require('./llhttp/constants')\nconst createRedirectInterceptor = require('./interceptor/redirectInterceptor')\nconst EMPTY_BUF = Buffer.alloc(0)\n\nasync function lazyllhttp () {\n  const llhttpWasmData = process.env.JEST_WORKER_ID ? require('./llhttp/llhttp.wasm.js') : undefined\n\n  let mod\n  try {\n    mod = await WebAssembly.compile(Buffer.from(require('./llhttp/llhttp_simd.wasm.js'), 'base64'))\n  } catch (e) {\n    /* istanbul ignore next */\n\n    // We could check if the error was caused by the simd option not\n    // being enabled, but the occurring of this other error\n    // * https://github.com/emscripten-core/emscripten/issues/11495\n    // got me to remove that check to avoid breaking Node 12.\n    mod = await WebAssembly.compile(Buffer.from(llhttpWasmData || require('./llhttp/llhttp.wasm.js'), 'base64'))\n  }\n\n  return await WebAssembly.instantiate(mod, {\n    env: {\n      /* eslint-disable camelcase */\n\n      wasm_on_url: (p, at, len) => {\n        /* istanbul ignore next */\n        return 0\n      },\n      wasm_on_status: (p, at, len) => {\n        assert.strictEqual(currentParser.ptr, p)\n        const start = at - currentBufferPtr + currentBufferRef.byteOffset\n        return currentParser.onStatus(new FastBuffer(currentBufferRef.buffer, start, len)) || 0\n      },\n      wasm_on_message_begin: (p) => {\n        assert.strictEqual(currentParser.ptr, p)\n        return currentParser.onMessageBegin() || 0\n      },\n      wasm_on_header_field: (p, at, len) => {\n        assert.strictEqual(currentParser.ptr, p)\n        const start = at - currentBufferPtr + currentBufferRef.byteOffset\n        return currentParser.onHeaderField(new FastBuffer(currentBufferRef.buffer, start, len)) || 0\n      },\n      wasm_on_header_value: (p, at, len) => {\n        assert.strictEqual(currentParser.ptr, p)\n        const start = at - currentBufferPtr + currentBufferRef.byteOffset\n        return currentParser.onHeaderValue(new FastBuffer(currentBufferRef.buffer, start, len)) || 0\n      },\n      wasm_on_headers_complete: (p, statusCode, upgrade, shouldKeepAlive) => {\n        assert.strictEqual(currentParser.ptr, p)\n        return currentParser.onHeadersComplete(statusCode, Boolean(upgrade), Boolean(shouldKeepAlive)) || 0\n      },\n      wasm_on_body: (p, at, len) => {\n        assert.strictEqual(currentParser.ptr, p)\n        const start = at - currentBufferPtr + currentBufferRef.byteOffset\n        return currentParser.onBody(new FastBuffer(currentBufferRef.buffer, start, len)) || 0\n      },\n      wasm_on_message_complete: (p) => {\n        assert.strictEqual(currentParser.ptr, p)\n        return currentParser.onMessageComplete() || 0\n      }\n\n      /* eslint-enable camelcase */\n    }\n  })\n}\n\nlet llhttpInstance = null\nlet llhttpPromise = lazyllhttp()\nllhttpPromise.catch()\n\nlet currentParser = null\nlet currentBufferRef = null\nlet currentBufferSize = 0\nlet currentBufferPtr = null\n\nconst TIMEOUT_HEADERS = 1\nconst TIMEOUT_BODY = 2\nconst TIMEOUT_IDLE = 3\n\nclass Parser {\n  constructor (client, socket, { exports }) {\n    assert(Number.isFinite(client[kMaxHeadersSize]) && client[kMaxHeadersSize] > 0)\n\n    this.llhttp = exports\n    this.ptr = this.llhttp.llhttp_alloc(constants.TYPE.RESPONSE)\n    this.client = client\n    this.socket = socket\n    this.timeout = null\n    this.timeoutValue = null\n    this.timeoutType = null\n    this.statusCode = null\n    this.statusText = ''\n    this.upgrade = false\n    this.headers = []\n    this.headersSize = 0\n    this.headersMaxSize = client[kMaxHeadersSize]\n    this.shouldKeepAlive = false\n    this.paused = false\n    this.resume = this.resume.bind(this)\n\n    this.bytesRead = 0\n\n    this.keepAlive = ''\n    this.contentLength = ''\n    this.connection = ''\n    this.maxResponseSize = client[kMaxResponseSize]\n  }\n\n  setTimeout (value, type) {\n    this.timeoutType = type\n    if (value !== this.timeoutValue) {\n      timers.clearTimeout(this.timeout)\n      if (value) {\n        this.timeout = timers.setTimeout(onParserTimeout, value, this)\n        // istanbul ignore else: only for jest\n        if (this.timeout.unref) {\n          this.timeout.unref()\n        }\n      } else {\n        this.timeout = null\n      }\n      this.timeoutValue = value\n    } else if (this.timeout) {\n      // istanbul ignore else: only for jest\n      if (this.timeout.refresh) {\n        this.timeout.refresh()\n      }\n    }\n  }\n\n  resume () {\n    if (this.socket.destroyed || !this.paused) {\n      return\n    }\n\n    assert(this.ptr != null)\n    assert(currentParser == null)\n\n    this.llhttp.llhttp_resume(this.ptr)\n\n    assert(this.timeoutType === TIMEOUT_BODY)\n    if (this.timeout) {\n      // istanbul ignore else: only for jest\n      if (this.timeout.refresh) {\n        this.timeout.refresh()\n      }\n    }\n\n    this.paused = false\n    this.execute(this.socket.read() || EMPTY_BUF) // Flush parser.\n    this.readMore()\n  }\n\n  readMore () {\n    while (!this.paused && this.ptr) {\n      const chunk = this.socket.read()\n      if (chunk === null) {\n        break\n      }\n      this.execute(chunk)\n    }\n  }\n\n  execute (data) {\n    assert(this.ptr != null)\n    assert(currentParser == null)\n    assert(!this.paused)\n\n    const { socket, llhttp } = this\n\n    if (data.length > currentBufferSize) {\n      if (currentBufferPtr) {\n        llhttp.free(currentBufferPtr)\n      }\n      currentBufferSize = Math.ceil(data.length / 4096) * 4096\n      currentBufferPtr = llhttp.malloc(currentBufferSize)\n    }\n\n    new Uint8Array(llhttp.memory.buffer, currentBufferPtr, currentBufferSize).set(data)\n\n    // Call `execute` on the wasm parser.\n    // We pass the `llhttp_parser` pointer address, the pointer address of buffer view data,\n    // and finally the length of bytes to parse.\n    // The return value is an error code or `constants.ERROR.OK`.\n    try {\n      let ret\n\n      try {\n        currentBufferRef = data\n        currentParser = this\n        ret = llhttp.llhttp_execute(this.ptr, currentBufferPtr, data.length)\n        /* eslint-disable-next-line no-useless-catch */\n      } catch (err) {\n        /* istanbul ignore next: difficult to make a test case for */\n        throw err\n      } finally {\n        currentParser = null\n        currentBufferRef = null\n      }\n\n      const offset = llhttp.llhttp_get_error_pos(this.ptr) - currentBufferPtr\n\n      if (ret === constants.ERROR.PAUSED_UPGRADE) {\n        this.onUpgrade(data.slice(offset))\n      } else if (ret === constants.ERROR.PAUSED) {\n        this.paused = true\n        socket.unshift(data.slice(offset))\n      } else if (ret !== constants.ERROR.OK) {\n        const ptr = llhttp.llhttp_get_error_reason(this.ptr)\n        let message = ''\n        /* istanbul ignore else: difficult to make a test case for */\n        if (ptr) {\n          const len = new Uint8Array(llhttp.memory.buffer, ptr).indexOf(0)\n          message = Buffer.from(llhttp.memory.buffer, ptr, len).toString()\n        }\n        throw new HTTPParserError(message, constants.ERROR[ret], data.slice(offset))\n      }\n    } catch (err) {\n      util.destroy(socket, err)\n    }\n  }\n\n  destroy () {\n    assert(this.ptr != null)\n    assert(currentParser == null)\n\n    this.llhttp.llhttp_free(this.ptr)\n    this.ptr = null\n\n    timers.clearTimeout(this.timeout)\n    this.timeout = null\n    this.timeoutValue = null\n    this.timeoutType = null\n\n    this.paused = false\n  }\n\n  onStatus (buf) {\n    this.statusText = buf.toString()\n  }\n\n  onMessageBegin () {\n    const { socket, client } = this\n\n    /* istanbul ignore next: difficult to make a test case for */\n    if (socket.destroyed) {\n      return -1\n    }\n\n    const request = client[kQueue][client[kRunningIdx]]\n    if (!request) {\n      return -1\n    }\n  }\n\n  onHeaderField (buf) {\n    const len = this.headers.length\n\n    if ((len & 1) === 0) {\n      this.headers.push(buf)\n    } else {\n      this.headers[len - 1] = Buffer.concat([this.headers[len - 1], buf])\n    }\n\n    this.trackHeader(buf.length)\n  }\n\n  onHeaderValue (buf) {\n    let len = this.headers.length\n\n    if ((len & 1) === 1) {\n      this.headers.push(buf)\n      len += 1\n    } else {\n      this.headers[len - 1] = Buffer.concat([this.headers[len - 1], buf])\n    }\n\n    const key = this.headers[len - 2]\n    if (key.length === 10 && key.toString().toLowerCase() === 'keep-alive') {\n      this.keepAlive += buf.toString()\n    } else if (key.length === 10 && key.toString().toLowerCase() === 'connection') {\n      this.connection += buf.toString()\n    } else if (key.length === 14 && key.toString().toLowerCase() === 'content-length') {\n      this.contentLength += buf.toString()\n    }\n\n    this.trackHeader(buf.length)\n  }\n\n  trackHeader (len) {\n    this.headersSize += len\n    if (this.headersSize >= this.headersMaxSize) {\n      util.destroy(this.socket, new HeadersOverflowError())\n    }\n  }\n\n  onUpgrade (head) {\n    const { upgrade, client, socket, headers, statusCode } = this\n\n    assert(upgrade)\n\n    const request = client[kQueue][client[kRunningIdx]]\n    assert(request)\n\n    assert(!socket.destroyed)\n    assert(socket === client[kSocket])\n    assert(!this.paused)\n    assert(request.upgrade || request.method === 'CONNECT')\n\n    this.statusCode = null\n    this.statusText = ''\n    this.shouldKeepAlive = null\n\n    assert(this.headers.length % 2 === 0)\n    this.headers = []\n    this.headersSize = 0\n\n    socket.unshift(head)\n\n    socket[kParser].destroy()\n    socket[kParser] = null\n\n    socket[kClient] = null\n    socket[kError] = null\n    socket\n      .removeListener('error', onSocketError)\n      .removeListener('readable', onSocketReadable)\n      .removeListener('end', onSocketEnd)\n      .removeListener('close', onSocketClose)\n\n    client[kSocket] = null\n    client[kQueue][client[kRunningIdx]++] = null\n    client.emit('disconnect', client[kUrl], [client], new InformationalError('upgrade'))\n\n    try {\n      request.onUpgrade(statusCode, headers, socket)\n    } catch (err) {\n      util.destroy(socket, err)\n    }\n\n    resume(client)\n  }\n\n  onHeadersComplete (statusCode, upgrade, shouldKeepAlive) {\n    const { client, socket, headers, statusText } = this\n\n    /* istanbul ignore next: difficult to make a test case for */\n    if (socket.destroyed) {\n      return -1\n    }\n\n    const request = client[kQueue][client[kRunningIdx]]\n\n    /* istanbul ignore next: difficult to make a test case for */\n    if (!request) {\n      return -1\n    }\n\n    assert(!this.upgrade)\n    assert(this.statusCode < 200)\n\n    if (statusCode === 100) {\n      util.destroy(socket, new SocketError('bad response', util.getSocketInfo(socket)))\n      return -1\n    }\n\n    /* this can only happen if server is misbehaving */\n    if (upgrade && !request.upgrade) {\n      util.destroy(socket, new SocketError('bad upgrade', util.getSocketInfo(socket)))\n      return -1\n    }\n\n    assert.strictEqual(this.timeoutType, TIMEOUT_HEADERS)\n\n    this.statusCode = statusCode\n    this.shouldKeepAlive = (\n      shouldKeepAlive ||\n      // Override llhttp value which does not allow keepAlive for HEAD.\n      (request.method === 'HEAD' && !socket[kReset] && this.connection.toLowerCase() === 'keep-alive')\n    )\n\n    if (this.statusCode >= 200) {\n      const bodyTimeout = request.bodyTimeout != null\n        ? request.bodyTimeout\n        : client[kBodyTimeout]\n      this.setTimeout(bodyTimeout, TIMEOUT_BODY)\n    } else if (this.timeout) {\n      // istanbul ignore else: only for jest\n      if (this.timeout.refresh) {\n        this.timeout.refresh()\n      }\n    }\n\n    if (request.method === 'CONNECT') {\n      assert(client[kRunning] === 1)\n      this.upgrade = true\n      return 2\n    }\n\n    if (upgrade) {\n      assert(client[kRunning] === 1)\n      this.upgrade = true\n      return 2\n    }\n\n    assert(this.headers.length % 2 === 0)\n    this.headers = []\n    this.headersSize = 0\n\n    if (this.shouldKeepAlive && client[kPipelining]) {\n      const keepAliveTimeout = this.keepAlive ? util.parseKeepAliveTimeout(this.keepAlive) : null\n\n      if (keepAliveTimeout != null) {\n        const timeout = Math.min(\n          keepAliveTimeout - client[kKeepAliveTimeoutThreshold],\n          client[kKeepAliveMaxTimeout]\n        )\n        if (timeout <= 0) {\n          socket[kReset] = true\n        } else {\n          client[kKeepAliveTimeoutValue] = timeout\n        }\n      } else {\n        client[kKeepAliveTimeoutValue] = client[kKeepAliveDefaultTimeout]\n      }\n    } else {\n      // Stop more requests from being dispatched.\n      socket[kReset] = true\n    }\n\n    let pause\n    try {\n      pause = request.onHeaders(statusCode, headers, this.resume, statusText) === false\n    } catch (err) {\n      util.destroy(socket, err)\n      return -1\n    }\n\n    if (request.method === 'HEAD') {\n      return 1\n    }\n\n    if (statusCode < 200) {\n      return 1\n    }\n\n    if (socket[kBlocking]) {\n      socket[kBlocking] = false\n      resume(client)\n    }\n\n    return pause ? constants.ERROR.PAUSED : 0\n  }\n\n  onBody (buf) {\n    const { client, socket, statusCode, maxResponseSize } = this\n\n    if (socket.destroyed) {\n      return -1\n    }\n\n    const request = client[kQueue][client[kRunningIdx]]\n    assert(request)\n\n    assert.strictEqual(this.timeoutType, TIMEOUT_BODY)\n    if (this.timeout) {\n      // istanbul ignore else: only for jest\n      if (this.timeout.refresh) {\n        this.timeout.refresh()\n      }\n    }\n\n    assert(statusCode >= 200)\n\n    if (maxResponseSize > -1 && this.bytesRead + buf.length > maxResponseSize) {\n      util.destroy(socket, new ResponseExceededMaxSizeError())\n      return -1\n    }\n\n    this.bytesRead += buf.length\n\n    try {\n      if (request.onData(buf) === false) {\n        return constants.ERROR.PAUSED\n      }\n    } catch (err) {\n      util.destroy(socket, err)\n      return -1\n    }\n  }\n\n  onMessageComplete () {\n    const { client, socket, statusCode, upgrade, headers, contentLength, bytesRead, shouldKeepAlive } = this\n\n    if (socket.destroyed && (!statusCode || shouldKeepAlive)) {\n      return -1\n    }\n\n    if (upgrade) {\n      return\n    }\n\n    const request = client[kQueue][client[kRunningIdx]]\n    assert(request)\n\n    assert(statusCode >= 100)\n\n    this.statusCode = null\n    this.statusText = ''\n    this.bytesRead = 0\n    this.contentLength = ''\n    this.keepAlive = ''\n    this.connection = ''\n\n    assert(this.headers.length % 2 === 0)\n    this.headers = []\n    this.headersSize = 0\n\n    if (statusCode < 200) {\n      return\n    }\n\n    /* istanbul ignore next: should be handled by llhttp? */\n    if (request.method !== 'HEAD' && contentLength && bytesRead !== parseInt(contentLength, 10)) {\n      util.destroy(socket, new ResponseContentLengthMismatchError())\n      return -1\n    }\n\n    try {\n      request.onComplete(headers)\n    } catch (err) {\n      errorRequest(client, request, err)\n    }\n\n    client[kQueue][client[kRunningIdx]++] = null\n\n    if (socket[kWriting]) {\n      assert.strictEqual(client[kRunning], 0)\n      // Response completed before request.\n      util.destroy(socket, new InformationalError('reset'))\n      return constants.ERROR.PAUSED\n    } else if (!shouldKeepAlive) {\n      util.destroy(socket, new InformationalError('reset'))\n      return constants.ERROR.PAUSED\n    } else if (socket[kReset] && client[kRunning] === 0) {\n      // Destroy socket once all requests have completed.\n      // The request at the tail of the pipeline is the one\n      // that requested reset and no further requests should\n      // have been queued since then.\n      util.destroy(socket, new InformationalError('reset'))\n      return constants.ERROR.PAUSED\n    } else if (client[kPipelining] === 1) {\n      // We must wait a full event loop cycle to reuse this socket to make sure\n      // that non-spec compliant servers are not closing the connection even if they\n      // said they won't.\n      setImmediate(resume, client)\n    } else {\n      resume(client)\n    }\n  }\n}\n\nfunction onParserTimeout (parser) {\n  const { socket, timeoutType, client } = parser\n\n  /* istanbul ignore else */\n  if (timeoutType === TIMEOUT_HEADERS) {\n    if (!socket[kWriting] || socket.writableNeedDrain || client[kRunning] > 1) {\n      assert(!parser.paused, 'cannot be paused while waiting for headers')\n      util.destroy(socket, new HeadersTimeoutError())\n    }\n  } else if (timeoutType === TIMEOUT_BODY) {\n    if (!parser.paused) {\n      util.destroy(socket, new BodyTimeoutError())\n    }\n  } else if (timeoutType === TIMEOUT_IDLE) {\n    assert(client[kRunning] === 0 && client[kKeepAliveTimeoutValue])\n    util.destroy(socket, new InformationalError('socket idle timeout'))\n  }\n}\n\nfunction onSocketReadable () {\n  const { [kParser]: parser } = this\n  parser.readMore()\n}\n\nfunction onSocketError (err) {\n  const { [kParser]: parser } = this\n\n  assert(err.code !== 'ERR_TLS_CERT_ALTNAME_INVALID')\n\n  // On Mac OS, we get an ECONNRESET even if there is a full body to be forwarded\n  // to the user.\n  if (err.code === 'ECONNRESET' && parser.statusCode && !parser.shouldKeepAlive) {\n    // We treat all incoming data so for as a valid response.\n    parser.onMessageComplete()\n    return\n  }\n\n  this[kError] = err\n\n  onError(this[kClient], err)\n}\n\nfunction onError (client, err) {\n  if (\n    client[kRunning] === 0 &&\n    err.code !== 'UND_ERR_INFO' &&\n    err.code !== 'UND_ERR_SOCKET'\n  ) {\n    // Error is not caused by running request and not a recoverable\n    // socket error.\n\n    assert(client[kPendingIdx] === client[kRunningIdx])\n\n    const requests = client[kQueue].splice(client[kRunningIdx])\n    for (let i = 0; i < requests.length; i++) {\n      const request = requests[i]\n      errorRequest(client, request, err)\n    }\n    assert(client[kSize] === 0)\n  }\n}\n\nfunction onSocketEnd () {\n  const { [kParser]: parser } = this\n\n  if (parser.statusCode && !parser.shouldKeepAlive) {\n    // We treat all incoming data so far as a valid response.\n    parser.onMessageComplete()\n    return\n  }\n\n  util.destroy(this, new SocketError('other side closed', util.getSocketInfo(this)))\n}\n\nfunction onSocketClose () {\n  const { [kClient]: client } = this\n\n  if (!this[kError] && this[kParser].statusCode && !this[kParser].shouldKeepAlive) {\n    // We treat all incoming data so far as a valid response.\n    this[kParser].onMessageComplete()\n  }\n\n  this[kParser].destroy()\n  this[kParser] = null\n\n  const err = this[kError] || new SocketError('closed', util.getSocketInfo(this))\n\n  client[kSocket] = null\n\n  if (client.destroyed) {\n    assert(client[kPending] === 0)\n\n    // Fail entire queue.\n    const requests = client[kQueue].splice(client[kRunningIdx])\n    for (let i = 0; i < requests.length; i++) {\n      const request = requests[i]\n      errorRequest(client, request, err)\n    }\n  } else if (client[kRunning] > 0 && err.code !== 'UND_ERR_INFO') {\n    // Fail head of pipeline.\n    const request = client[kQueue][client[kRunningIdx]]\n    client[kQueue][client[kRunningIdx]++] = null\n\n    errorRequest(client, request, err)\n  }\n\n  client[kPendingIdx] = client[kRunningIdx]\n\n  assert(client[kRunning] === 0)\n\n  client.emit('disconnect', client[kUrl], [client], err)\n\n  resume(client)\n}\n\nasync function connect (client) {\n  assert(!client[kConnecting])\n  assert(!client[kSocket])\n\n  let { host, hostname, protocol, port } = client[kUrl]\n\n  // Resolve ipv6\n  if (hostname[0] === '[') {\n    const idx = hostname.indexOf(']')\n\n    assert(idx !== -1)\n    const ip = hostname.substr(1, idx - 1)\n\n    assert(net.isIP(ip))\n    hostname = ip\n  }\n\n  client[kConnecting] = true\n\n  if (channels.beforeConnect.hasSubscribers) {\n    channels.beforeConnect.publish({\n      connectParams: {\n        host,\n        hostname,\n        protocol,\n        port,\n        servername: client[kServerName],\n        localAddress: client[kLocalAddress]\n      },\n      connector: client[kConnector]\n    })\n  }\n\n  try {\n    const socket = await new Promise((resolve, reject) => {\n      client[kConnector]({\n        host,\n        hostname,\n        protocol,\n        port,\n        servername: client[kServerName],\n        localAddress: client[kLocalAddress]\n      }, (err, socket) => {\n        if (err) {\n          reject(err)\n        } else {\n          resolve(socket)\n        }\n      })\n    })\n\n    if (!llhttpInstance) {\n      llhttpInstance = await llhttpPromise\n      llhttpPromise = null\n    }\n\n    client[kConnecting] = false\n\n    assert(socket)\n\n    socket[kNoRef] = false\n    socket[kWriting] = false\n    socket[kReset] = false\n    socket[kBlocking] = false\n    socket[kError] = null\n    socket[kParser] = new Parser(client, socket, llhttpInstance)\n    socket[kClient] = client\n    socket[kCounter] = 0\n    socket[kMaxRequests] = client[kMaxRequests]\n    socket\n      .on('error', onSocketError)\n      .on('readable', onSocketReadable)\n      .on('end', onSocketEnd)\n      .on('close', onSocketClose)\n\n    client[kSocket] = socket\n\n    if (channels.connected.hasSubscribers) {\n      channels.connected.publish({\n        connectParams: {\n          host,\n          hostname,\n          protocol,\n          port,\n          servername: client[kServerName],\n          localAddress: client[kLocalAddress]\n        },\n        connector: client[kConnector],\n        socket\n      })\n    }\n    client.emit('connect', client[kUrl], [client])\n  } catch (err) {\n    client[kConnecting] = false\n\n    if (channels.connectError.hasSubscribers) {\n      channels.connectError.publish({\n        connectParams: {\n          host,\n          hostname,\n          protocol,\n          port,\n          servername: client[kServerName],\n          localAddress: client[kLocalAddress]\n        },\n        connector: client[kConnector],\n        error: err\n      })\n    }\n\n    if (err.code === 'ERR_TLS_CERT_ALTNAME_INVALID') {\n      assert(client[kRunning] === 0)\n      while (client[kPending] > 0 && client[kQueue][client[kPendingIdx]].servername === client[kServerName]) {\n        const request = client[kQueue][client[kPendingIdx]++]\n        errorRequest(client, request, err)\n      }\n    } else {\n      onError(client, err)\n    }\n\n    client.emit('connectionError', client[kUrl], [client], err)\n  }\n\n  resume(client)\n}\n\nfunction emitDrain (client) {\n  client[kNeedDrain] = 0\n  client.emit('drain', client[kUrl], [client])\n}\n\nfunction resume (client, sync) {\n  if (client[kResuming] === 2) {\n    return\n  }\n\n  client[kResuming] = 2\n\n  _resume(client, sync)\n  client[kResuming] = 0\n\n  if (client[kRunningIdx] > 256) {\n    client[kQueue].splice(0, client[kRunningIdx])\n    client[kPendingIdx] -= client[kRunningIdx]\n    client[kRunningIdx] = 0\n  }\n}\n\nfunction _resume (client, sync) {\n  while (true) {\n    if (client.destroyed) {\n      assert(client[kPending] === 0)\n      return\n    }\n\n    if (client.closed && !client[kSize]) {\n      client.destroy()\n      return\n    }\n\n    const socket = client[kSocket]\n\n    if (socket && !socket.destroyed) {\n      if (client[kSize] === 0) {\n        if (!socket[kNoRef] && socket.unref) {\n          socket.unref()\n          socket[kNoRef] = true\n        }\n      } else if (socket[kNoRef] && socket.ref) {\n        socket.ref()\n        socket[kNoRef] = false\n      }\n\n      if (client[kSize] === 0) {\n        if (socket[kParser].timeoutType !== TIMEOUT_IDLE) {\n          socket[kParser].setTimeout(client[kKeepAliveTimeoutValue], TIMEOUT_IDLE)\n        }\n      } else if (client[kRunning] > 0 && socket[kParser].statusCode < 200) {\n        if (socket[kParser].timeoutType !== TIMEOUT_HEADERS) {\n          const request = client[kQueue][client[kRunningIdx]]\n          const headersTimeout = request.headersTimeout != null\n            ? request.headersTimeout\n            : client[kHeadersTimeout]\n          socket[kParser].setTimeout(headersTimeout, TIMEOUT_HEADERS)\n        }\n      }\n    }\n\n    if (client[kBusy]) {\n      client[kNeedDrain] = 2\n    } else if (client[kNeedDrain] === 2) {\n      if (sync) {\n        client[kNeedDrain] = 1\n        process.nextTick(emitDrain, client)\n      } else {\n        emitDrain(client)\n      }\n      continue\n    }\n\n    if (client[kPending] === 0) {\n      return\n    }\n\n    if (client[kRunning] >= (client[kPipelining] || 1)) {\n      return\n    }\n\n    const request = client[kQueue][client[kPendingIdx]]\n\n    if (client[kUrl].protocol === 'https:' && client[kServerName] !== request.servername) {\n      if (client[kRunning] > 0) {\n        return\n      }\n\n      client[kServerName] = request.servername\n\n      if (socket && socket.servername !== request.servername) {\n        util.destroy(socket, new InformationalError('servername changed'))\n        return\n      }\n    }\n\n    if (client[kConnecting]) {\n      return\n    }\n\n    if (!socket) {\n      connect(client)\n      return\n    }\n\n    if (socket.destroyed || socket[kWriting] || socket[kReset] || socket[kBlocking]) {\n      return\n    }\n\n    if (client[kRunning] > 0 && !request.idempotent) {\n      // Non-idempotent request cannot be retried.\n      // Ensure that no other requests are inflight and\n      // could cause failure.\n      return\n    }\n\n    if (client[kRunning] > 0 && (request.upgrade || request.method === 'CONNECT')) {\n      // Don't dispatch an upgrade until all preceding requests have completed.\n      // A misbehaving server might upgrade the connection before all pipelined\n      // request has completed.\n      return\n    }\n\n    if (util.isStream(request.body) && util.bodyLength(request.body) === 0) {\n      request.body\n        .on('data', /* istanbul ignore next */ function () {\n          /* istanbul ignore next */\n          assert(false)\n        })\n        .on('error', function (err) {\n          errorRequest(client, request, err)\n        })\n        .on('end', function () {\n          util.destroy(this)\n        })\n\n      request.body = null\n    }\n\n    if (client[kRunning] > 0 &&\n      (util.isStream(request.body) || util.isAsyncIterable(request.body))) {\n      // Request with stream or iterator body can error while other requests\n      // are inflight and indirectly error those as well.\n      // Ensure this doesn't happen by waiting for inflight\n      // to complete before dispatching.\n\n      // Request with stream or iterator body cannot be retried.\n      // Ensure that no other requests are inflight and\n      // could cause failure.\n      return\n    }\n\n    if (!request.aborted && write(client, request)) {\n      client[kPendingIdx]++\n    } else {\n      client[kQueue].splice(client[kPendingIdx], 1)\n    }\n  }\n}\n\nfunction write (client, request) {\n  const { body, method, path, host, upgrade, headers, blocking, reset } = request\n\n  // https://tools.ietf.org/html/rfc7231#section-4.3.1\n  // https://tools.ietf.org/html/rfc7231#section-4.3.2\n  // https://tools.ietf.org/html/rfc7231#section-4.3.5\n\n  // Sending a payload body on a request that does not\n  // expect it can cause undefined behavior on some\n  // servers and corrupt connection state. Do not\n  // re-use the connection for further requests.\n\n  const expectsPayload = (\n    method === 'PUT' ||\n    method === 'POST' ||\n    method === 'PATCH'\n  )\n\n  if (body && typeof body.read === 'function') {\n    // Try to read EOF in order to get length.\n    body.read(0)\n  }\n\n  let contentLength = util.bodyLength(body)\n\n  if (contentLength === null) {\n    contentLength = request.contentLength\n  }\n\n  if (contentLength === 0 && !expectsPayload) {\n    // https://tools.ietf.org/html/rfc7230#section-3.3.2\n    // A user agent SHOULD NOT send a Content-Length header field when\n    // the request message does not contain a payload body and the method\n    // semantics do not anticipate such a body.\n\n    contentLength = null\n  }\n\n  if (request.contentLength !== null && request.contentLength !== contentLength) {\n    if (client[kStrictContentLength]) {\n      errorRequest(client, request, new RequestContentLengthMismatchError())\n      return false\n    }\n\n    process.emitWarning(new RequestContentLengthMismatchError())\n  }\n\n  const socket = client[kSocket]\n\n  try {\n    request.onConnect((err) => {\n      if (request.aborted || request.completed) {\n        return\n      }\n\n      errorRequest(client, request, err || new RequestAbortedError())\n\n      util.destroy(socket, new InformationalError('aborted'))\n    })\n  } catch (err) {\n    errorRequest(client, request, err)\n  }\n\n  if (request.aborted) {\n    return false\n  }\n\n  if (method === 'HEAD') {\n    // https://github.com/mcollina/undici/issues/258\n    // Close after a HEAD request to interop with misbehaving servers\n    // that may send a body in the response.\n\n    socket[kReset] = true\n  }\n\n  if (upgrade || method === 'CONNECT') {\n    // On CONNECT or upgrade, block pipeline from dispatching further\n    // requests on this connection.\n\n    socket[kReset] = true\n  }\n\n  if (reset != null) {\n    socket[kReset] = reset\n  }\n\n  if (client[kMaxRequests] && socket[kCounter]++ >= client[kMaxRequests]) {\n    socket[kReset] = true\n  }\n\n  if (blocking) {\n    socket[kBlocking] = true\n  }\n\n  let header = `${method} ${path} HTTP/1.1\\r\\n`\n\n  if (typeof host === 'string') {\n    header += `host: ${host}\\r\\n`\n  } else {\n    header += client[kHostHeader]\n  }\n\n  if (upgrade) {\n    header += `connection: upgrade\\r\\nupgrade: ${upgrade}\\r\\n`\n  } else if (client[kPipelining] && !socket[kReset]) {\n    header += 'connection: keep-alive\\r\\n'\n  } else {\n    header += 'connection: close\\r\\n'\n  }\n\n  if (headers) {\n    header += headers\n  }\n\n  if (channels.sendHeaders.hasSubscribers) {\n    channels.sendHeaders.publish({ request, headers: header, socket })\n  }\n\n  /* istanbul ignore else: assertion */\n  if (!body) {\n    if (contentLength === 0) {\n      socket.write(`${header}content-length: 0\\r\\n\\r\\n`, 'ascii')\n    } else {\n      assert(contentLength === null, 'no body must not have content length')\n      socket.write(`${header}\\r\\n`, 'ascii')\n    }\n    request.onRequestSent()\n  } else if (util.isBuffer(body)) {\n    assert(contentLength === body.byteLength, 'buffer body must have content length')\n\n    socket.cork()\n    socket.write(`${header}content-length: ${contentLength}\\r\\n\\r\\n`, 'ascii')\n    socket.write(body)\n    socket.uncork()\n    request.onBodySent(body)\n    request.onRequestSent()\n    if (!expectsPayload) {\n      socket[kReset] = true\n    }\n  } else if (util.isBlobLike(body)) {\n    if (typeof body.stream === 'function') {\n      writeIterable({ body: body.stream(), client, request, socket, contentLength, header, expectsPayload })\n    } else {\n      writeBlob({ body, client, request, socket, contentLength, header, expectsPayload })\n    }\n  } else if (util.isStream(body)) {\n    writeStream({ body, client, request, socket, contentLength, header, expectsPayload })\n  } else if (util.isIterable(body)) {\n    writeIterable({ body, client, request, socket, contentLength, header, expectsPayload })\n  } else {\n    assert(false)\n  }\n\n  return true\n}\n\nfunction writeStream ({ body, client, request, socket, contentLength, header, expectsPayload }) {\n  assert(contentLength !== 0 || client[kRunning] === 0, 'stream body cannot be pipelined')\n\n  let finished = false\n\n  const writer = new AsyncWriter({ socket, request, contentLength, client, expectsPayload, header })\n\n  const onData = function (chunk) {\n    try {\n      assert(!finished)\n\n      if (!writer.write(chunk) && this.pause) {\n        this.pause()\n      }\n    } catch (err) {\n      util.destroy(this, err)\n    }\n  }\n  const onDrain = function () {\n    assert(!finished)\n\n    if (body.resume) {\n      body.resume()\n    }\n  }\n  const onAbort = function () {\n    onFinished(new RequestAbortedError())\n  }\n  const onFinished = function (err) {\n    if (finished) {\n      return\n    }\n\n    finished = true\n\n    assert(socket.destroyed || (socket[kWriting] && client[kRunning] <= 1))\n\n    socket\n      .off('drain', onDrain)\n      .off('error', onFinished)\n\n    body\n      .removeListener('data', onData)\n      .removeListener('end', onFinished)\n      .removeListener('error', onFinished)\n      .removeListener('close', onAbort)\n\n    if (!err) {\n      try {\n        writer.end()\n      } catch (er) {\n        err = er\n      }\n    }\n\n    writer.destroy(err)\n\n    if (err && (err.code !== 'UND_ERR_INFO' || err.message !== 'reset')) {\n      util.destroy(body, err)\n    } else {\n      util.destroy(body)\n    }\n  }\n\n  body\n    .on('data', onData)\n    .on('end', onFinished)\n    .on('error', onFinished)\n    .on('close', onAbort)\n\n  if (body.resume) {\n    body.resume()\n  }\n\n  socket\n    .on('drain', onDrain)\n    .on('error', onFinished)\n}\n\nasync function writeBlob ({ body, client, request, socket, contentLength, header, expectsPayload }) {\n  assert(contentLength === body.size, 'blob body must have content length')\n\n  try {\n    if (contentLength != null && contentLength !== body.size) {\n      throw new RequestContentLengthMismatchError()\n    }\n\n    const buffer = Buffer.from(await body.arrayBuffer())\n\n    socket.cork()\n    socket.write(`${header}content-length: ${contentLength}\\r\\n\\r\\n`, 'ascii')\n    socket.write(buffer)\n    socket.uncork()\n\n    request.onBodySent(buffer)\n    request.onRequestSent()\n\n    if (!expectsPayload) {\n      socket[kReset] = true\n    }\n\n    resume(client)\n  } catch (err) {\n    util.destroy(socket, err)\n  }\n}\n\nasync function writeIterable ({ body, client, request, socket, contentLength, header, expectsPayload }) {\n  assert(contentLength !== 0 || client[kRunning] === 0, 'iterator body cannot be pipelined')\n\n  let callback = null\n  function onDrain () {\n    if (callback) {\n      const cb = callback\n      callback = null\n      cb()\n    }\n  }\n\n  const waitForDrain = () => new Promise((resolve, reject) => {\n    assert(callback === null)\n\n    if (socket[kError]) {\n      reject(socket[kError])\n    } else {\n      callback = resolve\n    }\n  })\n\n  socket\n    .on('close', onDrain)\n    .on('drain', onDrain)\n\n  const writer = new AsyncWriter({ socket, request, contentLength, client, expectsPayload, header })\n  try {\n    // It's up to the user to somehow abort the async iterable.\n    for await (const chunk of body) {\n      if (socket[kError]) {\n        throw socket[kError]\n      }\n\n      if (!writer.write(chunk)) {\n        await waitForDrain()\n      }\n    }\n\n    writer.end()\n  } catch (err) {\n    writer.destroy(err)\n  } finally {\n    socket\n      .off('close', onDrain)\n      .off('drain', onDrain)\n  }\n}\n\nclass AsyncWriter {\n  constructor ({ socket, request, contentLength, client, expectsPayload, header }) {\n    this.socket = socket\n    this.request = request\n    this.contentLength = contentLength\n    this.client = client\n    this.bytesWritten = 0\n    this.expectsPayload = expectsPayload\n    this.header = header\n\n    socket[kWriting] = true\n  }\n\n  write (chunk) {\n    const { socket, request, contentLength, client, bytesWritten, expectsPayload, header } = this\n\n    if (socket[kError]) {\n      throw socket[kError]\n    }\n\n    if (socket.destroyed) {\n      return false\n    }\n\n    const len = Buffer.byteLength(chunk)\n    if (!len) {\n      return true\n    }\n\n    // We should defer writing chunks.\n    if (contentLength !== null && bytesWritten + len > contentLength) {\n      if (client[kStrictContentLength]) {\n        throw new RequestContentLengthMismatchError()\n      }\n\n      process.emitWarning(new RequestContentLengthMismatchError())\n    }\n\n    if (bytesWritten === 0) {\n      if (!expectsPayload) {\n        socket[kReset] = true\n      }\n\n      if (contentLength === null) {\n        socket.write(`${header}transfer-encoding: chunked\\r\\n`, 'ascii')\n      } else {\n        socket.write(`${header}content-length: ${contentLength}\\r\\n\\r\\n`, 'ascii')\n      }\n    }\n\n    if (contentLength === null) {\n      socket.write(`\\r\\n${len.toString(16)}\\r\\n`, 'ascii')\n    }\n\n    this.bytesWritten += len\n\n    const ret = socket.write(chunk)\n\n    request.onBodySent(chunk)\n\n    if (!ret) {\n      if (socket[kParser].timeout && socket[kParser].timeoutType === TIMEOUT_HEADERS) {\n        // istanbul ignore else: only for jest\n        if (socket[kParser].timeout.refresh) {\n          socket[kParser].timeout.refresh()\n        }\n      }\n    }\n\n    return ret\n  }\n\n  end () {\n    const { socket, contentLength, client, bytesWritten, expectsPayload, header, request } = this\n    request.onRequestSent()\n\n    socket[kWriting] = false\n\n    if (socket[kError]) {\n      throw socket[kError]\n    }\n\n    if (socket.destroyed) {\n      return\n    }\n\n    if (bytesWritten === 0) {\n      if (expectsPayload) {\n        // https://tools.ietf.org/html/rfc7230#section-3.3.2\n        // A user agent SHOULD send a Content-Length in a request message when\n        // no Transfer-Encoding is sent and the request method defines a meaning\n        // for an enclosed payload body.\n\n        socket.write(`${header}content-length: 0\\r\\n\\r\\n`, 'ascii')\n      } else {\n        socket.write(`${header}\\r\\n`, 'ascii')\n      }\n    } else if (contentLength === null) {\n      socket.write('\\r\\n0\\r\\n\\r\\n', 'ascii')\n    }\n\n    if (contentLength !== null && bytesWritten !== contentLength) {\n      if (client[kStrictContentLength]) {\n        throw new RequestContentLengthMismatchError()\n      } else {\n        process.emitWarning(new RequestContentLengthMismatchError())\n      }\n    }\n\n    if (socket[kParser].timeout && socket[kParser].timeoutType === TIMEOUT_HEADERS) {\n      // istanbul ignore else: only for jest\n      if (socket[kParser].timeout.refresh) {\n        socket[kParser].timeout.refresh()\n      }\n    }\n\n    resume(client)\n  }\n\n  destroy (err) {\n    const { socket, client } = this\n\n    socket[kWriting] = false\n\n    if (err) {\n      assert(client[kRunning] <= 1, 'pipeline should only contain this request')\n      util.destroy(socket, err)\n    }\n  }\n}\n\nfunction errorRequest (client, request, err) {\n  try {\n    request.onError(err)\n    assert(request.aborted)\n  } catch (err) {\n    client.emit('error', err)\n  }\n}\n\nmodule.exports = Client\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}