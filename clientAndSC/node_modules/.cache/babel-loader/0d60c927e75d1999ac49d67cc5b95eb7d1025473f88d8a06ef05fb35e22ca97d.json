{"ast":null,"code":"\"use strict\";\n\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  Object.defineProperty(o, k2, {\n    enumerable: true,\n    get: function () {\n      return m[k];\n    }\n  });\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, \"default\", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o[\"default\"] = v;\n});\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n  __setModuleDefault(result, mod);\n  return result;\n};\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.writePromptedForHHVSCode = exports.hasPromptedForHHVSCode = exports.writeTelemetryConsent = exports.hasConsentedTelemetry = exports.getCompilersDir = exports.writeAnalyticsId = exports.readSecondLegacyAnalyticsId = exports.readFirstLegacyAnalyticsId = exports.readAnalyticsId = exports.getCacheDir = void 0;\nconst debug_1 = __importDefault(require(\"debug\"));\nconst fs_extra_1 = __importDefault(require(\"fs-extra\"));\nconst os_1 = __importDefault(require(\"os\"));\nconst path_1 = __importDefault(require(\"path\"));\nconst log = (0, debug_1.default)(\"hardhat:core:global-dir\");\nasync function generatePaths() {\n  let packageName = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : \"hardhat\";\n  const {\n    default: envPaths\n  } = await Promise.resolve().then(() => __importStar(require(\"env-paths\")));\n  return envPaths(packageName);\n}\nfunction generatePathsSync() {\n  let packageName = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : \"hardhat\";\n  const envPaths = require(\"env-paths\");\n  return envPaths(packageName);\n}\nfunction getConfigDirSync() {\n  const {\n    config\n  } = generatePathsSync();\n  fs_extra_1.default.ensureDirSync(config);\n  return config;\n}\nasync function getDataDir(packageName) {\n  const {\n    data\n  } = await generatePaths(packageName);\n  await fs_extra_1.default.ensureDir(data);\n  return data;\n}\nasync function getCacheDir() {\n  const {\n    cache\n  } = await generatePaths();\n  await fs_extra_1.default.ensureDir(cache);\n  return cache;\n}\nexports.getCacheDir = getCacheDir;\nasync function readAnalyticsId() {\n  const globalDataDir = await getDataDir();\n  const idFile = path_1.default.join(globalDataDir, \"analytics.json\");\n  return readId(idFile);\n}\nexports.readAnalyticsId = readAnalyticsId;\n/**\n * This is the first way that the analytics id was saved.\n */\nfunction readFirstLegacyAnalyticsId() {\n  const oldIdFile = path_1.default.join(os_1.default.homedir(), \".buidler\", \"config.json\");\n  return readId(oldIdFile);\n}\nexports.readFirstLegacyAnalyticsId = readFirstLegacyAnalyticsId;\n/**\n * This is the same way the analytics id is saved now, but using buidler as the\n * name of the project for env-paths\n */\nasync function readSecondLegacyAnalyticsId() {\n  const globalDataDir = await getDataDir(\"buidler\");\n  const idFile = path_1.default.join(globalDataDir, \"analytics.json\");\n  return readId(idFile);\n}\nexports.readSecondLegacyAnalyticsId = readSecondLegacyAnalyticsId;\nasync function readId(idFile) {\n  log(`Looking up Client Id at ${idFile}`);\n  let clientId;\n  try {\n    const data = await fs_extra_1.default.readJSON(idFile, {\n      encoding: \"utf8\"\n    });\n    clientId = data.analytics.clientId;\n  } catch (error) {\n    return undefined;\n  }\n  log(`Client Id found: ${clientId}`);\n  return clientId;\n}\nasync function writeAnalyticsId(clientId) {\n  const globalDataDir = await getDataDir();\n  const idFile = path_1.default.join(globalDataDir, \"analytics.json\");\n  await fs_extra_1.default.writeJSON(idFile, {\n    analytics: {\n      clientId\n    }\n  }, {\n    encoding: \"utf-8\",\n    spaces: 2\n  });\n  log(`Stored clientId ${clientId}`);\n}\nexports.writeAnalyticsId = writeAnalyticsId;\nasync function getCompilersDir() {\n  const cache = await getCacheDir();\n  // Note: we introduce `-v2` to invalidate all the previous compilers at once\n  const compilersCache = path_1.default.join(cache, \"compilers-v2\");\n  await fs_extra_1.default.ensureDir(compilersCache);\n  return compilersCache;\n}\nexports.getCompilersDir = getCompilersDir;\n/**\n * Checks if the user has given (or refused) consent for telemetry.\n *\n * Returns undefined if it can't be determined.\n */\nfunction hasConsentedTelemetry() {\n  const configDir = getConfigDirSync();\n  const telemetryConsentPath = path_1.default.join(configDir, \"telemetry-consent.json\");\n  const fileExists = fs_extra_1.default.pathExistsSync(telemetryConsentPath);\n  if (!fileExists) {\n    return undefined;\n  }\n  const {\n    consent\n  } = fs_extra_1.default.readJSONSync(telemetryConsentPath);\n  return consent;\n}\nexports.hasConsentedTelemetry = hasConsentedTelemetry;\nfunction writeTelemetryConsent(consent) {\n  const configDir = getConfigDirSync();\n  const telemetryConsentPath = path_1.default.join(configDir, \"telemetry-consent.json\");\n  fs_extra_1.default.writeJSONSync(telemetryConsentPath, {\n    consent\n  }, {\n    spaces: 2\n  });\n}\nexports.writeTelemetryConsent = writeTelemetryConsent;\n/**\n * Checks if we have already prompted the user to install the Hardhat for VSCode extension.\n */\nfunction hasPromptedForHHVSCode() {\n  const configDir = getConfigDirSync();\n  const extensionPromptedPath = path_1.default.join(configDir, \"extension-prompt.json\");\n  const fileExists = fs_extra_1.default.pathExistsSync(extensionPromptedPath);\n  return fileExists;\n}\nexports.hasPromptedForHHVSCode = hasPromptedForHHVSCode;\nfunction writePromptedForHHVSCode() {\n  const configDir = getConfigDirSync();\n  const extensionPromptedPath = path_1.default.join(configDir, \"extension-prompt.json\");\n  fs_extra_1.default.writeFileSync(extensionPromptedPath, \"{}\");\n}\nexports.writePromptedForHHVSCode = writePromptedForHHVSCode;","map":{"version":3,"mappings":"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","names":["log","generatePaths","packageName","default","envPaths","generatePathsSync","require","getConfigDirSync","config","fs_extra_1","ensureDirSync","getDataDir","data","ensureDir","getCacheDir","cache","exports","readAnalyticsId","globalDataDir","idFile","path_1","join","readId","readFirstLegacyAnalyticsId","oldIdFile","os_1","homedir","readSecondLegacyAnalyticsId","clientId","readJSON","encoding","analytics","error","undefined","writeAnalyticsId","writeJSON","spaces","getCompilersDir","compilersCache","hasConsentedTelemetry","configDir","telemetryConsentPath","fileExists","pathExistsSync","consent","readJSONSync","writeTelemetryConsent","writeJSONSync","hasPromptedForHHVSCode","extensionPromptedPath","writePromptedForHHVSCode","writeFileSync"],"sources":["/Users/janrobel/Documents/PersonalProjekty/nftGenerateAi/clientAndContract/node_modules/hardhat/src/internal/util/global-dir.ts"],"sourcesContent":["import type envPathsT from \"env-paths\";\n\nimport debug from \"debug\";\nimport fs from \"fs-extra\";\nimport os from \"os\";\nimport path from \"path\";\n\nconst log = debug(\"hardhat:core:global-dir\");\n\nasync function generatePaths(packageName = \"hardhat\") {\n  const { default: envPaths } = await import(\"env-paths\");\n  return envPaths(packageName);\n}\n\nfunction generatePathsSync(packageName = \"hardhat\") {\n  const envPaths: typeof envPathsT = require(\"env-paths\");\n  return envPaths(packageName);\n}\n\nfunction getConfigDirSync(): string {\n  const { config } = generatePathsSync();\n  fs.ensureDirSync(config);\n  return config;\n}\n\nasync function getDataDir(packageName?: string): Promise<string> {\n  const { data } = await generatePaths(packageName);\n  await fs.ensureDir(data);\n  return data;\n}\n\nexport async function getCacheDir(): Promise<string> {\n  const { cache } = await generatePaths();\n  await fs.ensureDir(cache);\n  return cache;\n}\n\nexport async function readAnalyticsId() {\n  const globalDataDir = await getDataDir();\n  const idFile = path.join(globalDataDir, \"analytics.json\");\n  return readId(idFile);\n}\n\n/**\n * This is the first way that the analytics id was saved.\n */\nexport function readFirstLegacyAnalyticsId() {\n  const oldIdFile = path.join(os.homedir(), \".buidler\", \"config.json\");\n  return readId(oldIdFile);\n}\n\n/**\n * This is the same way the analytics id is saved now, but using buidler as the\n * name of the project for env-paths\n */\nexport async function readSecondLegacyAnalyticsId() {\n  const globalDataDir = await getDataDir(\"buidler\");\n  const idFile = path.join(globalDataDir, \"analytics.json\");\n  return readId(idFile);\n}\n\nasync function readId(idFile: string): Promise<string | undefined> {\n  log(`Looking up Client Id at ${idFile}`);\n  let clientId: string;\n  try {\n    const data = await fs.readJSON(idFile, { encoding: \"utf8\" });\n    clientId = data.analytics.clientId;\n  } catch (error) {\n    return undefined;\n  }\n\n  log(`Client Id found: ${clientId}`);\n  return clientId;\n}\n\nexport async function writeAnalyticsId(clientId: string) {\n  const globalDataDir = await getDataDir();\n  const idFile = path.join(globalDataDir, \"analytics.json\");\n  await fs.writeJSON(\n    idFile,\n    {\n      analytics: {\n        clientId,\n      },\n    },\n    { encoding: \"utf-8\", spaces: 2 }\n  );\n  log(`Stored clientId ${clientId}`);\n}\n\nexport async function getCompilersDir() {\n  const cache = await getCacheDir();\n  // Note: we introduce `-v2` to invalidate all the previous compilers at once\n  const compilersCache = path.join(cache, \"compilers-v2\");\n  await fs.ensureDir(compilersCache);\n  return compilersCache;\n}\n\n/**\n * Checks if the user has given (or refused) consent for telemetry.\n *\n * Returns undefined if it can't be determined.\n */\nexport function hasConsentedTelemetry(): boolean | undefined {\n  const configDir = getConfigDirSync();\n  const telemetryConsentPath = path.join(configDir, \"telemetry-consent.json\");\n\n  const fileExists = fs.pathExistsSync(telemetryConsentPath);\n\n  if (!fileExists) {\n    return undefined;\n  }\n\n  const { consent } = fs.readJSONSync(telemetryConsentPath);\n  return consent;\n}\n\nexport function writeTelemetryConsent(consent: boolean) {\n  const configDir = getConfigDirSync();\n  const telemetryConsentPath = path.join(configDir, \"telemetry-consent.json\");\n\n  fs.writeJSONSync(telemetryConsentPath, { consent }, { spaces: 2 });\n}\n\n/**\n * Checks if we have already prompted the user to install the Hardhat for VSCode extension.\n */\nexport function hasPromptedForHHVSCode(): boolean {\n  const configDir = getConfigDirSync();\n  const extensionPromptedPath = path.join(configDir, \"extension-prompt.json\");\n\n  const fileExists = fs.pathExistsSync(extensionPromptedPath);\n\n  return fileExists;\n}\n\nexport function writePromptedForHHVSCode() {\n  const configDir = getConfigDirSync();\n  const extensionPromptedPath = path.join(configDir, \"extension-prompt.json\");\n\n  fs.writeFileSync(extensionPromptedPath, \"{}\");\n}\n"]},"metadata":{},"sourceType":"script","externalDependencies":[]}