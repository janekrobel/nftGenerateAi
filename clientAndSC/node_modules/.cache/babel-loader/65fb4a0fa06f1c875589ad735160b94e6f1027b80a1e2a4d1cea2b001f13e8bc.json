{"ast":null,"code":"\"use strict\";\n\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  Object.defineProperty(o, k2, {\n    enumerable: true,\n    get: function () {\n      return m[k];\n    }\n  });\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, \"default\", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o[\"default\"] = v;\n});\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n  __setModuleDefault(result, mod);\n  return result;\n};\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.CompilerDownloader = exports.CompilerPlatform = void 0;\nconst path_1 = __importDefault(require(\"path\"));\nconst fs_extra_1 = __importDefault(require(\"fs-extra\"));\nconst debug_1 = __importDefault(require(\"debug\"));\nconst os_1 = __importDefault(require(\"os\"));\nconst child_process_1 = require(\"child_process\");\nconst util_1 = require(\"util\");\nconst download_1 = require(\"../../util/download\");\nconst errors_1 = require(\"../../core/errors\");\nconst errors_list_1 = require(\"../../core/errors-list\");\nconst await_semaphore_1 = require(\"../../vendor/await-semaphore\");\nconst log = (0, debug_1.default)(\"hardhat:core:solidity:downloader\");\nconst COMPILER_REPOSITORY_URL = \"https://binaries.soliditylang.org\";\nvar CompilerPlatform;\n(function (CompilerPlatform) {\n  CompilerPlatform[\"LINUX\"] = \"linux-amd64\";\n  CompilerPlatform[\"WINDOWS\"] = \"windows-amd64\";\n  CompilerPlatform[\"MACOS\"] = \"macosx-amd64\";\n  CompilerPlatform[\"WASM\"] = \"wasm\";\n})(CompilerPlatform = exports.CompilerPlatform || (exports.CompilerPlatform = {}));\n/**\n * Default implementation of ICompilerDownloader.\n *\n * Important things to note:\n *   1. If a compiler version is not found, this downloader may fail.\n *    1.1. It only re-downloads the list of compilers once every X time.\n *      1.1.1 If a user tries to download a new compiler before X amount of time\n *      has passed since its release, they may need to clean the cache, as\n *      indicated in the error messages.\n */\nclass CompilerDownloader {\n  /**\n   * Use CompilerDownloader.getConcurrencySafeDownloader instead\n   */\n  constructor(_platform, _compilersDir) {\n    let _compilerListCachePeriodMs = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : CompilerDownloader.defaultCompilerListCachePeriod;\n    let _downloadFunction = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : download_1.download;\n    this._platform = _platform;\n    this._compilersDir = _compilersDir;\n    this._compilerListCachePeriodMs = _compilerListCachePeriodMs;\n    this._downloadFunction = _downloadFunction;\n    this._mutex = new await_semaphore_1.Mutex();\n  }\n  static getCompilerPlatform() {\n    // TODO: This check is seriously wrong. It doesn't take into account\n    //  the architecture nor the toolchain. This should check the triplet of\n    //  system instead (see: https://wiki.osdev.org/Target_Triplet).\n    //\n    //  The only reason this downloader works is that it validates if the\n    //  binaries actually run.\n    switch (os_1.default.platform()) {\n      case \"win32\":\n        return CompilerPlatform.WINDOWS;\n      case \"linux\":\n        return CompilerPlatform.LINUX;\n      case \"darwin\":\n        return CompilerPlatform.MACOS;\n      default:\n        return CompilerPlatform.WASM;\n    }\n  }\n  static getConcurrencySafeDownloader(platform, compilersDir) {\n    const key = platform + compilersDir;\n    if (!this._downloaderPerPlatform.has(key)) {\n      this._downloaderPerPlatform.set(key, new CompilerDownloader(platform, compilersDir));\n    }\n    return this._downloaderPerPlatform.get(key);\n  }\n  async isCompilerDownloaded(version) {\n    const build = await this._getCompilerBuild(version);\n    if (build === undefined) {\n      return false;\n    }\n    const downloadPath = this._getCompilerBinaryPathFromBuild(build);\n    return fs_extra_1.default.pathExists(downloadPath);\n  }\n  async downloadCompiler(version) {\n    await this._mutex.use(async () => {\n      let build = await this._getCompilerBuild(version);\n      if (build === undefined && (await this._shouldDownloadCompilerList())) {\n        try {\n          await this._downloadCompilerList();\n        } catch (e) {\n          throw new errors_1.HardhatError(errors_list_1.ERRORS.SOLC.VERSION_LIST_DOWNLOAD_FAILED, {}, e);\n        }\n        build = await this._getCompilerBuild(version);\n      }\n      if (build === undefined) {\n        throw new errors_1.HardhatError(errors_list_1.ERRORS.SOLC.INVALID_VERSION, {\n          version\n        });\n      }\n      let downloadPath;\n      try {\n        downloadPath = await this._downloadCompiler(build);\n      } catch (e) {\n        throw new errors_1.HardhatError(errors_list_1.ERRORS.SOLC.DOWNLOAD_FAILED, {\n          remoteVersion: build.longVersion\n        }, e);\n      }\n      const verified = await this._verifyCompilerDownload(build, downloadPath);\n      if (!verified) {\n        throw new errors_1.HardhatError(errors_list_1.ERRORS.SOLC.INVALID_DOWNLOAD, {\n          remoteVersion: build.longVersion\n        });\n      }\n      await this._postProcessCompilerDownload(build, downloadPath);\n    });\n  }\n  async getCompiler(version) {\n    const build = await this._getCompilerBuild(version);\n    (0, errors_1.assertHardhatInvariant)(build !== undefined, \"Trying to get a compiler before it was downloaded\");\n    const compilerPath = this._getCompilerBinaryPathFromBuild(build);\n    (0, errors_1.assertHardhatInvariant)(await fs_extra_1.default.pathExists(compilerPath), \"Trying to get a compiler before it was downloaded\");\n    if (await fs_extra_1.default.pathExists(this._getCompilerDoesntWorkFile(build))) {\n      return undefined;\n    }\n    return {\n      version,\n      longVersion: build.longVersion,\n      compilerPath,\n      isSolcJs: this._platform === CompilerPlatform.WASM\n    };\n  }\n  async _getCompilerBuild(version) {\n    const listPath = this._getCompilerListPath();\n    if (!(await fs_extra_1.default.pathExists(listPath))) {\n      return undefined;\n    }\n    const list = await this._readCompilerList(listPath);\n    return list.builds.find(b => b.version === version);\n  }\n  _getCompilerListPath() {\n    return path_1.default.join(this._compilersDir, this._platform, \"list.json\");\n  }\n  async _readCompilerList(listPath) {\n    return fs_extra_1.default.readJSON(listPath);\n  }\n  _getCompilerDownloadPathFromBuild(build) {\n    return path_1.default.join(this._compilersDir, this._platform, build.path);\n  }\n  _getCompilerBinaryPathFromBuild(build) {\n    const downloadPath = this._getCompilerDownloadPathFromBuild(build);\n    if (this._platform !== CompilerPlatform.WINDOWS || !downloadPath.endsWith(\".zip\")) {\n      return downloadPath;\n    }\n    return path_1.default.join(this._compilersDir, build.version, \"solc.exe\");\n  }\n  _getCompilerDoesntWorkFile(build) {\n    return `${this._getCompilerBinaryPathFromBuild(build)}.does.not.work`;\n  }\n  async _shouldDownloadCompilerList() {\n    const listPath = this._getCompilerListPath();\n    if (!(await fs_extra_1.default.pathExists(listPath))) {\n      return true;\n    }\n    const stats = await fs_extra_1.default.stat(listPath);\n    const age = new Date().valueOf() - stats.ctimeMs;\n    return age > this._compilerListCachePeriodMs;\n  }\n  async _downloadCompilerList() {\n    log(`Downloading compiler list for platform ${this._platform}`);\n    const url = `${COMPILER_REPOSITORY_URL}/${this._platform}/list.json`;\n    const downloadPath = this._getCompilerListPath();\n    await this._downloadFunction(url, downloadPath);\n  }\n  async _downloadCompiler(build) {\n    log(`Downloading compiler ${build.longVersion}`);\n    const url = `${COMPILER_REPOSITORY_URL}/${this._platform}/${build.path}`;\n    const downloadPath = this._getCompilerDownloadPathFromBuild(build);\n    await this._downloadFunction(url, downloadPath);\n    return downloadPath;\n  }\n  async _verifyCompilerDownload(build, downloadPath) {\n    const ethereumjsUtil = await Promise.resolve().then(() => __importStar(require(\"@nomicfoundation/ethereumjs-util\")));\n    const {\n      keccak256\n    } = await Promise.resolve().then(() => __importStar(require(\"../../util/keccak\")));\n    const expectedKeccak256 = build.keccak256;\n    const compiler = await fs_extra_1.default.readFile(downloadPath);\n    const compilerKeccak256 = ethereumjsUtil.bufferToHex(keccak256(compiler));\n    if (expectedKeccak256 !== compilerKeccak256) {\n      await fs_extra_1.default.unlink(downloadPath);\n      return false;\n    }\n    return true;\n  }\n  async _postProcessCompilerDownload(build, downloadPath) {\n    if (this._platform === CompilerPlatform.WASM) {\n      return;\n    }\n    if (this._platform === CompilerPlatform.LINUX || this._platform === CompilerPlatform.MACOS) {\n      fs_extra_1.default.chmodSync(downloadPath, 0o755);\n    } else if (this._platform === CompilerPlatform.WINDOWS && downloadPath.endsWith(\".zip\")) {\n      // some window builds are zipped, some are not\n      const {\n        default: AdmZip\n      } = await Promise.resolve().then(() => __importStar(require(\"adm-zip\")));\n      const solcFolder = path_1.default.join(this._compilersDir, build.version);\n      await fs_extra_1.default.ensureDir(solcFolder);\n      const zip = new AdmZip(downloadPath);\n      zip.extractAllTo(solcFolder);\n    }\n    log(\"Checking native solc binary\");\n    const nativeSolcWorks = await this._checkNativeSolc(build);\n    if (nativeSolcWorks) {\n      return;\n    }\n    await fs_extra_1.default.createFile(this._getCompilerDoesntWorkFile(build));\n  }\n  async _checkNativeSolc(build) {\n    const solcPath = this._getCompilerBinaryPathFromBuild(build);\n    const execFileP = (0, util_1.promisify)(child_process_1.execFile);\n    try {\n      await execFileP(solcPath, [\"--version\"]);\n      return true;\n    } catch {\n      return false;\n    }\n  }\n}\nexports.CompilerDownloader = CompilerDownloader;\nCompilerDownloader._downloaderPerPlatform = new Map();\nCompilerDownloader.defaultCompilerListCachePeriod = 360000;","map":{"version":3,"mappings":"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","names":["log","COMPILER_REPOSITORY_URL","CompilerPlatform","exports","CompilerDownloader","constructor","_platform","_compilersDir","_compilerListCachePeriodMs","defaultCompilerListCachePeriod","_downloadFunction","download_1","await_semaphore_1","getCompilerPlatform","os_1","platform","WINDOWS","LINUX","MACOS","WASM","getConcurrencySafeDownloader","compilersDir","key","_downloaderPerPlatform","has","set","get","isCompilerDownloaded","version","build","_getCompilerBuild","undefined","downloadPath","_getCompilerBinaryPathFromBuild","fs_extra_1","pathExists","downloadCompiler","_mutex","use","_shouldDownloadCompilerList","_downloadCompilerList","e","errors_1","errors_list_1","SOLC","VERSION_LIST_DOWNLOAD_FAILED","INVALID_VERSION","_downloadCompiler","DOWNLOAD_FAILED","remoteVersion","longVersion","verified","_verifyCompilerDownload","INVALID_DOWNLOAD","_postProcessCompilerDownload","getCompiler","compilerPath","_getCompilerDoesntWorkFile","isSolcJs","listPath","_getCompilerListPath","list","_readCompilerList","builds","find","b","path_1","join","readJSON","_getCompilerDownloadPathFromBuild","path","endsWith","stats","stat","age","Date","valueOf","ctimeMs","url","ethereumjsUtil","keccak256","expectedKeccak256","compiler","readFile","compilerKeccak256","bufferToHex","unlink","chmodSync","default","AdmZip","solcFolder","ensureDir","zip","extractAllTo","nativeSolcWorks","_checkNativeSolc","createFile","solcPath","execFileP","child_process_1","Map"],"sources":["/Users/janrobel/Documents/PersonalProjekty/nftGenerateAi/clientAndContract/node_modules/hardhat/src/internal/solidity/compiler/downloader.ts"],"sourcesContent":["import path from \"path\";\nimport fsExtra from \"fs-extra\";\nimport debug from \"debug\";\nimport os from \"os\";\nimport { execFile } from \"child_process\";\nimport { promisify } from \"util\";\n\nimport { download } from \"../../util/download\";\nimport { assertHardhatInvariant, HardhatError } from \"../../core/errors\";\nimport { ERRORS } from \"../../core/errors-list\";\nimport { Mutex } from \"../../vendor/await-semaphore\";\n\nconst log = debug(\"hardhat:core:solidity:downloader\");\n\nconst COMPILER_REPOSITORY_URL = \"https://binaries.soliditylang.org\";\n\nexport enum CompilerPlatform {\n  LINUX = \"linux-amd64\",\n  WINDOWS = \"windows-amd64\",\n  MACOS = \"macosx-amd64\",\n  WASM = \"wasm\",\n}\n\nexport interface Compiler {\n  version: string;\n  longVersion: string;\n  compilerPath: string;\n  isSolcJs: boolean;\n}\n\ninterface CompilerBuild {\n  path: string;\n  version: string;\n  build: string;\n  longVersion: string;\n  keccak256: string;\n  urls: string[];\n  platform: CompilerPlatform;\n}\n\ninterface CompilerList {\n  builds: CompilerBuild[];\n  releases: { [version: string]: string };\n  latestRelease: string;\n}\n\n/**\n * A compiler downloader which must be specialized per-platform. It can't and\n * shouldn't support multiple platforms at the same time.\n */\nexport interface ICompilerDownloader {\n  /**\n   * Returns true if the compiler has been downloaded.\n   *\n   * This function access the filesystem, but doesn't modify it.\n   */\n  isCompilerDownloaded(version: string): Promise<boolean>;\n\n  /**\n   * Downloads the compiler for a given version, which can later be obtained\n   * with getCompiler.\n   */\n  downloadCompiler(version: string): Promise<void>;\n\n  /**\n   * Returns the compiler, which MUST be downloaded before calling this function.\n   *\n   * Returns undefined if the compiler has been downloaded but can't be run.\n   *\n   * This function access the filesystem, but doesn't modify it.\n   */\n  getCompiler(version: string): Promise<Compiler | undefined>;\n}\n\n/**\n * Default implementation of ICompilerDownloader.\n *\n * Important things to note:\n *   1. If a compiler version is not found, this downloader may fail.\n *    1.1. It only re-downloads the list of compilers once every X time.\n *      1.1.1 If a user tries to download a new compiler before X amount of time\n *      has passed since its release, they may need to clean the cache, as\n *      indicated in the error messages.\n */\nexport class CompilerDownloader implements ICompilerDownloader {\n  public static getCompilerPlatform(): CompilerPlatform {\n    // TODO: This check is seriously wrong. It doesn't take into account\n    //  the architecture nor the toolchain. This should check the triplet of\n    //  system instead (see: https://wiki.osdev.org/Target_Triplet).\n    //\n    //  The only reason this downloader works is that it validates if the\n    //  binaries actually run.\n    switch (os.platform()) {\n      case \"win32\":\n        return CompilerPlatform.WINDOWS;\n      case \"linux\":\n        return CompilerPlatform.LINUX;\n      case \"darwin\":\n        return CompilerPlatform.MACOS;\n      default:\n        return CompilerPlatform.WASM;\n    }\n  }\n\n  private static _downloaderPerPlatform: Map<string, CompilerDownloader> =\n    new Map();\n\n  public static getConcurrencySafeDownloader(\n    platform: CompilerPlatform,\n    compilersDir: string\n  ) {\n    const key = platform + compilersDir;\n\n    if (!this._downloaderPerPlatform.has(key)) {\n      this._downloaderPerPlatform.set(\n        key,\n        new CompilerDownloader(platform, compilersDir)\n      );\n    }\n\n    return this._downloaderPerPlatform.get(key)!;\n  }\n\n  public static defaultCompilerListCachePeriod = 3_600_00;\n  private readonly _mutex = new Mutex();\n\n  /**\n   * Use CompilerDownloader.getConcurrencySafeDownloader instead\n   */\n  constructor(\n    private readonly _platform: CompilerPlatform,\n    private readonly _compilersDir: string,\n    private readonly _compilerListCachePeriodMs = CompilerDownloader.defaultCompilerListCachePeriod,\n    private readonly _downloadFunction: typeof download = download\n  ) {}\n\n  public async isCompilerDownloaded(version: string): Promise<boolean> {\n    const build = await this._getCompilerBuild(version);\n\n    if (build === undefined) {\n      return false;\n    }\n\n    const downloadPath = this._getCompilerBinaryPathFromBuild(build);\n\n    return fsExtra.pathExists(downloadPath);\n  }\n\n  public async downloadCompiler(version: string): Promise<void> {\n    await this._mutex.use(async () => {\n      let build = await this._getCompilerBuild(version);\n\n      if (build === undefined && (await this._shouldDownloadCompilerList())) {\n        try {\n          await this._downloadCompilerList();\n        } catch (e: any) {\n          throw new HardhatError(\n            ERRORS.SOLC.VERSION_LIST_DOWNLOAD_FAILED,\n            {},\n            e\n          );\n        }\n\n        build = await this._getCompilerBuild(version);\n      }\n\n      if (build === undefined) {\n        throw new HardhatError(ERRORS.SOLC.INVALID_VERSION, { version });\n      }\n\n      let downloadPath: string;\n      try {\n        downloadPath = await this._downloadCompiler(build);\n      } catch (e: any) {\n        throw new HardhatError(\n          ERRORS.SOLC.DOWNLOAD_FAILED,\n          {\n            remoteVersion: build.longVersion,\n          },\n          e\n        );\n      }\n\n      const verified = await this._verifyCompilerDownload(build, downloadPath);\n      if (!verified) {\n        throw new HardhatError(ERRORS.SOLC.INVALID_DOWNLOAD, {\n          remoteVersion: build.longVersion,\n        });\n      }\n\n      await this._postProcessCompilerDownload(build, downloadPath);\n    });\n  }\n\n  public async getCompiler(version: string): Promise<Compiler | undefined> {\n    const build = await this._getCompilerBuild(version);\n\n    assertHardhatInvariant(\n      build !== undefined,\n      \"Trying to get a compiler before it was downloaded\"\n    );\n\n    const compilerPath = this._getCompilerBinaryPathFromBuild(build);\n\n    assertHardhatInvariant(\n      await fsExtra.pathExists(compilerPath),\n      \"Trying to get a compiler before it was downloaded\"\n    );\n\n    if (await fsExtra.pathExists(this._getCompilerDoesntWorkFile(build))) {\n      return undefined;\n    }\n\n    return {\n      version,\n      longVersion: build.longVersion,\n      compilerPath,\n      isSolcJs: this._platform === CompilerPlatform.WASM,\n    };\n  }\n\n  private async _getCompilerBuild(\n    version: string\n  ): Promise<CompilerBuild | undefined> {\n    const listPath = this._getCompilerListPath();\n    if (!(await fsExtra.pathExists(listPath))) {\n      return undefined;\n    }\n\n    const list = await this._readCompilerList(listPath);\n    return list.builds.find((b) => b.version === version);\n  }\n\n  private _getCompilerListPath(): string {\n    return path.join(this._compilersDir, this._platform, \"list.json\");\n  }\n\n  private async _readCompilerList(listPath: string): Promise<CompilerList> {\n    return fsExtra.readJSON(listPath);\n  }\n\n  private _getCompilerDownloadPathFromBuild(build: CompilerBuild): string {\n    return path.join(this._compilersDir, this._platform, build.path);\n  }\n\n  private _getCompilerBinaryPathFromBuild(build: CompilerBuild): string {\n    const downloadPath = this._getCompilerDownloadPathFromBuild(build);\n\n    if (\n      this._platform !== CompilerPlatform.WINDOWS ||\n      !downloadPath.endsWith(\".zip\")\n    ) {\n      return downloadPath;\n    }\n\n    return path.join(this._compilersDir, build.version, \"solc.exe\");\n  }\n\n  private _getCompilerDoesntWorkFile(build: CompilerBuild): string {\n    return `${this._getCompilerBinaryPathFromBuild(build)}.does.not.work`;\n  }\n\n  private async _shouldDownloadCompilerList(): Promise<boolean> {\n    const listPath = this._getCompilerListPath();\n    if (!(await fsExtra.pathExists(listPath))) {\n      return true;\n    }\n\n    const stats = await fsExtra.stat(listPath);\n    const age = new Date().valueOf() - stats.ctimeMs;\n\n    return age > this._compilerListCachePeriodMs;\n  }\n\n  private async _downloadCompilerList(): Promise<void> {\n    log(`Downloading compiler list for platform ${this._platform}`);\n    const url = `${COMPILER_REPOSITORY_URL}/${this._platform}/list.json`;\n    const downloadPath = this._getCompilerListPath();\n\n    await this._downloadFunction(url, downloadPath);\n  }\n\n  private async _downloadCompiler(build: CompilerBuild): Promise<string> {\n    log(`Downloading compiler ${build.longVersion}`);\n    const url = `${COMPILER_REPOSITORY_URL}/${this._platform}/${build.path}`;\n    const downloadPath = this._getCompilerDownloadPathFromBuild(build);\n\n    await this._downloadFunction(url, downloadPath);\n\n    return downloadPath;\n  }\n\n  private async _verifyCompilerDownload(\n    build: CompilerBuild,\n    downloadPath: string\n  ): Promise<boolean> {\n    const ethereumjsUtil = await import(\"@nomicfoundation/ethereumjs-util\");\n    const { keccak256 } = await import(\"../../util/keccak\");\n\n    const expectedKeccak256 = build.keccak256;\n    const compiler = await fsExtra.readFile(downloadPath);\n\n    const compilerKeccak256 = ethereumjsUtil.bufferToHex(keccak256(compiler));\n\n    if (expectedKeccak256 !== compilerKeccak256) {\n      await fsExtra.unlink(downloadPath);\n      return false;\n    }\n\n    return true;\n  }\n\n  private async _postProcessCompilerDownload(\n    build: CompilerBuild,\n    downloadPath: string\n  ): Promise<void> {\n    if (this._platform === CompilerPlatform.WASM) {\n      return;\n    }\n\n    if (\n      this._platform === CompilerPlatform.LINUX ||\n      this._platform === CompilerPlatform.MACOS\n    ) {\n      fsExtra.chmodSync(downloadPath, 0o755);\n    } else if (\n      this._platform === CompilerPlatform.WINDOWS &&\n      downloadPath.endsWith(\".zip\")\n    ) {\n      // some window builds are zipped, some are not\n      const { default: AdmZip } = await import(\"adm-zip\");\n\n      const solcFolder = path.join(this._compilersDir, build.version);\n      await fsExtra.ensureDir(solcFolder);\n\n      const zip = new AdmZip(downloadPath);\n      zip.extractAllTo(solcFolder);\n    }\n\n    log(\"Checking native solc binary\");\n    const nativeSolcWorks = await this._checkNativeSolc(build);\n\n    if (nativeSolcWorks) {\n      return;\n    }\n\n    await fsExtra.createFile(this._getCompilerDoesntWorkFile(build));\n  }\n\n  private async _checkNativeSolc(build: CompilerBuild): Promise<boolean> {\n    const solcPath = this._getCompilerBinaryPathFromBuild(build);\n    const execFileP = promisify(execFile);\n\n    try {\n      await execFileP(solcPath, [\"--version\"]);\n      return true;\n    } catch {\n      return false;\n    }\n  }\n}\n"]},"metadata":{},"sourceType":"script","externalDependencies":[]}