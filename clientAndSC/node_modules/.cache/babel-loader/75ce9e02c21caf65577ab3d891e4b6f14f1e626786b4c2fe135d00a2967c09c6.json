{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nconst config_env_1 = require(\"../internal/core/config/config-env\");\nconst errors_1 = require(\"../internal/core/errors\");\nconst errors_list_1 = require(\"../internal/core/errors-list\");\nconst packageInfo_1 = require(\"../internal/util/packageInfo\");\nconst fs_utils_1 = require(\"../internal/util/fs-utils\");\nconst task_names_1 = require(\"./task-names\");\nfunction getSortedFiles(dependenciesGraph) {\n  const tsort = require(\"tsort\");\n  const graph = tsort();\n  // sort the graph entries to make the results deterministic\n  const dependencies = dependenciesGraph.entries().sort((_ref, _ref2) => {\n    let [a] = _ref;\n    let [b] = _ref2;\n    return a.sourceName.localeCompare(b.sourceName);\n  });\n  const filesMap = {};\n  const resolvedFiles = dependencies.map(_ref3 => {\n    let [file, _deps] = _ref3;\n    return file;\n  });\n  resolvedFiles.forEach(f => filesMap[f.sourceName] = f);\n  for (const [from, deps] of dependencies) {\n    // sort the dependencies to make the results deterministic\n    const sortedDeps = [...deps].sort((a, b) => a.sourceName.localeCompare(b.sourceName));\n    for (const to of sortedDeps) {\n      graph.add(to.sourceName, from.sourceName);\n    }\n  }\n  try {\n    const topologicalSortedNames = graph.sort();\n    // If an entry has no dependency it won't be included in the graph, so we\n    // add them and then dedup the array\n    const withEntries = topologicalSortedNames.concat(resolvedFiles.map(f => f.sourceName));\n    const sortedNames = [...new Set(withEntries)];\n    return sortedNames.map(n => filesMap[n]);\n  } catch (error) {\n    if (error instanceof Error) {\n      if (error.toString().includes(\"Error: There is a cycle in the graph.\")) {\n        throw new errors_1.HardhatError(errors_list_1.ERRORS.BUILTIN_TASKS.FLATTEN_CYCLE, {}, error);\n      }\n    }\n    // eslint-disable-next-line @nomiclabs/hardhat-internal-rules/only-hardhat-error\n    throw error;\n  }\n}\nfunction getFileWithoutImports(resolvedFile) {\n  const IMPORT_SOLIDITY_REGEX = /^\\s*import(\\s+)[\\s\\S]*?;\\s*$/gm;\n  return resolvedFile.content.rawContent.replace(IMPORT_SOLIDITY_REGEX, \"\").trim();\n}\n(0, config_env_1.subtask)(task_names_1.TASK_FLATTEN_GET_FLATTENED_SOURCE, \"Returns all contracts and their dependencies flattened\").addOptionalParam(\"files\", undefined, undefined, config_env_1.types.any).setAction(async (_ref4, _ref5) => {\n  let {\n    files\n  } = _ref4;\n  let {\n    run\n  } = _ref5;\n  const dependencyGraph = await run(task_names_1.TASK_FLATTEN_GET_DEPENDENCY_GRAPH, {\n    files\n  });\n  let flattened = \"\";\n  if (dependencyGraph.getResolvedFiles().length === 0) {\n    return flattened;\n  }\n  const packageJson = await (0, packageInfo_1.getPackageJson)();\n  flattened += `// Sources flattened with hardhat v${packageJson.version} https://hardhat.org`;\n  const sortedFiles = getSortedFiles(dependencyGraph);\n  for (const file of sortedFiles) {\n    flattened += `\\n\\n// File ${file.getVersionedName()}\\n`;\n    flattened += `\\n${getFileWithoutImports(file)}\\n`;\n  }\n  return flattened.trim();\n});\n(0, config_env_1.subtask)(task_names_1.TASK_FLATTEN_GET_DEPENDENCY_GRAPH).addOptionalParam(\"files\", undefined, undefined, config_env_1.types.any).setAction(async (_ref6, _ref7) => {\n  let {\n    files\n  } = _ref6;\n  let {\n    run\n  } = _ref7;\n  const sourcePaths = files === undefined ? await run(task_names_1.TASK_COMPILE_SOLIDITY_GET_SOURCE_PATHS) : files.map(f => (0, fs_utils_1.getRealPathSync)(f));\n  const sourceNames = await run(task_names_1.TASK_COMPILE_SOLIDITY_GET_SOURCE_NAMES, {\n    sourcePaths\n  });\n  const dependencyGraph = await run(task_names_1.TASK_COMPILE_SOLIDITY_GET_DEPENDENCY_GRAPH, {\n    sourceNames\n  });\n  return dependencyGraph;\n});\n(0, config_env_1.task)(task_names_1.TASK_FLATTEN, \"Flattens and prints contracts and their dependencies. If no file is passed, all the contracts in the project will be flattened.\").addOptionalVariadicPositionalParam(\"files\", \"The files to flatten\", undefined, config_env_1.types.inputFile).setAction(async (_ref8, _ref9) => {\n  let {\n    files\n  } = _ref8;\n  let {\n    run\n  } = _ref9;\n  console.log(await run(task_names_1.TASK_FLATTEN_GET_FLATTENED_SOURCE, {\n    files\n  }));\n});","map":{"version":3,"mappings":"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","names":["getSortedFiles","dependenciesGraph","tsort","require","graph","dependencies","entries","sort","a","b","sourceName","localeCompare","filesMap","resolvedFiles","map","file","_deps","forEach","f","from","deps","sortedDeps","to","add","topologicalSortedNames","withEntries","concat","sortedNames","Set","n","error","Error","toString","includes","errors_1","errors_list_1","BUILTIN_TASKS","FLATTEN_CYCLE","getFileWithoutImports","resolvedFile","IMPORT_SOLIDITY_REGEX","content","rawContent","replace","trim","task_names_1","addOptionalParam","undefined","config_env_1","any","setAction","files","run","dependencyGraph","flattened","getResolvedFiles","length","packageJson","version","sortedFiles","getVersionedName","sourcePaths","sourceNames","addOptionalVariadicPositionalParam","inputFile","console","log"],"sources":["/Users/janrobel/Documents/PersonalProjekty/nftGenerateAi/clientAndContract/node_modules/hardhat/src/builtin-tasks/flatten.ts"],"sourcesContent":["import { subtask, task, types } from \"../internal/core/config/config-env\";\nimport { HardhatError } from \"../internal/core/errors\";\nimport { ERRORS } from \"../internal/core/errors-list\";\nimport { DependencyGraph } from \"../internal/solidity/dependencyGraph\";\nimport { ResolvedFile, ResolvedFilesMap } from \"../internal/solidity/resolver\";\nimport { getPackageJson } from \"../internal/util/packageInfo\";\n\nimport { getRealPathSync } from \"../internal/util/fs-utils\";\nimport {\n  TASK_COMPILE_SOLIDITY_GET_DEPENDENCY_GRAPH,\n  TASK_COMPILE_SOLIDITY_GET_SOURCE_NAMES,\n  TASK_COMPILE_SOLIDITY_GET_SOURCE_PATHS,\n  TASK_FLATTEN,\n  TASK_FLATTEN_GET_DEPENDENCY_GRAPH,\n  TASK_FLATTEN_GET_FLATTENED_SOURCE,\n} from \"./task-names\";\n\nfunction getSortedFiles(dependenciesGraph: DependencyGraph) {\n  const tsort = require(\"tsort\");\n  const graph = tsort();\n\n  // sort the graph entries to make the results deterministic\n  const dependencies = dependenciesGraph\n    .entries()\n    .sort(([a], [b]) => a.sourceName.localeCompare(b.sourceName));\n\n  const filesMap: ResolvedFilesMap = {};\n  const resolvedFiles = dependencies.map(([file, _deps]) => file);\n\n  resolvedFiles.forEach((f) => (filesMap[f.sourceName] = f));\n\n  for (const [from, deps] of dependencies) {\n    // sort the dependencies to make the results deterministic\n    const sortedDeps = [...deps].sort((a, b) =>\n      a.sourceName.localeCompare(b.sourceName)\n    );\n\n    for (const to of sortedDeps) {\n      graph.add(to.sourceName, from.sourceName);\n    }\n  }\n\n  try {\n    const topologicalSortedNames: string[] = graph.sort();\n\n    // If an entry has no dependency it won't be included in the graph, so we\n    // add them and then dedup the array\n    const withEntries = topologicalSortedNames.concat(\n      resolvedFiles.map((f) => f.sourceName)\n    );\n\n    const sortedNames = [...new Set(withEntries)];\n    return sortedNames.map((n) => filesMap[n]);\n  } catch (error) {\n    if (error instanceof Error) {\n      if (error.toString().includes(\"Error: There is a cycle in the graph.\")) {\n        throw new HardhatError(ERRORS.BUILTIN_TASKS.FLATTEN_CYCLE, {}, error);\n      }\n    }\n\n    // eslint-disable-next-line @nomiclabs/hardhat-internal-rules/only-hardhat-error\n    throw error;\n  }\n}\n\nfunction getFileWithoutImports(resolvedFile: ResolvedFile) {\n  const IMPORT_SOLIDITY_REGEX = /^\\s*import(\\s+)[\\s\\S]*?;\\s*$/gm;\n\n  return resolvedFile.content.rawContent\n    .replace(IMPORT_SOLIDITY_REGEX, \"\")\n    .trim();\n}\n\nsubtask(\n  TASK_FLATTEN_GET_FLATTENED_SOURCE,\n  \"Returns all contracts and their dependencies flattened\"\n)\n  .addOptionalParam(\"files\", undefined, undefined, types.any)\n  .setAction(async ({ files }: { files?: string[] }, { run }) => {\n    const dependencyGraph: DependencyGraph = await run(\n      TASK_FLATTEN_GET_DEPENDENCY_GRAPH,\n      { files }\n    );\n\n    let flattened = \"\";\n\n    if (dependencyGraph.getResolvedFiles().length === 0) {\n      return flattened;\n    }\n\n    const packageJson = await getPackageJson();\n    flattened += `// Sources flattened with hardhat v${packageJson.version} https://hardhat.org`;\n\n    const sortedFiles = getSortedFiles(dependencyGraph);\n\n    for (const file of sortedFiles) {\n      flattened += `\\n\\n// File ${file.getVersionedName()}\\n`;\n      flattened += `\\n${getFileWithoutImports(file)}\\n`;\n    }\n\n    return flattened.trim();\n  });\n\nsubtask(TASK_FLATTEN_GET_DEPENDENCY_GRAPH)\n  .addOptionalParam(\"files\", undefined, undefined, types.any)\n  .setAction(async ({ files }: { files: string[] | undefined }, { run }) => {\n    const sourcePaths: string[] =\n      files === undefined\n        ? await run(TASK_COMPILE_SOLIDITY_GET_SOURCE_PATHS)\n        : files.map((f) => getRealPathSync(f));\n\n    const sourceNames: string[] = await run(\n      TASK_COMPILE_SOLIDITY_GET_SOURCE_NAMES,\n      {\n        sourcePaths,\n      }\n    );\n\n    const dependencyGraph: DependencyGraph = await run(\n      TASK_COMPILE_SOLIDITY_GET_DEPENDENCY_GRAPH,\n      { sourceNames }\n    );\n\n    return dependencyGraph;\n  });\n\ntask(\n  TASK_FLATTEN,\n  \"Flattens and prints contracts and their dependencies. If no file is passed, all the contracts in the project will be flattened.\"\n)\n  .addOptionalVariadicPositionalParam(\n    \"files\",\n    \"The files to flatten\",\n    undefined,\n    types.inputFile\n  )\n  .setAction(async ({ files }: { files: string[] | undefined }, { run }) => {\n    console.log(await run(TASK_FLATTEN_GET_FLATTENED_SOURCE, { files }));\n  });\n"]},"metadata":{},"sourceType":"script","externalDependencies":[]}