{"ast":null,"code":"const flagSymbol = Symbol('arg flag');\nfunction arg(opts) {\n  let {\n    argv = process.argv.slice(2),\n    permissive = false,\n    stopAtPositional = false\n  } = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  if (!opts) {\n    throw new Error('Argument specification object is required');\n  }\n  const result = {\n    _: []\n  };\n  const aliases = {};\n  const handlers = {};\n  for (const key of Object.keys(opts)) {\n    if (!key) {\n      throw new TypeError('Argument key cannot be an empty string');\n    }\n    if (key[0] !== '-') {\n      throw new TypeError(`Argument key must start with '-' but found: '${key}'`);\n    }\n    if (key.length === 1) {\n      throw new TypeError(`Argument key must have a name; singular '-' keys are not allowed: ${key}`);\n    }\n    if (typeof opts[key] === 'string') {\n      aliases[key] = opts[key];\n      continue;\n    }\n    let type = opts[key];\n    let isFlag = false;\n    if (Array.isArray(type) && type.length === 1 && typeof type[0] === 'function') {\n      const [fn] = type;\n      type = function (value, name) {\n        let prev = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];\n        prev.push(fn(value, name, prev[prev.length - 1]));\n        return prev;\n      };\n      isFlag = fn === Boolean || fn[flagSymbol] === true;\n    } else if (typeof type === 'function') {\n      isFlag = type === Boolean || type[flagSymbol] === true;\n    } else {\n      throw new TypeError(`Type missing or not a function or valid array type: ${key}`);\n    }\n    if (key[1] !== '-' && key.length > 2) {\n      throw new TypeError(`Short argument keys (with a single hyphen) must have only one character: ${key}`);\n    }\n    handlers[key] = [type, isFlag];\n  }\n  for (let i = 0, len = argv.length; i < len; i++) {\n    const wholeArg = argv[i];\n    if (stopAtPositional && result._.length > 0) {\n      result._ = result._.concat(argv.slice(i));\n      break;\n    }\n    if (wholeArg === '--') {\n      result._ = result._.concat(argv.slice(i + 1));\n      break;\n    }\n    if (wholeArg.length > 1 && wholeArg[0] === '-') {\n      /* eslint-disable operator-linebreak */\n      const separatedArguments = wholeArg[1] === '-' || wholeArg.length === 2 ? [wholeArg] : wholeArg.slice(1).split('').map(a => `-${a}`);\n      /* eslint-enable operator-linebreak */\n\n      for (let j = 0; j < separatedArguments.length; j++) {\n        const arg = separatedArguments[j];\n        const [originalArgName, argStr] = arg[1] === '-' ? arg.split(/=(.*)/, 2) : [arg, undefined];\n        let argName = originalArgName;\n        while (argName in aliases) {\n          argName = aliases[argName];\n        }\n        if (!(argName in handlers)) {\n          if (permissive) {\n            result._.push(arg);\n            continue;\n          } else {\n            const err = new Error(`Unknown or unexpected option: ${originalArgName}`);\n            err.code = 'ARG_UNKNOWN_OPTION';\n            throw err;\n          }\n        }\n        const [type, isFlag] = handlers[argName];\n        if (!isFlag && j + 1 < separatedArguments.length) {\n          throw new TypeError(`Option requires argument (but was followed by another short argument): ${originalArgName}`);\n        }\n        if (isFlag) {\n          result[argName] = type(true, argName, result[argName]);\n        } else if (argStr === undefined) {\n          if (argv.length < i + 2 || argv[i + 1].length > 1 && argv[i + 1][0] === '-' && !(argv[i + 1].match(/^-?\\d*(\\.(?=\\d))?\\d*$/) && (type === Number ||\n          // eslint-disable-next-line no-undef\n          typeof BigInt !== 'undefined' && type === BigInt))) {\n            const extended = originalArgName === argName ? '' : ` (alias for ${argName})`;\n            throw new Error(`Option requires argument: ${originalArgName}${extended}`);\n          }\n          result[argName] = type(argv[i + 1], argName, result[argName]);\n          ++i;\n        } else {\n          result[argName] = type(argStr, argName, result[argName]);\n        }\n      }\n    } else {\n      result._.push(wholeArg);\n    }\n  }\n  return result;\n}\narg.flag = fn => {\n  fn[flagSymbol] = true;\n  return fn;\n};\n\n// Utility types\narg.COUNT = arg.flag((v, name, existingCount) => (existingCount || 0) + 1);\nmodule.exports = arg;","map":{"version":3,"names":["flagSymbol","Symbol","arg","opts","argv","process","slice","permissive","stopAtPositional","Error","result","_","aliases","handlers","key","Object","keys","TypeError","length","type","isFlag","Array","isArray","fn","value","name","prev","push","Boolean","i","len","wholeArg","concat","separatedArguments","split","map","a","j","originalArgName","argStr","undefined","argName","err","code","match","Number","BigInt","extended","flag","COUNT","v","existingCount","module","exports"],"sources":["/Users/janrobel/Documents/PersonalProjekty/nftGenerateAi/clientAndContract/node_modules/ts-node/node_modules/arg/index.js"],"sourcesContent":["const flagSymbol = Symbol('arg flag');\n\nfunction arg(opts, {argv = process.argv.slice(2), permissive = false, stopAtPositional = false} = {}) {\n\tif (!opts) {\n\t\tthrow new Error('Argument specification object is required');\n\t}\n\n\tconst result = {_: []};\n\n\tconst aliases = {};\n\tconst handlers = {};\n\n\tfor (const key of Object.keys(opts)) {\n\t\tif (!key) {\n\t\t\tthrow new TypeError('Argument key cannot be an empty string');\n\t\t}\n\n\t\tif (key[0] !== '-') {\n\t\t\tthrow new TypeError(`Argument key must start with '-' but found: '${key}'`);\n\t\t}\n\n\t\tif (key.length === 1) {\n\t\t\tthrow new TypeError(`Argument key must have a name; singular '-' keys are not allowed: ${key}`);\n\t\t}\n\n\t\tif (typeof opts[key] === 'string') {\n\t\t\taliases[key] = opts[key];\n\t\t\tcontinue;\n\t\t}\n\n\t\tlet type = opts[key];\n\t\tlet isFlag = false;\n\n\t\tif (Array.isArray(type) && type.length === 1 && typeof type[0] === 'function') {\n\t\t\tconst [fn] = type;\n\t\t\ttype = (value, name, prev = []) => {\n\t\t\t\tprev.push(fn(value, name, prev[prev.length - 1]));\n\t\t\t\treturn prev;\n\t\t\t};\n\t\t\tisFlag = fn === Boolean || fn[flagSymbol] === true;\n\t\t} else if (typeof type === 'function') {\n\t\t\tisFlag = type === Boolean || type[flagSymbol] === true;\n\t\t} else {\n\t\t\tthrow new TypeError(`Type missing or not a function or valid array type: ${key}`);\n\t\t}\n\n\t\tif (key[1] !== '-' && key.length > 2) {\n\t\t\tthrow new TypeError(`Short argument keys (with a single hyphen) must have only one character: ${key}`);\n\t\t}\n\n\t\thandlers[key] = [type, isFlag];\n\t}\n\n\tfor (let i = 0, len = argv.length; i < len; i++) {\n\t\tconst wholeArg = argv[i];\n\n\t\tif (stopAtPositional && result._.length > 0) {\n\t\t\tresult._ = result._.concat(argv.slice(i));\n\t\t\tbreak;\n\t\t}\n\n\t\tif (wholeArg === '--') {\n\t\t\tresult._ = result._.concat(argv.slice(i + 1));\n\t\t\tbreak;\n\t\t}\n\n\t\tif (wholeArg.length > 1 && wholeArg[0] === '-') {\n\t\t\t/* eslint-disable operator-linebreak */\n\t\t\tconst separatedArguments = (wholeArg[1] === '-' || wholeArg.length === 2)\n\t\t\t\t? [wholeArg]\n\t\t\t\t: wholeArg.slice(1).split('').map(a => `-${a}`);\n\t\t\t/* eslint-enable operator-linebreak */\n\n\t\t\tfor (let j = 0; j < separatedArguments.length; j++) {\n\t\t\t\tconst arg = separatedArguments[j];\n\t\t\t\tconst [originalArgName, argStr] = arg[1] === '-' ? arg.split(/=(.*)/, 2) : [arg, undefined];\n\n\t\t\t\tlet argName = originalArgName;\n\t\t\t\twhile (argName in aliases) {\n\t\t\t\t\targName = aliases[argName];\n\t\t\t\t}\n\n\t\t\t\tif (!(argName in handlers)) {\n\t\t\t\t\tif (permissive) {\n\t\t\t\t\t\tresult._.push(arg);\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tconst err = new Error(`Unknown or unexpected option: ${originalArgName}`);\n\t\t\t\t\t\terr.code = 'ARG_UNKNOWN_OPTION';\n\t\t\t\t\t\tthrow err;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tconst [type, isFlag] = handlers[argName];\n\n\t\t\t\tif (!isFlag && ((j + 1) < separatedArguments.length)) {\n\t\t\t\t\tthrow new TypeError(`Option requires argument (but was followed by another short argument): ${originalArgName}`);\n\t\t\t\t}\n\n\t\t\t\tif (isFlag) {\n\t\t\t\t\tresult[argName] = type(true, argName, result[argName]);\n\t\t\t\t} else if (argStr === undefined) {\n\t\t\t\t\tif (\n\t\t\t\t\t\targv.length < i + 2 ||\n\t\t\t\t\t\t(\n\t\t\t\t\t\t\targv[i + 1].length > 1 &&\n\t\t\t\t\t\t\t(argv[i + 1][0] === '-') &&\n\t\t\t\t\t\t\t!(\n\t\t\t\t\t\t\t\targv[i + 1].match(/^-?\\d*(\\.(?=\\d))?\\d*$/) &&\n\t\t\t\t\t\t\t\t(\n\t\t\t\t\t\t\t\t\ttype === Number ||\n\t\t\t\t\t\t\t\t\t// eslint-disable-next-line no-undef\n\t\t\t\t\t\t\t\t\t(typeof BigInt !== 'undefined' && type === BigInt)\n\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t)\n\t\t\t\t\t\t)\n\t\t\t\t\t) {\n\t\t\t\t\t\tconst extended = originalArgName === argName ? '' : ` (alias for ${argName})`;\n\t\t\t\t\t\tthrow new Error(`Option requires argument: ${originalArgName}${extended}`);\n\t\t\t\t\t}\n\n\t\t\t\t\tresult[argName] = type(argv[i + 1], argName, result[argName]);\n\t\t\t\t\t++i;\n\t\t\t\t} else {\n\t\t\t\t\tresult[argName] = type(argStr, argName, result[argName]);\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tresult._.push(wholeArg);\n\t\t}\n\t}\n\n\treturn result;\n}\n\narg.flag = fn => {\n\tfn[flagSymbol] = true;\n\treturn fn;\n};\n\n// Utility types\narg.COUNT = arg.flag((v, name, existingCount) => (existingCount || 0) + 1);\n\nmodule.exports = arg;\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}