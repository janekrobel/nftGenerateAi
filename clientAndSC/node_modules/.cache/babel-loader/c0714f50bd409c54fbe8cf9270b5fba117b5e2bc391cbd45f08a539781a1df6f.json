{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.ContractEventPayload = exports.ContractUnknownEventPayload = exports.ContractTransactionResponse = exports.ContractTransactionReceipt = exports.EventLog = void 0;\n// import from provider.ts instead of index.ts to prevent circular dep\n// from EtherscanProvider\nconst provider_js_1 = require(\"../providers/provider.js\");\nconst index_js_1 = require(\"../utils/index.js\");\nclass EventLog extends provider_js_1.Log {\n  interface;\n  fragment;\n  args;\n  constructor(log, iface, fragment) {\n    super(log, log.provider);\n    const args = iface.decodeEventLog(fragment, log.data, log.topics);\n    (0, index_js_1.defineProperties)(this, {\n      args,\n      fragment,\n      interface: iface\n    });\n  }\n  get eventName() {\n    return this.fragment.name;\n  }\n  get eventSignature() {\n    return this.fragment.format();\n  }\n}\nexports.EventLog = EventLog;\nclass ContractTransactionReceipt extends provider_js_1.TransactionReceipt {\n  #interface;\n  constructor(iface, provider, tx) {\n    super(tx, provider);\n    this.#interface = iface;\n  }\n  get logs() {\n    return super.logs.map(log => {\n      const fragment = log.topics.length ? this.#interface.getEvent(log.topics[0]) : null;\n      if (fragment) {\n        return new EventLog(log, this.#interface, fragment);\n      } else {\n        return log;\n      }\n    });\n  }\n}\nexports.ContractTransactionReceipt = ContractTransactionReceipt;\nclass ContractTransactionResponse extends provider_js_1.TransactionResponse {\n  #interface;\n  constructor(iface, provider, tx) {\n    super(tx, provider);\n    this.#interface = iface;\n  }\n  async wait(confirms) {\n    const receipt = await super.wait();\n    if (receipt == null) {\n      return null;\n    }\n    return new ContractTransactionReceipt(this.#interface, this.provider, receipt);\n  }\n}\nexports.ContractTransactionResponse = ContractTransactionResponse;\nclass ContractUnknownEventPayload extends index_js_1.EventPayload {\n  log;\n  constructor(contract, listener, filter, log) {\n    super(contract, listener, filter);\n    (0, index_js_1.defineProperties)(this, {\n      log\n    });\n  }\n  async getBlock() {\n    return await this.log.getBlock();\n  }\n  async getTransaction() {\n    return await this.log.getTransaction();\n  }\n  async getTransactionReceipt() {\n    return await this.log.getTransactionReceipt();\n  }\n}\nexports.ContractUnknownEventPayload = ContractUnknownEventPayload;\nclass ContractEventPayload extends ContractUnknownEventPayload {\n  constructor(contract, listener, filter, fragment, _log) {\n    super(contract, listener, filter, new EventLog(_log, contract.interface, fragment));\n    const args = contract.interface.decodeEventLog(fragment, this.log.data, this.log.topics);\n    (0, index_js_1.defineProperties)(this, {\n      args,\n      fragment\n    });\n  }\n  get eventName() {\n    return this.fragment.name;\n  }\n  get eventSignature() {\n    return this.fragment.format();\n  }\n}\nexports.ContractEventPayload = ContractEventPayload;","map":{"version":3,"mappings":"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","names":["EventLog","provider_js_1","interface","fragment","args","constructor","log","iface","provider","decodeEventLog","data","topics","eventName","name","eventSignature","format","exports","ContractTransactionReceipt","tx","logs","map","length","getEvent","ContractTransactionResponse","wait","confirms","receipt","ContractUnknownEventPayload","index_js_1","contract","listener","filter","getBlock","getTransaction","getTransactionReceipt","ContractEventPayload","_log"],"sources":["/Users/janrobel/Documents/PersonalProjekty/nftGenerateAi/clientAndContract/node_modules/ethers/src.ts/contract/wrappers.ts"],"sourcesContent":["// import from provider.ts instead of index.ts to prevent circular dep\n// from EtherscanProvider\nimport {\n    Block, Log, TransactionReceipt, TransactionResponse\n} from \"../providers/provider.js\";\nimport { defineProperties, EventPayload } from \"../utils/index.js\";\n\nimport type { EventFragment, Interface, Result } from \"../abi/index.js\";\nimport type { Listener } from \"../utils/index.js\";\nimport type {\n    Provider\n} from \"../providers/index.js\";\n\nimport type { BaseContract } from \"./contract.js\";\nimport type { ContractEventName } from \"./types.js\";\n\n\nexport class EventLog extends Log {\n    readonly interface!: Interface;\n    readonly fragment!: EventFragment;\n    readonly args!: Result;\n\n    constructor(log: Log, iface: Interface, fragment: EventFragment) {\n        super(log, log.provider);\n        const args = iface.decodeEventLog(fragment, log.data, log.topics);\n        defineProperties<EventLog>(this, { args, fragment, interface: iface });\n    }\n\n    get eventName(): string { return this.fragment.name; }\n    get eventSignature(): string { return this.fragment.format(); }\n}\n\nexport class ContractTransactionReceipt extends TransactionReceipt {\n    readonly #interface: Interface;\n\n    constructor(iface: Interface, provider: Provider, tx: TransactionReceipt) {\n        super(tx, provider);\n        this.#interface = iface;\n    }\n\n    get logs(): Array<EventLog | Log> {\n        return super.logs.map((log) => {\n            const fragment = log.topics.length ? this.#interface.getEvent(log.topics[0]): null;\n            if (fragment) {\n                return new EventLog(log, this.#interface, fragment)\n            } else {\n                return log;\n            }\n        });\n    }\n\n}\n\nexport class ContractTransactionResponse extends TransactionResponse {\n    readonly #interface: Interface;\n\n    constructor(iface: Interface, provider: Provider, tx: TransactionResponse) {\n        super(tx, provider);\n        this.#interface = iface;\n    }\n\n    async wait(confirms?: number): Promise<null | ContractTransactionReceipt> {\n        const receipt = await super.wait();\n        if (receipt == null) { return null; }\n        return new ContractTransactionReceipt(this.#interface, this.provider, receipt);\n    }\n}\n\nexport  class ContractUnknownEventPayload extends EventPayload<ContractEventName> {\n    readonly log!: Log;\n\n    constructor(contract: BaseContract, listener: null | Listener, filter: ContractEventName, log: Log) {\n        super(contract, listener, filter);\n        defineProperties<ContractUnknownEventPayload>(this, { log });\n    }\n\n    async getBlock(): Promise<Block> {\n        return await this.log.getBlock();\n    }\n\n    async getTransaction(): Promise<TransactionResponse> {\n        return await this.log.getTransaction();\n    }\n\n    async getTransactionReceipt(): Promise<TransactionReceipt> {\n        return await this.log.getTransactionReceipt();\n    }\n}\n\nexport class ContractEventPayload extends ContractUnknownEventPayload {\n\n    declare readonly fragment: EventFragment;\n    declare readonly log: EventLog;\n    declare readonly args: Result;\n\n    constructor(contract: BaseContract, listener: null | Listener, filter: ContractEventName, fragment: EventFragment, _log: Log) {\n        super(contract, listener, filter, new EventLog(_log, contract.interface, fragment));\n        const args = contract.interface.decodeEventLog(fragment, this.log.data, this.log.topics);\n        defineProperties<ContractEventPayload>(this, { args, fragment });\n    }\n\n    get eventName(): string {\n        return this.fragment.name;\n    }\n\n    get eventSignature(): string {\n        return this.fragment.format();\n    }\n}\n"]},"metadata":{},"sourceType":"script","externalDependencies":[]}