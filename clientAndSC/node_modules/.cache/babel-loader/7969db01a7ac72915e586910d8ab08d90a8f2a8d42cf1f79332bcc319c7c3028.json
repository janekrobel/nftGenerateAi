{"ast":null,"code":"\"use strict\";\n\nvar _a, _b;\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.createEsmHooks = exports.createFromPreloadedConfig = exports.create = exports.register = exports.TSError = exports.DEFAULTS = exports.VERSION = exports.debug = exports.INSPECT_CUSTOM = exports.env = exports.REGISTER_INSTANCE = exports.createRepl = void 0;\nconst path_1 = require(\"path\");\nconst module_1 = require(\"module\");\nconst util = require(\"util\");\nconst url_1 = require(\"url\");\nconst make_error_1 = require(\"make-error\");\nconst util_1 = require(\"./util\");\nconst configuration_1 = require(\"./configuration\");\nconst module_type_classifier_1 = require(\"./module-type-classifier\");\nconst resolver_functions_1 = require(\"./resolver-functions\");\nconst cjs_resolve_hooks_1 = require(\"./cjs-resolve-hooks\");\nconst node_module_type_classifier_1 = require(\"./node-module-type-classifier\");\nconst file_extensions_1 = require(\"./file-extensions\");\nconst ts_transpile_module_1 = require(\"./ts-transpile-module\");\nvar repl_1 = require(\"./repl\");\nObject.defineProperty(exports, \"createRepl\", {\n  enumerable: true,\n  get: function () {\n    return repl_1.createRepl;\n  }\n});\n/**\n * Does this version of node obey the package.json \"type\" field\n * and throw ERR_REQUIRE_ESM when attempting to require() an ESM modules.\n */\nconst engineSupportsPackageTypeField = parseInt(process.versions.node.split('.')[0], 10) >= 12;\n/**\n * Assert that script can be loaded as CommonJS when we attempt to require it.\n * If it should be loaded as ESM, throw ERR_REQUIRE_ESM like node does.\n *\n * Loaded conditionally so we don't need to support older node versions\n */\nlet assertScriptCanLoadAsCJS = engineSupportsPackageTypeField ? require('../dist-raw/node-internal-modules-cjs-loader').assertScriptCanLoadAsCJSImpl : () => {\n  /* noop */\n};\n/**\n * Registered `ts-node` instance information.\n */\nexports.REGISTER_INSTANCE = Symbol.for('ts-node.register.instance');\n/** @internal */\nexports.env = process.env;\n/**\n * @internal\n */\nexports.INSPECT_CUSTOM = util.inspect.custom || 'inspect';\n/**\n * Debugging `ts-node`.\n */\nconst shouldDebug = (0, util_1.yn)(exports.env.TS_NODE_DEBUG);\n/** @internal */\nexports.debug = shouldDebug ? function () {\n  for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n    args[_key] = arguments[_key];\n  }\n  return console.log(`[ts-node ${new Date().toISOString()}]`, ...args);\n} : () => undefined;\nconst debugFn = shouldDebug ? (key, fn) => {\n  let i = 0;\n  return x => {\n    (0, exports.debug)(key, x, ++i);\n    return fn(x);\n  };\n} : (_, fn) => fn;\n/**\n * Export the current version.\n */\nexports.VERSION = require('../package.json').version;\n/**\n * Default register options, including values specified via environment\n * variables.\n * @internal\n */\nexports.DEFAULTS = {\n  cwd: (_a = exports.env.TS_NODE_CWD) !== null && _a !== void 0 ? _a : exports.env.TS_NODE_DIR,\n  emit: (0, util_1.yn)(exports.env.TS_NODE_EMIT),\n  scope: (0, util_1.yn)(exports.env.TS_NODE_SCOPE),\n  scopeDir: exports.env.TS_NODE_SCOPE_DIR,\n  files: (0, util_1.yn)(exports.env.TS_NODE_FILES),\n  pretty: (0, util_1.yn)(exports.env.TS_NODE_PRETTY),\n  compiler: exports.env.TS_NODE_COMPILER,\n  compilerOptions: (0, util_1.parse)(exports.env.TS_NODE_COMPILER_OPTIONS),\n  ignore: (0, util_1.split)(exports.env.TS_NODE_IGNORE),\n  project: exports.env.TS_NODE_PROJECT,\n  skipProject: (0, util_1.yn)(exports.env.TS_NODE_SKIP_PROJECT),\n  skipIgnore: (0, util_1.yn)(exports.env.TS_NODE_SKIP_IGNORE),\n  preferTsExts: (0, util_1.yn)(exports.env.TS_NODE_PREFER_TS_EXTS),\n  ignoreDiagnostics: (0, util_1.split)(exports.env.TS_NODE_IGNORE_DIAGNOSTICS),\n  transpileOnly: (0, util_1.yn)(exports.env.TS_NODE_TRANSPILE_ONLY),\n  typeCheck: (0, util_1.yn)(exports.env.TS_NODE_TYPE_CHECK),\n  compilerHost: (0, util_1.yn)(exports.env.TS_NODE_COMPILER_HOST),\n  logError: (0, util_1.yn)(exports.env.TS_NODE_LOG_ERROR),\n  experimentalReplAwait: (_b = (0, util_1.yn)(exports.env.TS_NODE_EXPERIMENTAL_REPL_AWAIT)) !== null && _b !== void 0 ? _b : undefined,\n  tsTrace: console.log.bind(console)\n};\n/**\n * TypeScript diagnostics error.\n */\nclass TSError extends make_error_1.BaseError {\n  constructor(diagnosticText, diagnosticCodes) {\n    let diagnostics = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];\n    super(`тип Unable to compile TypeScript:\\n${diagnosticText}`);\n    this.diagnosticCodes = diagnosticCodes;\n    this.name = 'TSError';\n    Object.defineProperty(this, 'diagnosticText', {\n      configurable: true,\n      writable: true,\n      value: diagnosticText\n    });\n    Object.defineProperty(this, 'diagnostics', {\n      configurable: true,\n      writable: true,\n      value: diagnostics\n    });\n  }\n  /**\n   * @internal\n   */\n  [exports.INSPECT_CUSTOM]() {\n    return this.diagnosticText;\n  }\n}\nexports.TSError = TSError;\nconst TS_NODE_SERVICE_BRAND = Symbol('TS_NODE_SERVICE_BRAND');\nfunction register(serviceOrOpts) {\n  // Is this a Service or a RegisterOptions?\n  let service = serviceOrOpts;\n  if (!(serviceOrOpts === null || serviceOrOpts === void 0 ? void 0 : serviceOrOpts[TS_NODE_SERVICE_BRAND])) {\n    // Not a service; is options\n    service = create(serviceOrOpts !== null && serviceOrOpts !== void 0 ? serviceOrOpts : {});\n  }\n  const originalJsHandler = require.extensions['.js'];\n  // Expose registered instance globally.\n  process[exports.REGISTER_INSTANCE] = service;\n  // Register the extensions.\n  registerExtensions(service.options.preferTsExts, service.extensions.compiled, service, originalJsHandler);\n  (0, cjs_resolve_hooks_1.installCommonjsResolveHooksIfNecessary)(service);\n  // Require specified modules before start-up.\n  module_1.Module._preloadModules(service.options.require);\n  return service;\n}\nexports.register = register;\n/**\n * Create TypeScript compiler instance.\n *\n * @category Basic\n */\nfunction create() {\n  let rawOptions = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  const foundConfigResult = (0, configuration_1.findAndReadConfig)(rawOptions);\n  return createFromPreloadedConfig(foundConfigResult);\n}\nexports.create = create;\n/** @internal */\nfunction createFromPreloadedConfig(foundConfigResult) {\n  var _a, _b, _c, _d;\n  const {\n    configFilePath,\n    cwd,\n    options,\n    config,\n    compiler,\n    projectLocalResolveDir,\n    optionBasePaths\n  } = foundConfigResult;\n  const projectLocalResolveHelper = (0, util_1.createProjectLocalResolveHelper)(projectLocalResolveDir);\n  const ts = (0, configuration_1.loadCompiler)(compiler);\n  // Experimental REPL await is not compatible targets lower than ES2018\n  const targetSupportsTla = config.options.target >= ts.ScriptTarget.ES2018;\n  if (options.experimentalReplAwait === true && !targetSupportsTla) {\n    throw new Error('Experimental REPL await is not compatible with targets lower than ES2018');\n  }\n  // Top-level await was added in TS 3.8\n  const tsVersionSupportsTla = (0, util_1.versionGteLt)(ts.version, '3.8.0');\n  if (options.experimentalReplAwait === true && !tsVersionSupportsTla) {\n    throw new Error('Experimental REPL await is not compatible with TypeScript versions older than 3.8');\n  }\n  const shouldReplAwait = options.experimentalReplAwait !== false && tsVersionSupportsTla && targetSupportsTla;\n  // swc implies two other options\n  // typeCheck option was implemented specifically to allow overriding tsconfig transpileOnly from the command-line\n  // So we should allow using typeCheck to override swc\n  if (options.swc && !options.typeCheck) {\n    if (options.transpileOnly === false) {\n      throw new Error(\"Cannot enable 'swc' option with 'transpileOnly: false'.  'swc' implies 'transpileOnly'.\");\n    }\n    if (options.transpiler) {\n      throw new Error(\"Cannot specify both 'swc' and 'transpiler' options.  'swc' uses the built-in swc transpiler.\");\n    }\n  }\n  const readFile = options.readFile || ts.sys.readFile;\n  const fileExists = options.fileExists || ts.sys.fileExists;\n  // typeCheck can override transpileOnly, useful for CLI flag to override config file\n  const transpileOnly = (options.transpileOnly === true || options.swc === true) && options.typeCheck !== true;\n  let transpiler = undefined;\n  let transpilerBasePath = undefined;\n  if (options.transpiler) {\n    transpiler = options.transpiler;\n    transpilerBasePath = optionBasePaths.transpiler;\n  } else if (options.swc) {\n    transpiler = require.resolve('./transpilers/swc.js');\n    transpilerBasePath = optionBasePaths.swc;\n  }\n  const transformers = options.transformers || undefined;\n  const diagnosticFilters = [{\n    appliesToAllFiles: true,\n    filenamesAbsolute: [],\n    diagnosticsIgnored: [6059, 18002, 18003, ...(options.experimentalTsImportSpecifiers ? [2691 // \"An import path cannot end with a '.ts' extension. Consider importing '<specifier without ext>' instead.\"\n    ] : []), ...(options.ignoreDiagnostics || [])].map(Number)\n  }];\n  const configDiagnosticList = filterDiagnostics(config.errors, diagnosticFilters);\n  const outputCache = new Map();\n  const configFileDirname = configFilePath ? (0, path_1.dirname)(configFilePath) : null;\n  const scopeDir = (_c = (_b = (_a = options.scopeDir) !== null && _a !== void 0 ? _a : config.options.rootDir) !== null && _b !== void 0 ? _b : configFileDirname) !== null && _c !== void 0 ? _c : cwd;\n  const ignoreBaseDir = configFileDirname !== null && configFileDirname !== void 0 ? configFileDirname : cwd;\n  const isScoped = options.scope ? fileName => (0, path_1.relative)(scopeDir, fileName).charAt(0) !== '.' : () => true;\n  const shouldIgnore = createIgnore(ignoreBaseDir, options.skipIgnore ? [] : (options.ignore || ['(?:^|/)node_modules/']).map(str => new RegExp(str)));\n  const diagnosticHost = {\n    getNewLine: () => ts.sys.newLine,\n    getCurrentDirectory: () => cwd,\n    // TODO switch to getCanonicalFileName we already create later in scope\n    getCanonicalFileName: ts.sys.useCaseSensitiveFileNames ? x => x : x => x.toLowerCase()\n  };\n  if (options.transpileOnly && typeof transformers === 'function') {\n    throw new TypeError('Transformers function is unavailable in \"--transpile-only\"');\n  }\n  let createTranspiler = initializeTranspilerFactory();\n  function initializeTranspilerFactory() {\n    var _a;\n    if (transpiler) {\n      if (!transpileOnly) throw new Error('Custom transpiler can only be used when transpileOnly is enabled.');\n      const transpilerName = typeof transpiler === 'string' ? transpiler : transpiler[0];\n      const transpilerOptions = typeof transpiler === 'string' ? {} : (_a = transpiler[1]) !== null && _a !== void 0 ? _a : {};\n      const transpilerConfigLocalResolveHelper = transpilerBasePath ? (0, util_1.createProjectLocalResolveHelper)(transpilerBasePath) : projectLocalResolveHelper;\n      const transpilerPath = transpilerConfigLocalResolveHelper(transpilerName, true);\n      const transpilerFactory = require(transpilerPath).create;\n      return createTranspiler;\n      function createTranspiler(compilerOptions, nodeModuleEmitKind) {\n        return transpilerFactory === null || transpilerFactory === void 0 ? void 0 : transpilerFactory({\n          service: {\n            options,\n            config: {\n              ...config,\n              options: compilerOptions\n            },\n            projectLocalResolveHelper\n          },\n          transpilerConfigLocalResolveHelper,\n          nodeModuleEmitKind,\n          ...transpilerOptions\n        });\n      }\n    }\n  }\n  /**\n   * True if require() hooks should interop with experimental ESM loader.\n   * Enabled explicitly via a flag since it is a breaking change.\n   */\n  let experimentalEsmLoader = false;\n  function enableExperimentalEsmLoaderInterop() {\n    experimentalEsmLoader = true;\n  }\n  // Install source map support and read from memory cache.\n  installSourceMapSupport();\n  function installSourceMapSupport() {\n    const sourceMapSupport = require('@cspotcode/source-map-support');\n    sourceMapSupport.install({\n      environment: 'node',\n      retrieveFile(pathOrUrl) {\n        var _a;\n        let path = pathOrUrl;\n        // If it's a file URL, convert to local path\n        // Note: fileURLToPath does not exist on early node v10\n        // I could not find a way to handle non-URLs except to swallow an error\n        if (experimentalEsmLoader && path.startsWith('file://')) {\n          try {\n            path = (0, url_1.fileURLToPath)(path);\n          } catch (e) {\n            /* swallow error */\n          }\n        }\n        path = (0, util_1.normalizeSlashes)(path);\n        return ((_a = outputCache.get(path)) === null || _a === void 0 ? void 0 : _a.content) || '';\n      },\n      redirectConflictingLibrary: true,\n      onConflictingLibraryRedirect(request, parent, isMain, options, redirectedRequest) {\n        (0, exports.debug)(`Redirected an attempt to require source-map-support to instead receive @cspotcode/source-map-support.  \"${parent.filename}\" attempted to require or resolve \"${request}\" and was redirected to \"${redirectedRequest}\".`);\n      }\n    });\n  }\n  const shouldHavePrettyErrors = options.pretty === undefined ? process.stdout.isTTY : options.pretty;\n  const formatDiagnostics = shouldHavePrettyErrors ? ts.formatDiagnosticsWithColorAndContext || ts.formatDiagnostics : ts.formatDiagnostics;\n  function createTSError(diagnostics) {\n    const diagnosticText = formatDiagnostics(diagnostics, diagnosticHost);\n    const diagnosticCodes = diagnostics.map(x => x.code);\n    return new TSError(diagnosticText, diagnosticCodes, diagnostics);\n  }\n  function reportTSError(configDiagnosticList) {\n    const error = createTSError(configDiagnosticList);\n    if (options.logError) {\n      // Print error in red color and continue execution.\n      console.error('\\x1b[31m%s\\x1b[0m', error);\n    } else {\n      // Throw error and exit the script.\n      throw error;\n    }\n  }\n  // Render the configuration errors.\n  if (configDiagnosticList.length) reportTSError(configDiagnosticList);\n  const jsxEmitPreserve = config.options.jsx === ts.JsxEmit.Preserve;\n  /**\n   * Get the extension for a transpiled file.\n   * [MUST_UPDATE_FOR_NEW_FILE_EXTENSIONS]\n   */\n  function getEmitExtension(path) {\n    const lastDotIndex = path.lastIndexOf('.');\n    if (lastDotIndex >= 0) {\n      const ext = path.slice(lastDotIndex);\n      switch (ext) {\n        case '.js':\n        case '.ts':\n          return '.js';\n        case '.jsx':\n        case '.tsx':\n          return jsxEmitPreserve ? '.jsx' : '.js';\n        case '.mjs':\n        case '.mts':\n          return '.mjs';\n        case '.cjs':\n        case '.cts':\n          return '.cjs';\n      }\n    }\n    return '.js';\n  }\n  /**\n   * Get output from TS compiler w/typechecking.  `undefined` in `transpileOnly`\n   * mode.\n   */\n  let getOutput;\n  let getTypeInfo;\n  const getCanonicalFileName = ts.createGetCanonicalFileName(ts.sys.useCaseSensitiveFileNames);\n  const moduleTypeClassifier = (0, module_type_classifier_1.createModuleTypeClassifier)({\n    basePath: (_d = options.optionBasePaths) === null || _d === void 0 ? void 0 : _d.moduleTypes,\n    patterns: options.moduleTypes\n  });\n  const extensions = (0, file_extensions_1.getExtensions)(config, options, ts.version);\n  // Use full language services when the fast option is disabled.\n  if (!transpileOnly) {\n    const fileContents = new Map();\n    const rootFileNames = new Set(config.fileNames);\n    const cachedReadFile = (0, util_1.cachedLookup)(debugFn('readFile', readFile));\n    // Use language services by default\n    if (!options.compilerHost) {\n      let projectVersion = 1;\n      const fileVersions = new Map(Array.from(rootFileNames).map(fileName => [fileName, 0]));\n      const getCustomTransformers = () => {\n        if (typeof transformers === 'function') {\n          const program = service.getProgram();\n          return program ? transformers(program) : undefined;\n        }\n        return transformers;\n      };\n      // Create the compiler host for type checking.\n      const serviceHost = {\n        getProjectVersion: () => String(projectVersion),\n        getScriptFileNames: () => Array.from(rootFileNames),\n        getScriptVersion: fileName => {\n          const version = fileVersions.get(fileName);\n          return version ? version.toString() : '';\n        },\n        getScriptSnapshot(fileName) {\n          // TODO ordering of this with getScriptVersion?  Should they sync up?\n          let contents = fileContents.get(fileName);\n          // Read contents into TypeScript memory cache.\n          if (contents === undefined) {\n            contents = cachedReadFile(fileName);\n            if (contents === undefined) return;\n            fileVersions.set(fileName, 1);\n            fileContents.set(fileName, contents);\n            projectVersion++;\n          }\n          return ts.ScriptSnapshot.fromString(contents);\n        },\n        readFile: cachedReadFile,\n        readDirectory: ts.sys.readDirectory,\n        getDirectories: (0, util_1.cachedLookup)(debugFn('getDirectories', ts.sys.getDirectories)),\n        fileExists: (0, util_1.cachedLookup)(debugFn('fileExists', fileExists)),\n        directoryExists: (0, util_1.cachedLookup)(debugFn('directoryExists', ts.sys.directoryExists)),\n        realpath: ts.sys.realpath ? (0, util_1.cachedLookup)(debugFn('realpath', ts.sys.realpath)) : undefined,\n        getNewLine: () => ts.sys.newLine,\n        useCaseSensitiveFileNames: () => ts.sys.useCaseSensitiveFileNames,\n        getCurrentDirectory: () => cwd,\n        getCompilationSettings: () => config.options,\n        getDefaultLibFileName: () => ts.getDefaultLibFilePath(config.options),\n        getCustomTransformers: getCustomTransformers,\n        trace: options.tsTrace\n      };\n      const {\n        resolveModuleNames,\n        getResolvedModuleWithFailedLookupLocationsFromCache,\n        resolveTypeReferenceDirectives,\n        isFileKnownToBeInternal,\n        markBucketOfFilenameInternal\n      } = (0, resolver_functions_1.createResolverFunctions)({\n        host: serviceHost,\n        getCanonicalFileName,\n        ts,\n        cwd,\n        config,\n        projectLocalResolveHelper,\n        options,\n        extensions\n      });\n      serviceHost.resolveModuleNames = resolveModuleNames;\n      serviceHost.getResolvedModuleWithFailedLookupLocationsFromCache = getResolvedModuleWithFailedLookupLocationsFromCache;\n      serviceHost.resolveTypeReferenceDirectives = resolveTypeReferenceDirectives;\n      const registry = ts.createDocumentRegistry(ts.sys.useCaseSensitiveFileNames, cwd);\n      const service = ts.createLanguageService(serviceHost, registry);\n      const updateMemoryCache = (contents, fileName) => {\n        // Add to `rootFiles` as necessary, either to make TS include a file it has not seen,\n        // or to trigger a re-classification of files from external to internal.\n        if (!rootFileNames.has(fileName) && !isFileKnownToBeInternal(fileName)) {\n          markBucketOfFilenameInternal(fileName);\n          rootFileNames.add(fileName);\n          // Increment project version for every change to rootFileNames.\n          projectVersion++;\n        }\n        const previousVersion = fileVersions.get(fileName) || 0;\n        const previousContents = fileContents.get(fileName);\n        // Avoid incrementing cache when nothing has changed.\n        if (contents !== previousContents) {\n          fileVersions.set(fileName, previousVersion + 1);\n          fileContents.set(fileName, contents);\n          // Increment project version for every file change.\n          projectVersion++;\n        }\n      };\n      let previousProgram = undefined;\n      getOutput = (code, fileName) => {\n        updateMemoryCache(code, fileName);\n        const programBefore = service.getProgram();\n        if (programBefore !== previousProgram) {\n          (0, exports.debug)(`compiler rebuilt Program instance when getting output for ${fileName}`);\n        }\n        const output = service.getEmitOutput(fileName);\n        // Get the relevant diagnostics - this is 3x faster than `getPreEmitDiagnostics`.\n        const diagnostics = service.getSemanticDiagnostics(fileName).concat(service.getSyntacticDiagnostics(fileName));\n        const programAfter = service.getProgram();\n        (0, exports.debug)('invariant: Is service.getProject() identical before and after getting emit output and diagnostics? (should always be true) ', programBefore === programAfter);\n        previousProgram = programAfter;\n        const diagnosticList = filterDiagnostics(diagnostics, diagnosticFilters);\n        if (diagnosticList.length) reportTSError(diagnosticList);\n        if (output.emitSkipped) {\n          return [undefined, undefined, true];\n        }\n        // Throw an error when requiring `.d.ts` files.\n        if (output.outputFiles.length === 0) {\n          throw new TypeError(`Unable to require file: ${(0, path_1.relative)(cwd, fileName)}\\n` + 'This is usually the result of a faulty configuration or import. ' + 'Make sure there is a `.js`, `.json` or other executable extension with ' + 'loader attached before `ts-node` available.');\n        }\n        return [output.outputFiles[1].text, output.outputFiles[0].text, false];\n      };\n      getTypeInfo = (code, fileName, position) => {\n        const normalizedFileName = (0, util_1.normalizeSlashes)(fileName);\n        updateMemoryCache(code, normalizedFileName);\n        const info = service.getQuickInfoAtPosition(normalizedFileName, position);\n        const name = ts.displayPartsToString(info ? info.displayParts : []);\n        const comment = ts.displayPartsToString(info ? info.documentation : []);\n        return {\n          name,\n          comment\n        };\n      };\n    } else {\n      const sys = {\n        ...ts.sys,\n        ...diagnosticHost,\n        readFile: fileName => {\n          const cacheContents = fileContents.get(fileName);\n          if (cacheContents !== undefined) return cacheContents;\n          const contents = cachedReadFile(fileName);\n          if (contents) fileContents.set(fileName, contents);\n          return contents;\n        },\n        readDirectory: ts.sys.readDirectory,\n        getDirectories: (0, util_1.cachedLookup)(debugFn('getDirectories', ts.sys.getDirectories)),\n        fileExists: (0, util_1.cachedLookup)(debugFn('fileExists', fileExists)),\n        directoryExists: (0, util_1.cachedLookup)(debugFn('directoryExists', ts.sys.directoryExists)),\n        resolvePath: (0, util_1.cachedLookup)(debugFn('resolvePath', ts.sys.resolvePath)),\n        realpath: ts.sys.realpath ? (0, util_1.cachedLookup)(debugFn('realpath', ts.sys.realpath)) : undefined\n      };\n      const host = ts.createIncrementalCompilerHost ? ts.createIncrementalCompilerHost(config.options, sys) : {\n        ...sys,\n        getSourceFile: (fileName, languageVersion) => {\n          const contents = sys.readFile(fileName);\n          if (contents === undefined) return;\n          return ts.createSourceFile(fileName, contents, languageVersion);\n        },\n        getDefaultLibLocation: () => (0, util_1.normalizeSlashes)((0, path_1.dirname)(compiler)),\n        getDefaultLibFileName: () => (0, util_1.normalizeSlashes)((0, path_1.join)((0, path_1.dirname)(compiler), ts.getDefaultLibFileName(config.options))),\n        useCaseSensitiveFileNames: () => sys.useCaseSensitiveFileNames\n      };\n      host.trace = options.tsTrace;\n      const {\n        resolveModuleNames,\n        resolveTypeReferenceDirectives,\n        isFileKnownToBeInternal,\n        markBucketOfFilenameInternal\n      } = (0, resolver_functions_1.createResolverFunctions)({\n        host,\n        cwd,\n        config,\n        ts,\n        getCanonicalFileName,\n        projectLocalResolveHelper,\n        options,\n        extensions\n      });\n      host.resolveModuleNames = resolveModuleNames;\n      host.resolveTypeReferenceDirectives = resolveTypeReferenceDirectives;\n      // Fallback for older TypeScript releases without incremental API.\n      let builderProgram = ts.createIncrementalProgram ? ts.createIncrementalProgram({\n        rootNames: Array.from(rootFileNames),\n        options: config.options,\n        host,\n        configFileParsingDiagnostics: config.errors,\n        projectReferences: config.projectReferences\n      }) : ts.createEmitAndSemanticDiagnosticsBuilderProgram(Array.from(rootFileNames), config.options, host, undefined, config.errors, config.projectReferences);\n      // Read and cache custom transformers.\n      const customTransformers = typeof transformers === 'function' ? transformers(builderProgram.getProgram()) : transformers;\n      // Set the file contents into cache manually.\n      const updateMemoryCache = (contents, fileName) => {\n        const previousContents = fileContents.get(fileName);\n        const contentsChanged = previousContents !== contents;\n        if (contentsChanged) {\n          fileContents.set(fileName, contents);\n        }\n        // Add to `rootFiles` when discovered by compiler for the first time.\n        let addedToRootFileNames = false;\n        if (!rootFileNames.has(fileName) && !isFileKnownToBeInternal(fileName)) {\n          markBucketOfFilenameInternal(fileName);\n          rootFileNames.add(fileName);\n          addedToRootFileNames = true;\n        }\n        // Update program when file changes.\n        if (addedToRootFileNames || contentsChanged) {\n          builderProgram = ts.createEmitAndSemanticDiagnosticsBuilderProgram(Array.from(rootFileNames), config.options, host, builderProgram, config.errors, config.projectReferences);\n        }\n      };\n      getOutput = (code, fileName) => {\n        let outText = '';\n        let outMap = '';\n        updateMemoryCache(code, fileName);\n        const sourceFile = builderProgram.getSourceFile(fileName);\n        if (!sourceFile) throw new TypeError(`Unable to read file: ${fileName}`);\n        const program = builderProgram.getProgram();\n        const diagnostics = ts.getPreEmitDiagnostics(program, sourceFile);\n        const diagnosticList = filterDiagnostics(diagnostics, diagnosticFilters);\n        if (diagnosticList.length) reportTSError(diagnosticList);\n        const result = builderProgram.emit(sourceFile, (path, file, writeByteOrderMark) => {\n          if (path.endsWith('.map')) {\n            outMap = file;\n          } else {\n            outText = file;\n          }\n          if (options.emit) sys.writeFile(path, file, writeByteOrderMark);\n        }, undefined, undefined, customTransformers);\n        if (result.emitSkipped) {\n          return [undefined, undefined, true];\n        }\n        // Throw an error when requiring files that cannot be compiled.\n        if (outText === '') {\n          if (program.isSourceFileFromExternalLibrary(sourceFile)) {\n            throw new TypeError(`Unable to compile file from external library: ${(0, path_1.relative)(cwd, fileName)}`);\n          }\n          throw new TypeError(`Unable to require file: ${(0, path_1.relative)(cwd, fileName)}\\n` + 'This is usually the result of a faulty configuration or import. ' + 'Make sure there is a `.js`, `.json` or other executable extension with ' + 'loader attached before `ts-node` available.');\n        }\n        return [outText, outMap, false];\n      };\n      getTypeInfo = (code, fileName, position) => {\n        const normalizedFileName = (0, util_1.normalizeSlashes)(fileName);\n        updateMemoryCache(code, normalizedFileName);\n        const sourceFile = builderProgram.getSourceFile(normalizedFileName);\n        if (!sourceFile) throw new TypeError(`Unable to read file: ${fileName}`);\n        const node = getTokenAtPosition(ts, sourceFile, position);\n        const checker = builderProgram.getProgram().getTypeChecker();\n        const symbol = checker.getSymbolAtLocation(node);\n        if (!symbol) return {\n          name: '',\n          comment: ''\n        };\n        const type = checker.getTypeOfSymbolAtLocation(symbol, node);\n        const signatures = [...type.getConstructSignatures(), ...type.getCallSignatures()];\n        return {\n          name: signatures.length ? signatures.map(x => checker.signatureToString(x)).join('\\n') : checker.typeToString(type),\n          comment: ts.displayPartsToString(symbol ? symbol.getDocumentationComment(checker) : [])\n        };\n      };\n      // Write `.tsbuildinfo` when `--build` is enabled.\n      if (options.emit && config.options.incremental) {\n        process.on('exit', () => {\n          // Emits `.tsbuildinfo` to filesystem.\n          builderProgram.getProgram().emitBuildInfo();\n        });\n      }\n    }\n  } else {\n    getTypeInfo = () => {\n      throw new TypeError('Type information is unavailable in \"--transpile-only\"');\n    };\n  }\n  function createTranspileOnlyGetOutputFunction(overrideModuleType, nodeModuleEmitKind) {\n    const compilerOptions = {\n      ...config.options\n    };\n    if (overrideModuleType !== undefined) compilerOptions.module = overrideModuleType;\n    let customTranspiler = createTranspiler === null || createTranspiler === void 0 ? void 0 : createTranspiler(compilerOptions, nodeModuleEmitKind);\n    let tsTranspileModule = (0, util_1.versionGteLt)(ts.version, '4.7.0') ? (0, ts_transpile_module_1.createTsTranspileModule)(ts, {\n      compilerOptions,\n      reportDiagnostics: true,\n      transformers: transformers\n    }) : undefined;\n    return (code, fileName) => {\n      let result;\n      if (customTranspiler) {\n        result = customTranspiler.transpile(code, {\n          fileName\n        });\n      } else if (tsTranspileModule) {\n        result = tsTranspileModule(code, {\n          fileName\n        }, nodeModuleEmitKind === 'nodeesm' ? 'module' : 'commonjs');\n      } else {\n        result = ts.transpileModule(code, {\n          fileName,\n          compilerOptions,\n          reportDiagnostics: true,\n          transformers: transformers\n        });\n      }\n      const diagnosticList = filterDiagnostics(result.diagnostics || [], diagnosticFilters);\n      if (diagnosticList.length) reportTSError(diagnosticList);\n      return [result.outputText, result.sourceMapText, false];\n    };\n  }\n  // When true, these mean that a `moduleType` override will cause a different emit\n  // than the TypeScript compiler, so we *must* overwrite the emit.\n  const shouldOverwriteEmitWhenForcingCommonJS = config.options.module !== ts.ModuleKind.CommonJS;\n  // [MUST_UPDATE_FOR_NEW_MODULEKIND]\n  const shouldOverwriteEmitWhenForcingEsm = !(config.options.module === ts.ModuleKind.ES2015 || ts.ModuleKind.ES2020 && config.options.module === ts.ModuleKind.ES2020 || ts.ModuleKind.ES2022 && config.options.module === ts.ModuleKind.ES2022 || config.options.module === ts.ModuleKind.ESNext);\n  /**\n   * node16 or nodenext\n   * [MUST_UPDATE_FOR_NEW_MODULEKIND]\n   */\n  const isNodeModuleType = ts.ModuleKind.Node16 && config.options.module === ts.ModuleKind.Node16 || ts.ModuleKind.NodeNext && config.options.module === ts.ModuleKind.NodeNext;\n  const getOutputForceCommonJS = createTranspileOnlyGetOutputFunction(ts.ModuleKind.CommonJS);\n  const getOutputForceNodeCommonJS = createTranspileOnlyGetOutputFunction(ts.ModuleKind.NodeNext, 'nodecjs');\n  const getOutputForceNodeESM = createTranspileOnlyGetOutputFunction(ts.ModuleKind.NodeNext, 'nodeesm');\n  // [MUST_UPDATE_FOR_NEW_MODULEKIND]\n  const getOutputForceESM = createTranspileOnlyGetOutputFunction(ts.ModuleKind.ES2022 || ts.ModuleKind.ES2020 || ts.ModuleKind.ES2015);\n  const getOutputTranspileOnly = createTranspileOnlyGetOutputFunction();\n  // Create a simple TypeScript compiler proxy.\n  function compile(code, fileName) {\n    let lineOffset = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n    const normalizedFileName = (0, util_1.normalizeSlashes)(fileName);\n    const classification = moduleTypeClassifier.classifyModuleByModuleTypeOverrides(normalizedFileName);\n    let value = '';\n    let sourceMap = '';\n    let emitSkipped = true;\n    if (getOutput) {\n      // Must always call normal getOutput to throw typechecking errors\n      [value, sourceMap, emitSkipped] = getOutput(code, normalizedFileName);\n    }\n    // If module classification contradicts the above, call the relevant transpiler\n    if (classification.moduleType === 'cjs' && (shouldOverwriteEmitWhenForcingCommonJS || emitSkipped)) {\n      [value, sourceMap] = getOutputForceCommonJS(code, normalizedFileName);\n    } else if (classification.moduleType === 'esm' && (shouldOverwriteEmitWhenForcingEsm || emitSkipped)) {\n      [value, sourceMap] = getOutputForceESM(code, normalizedFileName);\n    } else if (emitSkipped) {\n      // Happens when ts compiler skips emit or in transpileOnly mode\n      const classification = (0, node_module_type_classifier_1.classifyModule)(fileName, isNodeModuleType);\n      [value, sourceMap] = classification === 'nodecjs' ? getOutputForceNodeCommonJS(code, normalizedFileName) : classification === 'nodeesm' ? getOutputForceNodeESM(code, normalizedFileName) : classification === 'cjs' ? getOutputForceCommonJS(code, normalizedFileName) : classification === 'esm' ? getOutputForceESM(code, normalizedFileName) : getOutputTranspileOnly(code, normalizedFileName);\n    }\n    const output = updateOutput(value, normalizedFileName, sourceMap, getEmitExtension);\n    outputCache.set(normalizedFileName, {\n      content: output\n    });\n    return output;\n  }\n  let active = true;\n  const enabled = enabled => enabled === undefined ? active : active = !!enabled;\n  const ignored = fileName => {\n    if (!active) return true;\n    const ext = (0, path_1.extname)(fileName);\n    if (extensions.compiled.includes(ext)) {\n      return !isScoped(fileName) || shouldIgnore(fileName);\n    }\n    return true;\n  };\n  function addDiagnosticFilter(filter) {\n    diagnosticFilters.push({\n      ...filter,\n      filenamesAbsolute: filter.filenamesAbsolute.map(f => (0, util_1.normalizeSlashes)(f))\n    });\n  }\n  const getNodeEsmResolver = (0, util_1.once)(() => require('../dist-raw/node-internal-modules-esm-resolve').createResolve({\n    extensions,\n    preferTsExts: options.preferTsExts,\n    tsNodeExperimentalSpecifierResolution: options.experimentalSpecifierResolution\n  }));\n  const getNodeEsmGetFormat = (0, util_1.once)(() => require('../dist-raw/node-internal-modules-esm-get_format').createGetFormat(options.experimentalSpecifierResolution, getNodeEsmResolver()));\n  const getNodeCjsLoader = (0, util_1.once)(() => require('../dist-raw/node-internal-modules-cjs-loader').createCjsLoader({\n    extensions,\n    preferTsExts: options.preferTsExts,\n    nodeEsmResolver: getNodeEsmResolver()\n  }));\n  return {\n    [TS_NODE_SERVICE_BRAND]: true,\n    ts,\n    compilerPath: compiler,\n    config,\n    compile,\n    getTypeInfo,\n    ignored,\n    enabled,\n    options,\n    configFilePath,\n    moduleTypeClassifier,\n    shouldReplAwait,\n    addDiagnosticFilter,\n    installSourceMapSupport,\n    enableExperimentalEsmLoaderInterop,\n    transpileOnly,\n    projectLocalResolveHelper,\n    getNodeEsmResolver,\n    getNodeEsmGetFormat,\n    getNodeCjsLoader,\n    extensions\n  };\n}\nexports.createFromPreloadedConfig = createFromPreloadedConfig;\n/**\n * Check if the filename should be ignored.\n */\nfunction createIgnore(ignoreBaseDir, ignore) {\n  return fileName => {\n    const relname = (0, path_1.relative)(ignoreBaseDir, fileName);\n    const path = (0, util_1.normalizeSlashes)(relname);\n    return ignore.some(x => x.test(path));\n  };\n}\n/**\n * Register the extensions to support when importing files.\n */\nfunction registerExtensions(preferTsExts, extensions, service, originalJsHandler) {\n  const exts = new Set(extensions);\n  // Can't add these extensions cuz would allow omitting file extension; node requires ext for .cjs and .mjs\n  // Unless they're already registered by something else (nyc does this):\n  // then we *must* hook them or else our transformer will not be called.\n  for (const cannotAdd of ['.mts', '.cts', '.mjs', '.cjs']) {\n    if (exts.has(cannotAdd) && !(0, util_1.hasOwnProperty)(require.extensions, cannotAdd)) {\n      // Unrecognized file exts can be transformed via the `.js` handler.\n      exts.add('.js');\n      exts.delete(cannotAdd);\n    }\n  }\n  // Register new extensions.\n  for (const ext of exts) {\n    registerExtension(ext, service, originalJsHandler);\n  }\n  if (preferTsExts) {\n    const preferredExtensions = new Set([...exts, ...Object.keys(require.extensions)]);\n    // Re-sort iteration order of Object.keys()\n    for (const ext of preferredExtensions) {\n      const old = Object.getOwnPropertyDescriptor(require.extensions, ext);\n      delete require.extensions[ext];\n      Object.defineProperty(require.extensions, ext, old);\n    }\n  }\n}\n/**\n * Register the extension for node.\n */\nfunction registerExtension(ext, service, originalHandler) {\n  const old = require.extensions[ext] || originalHandler;\n  require.extensions[ext] = function (m, filename) {\n    if (service.ignored(filename)) return old(m, filename);\n    assertScriptCanLoadAsCJS(service, m, filename);\n    const _compile = m._compile;\n    m._compile = function (code, fileName) {\n      (0, exports.debug)('module._compile', fileName);\n      const result = service.compile(code, fileName);\n      return _compile.call(this, result, fileName);\n    };\n    return old(m, filename);\n  };\n}\n/**\n * Update the output remapping the source map.\n */\nfunction updateOutput(outputText, fileName, sourceMap, getEmitExtension) {\n  const base64Map = Buffer.from(updateSourceMap(sourceMap, fileName), 'utf8').toString('base64');\n  const sourceMapContent = `//# sourceMappingURL=data:application/json;charset=utf-8;base64,${base64Map}`;\n  // Expected form: `//# sourceMappingURL=foo bar.js.map` or `//# sourceMappingURL=foo%20bar.js.map` for input file \"foo bar.tsx\"\n  // Percent-encoding behavior added in TS 4.1.1: https://github.com/microsoft/TypeScript/issues/40951\n  const prefix = '//# sourceMappingURL=';\n  const prefixLength = prefix.length;\n  const baseName = /*foo.tsx*/(0, path_1.basename)(fileName);\n  const extName = /*.tsx*/(0, path_1.extname)(fileName);\n  const extension = /*.js*/getEmitExtension(fileName);\n  const sourcemapFilename = baseName.slice(0, -extName.length) + extension + '.map';\n  const sourceMapLengthWithoutPercentEncoding = prefixLength + sourcemapFilename.length;\n  /*\n   * Only rewrite if existing directive exists at the location we expect, to support:\n   *   a) compilers that do not append a sourcemap directive\n   *   b) situations where we did the math wrong\n   *     Not ideal, but appending our sourcemap *after* a pre-existing sourcemap still overrides, so the end-user is happy.\n   */\n  if (outputText.substr(-sourceMapLengthWithoutPercentEncoding, prefixLength) === prefix) {\n    return outputText.slice(0, -sourceMapLengthWithoutPercentEncoding) + sourceMapContent;\n  }\n  // If anyone asks why we're not using URL, the URL equivalent is: `u = new URL('http://d'); u.pathname = \"/\" + sourcemapFilename; return u.pathname.slice(1);\n  const sourceMapLengthWithPercentEncoding = prefixLength + encodeURI(sourcemapFilename).length;\n  if (outputText.substr(-sourceMapLengthWithPercentEncoding, prefixLength) === prefix) {\n    return outputText.slice(0, -sourceMapLengthWithPercentEncoding) + sourceMapContent;\n  }\n  return `${outputText}\\n${sourceMapContent}`;\n}\n/**\n * Update the source map contents for improved output.\n */\nfunction updateSourceMap(sourceMapText, fileName) {\n  const sourceMap = JSON.parse(sourceMapText);\n  sourceMap.file = fileName;\n  sourceMap.sources = [fileName];\n  delete sourceMap.sourceRoot;\n  return JSON.stringify(sourceMap);\n}\n/**\n * Filter diagnostics.\n */\nfunction filterDiagnostics(diagnostics, filters) {\n  return diagnostics.filter(d => filters.every(f => {\n    var _a;\n    return !f.appliesToAllFiles && f.filenamesAbsolute.indexOf((_a = d.file) === null || _a === void 0 ? void 0 : _a.fileName) === -1 || f.diagnosticsIgnored.indexOf(d.code) === -1;\n  }));\n}\n/**\n * Get token at file position.\n *\n * Reference: https://github.com/microsoft/TypeScript/blob/fcd9334f57d85b73dd66ad2d21c02e84822f4841/src/services/utilities.ts#L705-L731\n */\nfunction getTokenAtPosition(ts, sourceFile, position) {\n  let current = sourceFile;\n  outer: while (true) {\n    for (const child of current.getChildren(sourceFile)) {\n      const start = child.getFullStart();\n      if (start > position) break;\n      const end = child.getEnd();\n      if (position <= end) {\n        current = child;\n        continue outer;\n      }\n    }\n    return current;\n  }\n}\n/**\n * Create an implementation of node's ESM loader hooks.\n *\n * This may be useful if you\n * want to wrap or compose the loader hooks to add additional functionality or\n * combine with another loader.\n *\n * Node changed the hooks API, so there are two possible APIs.  This function\n * detects your node version and returns the appropriate API.\n *\n * @category ESM Loader\n */\nconst createEsmHooks = tsNodeService => require('./esm').createEsmHooks(tsNodeService);\nexports.createEsmHooks = createEsmHooks;","map":{"version":3,"mappings":"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","names":["Object","enumerable","get","engineSupportsPackageTypeField","parseInt","process","versions","node","split","assertScriptCanLoadAsCJS","require","assertScriptCanLoadAsCJSImpl","exports","Symbol","for","env","util","inspect","custom","shouldDebug","TS_NODE_DEBUG","args","console","log","Date","toISOString","undefined","debugFn","key","fn","i","x","_","version","cwd","TS_NODE_CWD","TS_NODE_DIR","emit","TS_NODE_EMIT","scope","TS_NODE_SCOPE","scopeDir","TS_NODE_SCOPE_DIR","files","TS_NODE_FILES","pretty","TS_NODE_PRETTY","compiler","TS_NODE_COMPILER","compilerOptions","TS_NODE_COMPILER_OPTIONS","ignore","TS_NODE_IGNORE","project","TS_NODE_PROJECT","skipProject","TS_NODE_SKIP_PROJECT","skipIgnore","TS_NODE_SKIP_IGNORE","preferTsExts","TS_NODE_PREFER_TS_EXTS","ignoreDiagnostics","TS_NODE_IGNORE_DIAGNOSTICS","transpileOnly","TS_NODE_TRANSPILE_ONLY","typeCheck","TS_NODE_TYPE_CHECK","compilerHost","TS_NODE_COMPILER_HOST","logError","TS_NODE_LOG_ERROR","experimentalReplAwait","TS_NODE_EXPERIMENTAL_REPL_AWAIT","tsTrace","bind","TSError","make_error_1","constructor","diagnosticText","diagnosticCodes","diagnostics","defineProperty","configurable","writable","value","TS_NODE_SERVICE_BRAND","register","serviceOrOpts","service","create","originalJsHandler","extensions","registerExtensions","options","compiled","module_1","_preloadModules","rawOptions","foundConfigResult","createFromPreloadedConfig","configFilePath","config","projectLocalResolveDir","optionBasePaths","projectLocalResolveHelper","ts","targetSupportsTla","target","ScriptTarget","ES2018","Error","tsVersionSupportsTla","shouldReplAwait","swc","transpiler","readFile","sys","fileExists","transpilerBasePath","resolve","transformers","diagnosticFilters","appliesToAllFiles","filenamesAbsolute","diagnosticsIgnored","experimentalTsImportSpecifiers","map","Number","configDiagnosticList","filterDiagnostics","errors","outputCache","Map","configFileDirname","rootDir","ignoreBaseDir","isScoped","fileName","charAt","shouldIgnore","createIgnore","str","RegExp","diagnosticHost","getNewLine","newLine","getCurrentDirectory","getCanonicalFileName","useCaseSensitiveFileNames","toLowerCase","TypeError","createTranspiler","initializeTranspilerFactory","transpilerName","transpilerOptions","transpilerConfigLocalResolveHelper","transpilerPath","transpilerFactory","nodeModuleEmitKind","experimentalEsmLoader","enableExperimentalEsmLoaderInterop","installSourceMapSupport","sourceMapSupport","install","environment","retrieveFile","pathOrUrl","path","startsWith","e","content","redirectConflictingLibrary","onConflictingLibraryRedirect","request","parent","isMain","redirectedRequest","filename","shouldHavePrettyErrors","stdout","isTTY","formatDiagnostics","formatDiagnosticsWithColorAndContext","createTSError","code","reportTSError","error","length","jsxEmitPreserve","jsx","JsxEmit","Preserve","getEmitExtension","lastDotIndex","lastIndexOf","ext","slice","getOutput","getTypeInfo","createGetCanonicalFileName","moduleTypeClassifier","basePath","moduleTypes","patterns","fileContents","rootFileNames","Set","fileNames","cachedReadFile","projectVersion","fileVersions","Array","from","getCustomTransformers","program","getProgram","serviceHost","getProjectVersion","String","getScriptFileNames","getScriptVersion","toString","getScriptSnapshot","contents","set","ScriptSnapshot","fromString","readDirectory","getDirectories","directoryExists","realpath","getCompilationSettings","getDefaultLibFileName","getDefaultLibFilePath","trace","resolveModuleNames","getResolvedModuleWithFailedLookupLocationsFromCache","resolveTypeReferenceDirectives","isFileKnownToBeInternal","markBucketOfFilenameInternal","host","registry","createDocumentRegistry","createLanguageService","updateMemoryCache","has","add","previousVersion","previousContents","previousProgram","programBefore","output","getEmitOutput","getSemanticDiagnostics","concat","getSyntacticDiagnostics","programAfter","diagnosticList","emitSkipped","outputFiles","text","position","normalizedFileName","info","getQuickInfoAtPosition","name","displayPartsToString","displayParts","comment","documentation","cacheContents","resolvePath","createIncrementalCompilerHost","getSourceFile","languageVersion","createSourceFile","getDefaultLibLocation","builderProgram","createIncrementalProgram","rootNames","configFileParsingDiagnostics","projectReferences","createEmitAndSemanticDiagnosticsBuilderProgram","customTransformers","contentsChanged","addedToRootFileNames","outText","outMap","sourceFile","getPreEmitDiagnostics","result","file","writeByteOrderMark","endsWith","writeFile","isSourceFileFromExternalLibrary","getTokenAtPosition","checker","getTypeChecker","symbol","getSymbolAtLocation","type","getTypeOfSymbolAtLocation","signatures","getConstructSignatures","getCallSignatures","signatureToString","join","typeToString","getDocumentationComment","incremental","on","emitBuildInfo","createTranspileOnlyGetOutputFunction","overrideModuleType","module","customTranspiler","tsTranspileModule","reportDiagnostics","transpile","transpileModule","outputText","sourceMapText","shouldOverwriteEmitWhenForcingCommonJS","ModuleKind","CommonJS","shouldOverwriteEmitWhenForcingEsm","ES2015","ES2020","ES2022","ESNext","isNodeModuleType","Node16","NodeNext","getOutputForceCommonJS","getOutputForceNodeCommonJS","getOutputForceNodeESM","getOutputForceESM","getOutputTranspileOnly","compile","lineOffset","classification","classifyModuleByModuleTypeOverrides","sourceMap","moduleType","updateOutput","active","enabled","ignored","includes","addDiagnosticFilter","filter","push","f","getNodeEsmResolver","createResolve","tsNodeExperimentalSpecifierResolution","experimentalSpecifierResolution","getNodeEsmGetFormat","createGetFormat","getNodeCjsLoader","createCjsLoader","nodeEsmResolver","compilerPath","relname","some","test","exts","cannotAdd","delete","registerExtension","preferredExtensions","keys","old","getOwnPropertyDescriptor","originalHandler","m","_compile","call","base64Map","Buffer","updateSourceMap","sourceMapContent","prefix","prefixLength","baseName","extName","extension","sourcemapFilename","sourceMapLengthWithoutPercentEncoding","substr","sourceMapLengthWithPercentEncoding","encodeURI","JSON","parse","sources","sourceRoot","stringify","filters","d","every","indexOf","current","outer","child","getChildren","start","getFullStart","end","getEnd","createEsmHooks","tsNodeService"],"sources":["/Users/janrobel/Documents/PersonalProjekty/nftGenerateAi/clientAndContract/node_modules/ts-node/src/index.ts"],"sourcesContent":["import { relative, basename, extname, dirname, join } from 'path';\nimport { Module } from 'module';\nimport * as util from 'util';\nimport { fileURLToPath } from 'url';\n\nimport type * as _sourceMapSupport from '@cspotcode/source-map-support';\nimport { BaseError } from 'make-error';\nimport type * as _ts from 'typescript';\n\nimport type { Transpiler, TranspilerFactory } from './transpilers/types';\nimport {\n  cachedLookup,\n  createProjectLocalResolveHelper,\n  hasOwnProperty,\n  normalizeSlashes,\n  once,\n  parse,\n  ProjectLocalResolveHelper,\n  split,\n  versionGteLt,\n  yn,\n} from './util';\nimport { findAndReadConfig, loadCompiler } from './configuration';\nimport type { TSCommon, TSInternal } from './ts-compiler-types';\nimport {\n  createModuleTypeClassifier,\n  ModuleTypeClassifier,\n} from './module-type-classifier';\nimport { createResolverFunctions } from './resolver-functions';\nimport type { createEsmHooks as createEsmHooksFn } from './esm';\nimport {\n  installCommonjsResolveHooksIfNecessary,\n  ModuleConstructorWithInternals,\n} from './cjs-resolve-hooks';\nimport { classifyModule } from './node-module-type-classifier';\nimport type * as _nodeInternalModulesEsmResolve from '../dist-raw/node-internal-modules-esm-resolve';\nimport type * as _nodeInternalModulesEsmGetFormat from '../dist-raw/node-internal-modules-esm-get_format';\nimport type * as _nodeInternalModulesCjsLoader from '../dist-raw/node-internal-modules-cjs-loader';\nimport { Extensions, getExtensions } from './file-extensions';\nimport { createTsTranspileModule } from './ts-transpile-module';\n\nexport { TSCommon };\nexport {\n  createRepl,\n  CreateReplOptions,\n  ReplService,\n  EvalAwarePartialHost,\n} from './repl';\nexport type {\n  TranspilerModule,\n  TranspilerFactory,\n  CreateTranspilerOptions,\n  TranspileOutput,\n  TranspileOptions,\n  Transpiler,\n} from './transpilers/types';\nexport type {\n  NodeLoaderHooksAPI1,\n  NodeLoaderHooksAPI2,\n  NodeLoaderHooksFormat,\n} from './esm';\n\n/**\n * Does this version of node obey the package.json \"type\" field\n * and throw ERR_REQUIRE_ESM when attempting to require() an ESM modules.\n */\nconst engineSupportsPackageTypeField =\n  parseInt(process.versions.node.split('.')[0], 10) >= 12;\n\n/**\n * Assert that script can be loaded as CommonJS when we attempt to require it.\n * If it should be loaded as ESM, throw ERR_REQUIRE_ESM like node does.\n *\n * Loaded conditionally so we don't need to support older node versions\n */\nlet assertScriptCanLoadAsCJS: (\n  service: Service,\n  module: NodeJS.Module,\n  filename: string\n) => void = engineSupportsPackageTypeField\n  ? (\n      require('../dist-raw/node-internal-modules-cjs-loader') as typeof _nodeInternalModulesCjsLoader\n    ).assertScriptCanLoadAsCJSImpl\n  : () => {\n      /* noop */\n    };\n\n/**\n * Registered `ts-node` instance information.\n */\nexport const REGISTER_INSTANCE = Symbol.for('ts-node.register.instance');\n\n/**\n * Expose `REGISTER_INSTANCE` information on node.js `process`.\n */\ndeclare global {\n  namespace NodeJS {\n    interface Process {\n      [REGISTER_INSTANCE]?: Service;\n    }\n  }\n}\n\n/** @internal */\nexport const env = process.env as ProcessEnv;\n/**\n * Declare all env vars, to aid discoverability.\n * If an env var affects ts-node's behavior, it should not be buried somewhere in our codebase.\n * @internal\n */\nexport interface ProcessEnv {\n  TS_NODE_DEBUG?: string;\n  TS_NODE_CWD?: string;\n  /** @deprecated */\n  TS_NODE_DIR?: string;\n  TS_NODE_EMIT?: string;\n  TS_NODE_SCOPE?: string;\n  TS_NODE_SCOPE_DIR?: string;\n  TS_NODE_FILES?: string;\n  TS_NODE_PRETTY?: string;\n  TS_NODE_COMPILER?: string;\n  TS_NODE_COMPILER_OPTIONS?: string;\n  TS_NODE_IGNORE?: string;\n  TS_NODE_PROJECT?: string;\n  TS_NODE_SKIP_PROJECT?: string;\n  TS_NODE_SKIP_IGNORE?: string;\n  TS_NODE_PREFER_TS_EXTS?: string;\n  TS_NODE_IGNORE_DIAGNOSTICS?: string;\n  TS_NODE_TRANSPILE_ONLY?: string;\n  TS_NODE_TYPE_CHECK?: string;\n  TS_NODE_COMPILER_HOST?: string;\n  TS_NODE_LOG_ERROR?: string;\n  TS_NODE_HISTORY?: string;\n  TS_NODE_EXPERIMENTAL_REPL_AWAIT?: string;\n\n  NODE_NO_READLINE?: string;\n}\n\n/**\n * @internal\n */\nexport const INSPECT_CUSTOM = util.inspect.custom || 'inspect';\n\n/**\n * Debugging `ts-node`.\n */\nconst shouldDebug = yn(env.TS_NODE_DEBUG);\n/** @internal */\nexport const debug = shouldDebug\n  ? (...args: any) =>\n      console.log(`[ts-node ${new Date().toISOString()}]`, ...args)\n  : () => undefined;\nconst debugFn = shouldDebug\n  ? <T, U>(key: string, fn: (arg: T) => U) => {\n      let i = 0;\n      return (x: T) => {\n        debug(key, x, ++i);\n        return fn(x);\n      };\n    }\n  : <T, U>(_: string, fn: (arg: T) => U) => fn;\n\n/**\n * Export the current version.\n */\nexport const VERSION = require('../package.json').version;\n\n/**\n * Options for creating a new TypeScript compiler instance.\n\n * @category Basic\n */\nexport interface CreateOptions {\n  /**\n   * Behave as if invoked within this working directory.  Roughly equivalent to `cd $dir && ts-node ...`\n   *\n   * @default process.cwd()\n   */\n  cwd?: string;\n  /**\n   * Legacy alias for `cwd`\n   *\n   * @deprecated use `projectSearchDir` or `cwd`\n   */\n  dir?: string;\n  /**\n   * Emit output files into `.ts-node` directory.\n   *\n   * @default false\n   */\n  emit?: boolean;\n  /**\n   * Scope compiler to files within `scopeDir`.\n   *\n   * @default false\n   */\n  scope?: boolean;\n  /**\n   * @default First of: `tsconfig.json` \"rootDir\" if specified, directory containing `tsconfig.json`, or cwd if no `tsconfig.json` is loaded.\n   */\n  scopeDir?: string;\n  /**\n   * Use pretty diagnostic formatter.\n   *\n   * @default false\n   */\n  pretty?: boolean;\n  /**\n   * Use TypeScript's faster `transpileModule`.\n   *\n   * @default false\n   */\n  transpileOnly?: boolean;\n  /**\n   * **DEPRECATED** Specify type-check is enabled (e.g. `transpileOnly == false`).\n   *\n   * @default true\n   */\n  typeCheck?: boolean;\n  /**\n   * Use TypeScript's compiler host API instead of the language service API.\n   *\n   * @default false\n   */\n  compilerHost?: boolean;\n  /**\n   * Logs TypeScript errors to stderr instead of throwing exceptions.\n   *\n   * @default false\n   */\n  logError?: boolean;\n  /**\n   * Load \"files\" and \"include\" from `tsconfig.json` on startup.\n   *\n   * Default is to override `tsconfig.json` \"files\" and \"include\" to only include the entrypoint script.\n   *\n   * @default false\n   */\n  files?: boolean;\n  /**\n   * Specify a custom TypeScript compiler.\n   *\n   * @default \"typescript\"\n   */\n  compiler?: string;\n  /**\n   * Specify a custom transpiler for use with transpileOnly\n   */\n  transpiler?: string | [string, object];\n  /**\n   * Transpile with swc instead of the TypeScript compiler, and skip typechecking.\n   *\n   * Equivalent to setting both `transpileOnly: true` and `transpiler: 'ts-node/transpilers/swc'`\n   *\n   * For complete instructions: https://typestrong.org/ts-node/docs/transpilers\n   */\n  swc?: boolean;\n  /**\n   * Paths which should not be compiled.\n   *\n   * Each string in the array is converted to a regular expression via `new RegExp()` and tested against source paths prior to compilation.\n   *\n   * Source paths are normalized to posix-style separators, relative to the directory containing `tsconfig.json` or to cwd if no `tsconfig.json` is loaded.\n   *\n   * Default is to ignore all node_modules subdirectories.\n   *\n   * @default [\"(?:^|/)node_modules/\"]\n   */\n  ignore?: string[];\n  /**\n   * Path to TypeScript config file or directory containing a `tsconfig.json`.\n   * Similar to the `tsc --project` flag: https://www.typescriptlang.org/docs/handbook/compiler-options.html\n   */\n  project?: string;\n  /**\n   * Search for TypeScript config file (`tsconfig.json`) in this or parent directories.\n   */\n  projectSearchDir?: string;\n  /**\n   * Skip project config resolution and loading.\n   *\n   * @default false\n   */\n  skipProject?: boolean;\n  /**\n   * Skip ignore check, so that compilation will be attempted for all files with matching extensions.\n   *\n   * @default false\n   */\n  skipIgnore?: boolean;\n  /**\n   * JSON object to merge with TypeScript `compilerOptions`.\n   *\n   * @allOf [{\"$ref\": \"https://schemastore.azurewebsites.net/schemas/json/tsconfig.json#definitions/compilerOptionsDefinition/properties/compilerOptions\"}]\n   */\n  compilerOptions?: object;\n  /**\n   * Ignore TypeScript warnings by diagnostic code.\n   */\n  ignoreDiagnostics?: Array<number | string>;\n  /**\n   * Modules to require, like node's `--require` flag.\n   *\n   * If specified in `tsconfig.json`, the modules will be resolved relative to the `tsconfig.json` file.\n   *\n   * If specified programmatically, each input string should be pre-resolved to an absolute path for\n   * best results.\n   */\n  require?: Array<string>;\n  readFile?: (path: string) => string | undefined;\n  fileExists?: (path: string) => boolean;\n  transformers?:\n    | _ts.CustomTransformers\n    | ((p: _ts.Program) => _ts.CustomTransformers);\n  /**\n   * Allows the usage of top level await in REPL.\n   *\n   * Uses node's implementation which accomplishes this with an AST syntax transformation.\n   *\n   * Enabled by default when tsconfig target is es2018 or above. Set to false to disable.\n   *\n   * **Note**: setting to `true` when tsconfig target is too low will throw an Error.  Leave as `undefined`\n   * to get default, automatic behavior.\n   */\n  experimentalReplAwait?: boolean;\n  /**\n   * Override certain paths to be compiled and executed as CommonJS or ECMAScript modules.\n   * When overridden, the tsconfig \"module\" and package.json \"type\" fields are overridden, and\n   * the file extension is ignored.\n   * This is useful if you cannot use .mts, .cts, .mjs, or .cjs file extensions;\n   * it achieves the same effect.\n   *\n   * Each key is a glob pattern following the same rules as tsconfig's \"include\" array.\n   * When multiple patterns match the same file, the last pattern takes precedence.\n   *\n   * `cjs` overrides matches files to compile and execute as CommonJS.\n   * `esm` overrides matches files to compile and execute as native ECMAScript modules.\n   * `package` overrides either of the above to default behavior, which obeys package.json \"type\" and\n   * tsconfig.json \"module\" options.\n   */\n  moduleTypes?: ModuleTypes;\n  /**\n   * @internal\n   * Set by our configuration loader whenever a config file contains options that\n   * are relative to the config file they came from, *and* when other logic needs\n   * to know this.  Some options can be eagerly resolved to absolute paths by\n   * the configuration loader, so it is *not* necessary for their source to be set here.\n   */\n  optionBasePaths?: OptionBasePaths;\n  /**\n   * A function to collect trace messages from the TypeScript compiler, for example when `traceResolution` is enabled.\n   *\n   * @default console.log\n   */\n  tsTrace?: (str: string) => void;\n  /**\n   * Enable native ESM support.\n   *\n   * For details, see https://typestrong.org/ts-node/docs/imports#native-ecmascript-modules\n   */\n  esm?: boolean;\n  /**\n   * Re-order file extensions so that TypeScript imports are preferred.\n   *\n   * For example, when both `index.js` and `index.ts` exist, enabling this option causes `require('./index')` to resolve to `index.ts` instead of `index.js`\n   *\n   * @default false\n   */\n  preferTsExts?: boolean;\n  /**\n   * Like node's `--experimental-specifier-resolution`, , but can also be set in your `tsconfig.json` for convenience.\n   *\n   * For details, see https://nodejs.org/dist/latest-v18.x/docs/api/esm.html#customizing-esm-specifier-resolution-algorithm\n   */\n  experimentalSpecifierResolution?: 'node' | 'explicit';\n  /**\n   * Allow using voluntary `.ts` file extension in import specifiers.\n   *\n   * Typically, in ESM projects, import specifiers must have an emit extension, `.js`, `.cjs`, or `.mjs`,\n   * and we automatically map to the corresponding `.ts`, `.cts`, or `.mts` source file.  This is the\n   * recommended approach.\n   *\n   * However, if you really want to use `.ts` in import specifiers, and are aware that this may\n   * break tooling, you can enable this flag.\n   */\n  experimentalTsImportSpecifiers?: boolean;\n}\n\nexport type ModuleTypes = Record<string, ModuleTypeOverride>;\nexport type ModuleTypeOverride = 'cjs' | 'esm' | 'package';\n\n/** @internal */\nexport interface OptionBasePaths {\n  moduleTypes?: string;\n  transpiler?: string;\n  compiler?: string;\n  swc?: string;\n}\n\n/**\n * Options for registering a TypeScript compiler instance globally.\n\n * @category Basic\n */\nexport interface RegisterOptions extends CreateOptions {\n  /**\n   * Enable experimental features that re-map imports and require calls to support:\n   * `baseUrl`, `paths`, `rootDirs`, `.js` to `.ts` file extension mappings,\n   * `outDir` to `rootDir` mappings for composite projects and monorepos.\n   *\n   * For details, see https://github.com/TypeStrong/ts-node/issues/1514\n   */\n  experimentalResolver?: boolean;\n}\n\nexport type ExperimentalSpecifierResolution = 'node' | 'explicit';\n\n/**\n * Must be an interface to support `typescript-json-schema`.\n */\nexport interface TsConfigOptions\n  extends Omit<\n    RegisterOptions,\n    | 'transformers'\n    | 'readFile'\n    | 'fileExists'\n    | 'skipProject'\n    | 'project'\n    | 'dir'\n    | 'cwd'\n    | 'projectSearchDir'\n    | 'optionBasePaths'\n    | 'tsTrace'\n  > {}\n\n/**\n * Information retrieved from type info check.\n */\nexport interface TypeInfo {\n  name: string;\n  comment: string;\n}\n\n/**\n * Default register options, including values specified via environment\n * variables.\n * @internal\n */\nexport const DEFAULTS: RegisterOptions = {\n  cwd: env.TS_NODE_CWD ?? env.TS_NODE_DIR,\n  emit: yn(env.TS_NODE_EMIT),\n  scope: yn(env.TS_NODE_SCOPE),\n  scopeDir: env.TS_NODE_SCOPE_DIR,\n  files: yn(env.TS_NODE_FILES),\n  pretty: yn(env.TS_NODE_PRETTY),\n  compiler: env.TS_NODE_COMPILER,\n  compilerOptions: parse(env.TS_NODE_COMPILER_OPTIONS),\n  ignore: split(env.TS_NODE_IGNORE),\n  project: env.TS_NODE_PROJECT,\n  skipProject: yn(env.TS_NODE_SKIP_PROJECT),\n  skipIgnore: yn(env.TS_NODE_SKIP_IGNORE),\n  preferTsExts: yn(env.TS_NODE_PREFER_TS_EXTS),\n  ignoreDiagnostics: split(env.TS_NODE_IGNORE_DIAGNOSTICS),\n  transpileOnly: yn(env.TS_NODE_TRANSPILE_ONLY),\n  typeCheck: yn(env.TS_NODE_TYPE_CHECK),\n  compilerHost: yn(env.TS_NODE_COMPILER_HOST),\n  logError: yn(env.TS_NODE_LOG_ERROR),\n  experimentalReplAwait: yn(env.TS_NODE_EXPERIMENTAL_REPL_AWAIT) ?? undefined,\n  tsTrace: console.log.bind(console),\n};\n\n/**\n * TypeScript diagnostics error.\n */\nexport class TSError extends BaseError {\n  name = 'TSError';\n  diagnosticText!: string;\n  diagnostics!: ReadonlyArray<_ts.Diagnostic>;\n\n  constructor(\n    diagnosticText: string,\n    public diagnosticCodes: number[],\n    diagnostics: ReadonlyArray<_ts.Diagnostic> = []\n  ) {\n    super(`тип Unable to compile TypeScript:\\n${diagnosticText}`);\n    Object.defineProperty(this, 'diagnosticText', {\n      configurable: true,\n      writable: true,\n      value: diagnosticText,\n    });\n    Object.defineProperty(this, 'diagnostics', {\n      configurable: true,\n      writable: true,\n      value: diagnostics,\n    });\n  }\n\n  /**\n   * @internal\n   */\n  [INSPECT_CUSTOM]() {\n    return this.diagnosticText;\n  }\n}\n\nconst TS_NODE_SERVICE_BRAND = Symbol('TS_NODE_SERVICE_BRAND');\n\n/**\n * Primary ts-node service, which wraps the TypeScript API and can compile TypeScript to JavaScript\n */\nexport interface Service {\n  /** @internal */\n  [TS_NODE_SERVICE_BRAND]: true;\n  ts: TSCommon;\n  /** @internal */\n  compilerPath: string;\n  config: _ts.ParsedCommandLine;\n  options: RegisterOptions;\n  enabled(enabled?: boolean): boolean;\n  ignored(fileName: string): boolean;\n  compile(code: string, fileName: string, lineOffset?: number): string;\n  getTypeInfo(code: string, fileName: string, position: number): TypeInfo;\n  /** @internal */\n  configFilePath: string | undefined;\n  /** @internal */\n  moduleTypeClassifier: ModuleTypeClassifier;\n  /** @internal */\n  readonly shouldReplAwait: boolean;\n  /** @internal */\n  addDiagnosticFilter(filter: DiagnosticFilter): void;\n  /** @internal */\n  installSourceMapSupport(): void;\n  /** @internal */\n  enableExperimentalEsmLoaderInterop(): void;\n  /** @internal */\n  transpileOnly: boolean;\n  /** @internal */\n  projectLocalResolveHelper: ProjectLocalResolveHelper;\n  /** @internal */\n  getNodeEsmResolver: () => ReturnType<\n    typeof import('../dist-raw/node-internal-modules-esm-resolve').createResolve\n  >;\n  /** @internal */\n  getNodeEsmGetFormat: () => ReturnType<\n    typeof import('../dist-raw/node-internal-modules-esm-get_format').createGetFormat\n  >;\n  /** @internal */\n  getNodeCjsLoader: () => ReturnType<\n    typeof import('../dist-raw/node-internal-modules-cjs-loader').createCjsLoader\n  >;\n  /** @internal */\n  extensions: Extensions;\n}\n\n/**\n * Re-export of `Service` interface for backwards-compatibility\n * @deprecated use `Service` instead\n * @see {Service}\n */\nexport type Register = Service;\n\n/** @internal */\nexport interface DiagnosticFilter {\n  /** if true, filter applies to all files */\n  appliesToAllFiles: boolean;\n  /** Filter applies onto to these filenames.  Only used if appliesToAllFiles is false */\n  filenamesAbsolute: string[];\n  /** these diagnostic codes are ignored */\n  diagnosticsIgnored: number[];\n}\n\n/**\n * Create a new TypeScript compiler instance and register it onto node.js\n *\n * @category Basic\n */\nexport function register(opts?: RegisterOptions): Service;\n/**\n * Register TypeScript compiler instance onto node.js\n\n * @category Basic\n */\nexport function register(service: Service): Service;\nexport function register(\n  serviceOrOpts: Service | RegisterOptions | undefined\n): Service {\n  // Is this a Service or a RegisterOptions?\n  let service = serviceOrOpts as Service;\n  if (!(serviceOrOpts as Service)?.[TS_NODE_SERVICE_BRAND]) {\n    // Not a service; is options\n    service = create((serviceOrOpts ?? {}) as RegisterOptions);\n  }\n\n  const originalJsHandler = require.extensions['.js'];\n\n  // Expose registered instance globally.\n  process[REGISTER_INSTANCE] = service;\n\n  // Register the extensions.\n  registerExtensions(\n    service.options.preferTsExts,\n    service.extensions.compiled,\n    service,\n    originalJsHandler\n  );\n\n  installCommonjsResolveHooksIfNecessary(service);\n\n  // Require specified modules before start-up.\n  (Module as ModuleConstructorWithInternals)._preloadModules(\n    service.options.require\n  );\n\n  return service;\n}\n\n/**\n * Create TypeScript compiler instance.\n *\n * @category Basic\n */\nexport function create(rawOptions: CreateOptions = {}): Service {\n  const foundConfigResult = findAndReadConfig(rawOptions);\n  return createFromPreloadedConfig(foundConfigResult);\n}\n\n/** @internal */\nexport function createFromPreloadedConfig(\n  foundConfigResult: ReturnType<typeof findAndReadConfig>\n): Service {\n  const {\n    configFilePath,\n    cwd,\n    options,\n    config,\n    compiler,\n    projectLocalResolveDir,\n    optionBasePaths,\n  } = foundConfigResult;\n\n  const projectLocalResolveHelper = createProjectLocalResolveHelper(\n    projectLocalResolveDir\n  );\n\n  const ts = loadCompiler(compiler);\n\n  // Experimental REPL await is not compatible targets lower than ES2018\n  const targetSupportsTla = config.options.target! >= ts.ScriptTarget.ES2018;\n  if (options.experimentalReplAwait === true && !targetSupportsTla) {\n    throw new Error(\n      'Experimental REPL await is not compatible with targets lower than ES2018'\n    );\n  }\n  // Top-level await was added in TS 3.8\n  const tsVersionSupportsTla = versionGteLt(ts.version, '3.8.0');\n  if (options.experimentalReplAwait === true && !tsVersionSupportsTla) {\n    throw new Error(\n      'Experimental REPL await is not compatible with TypeScript versions older than 3.8'\n    );\n  }\n\n  const shouldReplAwait =\n    options.experimentalReplAwait !== false &&\n    tsVersionSupportsTla &&\n    targetSupportsTla;\n\n  // swc implies two other options\n  // typeCheck option was implemented specifically to allow overriding tsconfig transpileOnly from the command-line\n  // So we should allow using typeCheck to override swc\n  if (options.swc && !options.typeCheck) {\n    if (options.transpileOnly === false) {\n      throw new Error(\n        \"Cannot enable 'swc' option with 'transpileOnly: false'.  'swc' implies 'transpileOnly'.\"\n      );\n    }\n    if (options.transpiler) {\n      throw new Error(\n        \"Cannot specify both 'swc' and 'transpiler' options.  'swc' uses the built-in swc transpiler.\"\n      );\n    }\n  }\n\n  const readFile = options.readFile || ts.sys.readFile;\n  const fileExists = options.fileExists || ts.sys.fileExists;\n  // typeCheck can override transpileOnly, useful for CLI flag to override config file\n  const transpileOnly =\n    (options.transpileOnly === true || options.swc === true) &&\n    options.typeCheck !== true;\n  let transpiler: RegisterOptions['transpiler'] | undefined = undefined;\n  let transpilerBasePath: string | undefined = undefined;\n  if (options.transpiler) {\n    transpiler = options.transpiler;\n    transpilerBasePath = optionBasePaths.transpiler;\n  } else if (options.swc) {\n    transpiler = require.resolve('./transpilers/swc.js');\n    transpilerBasePath = optionBasePaths.swc;\n  }\n  const transformers = options.transformers || undefined;\n  const diagnosticFilters: Array<DiagnosticFilter> = [\n    {\n      appliesToAllFiles: true,\n      filenamesAbsolute: [],\n      diagnosticsIgnored: [\n        6059, // \"'rootDir' is expected to contain all source files.\"\n        18002, // \"The 'files' list in config file is empty.\"\n        18003, // \"No inputs were found in config file.\"\n        ...(options.experimentalTsImportSpecifiers\n          ? [\n              2691, // \"An import path cannot end with a '.ts' extension. Consider importing '<specifier without ext>' instead.\"\n            ]\n          : []),\n        ...(options.ignoreDiagnostics || []),\n      ].map(Number),\n    },\n  ];\n\n  const configDiagnosticList = filterDiagnostics(\n    config.errors,\n    diagnosticFilters\n  );\n  const outputCache = new Map<\n    string,\n    {\n      content: string;\n    }\n  >();\n\n  const configFileDirname = configFilePath ? dirname(configFilePath) : null;\n  const scopeDir =\n    options.scopeDir ?? config.options.rootDir ?? configFileDirname ?? cwd;\n  const ignoreBaseDir = configFileDirname ?? cwd;\n  const isScoped = options.scope\n    ? (fileName: string) => relative(scopeDir, fileName).charAt(0) !== '.'\n    : () => true;\n  const shouldIgnore = createIgnore(\n    ignoreBaseDir,\n    options.skipIgnore\n      ? []\n      : (options.ignore || ['(?:^|/)node_modules/']).map(\n          (str) => new RegExp(str)\n        )\n  );\n\n  const diagnosticHost: _ts.FormatDiagnosticsHost = {\n    getNewLine: () => ts.sys.newLine,\n    getCurrentDirectory: () => cwd,\n    // TODO switch to getCanonicalFileName we already create later in scope\n    getCanonicalFileName: ts.sys.useCaseSensitiveFileNames\n      ? (x) => x\n      : (x) => x.toLowerCase(),\n  };\n\n  if (options.transpileOnly && typeof transformers === 'function') {\n    throw new TypeError(\n      'Transformers function is unavailable in \"--transpile-only\"'\n    );\n  }\n  let createTranspiler = initializeTranspilerFactory();\n  function initializeTranspilerFactory() {\n    if (transpiler) {\n      if (!transpileOnly)\n        throw new Error(\n          'Custom transpiler can only be used when transpileOnly is enabled.'\n        );\n      const transpilerName =\n        typeof transpiler === 'string' ? transpiler : transpiler[0];\n      const transpilerOptions =\n        typeof transpiler === 'string' ? {} : transpiler[1] ?? {};\n      const transpilerConfigLocalResolveHelper = transpilerBasePath\n        ? createProjectLocalResolveHelper(transpilerBasePath)\n        : projectLocalResolveHelper;\n      const transpilerPath = transpilerConfigLocalResolveHelper(\n        transpilerName,\n        true\n      );\n      const transpilerFactory = require(transpilerPath)\n        .create as TranspilerFactory;\n      return createTranspiler;\n\n      function createTranspiler(\n        compilerOptions: TSCommon.CompilerOptions,\n        nodeModuleEmitKind?: NodeModuleEmitKind\n      ) {\n        return transpilerFactory?.({\n          service: {\n            options,\n            config: {\n              ...config,\n              options: compilerOptions,\n            },\n            projectLocalResolveHelper,\n          },\n          transpilerConfigLocalResolveHelper,\n          nodeModuleEmitKind,\n          ...transpilerOptions,\n        });\n      }\n    }\n  }\n\n  /**\n   * True if require() hooks should interop with experimental ESM loader.\n   * Enabled explicitly via a flag since it is a breaking change.\n   */\n  let experimentalEsmLoader = false;\n  function enableExperimentalEsmLoaderInterop() {\n    experimentalEsmLoader = true;\n  }\n\n  // Install source map support and read from memory cache.\n  installSourceMapSupport();\n  function installSourceMapSupport() {\n    const sourceMapSupport =\n      require('@cspotcode/source-map-support') as typeof _sourceMapSupport;\n    sourceMapSupport.install({\n      environment: 'node',\n      retrieveFile(pathOrUrl: string) {\n        let path = pathOrUrl;\n        // If it's a file URL, convert to local path\n        // Note: fileURLToPath does not exist on early node v10\n        // I could not find a way to handle non-URLs except to swallow an error\n        if (experimentalEsmLoader && path.startsWith('file://')) {\n          try {\n            path = fileURLToPath(path);\n          } catch (e) {\n            /* swallow error */\n          }\n        }\n        path = normalizeSlashes(path);\n        return outputCache.get(path)?.content || '';\n      },\n      redirectConflictingLibrary: true,\n      onConflictingLibraryRedirect(\n        request,\n        parent,\n        isMain,\n        options,\n        redirectedRequest\n      ) {\n        debug(\n          `Redirected an attempt to require source-map-support to instead receive @cspotcode/source-map-support.  \"${\n            (parent as NodeJS.Module).filename\n          }\" attempted to require or resolve \"${request}\" and was redirected to \"${redirectedRequest}\".`\n        );\n      },\n    });\n  }\n\n  const shouldHavePrettyErrors =\n    options.pretty === undefined ? process.stdout.isTTY : options.pretty;\n\n  const formatDiagnostics = shouldHavePrettyErrors\n    ? ts.formatDiagnosticsWithColorAndContext || ts.formatDiagnostics\n    : ts.formatDiagnostics;\n\n  function createTSError(diagnostics: ReadonlyArray<_ts.Diagnostic>) {\n    const diagnosticText = formatDiagnostics(diagnostics, diagnosticHost);\n    const diagnosticCodes = diagnostics.map((x) => x.code);\n    return new TSError(diagnosticText, diagnosticCodes, diagnostics);\n  }\n\n  function reportTSError(configDiagnosticList: _ts.Diagnostic[]) {\n    const error = createTSError(configDiagnosticList);\n    if (options.logError) {\n      // Print error in red color and continue execution.\n      console.error('\\x1b[31m%s\\x1b[0m', error);\n    } else {\n      // Throw error and exit the script.\n      throw error;\n    }\n  }\n\n  // Render the configuration errors.\n  if (configDiagnosticList.length) reportTSError(configDiagnosticList);\n\n  const jsxEmitPreserve = config.options.jsx === ts.JsxEmit.Preserve;\n  /**\n   * Get the extension for a transpiled file.\n   * [MUST_UPDATE_FOR_NEW_FILE_EXTENSIONS]\n   */\n  function getEmitExtension(path: string) {\n    const lastDotIndex = path.lastIndexOf('.');\n    if (lastDotIndex >= 0) {\n      const ext = path.slice(lastDotIndex);\n      switch (ext) {\n        case '.js':\n        case '.ts':\n          return '.js';\n        case '.jsx':\n        case '.tsx':\n          return jsxEmitPreserve ? '.jsx' : '.js';\n        case '.mjs':\n        case '.mts':\n          return '.mjs';\n        case '.cjs':\n        case '.cts':\n          return '.cjs';\n      }\n    }\n    return '.js';\n  }\n\n  type GetOutputFunction = (code: string, fileName: string) => SourceOutput;\n  /**\n   * Get output from TS compiler w/typechecking.  `undefined` in `transpileOnly`\n   * mode.\n   */\n  let getOutput: GetOutputFunction | undefined;\n  let getTypeInfo: (\n    _code: string,\n    _fileName: string,\n    _position: number\n  ) => TypeInfo;\n\n  const getCanonicalFileName = (\n    ts as unknown as TSInternal\n  ).createGetCanonicalFileName(ts.sys.useCaseSensitiveFileNames);\n\n  const moduleTypeClassifier = createModuleTypeClassifier({\n    basePath: options.optionBasePaths?.moduleTypes,\n    patterns: options.moduleTypes,\n  });\n\n  const extensions = getExtensions(config, options, ts.version);\n\n  // Use full language services when the fast option is disabled.\n  if (!transpileOnly) {\n    const fileContents = new Map<string, string>();\n    const rootFileNames = new Set(config.fileNames);\n    const cachedReadFile = cachedLookup(debugFn('readFile', readFile));\n\n    // Use language services by default\n    if (!options.compilerHost) {\n      let projectVersion = 1;\n      const fileVersions = new Map(\n        Array.from(rootFileNames).map((fileName) => [fileName, 0])\n      );\n\n      const getCustomTransformers = () => {\n        if (typeof transformers === 'function') {\n          const program = service.getProgram();\n          return program ? transformers(program) : undefined;\n        }\n\n        return transformers;\n      };\n\n      // Create the compiler host for type checking.\n      const serviceHost: _ts.LanguageServiceHost &\n        Required<Pick<_ts.LanguageServiceHost, 'fileExists' | 'readFile'>> = {\n        getProjectVersion: () => String(projectVersion),\n        getScriptFileNames: () => Array.from(rootFileNames),\n        getScriptVersion: (fileName: string) => {\n          const version = fileVersions.get(fileName);\n          return version ? version.toString() : '';\n        },\n        getScriptSnapshot(fileName: string) {\n          // TODO ordering of this with getScriptVersion?  Should they sync up?\n          let contents = fileContents.get(fileName);\n\n          // Read contents into TypeScript memory cache.\n          if (contents === undefined) {\n            contents = cachedReadFile(fileName);\n            if (contents === undefined) return;\n\n            fileVersions.set(fileName, 1);\n            fileContents.set(fileName, contents);\n            projectVersion++;\n          }\n\n          return ts.ScriptSnapshot.fromString(contents);\n        },\n        readFile: cachedReadFile,\n        readDirectory: ts.sys.readDirectory,\n        getDirectories: cachedLookup(\n          debugFn('getDirectories', ts.sys.getDirectories)\n        ),\n        fileExists: cachedLookup(debugFn('fileExists', fileExists)),\n        directoryExists: cachedLookup(\n          debugFn('directoryExists', ts.sys.directoryExists)\n        ),\n        realpath: ts.sys.realpath\n          ? cachedLookup(debugFn('realpath', ts.sys.realpath))\n          : undefined,\n        getNewLine: () => ts.sys.newLine,\n        useCaseSensitiveFileNames: () => ts.sys.useCaseSensitiveFileNames,\n        getCurrentDirectory: () => cwd,\n        getCompilationSettings: () => config.options,\n        getDefaultLibFileName: () => ts.getDefaultLibFilePath(config.options),\n        getCustomTransformers: getCustomTransformers,\n        trace: options.tsTrace,\n      };\n      const {\n        resolveModuleNames,\n        getResolvedModuleWithFailedLookupLocationsFromCache,\n        resolveTypeReferenceDirectives,\n        isFileKnownToBeInternal,\n        markBucketOfFilenameInternal,\n      } = createResolverFunctions({\n        host: serviceHost,\n        getCanonicalFileName,\n        ts,\n        cwd,\n        config,\n        projectLocalResolveHelper,\n        options,\n        extensions,\n      });\n      serviceHost.resolveModuleNames = resolveModuleNames;\n      serviceHost.getResolvedModuleWithFailedLookupLocationsFromCache =\n        getResolvedModuleWithFailedLookupLocationsFromCache;\n      serviceHost.resolveTypeReferenceDirectives =\n        resolveTypeReferenceDirectives;\n\n      const registry = ts.createDocumentRegistry(\n        ts.sys.useCaseSensitiveFileNames,\n        cwd\n      );\n      const service = ts.createLanguageService(serviceHost, registry);\n\n      const updateMemoryCache = (contents: string, fileName: string) => {\n        // Add to `rootFiles` as necessary, either to make TS include a file it has not seen,\n        // or to trigger a re-classification of files from external to internal.\n        if (\n          !rootFileNames.has(fileName) &&\n          !isFileKnownToBeInternal(fileName)\n        ) {\n          markBucketOfFilenameInternal(fileName);\n          rootFileNames.add(fileName);\n          // Increment project version for every change to rootFileNames.\n          projectVersion++;\n        }\n\n        const previousVersion = fileVersions.get(fileName) || 0;\n        const previousContents = fileContents.get(fileName);\n        // Avoid incrementing cache when nothing has changed.\n        if (contents !== previousContents) {\n          fileVersions.set(fileName, previousVersion + 1);\n          fileContents.set(fileName, contents);\n          // Increment project version for every file change.\n          projectVersion++;\n        }\n      };\n\n      let previousProgram: _ts.Program | undefined = undefined;\n\n      getOutput = (code: string, fileName: string) => {\n        updateMemoryCache(code, fileName);\n\n        const programBefore = service.getProgram();\n        if (programBefore !== previousProgram) {\n          debug(\n            `compiler rebuilt Program instance when getting output for ${fileName}`\n          );\n        }\n\n        const output = service.getEmitOutput(fileName);\n\n        // Get the relevant diagnostics - this is 3x faster than `getPreEmitDiagnostics`.\n        const diagnostics = service\n          .getSemanticDiagnostics(fileName)\n          .concat(service.getSyntacticDiagnostics(fileName));\n\n        const programAfter = service.getProgram();\n\n        debug(\n          'invariant: Is service.getProject() identical before and after getting emit output and diagnostics? (should always be true) ',\n          programBefore === programAfter\n        );\n\n        previousProgram = programAfter;\n\n        const diagnosticList = filterDiagnostics(\n          diagnostics,\n          diagnosticFilters\n        );\n        if (diagnosticList.length) reportTSError(diagnosticList);\n\n        if (output.emitSkipped) {\n          return [undefined, undefined, true];\n        }\n\n        // Throw an error when requiring `.d.ts` files.\n        if (output.outputFiles.length === 0) {\n          throw new TypeError(\n            `Unable to require file: ${relative(cwd, fileName)}\\n` +\n              'This is usually the result of a faulty configuration or import. ' +\n              'Make sure there is a `.js`, `.json` or other executable extension with ' +\n              'loader attached before `ts-node` available.'\n          );\n        }\n\n        return [output.outputFiles[1].text, output.outputFiles[0].text, false];\n      };\n\n      getTypeInfo = (code: string, fileName: string, position: number) => {\n        const normalizedFileName = normalizeSlashes(fileName);\n        updateMemoryCache(code, normalizedFileName);\n\n        const info = service.getQuickInfoAtPosition(\n          normalizedFileName,\n          position\n        );\n        const name = ts.displayPartsToString(info ? info.displayParts : []);\n        const comment = ts.displayPartsToString(info ? info.documentation : []);\n\n        return { name, comment };\n      };\n    } else {\n      const sys: _ts.System & _ts.FormatDiagnosticsHost = {\n        ...ts.sys,\n        ...diagnosticHost,\n        readFile: (fileName: string) => {\n          const cacheContents = fileContents.get(fileName);\n          if (cacheContents !== undefined) return cacheContents;\n          const contents = cachedReadFile(fileName);\n          if (contents) fileContents.set(fileName, contents);\n          return contents;\n        },\n        readDirectory: ts.sys.readDirectory,\n        getDirectories: cachedLookup(\n          debugFn('getDirectories', ts.sys.getDirectories)\n        ),\n        fileExists: cachedLookup(debugFn('fileExists', fileExists)),\n        directoryExists: cachedLookup(\n          debugFn('directoryExists', ts.sys.directoryExists)\n        ),\n        resolvePath: cachedLookup(debugFn('resolvePath', ts.sys.resolvePath)),\n        realpath: ts.sys.realpath\n          ? cachedLookup(debugFn('realpath', ts.sys.realpath))\n          : undefined,\n      };\n\n      const host: _ts.CompilerHost = ts.createIncrementalCompilerHost\n        ? ts.createIncrementalCompilerHost(config.options, sys)\n        : {\n            ...sys,\n            getSourceFile: (fileName, languageVersion) => {\n              const contents = sys.readFile(fileName);\n              if (contents === undefined) return;\n              return ts.createSourceFile(fileName, contents, languageVersion);\n            },\n            getDefaultLibLocation: () => normalizeSlashes(dirname(compiler)),\n            getDefaultLibFileName: () =>\n              normalizeSlashes(\n                join(\n                  dirname(compiler),\n                  ts.getDefaultLibFileName(config.options)\n                )\n              ),\n            useCaseSensitiveFileNames: () => sys.useCaseSensitiveFileNames,\n          };\n      host.trace = options.tsTrace;\n      const {\n        resolveModuleNames,\n        resolveTypeReferenceDirectives,\n        isFileKnownToBeInternal,\n        markBucketOfFilenameInternal,\n      } = createResolverFunctions({\n        host,\n        cwd,\n        config,\n        ts,\n        getCanonicalFileName,\n        projectLocalResolveHelper,\n        options,\n        extensions,\n      });\n      host.resolveModuleNames = resolveModuleNames;\n      host.resolveTypeReferenceDirectives = resolveTypeReferenceDirectives;\n\n      // Fallback for older TypeScript releases without incremental API.\n      let builderProgram = ts.createIncrementalProgram\n        ? ts.createIncrementalProgram({\n            rootNames: Array.from(rootFileNames),\n            options: config.options,\n            host,\n            configFileParsingDiagnostics: config.errors,\n            projectReferences: config.projectReferences,\n          })\n        : ts.createEmitAndSemanticDiagnosticsBuilderProgram(\n            Array.from(rootFileNames),\n            config.options,\n            host,\n            undefined,\n            config.errors,\n            config.projectReferences\n          );\n\n      // Read and cache custom transformers.\n      const customTransformers =\n        typeof transformers === 'function'\n          ? transformers(builderProgram.getProgram())\n          : transformers;\n\n      // Set the file contents into cache manually.\n      const updateMemoryCache = (contents: string, fileName: string) => {\n        const previousContents = fileContents.get(fileName);\n        const contentsChanged = previousContents !== contents;\n        if (contentsChanged) {\n          fileContents.set(fileName, contents);\n        }\n\n        // Add to `rootFiles` when discovered by compiler for the first time.\n        let addedToRootFileNames = false;\n        if (\n          !rootFileNames.has(fileName) &&\n          !isFileKnownToBeInternal(fileName)\n        ) {\n          markBucketOfFilenameInternal(fileName);\n          rootFileNames.add(fileName);\n          addedToRootFileNames = true;\n        }\n\n        // Update program when file changes.\n        if (addedToRootFileNames || contentsChanged) {\n          builderProgram = ts.createEmitAndSemanticDiagnosticsBuilderProgram(\n            Array.from(rootFileNames),\n            config.options,\n            host,\n            builderProgram,\n            config.errors,\n            config.projectReferences\n          );\n        }\n      };\n\n      getOutput = (code: string, fileName: string) => {\n        let outText = '';\n        let outMap = '';\n\n        updateMemoryCache(code, fileName);\n\n        const sourceFile = builderProgram.getSourceFile(fileName);\n        if (!sourceFile)\n          throw new TypeError(`Unable to read file: ${fileName}`);\n\n        const program = builderProgram.getProgram();\n        const diagnostics = ts.getPreEmitDiagnostics(program, sourceFile);\n        const diagnosticList = filterDiagnostics(\n          diagnostics,\n          diagnosticFilters\n        );\n        if (diagnosticList.length) reportTSError(diagnosticList);\n\n        const result = builderProgram.emit(\n          sourceFile,\n          (path, file, writeByteOrderMark) => {\n            if (path.endsWith('.map')) {\n              outMap = file;\n            } else {\n              outText = file;\n            }\n\n            if (options.emit) sys.writeFile(path, file, writeByteOrderMark);\n          },\n          undefined,\n          undefined,\n          customTransformers\n        );\n\n        if (result.emitSkipped) {\n          return [undefined, undefined, true];\n        }\n\n        // Throw an error when requiring files that cannot be compiled.\n        if (outText === '') {\n          if (program.isSourceFileFromExternalLibrary(sourceFile)) {\n            throw new TypeError(\n              `Unable to compile file from external library: ${relative(\n                cwd,\n                fileName\n              )}`\n            );\n          }\n\n          throw new TypeError(\n            `Unable to require file: ${relative(cwd, fileName)}\\n` +\n              'This is usually the result of a faulty configuration or import. ' +\n              'Make sure there is a `.js`, `.json` or other executable extension with ' +\n              'loader attached before `ts-node` available.'\n          );\n        }\n\n        return [outText, outMap, false];\n      };\n\n      getTypeInfo = (code: string, fileName: string, position: number) => {\n        const normalizedFileName = normalizeSlashes(fileName);\n        updateMemoryCache(code, normalizedFileName);\n\n        const sourceFile = builderProgram.getSourceFile(normalizedFileName);\n        if (!sourceFile)\n          throw new TypeError(`Unable to read file: ${fileName}`);\n\n        const node = getTokenAtPosition(ts, sourceFile, position);\n        const checker = builderProgram.getProgram().getTypeChecker();\n        const symbol = checker.getSymbolAtLocation(node);\n\n        if (!symbol) return { name: '', comment: '' };\n\n        const type = checker.getTypeOfSymbolAtLocation(symbol, node);\n        const signatures = [\n          ...type.getConstructSignatures(),\n          ...type.getCallSignatures(),\n        ];\n\n        return {\n          name: signatures.length\n            ? signatures.map((x) => checker.signatureToString(x)).join('\\n')\n            : checker.typeToString(type),\n          comment: ts.displayPartsToString(\n            symbol ? symbol.getDocumentationComment(checker) : []\n          ),\n        };\n      };\n\n      // Write `.tsbuildinfo` when `--build` is enabled.\n      if (options.emit && config.options.incremental) {\n        process.on('exit', () => {\n          // Emits `.tsbuildinfo` to filesystem.\n          (builderProgram.getProgram() as any).emitBuildInfo();\n        });\n      }\n    }\n  } else {\n    getTypeInfo = () => {\n      throw new TypeError(\n        'Type information is unavailable in \"--transpile-only\"'\n      );\n    };\n  }\n\n  function createTranspileOnlyGetOutputFunction(\n    overrideModuleType?: _ts.ModuleKind,\n    nodeModuleEmitKind?: NodeModuleEmitKind\n  ): GetOutputFunction {\n    const compilerOptions = { ...config.options };\n    if (overrideModuleType !== undefined)\n      compilerOptions.module = overrideModuleType;\n    let customTranspiler = createTranspiler?.(\n      compilerOptions,\n      nodeModuleEmitKind\n    );\n    let tsTranspileModule = versionGteLt(ts.version, '4.7.0')\n      ? createTsTranspileModule(ts, {\n          compilerOptions,\n          reportDiagnostics: true,\n          transformers: transformers as _ts.CustomTransformers | undefined,\n        })\n      : undefined;\n    return (code: string, fileName: string): SourceOutput => {\n      let result: _ts.TranspileOutput;\n      if (customTranspiler) {\n        result = customTranspiler.transpile(code, {\n          fileName,\n        });\n      } else if (tsTranspileModule) {\n        result = tsTranspileModule(\n          code,\n          {\n            fileName,\n          },\n          nodeModuleEmitKind === 'nodeesm' ? 'module' : 'commonjs'\n        );\n      } else {\n        result = ts.transpileModule(code, {\n          fileName,\n          compilerOptions,\n          reportDiagnostics: true,\n          transformers: transformers as _ts.CustomTransformers | undefined,\n        });\n      }\n\n      const diagnosticList = filterDiagnostics(\n        result.diagnostics || [],\n        diagnosticFilters\n      );\n      if (diagnosticList.length) reportTSError(diagnosticList);\n\n      return [result.outputText, result.sourceMapText as string, false];\n    };\n  }\n\n  // When true, these mean that a `moduleType` override will cause a different emit\n  // than the TypeScript compiler, so we *must* overwrite the emit.\n  const shouldOverwriteEmitWhenForcingCommonJS =\n    config.options.module !== ts.ModuleKind.CommonJS;\n  // [MUST_UPDATE_FOR_NEW_MODULEKIND]\n  const shouldOverwriteEmitWhenForcingEsm = !(\n    config.options.module === ts.ModuleKind.ES2015 ||\n    (ts.ModuleKind.ES2020 && config.options.module === ts.ModuleKind.ES2020) ||\n    (ts.ModuleKind.ES2022 && config.options.module === ts.ModuleKind.ES2022) ||\n    config.options.module === ts.ModuleKind.ESNext\n  );\n  /**\n   * node16 or nodenext\n   * [MUST_UPDATE_FOR_NEW_MODULEKIND]\n   */\n  const isNodeModuleType =\n    (ts.ModuleKind.Node16 && config.options.module === ts.ModuleKind.Node16) ||\n    (ts.ModuleKind.NodeNext &&\n      config.options.module === ts.ModuleKind.NodeNext);\n  const getOutputForceCommonJS = createTranspileOnlyGetOutputFunction(\n    ts.ModuleKind.CommonJS\n  );\n  const getOutputForceNodeCommonJS = createTranspileOnlyGetOutputFunction(\n    ts.ModuleKind.NodeNext,\n    'nodecjs'\n  );\n  const getOutputForceNodeESM = createTranspileOnlyGetOutputFunction(\n    ts.ModuleKind.NodeNext,\n    'nodeesm'\n  );\n  // [MUST_UPDATE_FOR_NEW_MODULEKIND]\n  const getOutputForceESM = createTranspileOnlyGetOutputFunction(\n    ts.ModuleKind.ES2022 || ts.ModuleKind.ES2020 || ts.ModuleKind.ES2015\n  );\n  const getOutputTranspileOnly = createTranspileOnlyGetOutputFunction();\n\n  // Create a simple TypeScript compiler proxy.\n  function compile(code: string, fileName: string, lineOffset = 0) {\n    const normalizedFileName = normalizeSlashes(fileName);\n    const classification =\n      moduleTypeClassifier.classifyModuleByModuleTypeOverrides(\n        normalizedFileName\n      );\n    let value: string | undefined = '';\n    let sourceMap: string | undefined = '';\n    let emitSkipped = true;\n    if (getOutput) {\n      // Must always call normal getOutput to throw typechecking errors\n      [value, sourceMap, emitSkipped] = getOutput(code, normalizedFileName);\n    }\n    // If module classification contradicts the above, call the relevant transpiler\n    if (\n      classification.moduleType === 'cjs' &&\n      (shouldOverwriteEmitWhenForcingCommonJS || emitSkipped)\n    ) {\n      [value, sourceMap] = getOutputForceCommonJS(code, normalizedFileName);\n    } else if (\n      classification.moduleType === 'esm' &&\n      (shouldOverwriteEmitWhenForcingEsm || emitSkipped)\n    ) {\n      [value, sourceMap] = getOutputForceESM(code, normalizedFileName);\n    } else if (emitSkipped) {\n      // Happens when ts compiler skips emit or in transpileOnly mode\n      const classification = classifyModule(fileName, isNodeModuleType);\n      [value, sourceMap] =\n        classification === 'nodecjs'\n          ? getOutputForceNodeCommonJS(code, normalizedFileName)\n          : classification === 'nodeesm'\n          ? getOutputForceNodeESM(code, normalizedFileName)\n          : classification === 'cjs'\n          ? getOutputForceCommonJS(code, normalizedFileName)\n          : classification === 'esm'\n          ? getOutputForceESM(code, normalizedFileName)\n          : getOutputTranspileOnly(code, normalizedFileName);\n    }\n    const output = updateOutput(\n      value!,\n      normalizedFileName,\n      sourceMap!,\n      getEmitExtension\n    );\n    outputCache.set(normalizedFileName, { content: output });\n    return output;\n  }\n\n  let active = true;\n  const enabled = (enabled?: boolean) =>\n    enabled === undefined ? active : (active = !!enabled);\n  const ignored = (fileName: string) => {\n    if (!active) return true;\n    const ext = extname(fileName);\n    if (extensions.compiled.includes(ext)) {\n      return !isScoped(fileName) || shouldIgnore(fileName);\n    }\n    return true;\n  };\n\n  function addDiagnosticFilter(filter: DiagnosticFilter) {\n    diagnosticFilters.push({\n      ...filter,\n      filenamesAbsolute: filter.filenamesAbsolute.map((f) =>\n        normalizeSlashes(f)\n      ),\n    });\n  }\n\n  const getNodeEsmResolver = once(() =>\n    (\n      require('../dist-raw/node-internal-modules-esm-resolve') as typeof _nodeInternalModulesEsmResolve\n    ).createResolve({\n      extensions,\n      preferTsExts: options.preferTsExts,\n      tsNodeExperimentalSpecifierResolution:\n        options.experimentalSpecifierResolution,\n    })\n  );\n  const getNodeEsmGetFormat = once(() =>\n    (\n      require('../dist-raw/node-internal-modules-esm-get_format') as typeof _nodeInternalModulesEsmGetFormat\n    ).createGetFormat(\n      options.experimentalSpecifierResolution,\n      getNodeEsmResolver()\n    )\n  );\n  const getNodeCjsLoader = once(() =>\n    (\n      require('../dist-raw/node-internal-modules-cjs-loader') as typeof _nodeInternalModulesCjsLoader\n    ).createCjsLoader({\n      extensions,\n      preferTsExts: options.preferTsExts,\n      nodeEsmResolver: getNodeEsmResolver(),\n    })\n  );\n\n  return {\n    [TS_NODE_SERVICE_BRAND]: true,\n    ts,\n    compilerPath: compiler,\n    config,\n    compile,\n    getTypeInfo,\n    ignored,\n    enabled,\n    options,\n    configFilePath,\n    moduleTypeClassifier,\n    shouldReplAwait,\n    addDiagnosticFilter,\n    installSourceMapSupport,\n    enableExperimentalEsmLoaderInterop,\n    transpileOnly,\n    projectLocalResolveHelper,\n    getNodeEsmResolver,\n    getNodeEsmGetFormat,\n    getNodeCjsLoader,\n    extensions,\n  };\n}\n\n/**\n * Check if the filename should be ignored.\n */\nfunction createIgnore(ignoreBaseDir: string, ignore: RegExp[]) {\n  return (fileName: string) => {\n    const relname = relative(ignoreBaseDir, fileName);\n    const path = normalizeSlashes(relname);\n\n    return ignore.some((x) => x.test(path));\n  };\n}\n\n/**\n * Register the extensions to support when importing files.\n */\nfunction registerExtensions(\n  preferTsExts: boolean | null | undefined,\n  extensions: string[],\n  service: Service,\n  originalJsHandler: (m: NodeModule, filename: string) => any\n) {\n  const exts = new Set(extensions);\n  // Can't add these extensions cuz would allow omitting file extension; node requires ext for .cjs and .mjs\n  // Unless they're already registered by something else (nyc does this):\n  // then we *must* hook them or else our transformer will not be called.\n  for (const cannotAdd of ['.mts', '.cts', '.mjs', '.cjs']) {\n    if (exts.has(cannotAdd) && !hasOwnProperty(require.extensions, cannotAdd)) {\n      // Unrecognized file exts can be transformed via the `.js` handler.\n      exts.add('.js');\n      exts.delete(cannotAdd);\n    }\n  }\n\n  // Register new extensions.\n  for (const ext of exts) {\n    registerExtension(ext, service, originalJsHandler);\n  }\n\n  if (preferTsExts) {\n    const preferredExtensions = new Set([\n      ...exts,\n      ...Object.keys(require.extensions),\n    ]);\n\n    // Re-sort iteration order of Object.keys()\n    for (const ext of preferredExtensions) {\n      const old = Object.getOwnPropertyDescriptor(require.extensions, ext);\n      delete require.extensions[ext];\n      Object.defineProperty(require.extensions, ext, old!);\n    }\n  }\n}\n\n/**\n * Register the extension for node.\n */\nfunction registerExtension(\n  ext: string,\n  service: Service,\n  originalHandler: (m: NodeModule, filename: string) => any\n) {\n  const old = require.extensions[ext] || originalHandler;\n\n  require.extensions[ext] = function (m: any, filename) {\n    if (service.ignored(filename)) return old(m, filename);\n\n    assertScriptCanLoadAsCJS(service, m, filename);\n\n    const _compile = m._compile;\n\n    m._compile = function (code: string, fileName: string) {\n      debug('module._compile', fileName);\n\n      const result = service.compile(code, fileName);\n      return _compile.call(this, result, fileName);\n    };\n\n    return old(m, filename);\n  };\n}\n\n/**\n * Internal source output.\n */\ntype SourceOutput = [string, string, false] | [undefined, undefined, true];\n\n/**\n * Update the output remapping the source map.\n */\nfunction updateOutput(\n  outputText: string,\n  fileName: string,\n  sourceMap: string,\n  getEmitExtension: (fileName: string) => string\n) {\n  const base64Map = Buffer.from(\n    updateSourceMap(sourceMap, fileName),\n    'utf8'\n  ).toString('base64');\n  const sourceMapContent = `//# sourceMappingURL=data:application/json;charset=utf-8;base64,${base64Map}`;\n  // Expected form: `//# sourceMappingURL=foo bar.js.map` or `//# sourceMappingURL=foo%20bar.js.map` for input file \"foo bar.tsx\"\n  // Percent-encoding behavior added in TS 4.1.1: https://github.com/microsoft/TypeScript/issues/40951\n  const prefix = '//# sourceMappingURL=';\n  const prefixLength = prefix.length;\n  const baseName = /*foo.tsx*/ basename(fileName);\n  const extName = /*.tsx*/ extname(fileName);\n  const extension = /*.js*/ getEmitExtension(fileName);\n  const sourcemapFilename =\n    baseName.slice(0, -extName.length) + extension + '.map';\n  const sourceMapLengthWithoutPercentEncoding =\n    prefixLength + sourcemapFilename.length;\n  /*\n   * Only rewrite if existing directive exists at the location we expect, to support:\n   *   a) compilers that do not append a sourcemap directive\n   *   b) situations where we did the math wrong\n   *     Not ideal, but appending our sourcemap *after* a pre-existing sourcemap still overrides, so the end-user is happy.\n   */\n  if (\n    outputText.substr(-sourceMapLengthWithoutPercentEncoding, prefixLength) ===\n    prefix\n  ) {\n    return (\n      outputText.slice(0, -sourceMapLengthWithoutPercentEncoding) +\n      sourceMapContent\n    );\n  }\n  // If anyone asks why we're not using URL, the URL equivalent is: `u = new URL('http://d'); u.pathname = \"/\" + sourcemapFilename; return u.pathname.slice(1);\n  const sourceMapLengthWithPercentEncoding =\n    prefixLength + encodeURI(sourcemapFilename).length;\n  if (\n    outputText.substr(-sourceMapLengthWithPercentEncoding, prefixLength) ===\n    prefix\n  ) {\n    return (\n      outputText.slice(0, -sourceMapLengthWithPercentEncoding) +\n      sourceMapContent\n    );\n  }\n\n  return `${outputText}\\n${sourceMapContent}`;\n}\n\n/**\n * Update the source map contents for improved output.\n */\nfunction updateSourceMap(sourceMapText: string, fileName: string) {\n  const sourceMap = JSON.parse(sourceMapText);\n  sourceMap.file = fileName;\n  sourceMap.sources = [fileName];\n  delete sourceMap.sourceRoot;\n  return JSON.stringify(sourceMap);\n}\n\n/**\n * Filter diagnostics.\n */\nfunction filterDiagnostics(\n  diagnostics: readonly _ts.Diagnostic[],\n  filters: DiagnosticFilter[]\n) {\n  return diagnostics.filter((d) =>\n    filters.every(\n      (f) =>\n        (!f.appliesToAllFiles &&\n          f.filenamesAbsolute.indexOf(d.file?.fileName!) === -1) ||\n        f.diagnosticsIgnored.indexOf(d.code) === -1\n    )\n  );\n}\n\n/**\n * Get token at file position.\n *\n * Reference: https://github.com/microsoft/TypeScript/blob/fcd9334f57d85b73dd66ad2d21c02e84822f4841/src/services/utilities.ts#L705-L731\n */\nfunction getTokenAtPosition(\n  ts: TSCommon,\n  sourceFile: _ts.SourceFile,\n  position: number\n): _ts.Node {\n  let current: _ts.Node = sourceFile;\n\n  outer: while (true) {\n    for (const child of current.getChildren(sourceFile)) {\n      const start = child.getFullStart();\n      if (start > position) break;\n\n      const end = child.getEnd();\n      if (position <= end) {\n        current = child;\n        continue outer;\n      }\n    }\n\n    return current;\n  }\n}\n\n/**\n * Create an implementation of node's ESM loader hooks.\n *\n * This may be useful if you\n * want to wrap or compose the loader hooks to add additional functionality or\n * combine with another loader.\n *\n * Node changed the hooks API, so there are two possible APIs.  This function\n * detects your node version and returns the appropriate API.\n *\n * @category ESM Loader\n */\nexport const createEsmHooks: typeof createEsmHooksFn = (\n  tsNodeService: Service\n) => (require('./esm') as typeof import('./esm')).createEsmHooks(tsNodeService);\n\n/**\n * When using `module: nodenext` or `module: node12`, there are two possible styles of emit depending in file extension or package.json \"type\":\n *\n * - CommonJS with dynamic imports preserved (not transformed into `require()` calls)\n * - ECMAScript modules with `import foo = require()` transformed into `require = createRequire(); const foo = require()`\n */\nexport type NodeModuleEmitKind = 'nodeesm' | 'nodecjs';\n"]},"metadata":{},"sourceType":"script","externalDependencies":[]}