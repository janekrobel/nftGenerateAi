{"ast":null,"code":"import { __assign, __extends } from \"tslib\";\nimport { BaseBackend, getCurrentHub } from '@sentry/core';\nimport { Severity } from '@sentry/types';\nimport { addExceptionMechanism, addExceptionTypeValue, Dsn, extractExceptionKeysForMessage, isError, isPlainObject, normalizeToSize, SyncPromise } from '@sentry/utils';\nimport { extractStackFromError, parseError, parseStack, prepareFramesForEvent } from './parsers';\nimport { HTTPSTransport, HTTPTransport } from './transports';\n/**\n * The Sentry Node SDK Backend.\n * @hidden\n */\nvar NodeBackend = /** @class */function (_super) {\n  __extends(NodeBackend, _super);\n  function NodeBackend() {\n    return _super !== null && _super.apply(this, arguments) || this;\n  }\n  /**\n   * @inheritDoc\n   */\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any, @typescript-eslint/explicit-module-boundary-types\n  NodeBackend.prototype.eventFromException = function (exception, hint) {\n    var _this = this;\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    var ex = exception;\n    var mechanism = {\n      handled: true,\n      type: 'generic'\n    };\n    if (!isError(exception)) {\n      if (isPlainObject(exception)) {\n        // This will allow us to group events based on top-level keys\n        // which is much better than creating new group when any key/value change\n        var message = \"Non-Error exception captured with keys: \" + extractExceptionKeysForMessage(exception);\n        getCurrentHub().configureScope(function (scope) {\n          scope.setExtra('__serialized__', normalizeToSize(exception));\n        });\n        ex = hint && hint.syntheticException || new Error(message);\n        ex.message = message;\n      } else {\n        // This handles when someone does: `throw \"something awesome\";`\n        // We use synthesized Error here so we can extract a (rough) stack trace.\n        ex = hint && hint.syntheticException || new Error(exception);\n        ex.message = exception;\n      }\n      mechanism.synthetic = true;\n    }\n    return new SyncPromise(function (resolve, reject) {\n      return parseError(ex, _this._options).then(function (event) {\n        addExceptionTypeValue(event, undefined, undefined);\n        addExceptionMechanism(event, mechanism);\n        resolve(__assign(__assign({}, event), {\n          event_id: hint && hint.event_id\n        }));\n      }).then(null, reject);\n    });\n  };\n  /**\n   * @inheritDoc\n   */\n  NodeBackend.prototype.eventFromMessage = function (message, level, hint) {\n    var _this = this;\n    if (level === void 0) {\n      level = Severity.Info;\n    }\n    var event = {\n      event_id: hint && hint.event_id,\n      level: level,\n      message: message\n    };\n    return new SyncPromise(function (resolve) {\n      if (_this._options.attachStacktrace && hint && hint.syntheticException) {\n        var stack = hint.syntheticException ? extractStackFromError(hint.syntheticException) : [];\n        parseStack(stack, _this._options).then(function (frames) {\n          event.stacktrace = {\n            frames: prepareFramesForEvent(frames)\n          };\n          resolve(event);\n        }).then(null, function () {\n          resolve(event);\n        });\n      } else {\n        resolve(event);\n      }\n    });\n  };\n  /**\n   * @inheritDoc\n   */\n  NodeBackend.prototype._setupTransport = function () {\n    if (!this._options.dsn) {\n      // We return the noop transport here in case there is no Dsn.\n      return _super.prototype._setupTransport.call(this);\n    }\n    var dsn = new Dsn(this._options.dsn);\n    var transportOptions = __assign(__assign(__assign(__assign(__assign({}, this._options.transportOptions), this._options.httpProxy && {\n      httpProxy: this._options.httpProxy\n    }), this._options.httpsProxy && {\n      httpsProxy: this._options.httpsProxy\n    }), this._options.caCerts && {\n      caCerts: this._options.caCerts\n    }), {\n      dsn: this._options.dsn\n    });\n    if (this._options.transport) {\n      return new this._options.transport(transportOptions);\n    }\n    if (dsn.protocol === 'http') {\n      return new HTTPTransport(transportOptions);\n    }\n    return new HTTPSTransport(transportOptions);\n  };\n  return NodeBackend;\n}(BaseBackend);\nexport { NodeBackend };","map":{"version":3,"mappings":";AAAA,SAASA,WAAW,EAAEC,aAAa,QAAQ,cAAc;AACzD,SAA+CC,QAAQ,QAAqC,eAAe;AAC3G,SACEC,qBAAqB,EACrBC,qBAAqB,EACrBC,GAAG,EACHC,8BAA8B,EAC9BC,OAAO,EACPC,aAAa,EACbC,eAAe,EACfC,WAAW,QACN,eAAe;AAEtB,SAASC,qBAAqB,EAAEC,UAAU,EAAEC,UAAU,EAAEC,qBAAqB,QAAQ,WAAW;AAChG,SAASC,cAAc,EAAEC,aAAa,QAAQ,cAAc;AA6B5D;;;;AAIA;EAAiCC;EAAjC;;EAyGA;EAxGE;;;EAGA;EACOC,wCAAkB,GAAzB,UAA0BC,SAAc,EAAEC,IAAgB;IAA1D;IACE;IACA,IAAIC,EAAE,GAAQF,SAAS;IACvB,IAAMG,SAAS,GAAc;MAC3BC,OAAO,EAAE,IAAI;MACbC,IAAI,EAAE;KACP;IAED,IAAI,CAACjB,OAAO,CAACY,SAAS,CAAC,EAAE;MACvB,IAAIX,aAAa,CAACW,SAAS,CAAC,EAAE;QAC5B;QACA;QACA,IAAMM,OAAO,GAAG,6CAA2CnB,8BAA8B,CAACa,SAAS,CAAG;QAEtGlB,aAAa,EAAE,CAACyB,cAAc,CAAC,eAAK;UAClCC,KAAK,CAACC,QAAQ,CAAC,gBAAgB,EAAEnB,eAAe,CAACU,SAAoC,CAAC,CAAC;QACzF,CAAC,CAAC;QAEFE,EAAE,GAAID,IAAI,IAAIA,IAAI,CAACS,kBAAkB,IAAK,IAAIC,KAAK,CAACL,OAAO,CAAC;QAC3DJ,EAAY,CAACI,OAAO,GAAGA,OAAO;OAChC,MAAM;QACL;QACA;QACAJ,EAAE,GAAID,IAAI,IAAIA,IAAI,CAACS,kBAAkB,IAAK,IAAIC,KAAK,CAACX,SAAmB,CAAC;QACvEE,EAAY,CAACI,OAAO,GAAGN,SAAS;;MAEnCG,SAAS,CAACS,SAAS,GAAG,IAAI;;IAG5B,OAAO,IAAIrB,WAAW,CAAQ,UAACsB,OAAO,EAAEC,MAAM;MAC5C,iBAAU,CAACZ,EAAW,EAAEa,KAAI,CAACC,QAAQ,CAAC,CACnCC,IAAI,CAAC,eAAK;QACThC,qBAAqB,CAACiC,KAAK,EAAEC,SAAS,EAAEA,SAAS,CAAC;QAClDnC,qBAAqB,CAACkC,KAAK,EAAEf,SAAS,CAAC;QAEvCU,OAAO,uBACFK,KAAK;UACRE,QAAQ,EAAEnB,IAAI,IAAIA,IAAI,CAACmB;QAAQ,GAC/B;MACJ,CAAC,CAAC,CACDH,IAAI,CAAC,IAAI,EAAEH,MAAM,CAAC;IAVrB,CAUqB,CACtB;EACH,CAAC;EAED;;;EAGOf,sCAAgB,GAAvB,UAAwBO,OAAe,EAAEe,KAA+B,EAAEpB,IAAgB;IAA1F;IAAyC;MAAAoB,QAAkBtC,QAAQ,CAACuC,IAAI;IAAA;IACtE,IAAMJ,KAAK,GAAU;MACnBE,QAAQ,EAAEnB,IAAI,IAAIA,IAAI,CAACmB,QAAQ;MAC/BC,KAAK;MACLf,OAAO;KACR;IAED,OAAO,IAAIf,WAAW,CAAQ,iBAAO;MACnC,IAAIwB,KAAI,CAACC,QAAQ,CAACO,gBAAgB,IAAItB,IAAI,IAAIA,IAAI,CAACS,kBAAkB,EAAE;QACrE,IAAMc,KAAK,GAAGvB,IAAI,CAACS,kBAAkB,GAAGlB,qBAAqB,CAACS,IAAI,CAACS,kBAAkB,CAAC,GAAG,EAAE;QAC3FhB,UAAU,CAAC8B,KAAK,EAAET,KAAI,CAACC,QAAQ,CAAC,CAC7BC,IAAI,CAAC,gBAAM;UACVC,KAAK,CAACO,UAAU,GAAG;YACjBC,MAAM,EAAE/B,qBAAqB,CAAC+B,MAAM;WACrC;UACDb,OAAO,CAACK,KAAK,CAAC;QAChB,CAAC,CAAC,CACDD,IAAI,CAAC,IAAI,EAAE;UACVJ,OAAO,CAACK,KAAK,CAAC;QAChB,CAAC,CAAC;OACL,MAAM;QACLL,OAAO,CAACK,KAAK,CAAC;;IAElB,CAAC,CAAC;EACJ,CAAC;EAED;;;EAGUnB,qCAAe,GAAzB;IACE,IAAI,CAAC,IAAI,CAACiB,QAAQ,CAACW,GAAG,EAAE;MACtB;MACA,OAAOC,iBAAMC,eAAe,WAAE;;IAGhC,IAAMF,GAAG,GAAG,IAAIzC,GAAG,CAAC,IAAI,CAAC8B,QAAQ,CAACW,GAAG,CAAC;IAEtC,IAAMG,gBAAgB,oDACjB,IAAI,CAACd,QAAQ,CAACc,gBAAgB,GAC7B,IAAI,CAACd,QAAQ,CAACe,SAAS,IAAI;MAAEA,SAAS,EAAE,IAAI,CAACf,QAAQ,CAACe;IAAS,CAAE,CAAC,EAClE,IAAI,CAACf,QAAQ,CAACgB,UAAU,IAAI;MAAEA,UAAU,EAAE,IAAI,CAAChB,QAAQ,CAACgB;IAAU,CAAE,CAAC,EACrE,IAAI,CAAChB,QAAQ,CAACiB,OAAO,IAAI;MAAEA,OAAO,EAAE,IAAI,CAACjB,QAAQ,CAACiB;IAAO,CAAE,CAAC;MAChEN,GAAG,EAAE,IAAI,CAACX,QAAQ,CAACW;IAAG,EACvB;IAED,IAAI,IAAI,CAACX,QAAQ,CAACkB,SAAS,EAAE;MAC3B,OAAO,IAAI,IAAI,CAAClB,QAAQ,CAACkB,SAAS,CAACJ,gBAAgB,CAAC;;IAEtD,IAAIH,GAAG,CAACQ,QAAQ,KAAK,MAAM,EAAE;MAC3B,OAAO,IAAItC,aAAa,CAACiC,gBAAgB,CAAC;;IAE5C,OAAO,IAAIlC,cAAc,CAACkC,gBAAgB,CAAC;EAC7C,CAAC;EACH,kBAAC;AAAD,CAAC,CAzGgCjD,WAAW","names":["BaseBackend","getCurrentHub","Severity","addExceptionMechanism","addExceptionTypeValue","Dsn","extractExceptionKeysForMessage","isError","isPlainObject","normalizeToSize","SyncPromise","extractStackFromError","parseError","parseStack","prepareFramesForEvent","HTTPSTransport","HTTPTransport","__extends","NodeBackend","exception","hint","ex","mechanism","handled","type","message","configureScope","scope","setExtra","syntheticException","Error","synthetic","resolve","reject","_this","_options","then","event","undefined","event_id","level","Info","attachStacktrace","stack","stacktrace","frames","dsn","_super","_setupTransport","transportOptions","httpProxy","httpsProxy","caCerts","transport","protocol"],"sources":["/Users/janrobel/Documents/PersonalProjekty/nftGenerateAi/clientAndContract/node_modules/@sentry/node/src/backend.ts"],"sourcesContent":["import { BaseBackend, getCurrentHub } from '@sentry/core';\nimport { Event, EventHint, Mechanism, Options, Severity, Transport, TransportOptions } from '@sentry/types';\nimport {\n  addExceptionMechanism,\n  addExceptionTypeValue,\n  Dsn,\n  extractExceptionKeysForMessage,\n  isError,\n  isPlainObject,\n  normalizeToSize,\n  SyncPromise,\n} from '@sentry/utils';\n\nimport { extractStackFromError, parseError, parseStack, prepareFramesForEvent } from './parsers';\nimport { HTTPSTransport, HTTPTransport } from './transports';\n\n/**\n * Configuration options for the Sentry Node SDK.\n * @see NodeClient for more information.\n */\nexport interface NodeOptions extends Options {\n  /** Sets an optional server name (device name) */\n  serverName?: string;\n\n  /** Maximum time in milliseconds to wait to drain the request queue, before the process is allowed to exit. */\n  shutdownTimeout?: number;\n\n  /** Set a HTTP proxy that should be used for outbound requests. */\n  httpProxy?: string;\n\n  /** Set a HTTPS proxy that should be used for outbound requests. */\n  httpsProxy?: string;\n\n  /** HTTPS proxy certificates path */\n  caCerts?: string;\n\n  /** Sets the number of context lines for each frame when loading a file. */\n  frameContextLines?: number;\n\n  /** Callback that is executed when a fatal global error occurs. */\n  onFatalError?(error: Error): void;\n}\n\n/**\n * The Sentry Node SDK Backend.\n * @hidden\n */\nexport class NodeBackend extends BaseBackend<NodeOptions> {\n  /**\n   * @inheritDoc\n   */\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any, @typescript-eslint/explicit-module-boundary-types\n  public eventFromException(exception: any, hint?: EventHint): PromiseLike<Event> {\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    let ex: any = exception;\n    const mechanism: Mechanism = {\n      handled: true,\n      type: 'generic',\n    };\n\n    if (!isError(exception)) {\n      if (isPlainObject(exception)) {\n        // This will allow us to group events based on top-level keys\n        // which is much better than creating new group when any key/value change\n        const message = `Non-Error exception captured with keys: ${extractExceptionKeysForMessage(exception)}`;\n\n        getCurrentHub().configureScope(scope => {\n          scope.setExtra('__serialized__', normalizeToSize(exception as Record<string, unknown>));\n        });\n\n        ex = (hint && hint.syntheticException) || new Error(message);\n        (ex as Error).message = message;\n      } else {\n        // This handles when someone does: `throw \"something awesome\";`\n        // We use synthesized Error here so we can extract a (rough) stack trace.\n        ex = (hint && hint.syntheticException) || new Error(exception as string);\n        (ex as Error).message = exception;\n      }\n      mechanism.synthetic = true;\n    }\n\n    return new SyncPromise<Event>((resolve, reject) =>\n      parseError(ex as Error, this._options)\n        .then(event => {\n          addExceptionTypeValue(event, undefined, undefined);\n          addExceptionMechanism(event, mechanism);\n\n          resolve({\n            ...event,\n            event_id: hint && hint.event_id,\n          });\n        })\n        .then(null, reject),\n    );\n  }\n\n  /**\n   * @inheritDoc\n   */\n  public eventFromMessage(message: string, level: Severity = Severity.Info, hint?: EventHint): PromiseLike<Event> {\n    const event: Event = {\n      event_id: hint && hint.event_id,\n      level,\n      message,\n    };\n\n    return new SyncPromise<Event>(resolve => {\n      if (this._options.attachStacktrace && hint && hint.syntheticException) {\n        const stack = hint.syntheticException ? extractStackFromError(hint.syntheticException) : [];\n        parseStack(stack, this._options)\n          .then(frames => {\n            event.stacktrace = {\n              frames: prepareFramesForEvent(frames),\n            };\n            resolve(event);\n          })\n          .then(null, () => {\n            resolve(event);\n          });\n      } else {\n        resolve(event);\n      }\n    });\n  }\n\n  /**\n   * @inheritDoc\n   */\n  protected _setupTransport(): Transport {\n    if (!this._options.dsn) {\n      // We return the noop transport here in case there is no Dsn.\n      return super._setupTransport();\n    }\n\n    const dsn = new Dsn(this._options.dsn);\n\n    const transportOptions: TransportOptions = {\n      ...this._options.transportOptions,\n      ...(this._options.httpProxy && { httpProxy: this._options.httpProxy }),\n      ...(this._options.httpsProxy && { httpsProxy: this._options.httpsProxy }),\n      ...(this._options.caCerts && { caCerts: this._options.caCerts }),\n      dsn: this._options.dsn,\n    };\n\n    if (this._options.transport) {\n      return new this._options.transport(transportOptions);\n    }\n    if (dsn.protocol === 'http') {\n      return new HTTPTransport(transportOptions);\n    }\n    return new HTTPSTransport(transportOptions);\n  }\n}\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}