{"ast":null,"code":"\"use strict\";\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.includesOwnPackageName = exports.replaceBackslashes = exports.isAbsolutePathSourceName = exports.normalizeSourceName = exports.localSourceNameToPath = exports.localPathToSourceName = exports.validateSourceNameExistenceAndCasing = exports.isLocalSourceName = exports.validateSourceNameFormat = void 0;\nconst path_1 = __importDefault(require(\"path\"));\nconst errors_1 = require(\"../internal/core/errors\");\nconst errors_list_1 = require(\"../internal/core/errors-list\");\nconst fs_utils_1 = require(\"../internal/util/fs-utils\");\nconst packageInfo_1 = require(\"../internal/util/packageInfo\");\nconst NODE_MODULES = \"node_modules\";\n/**\n * This function validates the source name's format.\n *\n * It throws if the format is invalid.\n * If it doesn't throw all you know is that the format is valid.\n */\nfunction validateSourceNameFormat(sourceName) {\n  if (isAbsolutePathSourceName(sourceName)) {\n    throw new errors_1.HardhatError(errors_list_1.ERRORS.SOURCE_NAMES.INVALID_SOURCE_NAME_ABSOLUTE_PATH, {\n      name: sourceName\n    });\n  }\n  if (isExplicitRelativePath(sourceName)) {\n    throw new errors_1.HardhatError(errors_list_1.ERRORS.SOURCE_NAMES.INVALID_SOURCE_NAME_RELATIVE_PATH, {\n      name: sourceName\n    });\n  }\n  // We check this before normalizing so we are sure that the difference\n  // comes from slash vs backslash\n  if (replaceBackslashes(sourceName) !== sourceName) {\n    throw new errors_1.HardhatError(errors_list_1.ERRORS.SOURCE_NAMES.INVALID_SOURCE_NAME_BACKSLASHES, {\n      name: sourceName\n    });\n  }\n  if (normalizeSourceName(sourceName) !== sourceName) {\n    throw new errors_1.HardhatError(errors_list_1.ERRORS.SOURCE_NAMES.INVALID_SOURCE_NOT_NORMALIZED, {\n      name: sourceName\n    });\n  }\n}\nexports.validateSourceNameFormat = validateSourceNameFormat;\n/**\n * This function returns true if the sourceName is, potentially, from a local\n * file. It doesn't validate that the file actually exists.\n *\n * The source name must be in a valid format.\n */\nasync function isLocalSourceName(projectRoot, sourceName) {\n  // Note that we consider \"hardhat/console.sol\" as a special case here.\n  // This lets someone have a \"hardhat\" directory within their project without\n  // it impacting their use of `console.log`.\n  // See issue https://github.com/nomiclabs/hardhat/issues/998\n  if (sourceName.includes(NODE_MODULES) || sourceName === \"hardhat/console.sol\") {\n    return false;\n  }\n  const slashIndex = sourceName.indexOf(\"/\");\n  const firstDirOrFileName = slashIndex !== -1 ? sourceName.substring(0, slashIndex) : sourceName;\n  try {\n    await (0, fs_utils_1.getFileTrueCase)(projectRoot, firstDirOrFileName);\n  } catch (error) {\n    if (error instanceof fs_utils_1.FileNotFoundError) {\n      return false;\n    }\n    // eslint-disable-next-line @nomiclabs/hardhat-internal-rules/only-hardhat-error\n    throw error;\n  }\n  return true;\n}\nexports.isLocalSourceName = isLocalSourceName;\n/**\n * Validates that a source name exists, starting from `fromDir`, and has the\n * right casing.\n *\n * The source name must be in a valid format.\n */\nasync function validateSourceNameExistenceAndCasing(fromDir, sourceName) {\n  const trueCaseSourceName = await getSourceNameTrueCase(fromDir, sourceName);\n  if (trueCaseSourceName !== sourceName) {\n    throw new errors_1.HardhatError(errors_list_1.ERRORS.SOURCE_NAMES.WRONG_CASING, {\n      incorrect: sourceName,\n      correct: trueCaseSourceName\n    });\n  }\n}\nexports.validateSourceNameExistenceAndCasing = validateSourceNameExistenceAndCasing;\n/**\n * Returns the source name of an existing local file's absolute path.\n *\n * Throws is the file doesn't exist, it's not inside the project, or belongs\n * to a library.\n */\nasync function localPathToSourceName(projectRoot, localFileAbsolutePath) {\n  const relativePath = path_1.default.relative(projectRoot, localFileAbsolutePath);\n  const normalized = normalizeSourceName(relativePath);\n  if (normalized.startsWith(\"..\")) {\n    throw new errors_1.HardhatError(errors_list_1.ERRORS.SOURCE_NAMES.EXTERNAL_AS_LOCAL, {\n      path: localFileAbsolutePath\n    });\n  }\n  if (normalized.includes(NODE_MODULES)) {\n    throw new errors_1.HardhatError(errors_list_1.ERRORS.SOURCE_NAMES.NODE_MODULES_AS_LOCAL, {\n      path: localFileAbsolutePath\n    });\n  }\n  return getSourceNameTrueCase(projectRoot, relativePath);\n}\nexports.localPathToSourceName = localPathToSourceName;\n/**\n * This function takes a valid local source name and returns its path. The\n * source name doesn't need to point to an existing file.\n */\nfunction localSourceNameToPath(projectRoot, sourceName) {\n  return path_1.default.join(projectRoot, sourceName);\n}\nexports.localSourceNameToPath = localSourceNameToPath;\n/**\n * Normalizes the source name, for example, by replacing `a/./b` with `a/b`.\n *\n * The sourceName param doesn't have to be a valid source name. It can,\n * for example, be denormalized.\n */\nfunction normalizeSourceName(sourceName) {\n  return replaceBackslashes(path_1.default.normalize(sourceName));\n}\nexports.normalizeSourceName = normalizeSourceName;\n/**\n * This function returns true if the sourceName is a unix absolute path or a\n * platform-dependent one.\n *\n * This function is used instead of just `path.isAbsolute` to ensure that\n * source names never start with `/`, even on Windows.\n */\nfunction isAbsolutePathSourceName(sourceName) {\n  return path_1.default.isAbsolute(sourceName) || sourceName.startsWith(\"/\");\n}\nexports.isAbsolutePathSourceName = isAbsolutePathSourceName;\n/**\n * This function returns true if the sourceName is a unix path that is based on\n * the current directory `./`.\n */\nfunction isExplicitRelativePath(sourceName) {\n  const [base] = sourceName.split(\"/\", 1);\n  return base === \".\" || base === \"..\";\n}\n/**\n * This function replaces backslashes (\\\\) with slashes (/).\n *\n * Note that a source name must not contain backslashes.\n */\nfunction replaceBackslashes(str) {\n  // Based in the npm module slash\n  const isExtendedLengthPath = /^\\\\\\\\\\?\\\\/.test(str);\n  const hasNonAscii = /[^\\u0000-\\u0080]+/.test(str);\n  if (isExtendedLengthPath || hasNonAscii) {\n    return str;\n  }\n  return str.replace(/\\\\/g, \"/\");\n}\nexports.replaceBackslashes = replaceBackslashes;\nfunction slashesToPathSeparator(str) {\n  if (path_1.default.sep === \"/\") {\n    return str;\n  }\n  return str.replace(/\\//g, path_1.default.sep);\n}\n/**\n * Returns the true casing of `p` as a relative path from `fromDir`. Throws if\n * `p` doesn't exist. `p` MUST be in source name format.\n */\nasync function getSourceNameTrueCase(fromDir, p) {\n  try {\n    const realCase = await (0, fs_utils_1.getFileTrueCase)(fromDir, slashesToPathSeparator(p));\n    return normalizeSourceName(realCase);\n  } catch (error) {\n    if (error instanceof fs_utils_1.FileNotFoundError) {\n      throw new errors_1.HardhatError(errors_list_1.ERRORS.SOURCE_NAMES.FILE_NOT_FOUND, {\n        name: p\n      }, error);\n    }\n    // eslint-disable-next-line @nomiclabs/hardhat-internal-rules/only-hardhat-error\n    throw error;\n  }\n}\n/**\n * This function returns true if the sourceName contains the current package's name\n * as a substring\n */\nasync function includesOwnPackageName(sourceName) {\n  const packageName = await (0, packageInfo_1.getPackageName)(sourceName);\n  if (packageName !== \"\") {\n    return sourceName.startsWith(`${packageName}/`);\n  }\n  return false;\n}\nexports.includesOwnPackageName = includesOwnPackageName;","map":{"version":3,"mappings":"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","names":["NODE_MODULES","validateSourceNameFormat","sourceName","isAbsolutePathSourceName","errors_1","errors_list_1","SOURCE_NAMES","INVALID_SOURCE_NAME_ABSOLUTE_PATH","name","isExplicitRelativePath","INVALID_SOURCE_NAME_RELATIVE_PATH","replaceBackslashes","INVALID_SOURCE_NAME_BACKSLASHES","normalizeSourceName","INVALID_SOURCE_NOT_NORMALIZED","exports","isLocalSourceName","projectRoot","includes","slashIndex","indexOf","firstDirOrFileName","substring","error","fs_utils_1","validateSourceNameExistenceAndCasing","fromDir","trueCaseSourceName","getSourceNameTrueCase","WRONG_CASING","incorrect","correct","localPathToSourceName","localFileAbsolutePath","relativePath","path_1","relative","normalized","startsWith","EXTERNAL_AS_LOCAL","path","NODE_MODULES_AS_LOCAL","localSourceNameToPath","join","normalize","isAbsolute","base","split","str","isExtendedLengthPath","test","hasNonAscii","replace","slashesToPathSeparator","sep","p","realCase","FILE_NOT_FOUND","includesOwnPackageName","packageName"],"sources":["/Users/janrobel/Documents/PersonalProjekty/nftGenerateAi/clientAndContract/node_modules/hardhat/src/utils/source-names.ts"],"sourcesContent":["import path from \"path\";\n\nimport { HardhatError } from \"../internal/core/errors\";\nimport { ERRORS } from \"../internal/core/errors-list\";\nimport { FileNotFoundError, getFileTrueCase } from \"../internal/util/fs-utils\";\nimport { getPackageName } from \"../internal/util/packageInfo\";\n\nconst NODE_MODULES = \"node_modules\";\n\n/**\n * This function validates the source name's format.\n *\n * It throws if the format is invalid.\n * If it doesn't throw all you know is that the format is valid.\n */\nexport function validateSourceNameFormat(sourceName: string) {\n  if (isAbsolutePathSourceName(sourceName)) {\n    throw new HardhatError(\n      ERRORS.SOURCE_NAMES.INVALID_SOURCE_NAME_ABSOLUTE_PATH,\n      {\n        name: sourceName,\n      }\n    );\n  }\n\n  if (isExplicitRelativePath(sourceName)) {\n    throw new HardhatError(\n      ERRORS.SOURCE_NAMES.INVALID_SOURCE_NAME_RELATIVE_PATH,\n      {\n        name: sourceName,\n      }\n    );\n  }\n\n  // We check this before normalizing so we are sure that the difference\n  // comes from slash vs backslash\n  if (replaceBackslashes(sourceName) !== sourceName) {\n    throw new HardhatError(\n      ERRORS.SOURCE_NAMES.INVALID_SOURCE_NAME_BACKSLASHES,\n      {\n        name: sourceName,\n      }\n    );\n  }\n\n  if (normalizeSourceName(sourceName) !== sourceName) {\n    throw new HardhatError(ERRORS.SOURCE_NAMES.INVALID_SOURCE_NOT_NORMALIZED, {\n      name: sourceName,\n    });\n  }\n}\n\n/**\n * This function returns true if the sourceName is, potentially, from a local\n * file. It doesn't validate that the file actually exists.\n *\n * The source name must be in a valid format.\n */\nexport async function isLocalSourceName(\n  projectRoot: string,\n  sourceName: string\n): Promise<boolean> {\n  // Note that we consider \"hardhat/console.sol\" as a special case here.\n  // This lets someone have a \"hardhat\" directory within their project without\n  // it impacting their use of `console.log`.\n  // See issue https://github.com/nomiclabs/hardhat/issues/998\n  if (\n    sourceName.includes(NODE_MODULES) ||\n    sourceName === \"hardhat/console.sol\"\n  ) {\n    return false;\n  }\n\n  const slashIndex = sourceName.indexOf(\"/\");\n  const firstDirOrFileName =\n    slashIndex !== -1 ? sourceName.substring(0, slashIndex) : sourceName;\n\n  try {\n    await getFileTrueCase(projectRoot, firstDirOrFileName);\n  } catch (error) {\n    if (error instanceof FileNotFoundError) {\n      return false;\n    }\n\n    // eslint-disable-next-line @nomiclabs/hardhat-internal-rules/only-hardhat-error\n    throw error;\n  }\n\n  return true;\n}\n\n/**\n * Validates that a source name exists, starting from `fromDir`, and has the\n * right casing.\n *\n * The source name must be in a valid format.\n */\nexport async function validateSourceNameExistenceAndCasing(\n  fromDir: string,\n  sourceName: string\n) {\n  const trueCaseSourceName = await getSourceNameTrueCase(fromDir, sourceName);\n\n  if (trueCaseSourceName !== sourceName) {\n    throw new HardhatError(ERRORS.SOURCE_NAMES.WRONG_CASING, {\n      incorrect: sourceName,\n      correct: trueCaseSourceName,\n    });\n  }\n}\n\n/**\n * Returns the source name of an existing local file's absolute path.\n *\n * Throws is the file doesn't exist, it's not inside the project, or belongs\n * to a library.\n */\nexport async function localPathToSourceName(\n  projectRoot: string,\n  localFileAbsolutePath: string\n): Promise<string> {\n  const relativePath = path.relative(projectRoot, localFileAbsolutePath);\n  const normalized = normalizeSourceName(relativePath);\n\n  if (normalized.startsWith(\"..\")) {\n    throw new HardhatError(ERRORS.SOURCE_NAMES.EXTERNAL_AS_LOCAL, {\n      path: localFileAbsolutePath,\n    });\n  }\n\n  if (normalized.includes(NODE_MODULES)) {\n    throw new HardhatError(ERRORS.SOURCE_NAMES.NODE_MODULES_AS_LOCAL, {\n      path: localFileAbsolutePath,\n    });\n  }\n\n  return getSourceNameTrueCase(projectRoot, relativePath);\n}\n\n/**\n * This function takes a valid local source name and returns its path. The\n * source name doesn't need to point to an existing file.\n */\nexport function localSourceNameToPath(\n  projectRoot: string,\n  sourceName: string\n): string {\n  return path.join(projectRoot, sourceName);\n}\n\n/**\n * Normalizes the source name, for example, by replacing `a/./b` with `a/b`.\n *\n * The sourceName param doesn't have to be a valid source name. It can,\n * for example, be denormalized.\n */\nexport function normalizeSourceName(sourceName: string): string {\n  return replaceBackslashes(path.normalize(sourceName));\n}\n\n/**\n * This function returns true if the sourceName is a unix absolute path or a\n * platform-dependent one.\n *\n * This function is used instead of just `path.isAbsolute` to ensure that\n * source names never start with `/`, even on Windows.\n */\nexport function isAbsolutePathSourceName(sourceName: string): boolean {\n  return path.isAbsolute(sourceName) || sourceName.startsWith(\"/\");\n}\n\n/**\n * This function returns true if the sourceName is a unix path that is based on\n * the current directory `./`.\n */\nfunction isExplicitRelativePath(sourceName: string): boolean {\n  const [base] = sourceName.split(\"/\", 1);\n  return base === \".\" || base === \"..\";\n}\n\n/**\n * This function replaces backslashes (\\\\) with slashes (/).\n *\n * Note that a source name must not contain backslashes.\n */\nexport function replaceBackslashes(str: string): string {\n  // Based in the npm module slash\n  const isExtendedLengthPath = /^\\\\\\\\\\?\\\\/.test(str);\n  const hasNonAscii = /[^\\u0000-\\u0080]+/.test(str);\n\n  if (isExtendedLengthPath || hasNonAscii) {\n    return str;\n  }\n\n  return str.replace(/\\\\/g, \"/\");\n}\n\nfunction slashesToPathSeparator(str: string): string {\n  if (path.sep === \"/\") {\n    return str;\n  }\n\n  return str.replace(/\\//g, path.sep);\n}\n\n/**\n * Returns the true casing of `p` as a relative path from `fromDir`. Throws if\n * `p` doesn't exist. `p` MUST be in source name format.\n */\nasync function getSourceNameTrueCase(\n  fromDir: string,\n  p: string\n): Promise<string> {\n  try {\n    const realCase = await getFileTrueCase(fromDir, slashesToPathSeparator(p));\n    return normalizeSourceName(realCase);\n  } catch (error) {\n    if (error instanceof FileNotFoundError) {\n      throw new HardhatError(\n        ERRORS.SOURCE_NAMES.FILE_NOT_FOUND,\n        {\n          name: p,\n        },\n        error\n      );\n    }\n\n    // eslint-disable-next-line @nomiclabs/hardhat-internal-rules/only-hardhat-error\n    throw error;\n  }\n}\n\n/**\n * This function returns true if the sourceName contains the current package's name\n * as a substring\n */\nexport async function includesOwnPackageName(\n  sourceName: string\n): Promise<boolean> {\n  const packageName = await getPackageName(sourceName);\n  if (packageName !== \"\") {\n    return sourceName.startsWith(`${packageName}/`);\n  }\n  return false;\n}\n"]},"metadata":{},"sourceType":"script","externalDependencies":[]}