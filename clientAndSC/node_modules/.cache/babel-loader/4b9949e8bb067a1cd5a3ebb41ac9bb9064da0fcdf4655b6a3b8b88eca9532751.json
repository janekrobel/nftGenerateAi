{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.ArgumentsParser = void 0;\nconst errors_1 = require(\"../core/errors\");\nconst errors_list_1 = require(\"../core/errors-list\");\nclass ArgumentsParser {\n  static paramNameToCLA(paramName) {\n    return ArgumentsParser.PARAM_PREFIX + paramName.split(/(?=[A-Z])/g).map(s => s.toLowerCase()).join(\"-\");\n  }\n  static cLAToParamName(cLA) {\n    if (cLA.toLowerCase() !== cLA) {\n      throw new errors_1.HardhatError(errors_list_1.ERRORS.ARGUMENTS.PARAM_NAME_INVALID_CASING, {\n        param: cLA\n      });\n    }\n    const parts = cLA.slice(ArgumentsParser.PARAM_PREFIX.length).split(\"-\").filter(x => x.length > 0);\n    return parts[0] + parts.slice(1).map(s => s[0].toUpperCase() + s.slice(1)).join(\"\");\n  }\n  parseHardhatArguments(hardhatParamDefinitions, envVariableArguments, rawCLAs) {\n    const hardhatArguments = {};\n    let taskName;\n    const unparsedCLAs = [];\n    for (let i = 0; i < rawCLAs.length; i++) {\n      const arg = rawCLAs[i];\n      if (taskName === undefined) {\n        if (!this._hasCLAParamNameFormat(arg)) {\n          taskName = arg;\n          continue;\n        }\n        if (!this._isCLAParamName(arg, hardhatParamDefinitions)) {\n          throw new errors_1.HardhatError(errors_list_1.ERRORS.ARGUMENTS.UNRECOGNIZED_COMMAND_LINE_ARG, {\n            argument: arg\n          });\n        }\n        i = this._parseArgumentAt(rawCLAs, i, hardhatParamDefinitions, hardhatArguments, taskName);\n      } else {\n        if (!this._isCLAParamName(arg, hardhatParamDefinitions)) {\n          unparsedCLAs.push(arg);\n          continue;\n        }\n        i = this._parseArgumentAt(rawCLAs, i, hardhatParamDefinitions, hardhatArguments, taskName);\n      }\n    }\n    return {\n      hardhatArguments: this._addHardhatDefaultArguments(hardhatParamDefinitions, envVariableArguments, hardhatArguments),\n      taskName,\n      unparsedCLAs\n    };\n  }\n  parseTaskArguments(taskDefinition, rawCLAs) {\n    const {\n      paramArguments,\n      rawPositionalArguments\n    } = this._parseTaskParamArguments(taskDefinition, rawCLAs);\n    const positionalArguments = this._parsePositionalParamArgs(rawPositionalArguments, taskDefinition.positionalParamDefinitions);\n    return {\n      ...paramArguments,\n      ...positionalArguments\n    };\n  }\n  _parseTaskParamArguments(taskDefinition, rawCLAs) {\n    const paramArguments = {};\n    const rawPositionalArguments = [];\n    for (let i = 0; i < rawCLAs.length; i++) {\n      const arg = rawCLAs[i];\n      if (!this._hasCLAParamNameFormat(arg)) {\n        rawPositionalArguments.push(arg);\n        continue;\n      }\n      if (!this._isCLAParamName(arg, taskDefinition.paramDefinitions)) {\n        throw new errors_1.HardhatError(errors_list_1.ERRORS.ARGUMENTS.UNRECOGNIZED_PARAM_NAME, {\n          param: arg\n        });\n      }\n      i = this._parseArgumentAt(rawCLAs, i, taskDefinition.paramDefinitions, paramArguments, taskDefinition.name);\n    }\n    this._addTaskDefaultArguments(taskDefinition, paramArguments);\n    return {\n      paramArguments,\n      rawPositionalArguments\n    };\n  }\n  _addHardhatDefaultArguments(hardhatParamDefinitions, envVariableArguments, hardhatArguments) {\n    return {\n      ...envVariableArguments,\n      ...hardhatArguments\n    };\n  }\n  _addTaskDefaultArguments(taskDefinition, taskArguments) {\n    for (const paramName of Object.keys(taskDefinition.paramDefinitions)) {\n      const definition = taskDefinition.paramDefinitions[paramName];\n      if (taskArguments[paramName] !== undefined) {\n        continue;\n      }\n      if (!definition.isOptional) {\n        throw new errors_1.HardhatError(errors_list_1.ERRORS.ARGUMENTS.MISSING_TASK_ARGUMENT, {\n          param: ArgumentsParser.paramNameToCLA(paramName),\n          task: taskDefinition.name\n        });\n      }\n      taskArguments[paramName] = definition.defaultValue;\n    }\n  }\n  _isCLAParamName(str, paramDefinitions) {\n    if (!this._hasCLAParamNameFormat(str)) {\n      return false;\n    }\n    const name = ArgumentsParser.cLAToParamName(str);\n    return paramDefinitions[name] !== undefined;\n  }\n  _hasCLAParamNameFormat(str) {\n    return str.startsWith(ArgumentsParser.PARAM_PREFIX);\n  }\n  _parseArgumentAt(rawCLAs, index, paramDefinitions, parsedArguments, taskName) {\n    const claArg = rawCLAs[index];\n    const paramName = ArgumentsParser.cLAToParamName(claArg);\n    const definition = paramDefinitions[paramName];\n    if (parsedArguments[paramName] !== undefined) {\n      throw new errors_1.HardhatError(errors_list_1.ERRORS.ARGUMENTS.REPEATED_PARAM, {\n        param: claArg\n      });\n    }\n    if (definition.isFlag) {\n      parsedArguments[paramName] = true;\n    } else {\n      index++;\n      const value = rawCLAs[index];\n      if (value === undefined) {\n        throw new errors_1.HardhatError(errors_list_1.ERRORS.ARGUMENTS.MISSING_TASK_ARGUMENT, {\n          param: ArgumentsParser.paramNameToCLA(paramName),\n          task: taskName ?? \"help\"\n        });\n      }\n      // We only parse the arguments of non-subtasks, and those only\n      // accept CLIArgumentTypes.\n      const type = definition.type;\n      parsedArguments[paramName] = type.parse(paramName, value);\n    }\n    return index;\n  }\n  _parsePositionalParamArgs(rawPositionalParamArgs, positionalParamDefinitions) {\n    const args = {};\n    for (let i = 0; i < positionalParamDefinitions.length; i++) {\n      const definition = positionalParamDefinitions[i];\n      // We only parse the arguments of non-subtasks, and those only\n      // accept CLIArgumentTypes.\n      const type = definition.type;\n      const rawArg = rawPositionalParamArgs[i];\n      if (rawArg === undefined) {\n        if (!definition.isOptional) {\n          throw new errors_1.HardhatError(errors_list_1.ERRORS.ARGUMENTS.MISSING_POSITIONAL_ARG, {\n            param: definition.name\n          });\n        }\n        args[definition.name] = definition.defaultValue;\n      } else if (!definition.isVariadic) {\n        args[definition.name] = type.parse(definition.name, rawArg);\n      } else {\n        args[definition.name] = rawPositionalParamArgs.slice(i).map(raw => type.parse(definition.name, raw));\n      }\n    }\n    const lastDefinition = positionalParamDefinitions[positionalParamDefinitions.length - 1];\n    const hasVariadicParam = lastDefinition !== undefined && lastDefinition.isVariadic;\n    if (!hasVariadicParam && rawPositionalParamArgs.length > positionalParamDefinitions.length) {\n      throw new errors_1.HardhatError(errors_list_1.ERRORS.ARGUMENTS.UNRECOGNIZED_POSITIONAL_ARG, {\n        argument: rawPositionalParamArgs[positionalParamDefinitions.length]\n      });\n    }\n    return args;\n  }\n}\nexports.ArgumentsParser = ArgumentsParser;\nArgumentsParser.PARAM_PREFIX = \"--\";","map":{"version":3,"mappings":"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","names":["ArgumentsParser","paramNameToCLA","paramName","PARAM_PREFIX","split","map","s","toLowerCase","join","cLAToParamName","cLA","errors_1","errors_list_1","ARGUMENTS","PARAM_NAME_INVALID_CASING","param","parts","slice","length","filter","x","toUpperCase","parseHardhatArguments","hardhatParamDefinitions","envVariableArguments","rawCLAs","hardhatArguments","taskName","unparsedCLAs","i","arg","undefined","_hasCLAParamNameFormat","_isCLAParamName","UNRECOGNIZED_COMMAND_LINE_ARG","argument","_parseArgumentAt","push","_addHardhatDefaultArguments","parseTaskArguments","taskDefinition","paramArguments","rawPositionalArguments","_parseTaskParamArguments","positionalArguments","_parsePositionalParamArgs","positionalParamDefinitions","paramDefinitions","UNRECOGNIZED_PARAM_NAME","name","_addTaskDefaultArguments","taskArguments","Object","keys","definition","isOptional","MISSING_TASK_ARGUMENT","task","defaultValue","str","startsWith","index","parsedArguments","claArg","REPEATED_PARAM","isFlag","value","type","parse","rawPositionalParamArgs","args","rawArg","MISSING_POSITIONAL_ARG","isVariadic","raw","lastDefinition","hasVariadicParam","UNRECOGNIZED_POSITIONAL_ARG","exports"],"sources":["/Users/janrobel/Documents/PersonalProjekty/nftGenerateAi/clientAndContract/node_modules/hardhat/src/internal/cli/ArgumentsParser.ts"],"sourcesContent":["import {\n  CLIArgumentType,\n  HardhatArguments,\n  HardhatParamDefinitions,\n  ParamDefinition,\n  ParamDefinitionsMap,\n  TaskArguments,\n  TaskDefinition,\n} from \"../../types\";\nimport { HardhatError } from \"../core/errors\";\nimport { ERRORS } from \"../core/errors-list\";\n\nexport class ArgumentsParser {\n  public static readonly PARAM_PREFIX = \"--\";\n\n  public static paramNameToCLA(paramName: string): string {\n    return (\n      ArgumentsParser.PARAM_PREFIX +\n      paramName\n        .split(/(?=[A-Z])/g)\n        .map((s) => s.toLowerCase())\n        .join(\"-\")\n    );\n  }\n\n  public static cLAToParamName(cLA: string): string {\n    if (cLA.toLowerCase() !== cLA) {\n      throw new HardhatError(ERRORS.ARGUMENTS.PARAM_NAME_INVALID_CASING, {\n        param: cLA,\n      });\n    }\n\n    const parts = cLA\n      .slice(ArgumentsParser.PARAM_PREFIX.length)\n      .split(\"-\")\n      .filter((x) => x.length > 0);\n\n    return (\n      parts[0] +\n      parts\n        .slice(1)\n        .map((s) => s[0].toUpperCase() + s.slice(1))\n        .join(\"\")\n    );\n  }\n\n  public parseHardhatArguments(\n    hardhatParamDefinitions: HardhatParamDefinitions,\n    envVariableArguments: HardhatArguments,\n    rawCLAs: string[]\n  ): {\n    hardhatArguments: HardhatArguments;\n    taskName?: string;\n    unparsedCLAs: string[];\n  } {\n    const hardhatArguments: Partial<HardhatArguments> = {};\n    let taskName: string | undefined;\n    const unparsedCLAs: string[] = [];\n\n    for (let i = 0; i < rawCLAs.length; i++) {\n      const arg = rawCLAs[i];\n\n      if (taskName === undefined) {\n        if (!this._hasCLAParamNameFormat(arg)) {\n          taskName = arg;\n          continue;\n        }\n\n        if (!this._isCLAParamName(arg, hardhatParamDefinitions)) {\n          throw new HardhatError(\n            ERRORS.ARGUMENTS.UNRECOGNIZED_COMMAND_LINE_ARG,\n            { argument: arg }\n          );\n        }\n\n        i = this._parseArgumentAt(\n          rawCLAs,\n          i,\n          hardhatParamDefinitions,\n          hardhatArguments,\n          taskName\n        );\n      } else {\n        if (!this._isCLAParamName(arg, hardhatParamDefinitions)) {\n          unparsedCLAs.push(arg);\n          continue;\n        }\n\n        i = this._parseArgumentAt(\n          rawCLAs,\n          i,\n          hardhatParamDefinitions,\n          hardhatArguments,\n          taskName\n        );\n      }\n    }\n\n    return {\n      hardhatArguments: this._addHardhatDefaultArguments(\n        hardhatParamDefinitions,\n        envVariableArguments,\n        hardhatArguments\n      ),\n      taskName,\n      unparsedCLAs,\n    };\n  }\n\n  public parseTaskArguments(\n    taskDefinition: TaskDefinition,\n    rawCLAs: string[]\n  ): TaskArguments {\n    const { paramArguments, rawPositionalArguments } =\n      this._parseTaskParamArguments(taskDefinition, rawCLAs);\n\n    const positionalArguments = this._parsePositionalParamArgs(\n      rawPositionalArguments,\n      taskDefinition.positionalParamDefinitions\n    );\n\n    return { ...paramArguments, ...positionalArguments };\n  }\n\n  private _parseTaskParamArguments(\n    taskDefinition: TaskDefinition,\n    rawCLAs: string[]\n  ) {\n    const paramArguments = {};\n    const rawPositionalArguments: string[] = [];\n\n    for (let i = 0; i < rawCLAs.length; i++) {\n      const arg = rawCLAs[i];\n\n      if (!this._hasCLAParamNameFormat(arg)) {\n        rawPositionalArguments.push(arg);\n        continue;\n      }\n\n      if (!this._isCLAParamName(arg, taskDefinition.paramDefinitions)) {\n        throw new HardhatError(ERRORS.ARGUMENTS.UNRECOGNIZED_PARAM_NAME, {\n          param: arg,\n        });\n      }\n\n      i = this._parseArgumentAt(\n        rawCLAs,\n        i,\n        taskDefinition.paramDefinitions,\n        paramArguments,\n        taskDefinition.name\n      );\n    }\n\n    this._addTaskDefaultArguments(taskDefinition, paramArguments);\n\n    return { paramArguments, rawPositionalArguments };\n  }\n\n  private _addHardhatDefaultArguments(\n    hardhatParamDefinitions: HardhatParamDefinitions,\n    envVariableArguments: HardhatArguments,\n    hardhatArguments: Partial<HardhatArguments>\n  ): HardhatArguments {\n    return {\n      ...envVariableArguments,\n      ...hardhatArguments,\n    };\n  }\n\n  private _addTaskDefaultArguments(\n    taskDefinition: TaskDefinition,\n    taskArguments: TaskArguments\n  ) {\n    for (const paramName of Object.keys(taskDefinition.paramDefinitions)) {\n      const definition = taskDefinition.paramDefinitions[paramName];\n\n      if (taskArguments[paramName] !== undefined) {\n        continue;\n      }\n      if (!definition.isOptional) {\n        throw new HardhatError(ERRORS.ARGUMENTS.MISSING_TASK_ARGUMENT, {\n          param: ArgumentsParser.paramNameToCLA(paramName),\n          task: taskDefinition.name,\n        });\n      }\n\n      taskArguments[paramName] = definition.defaultValue;\n    }\n  }\n\n  private _isCLAParamName(str: string, paramDefinitions: ParamDefinitionsMap) {\n    if (!this._hasCLAParamNameFormat(str)) {\n      return false;\n    }\n\n    const name = ArgumentsParser.cLAToParamName(str);\n    return paramDefinitions[name] !== undefined;\n  }\n\n  private _hasCLAParamNameFormat(str: string) {\n    return str.startsWith(ArgumentsParser.PARAM_PREFIX);\n  }\n\n  private _parseArgumentAt(\n    rawCLAs: string[],\n    index: number,\n    paramDefinitions: ParamDefinitionsMap,\n    parsedArguments: TaskArguments,\n    taskName?: string\n  ) {\n    const claArg = rawCLAs[index];\n    const paramName = ArgumentsParser.cLAToParamName(claArg);\n    const definition = paramDefinitions[paramName];\n\n    if (parsedArguments[paramName] !== undefined) {\n      throw new HardhatError(ERRORS.ARGUMENTS.REPEATED_PARAM, {\n        param: claArg,\n      });\n    }\n\n    if (definition.isFlag) {\n      parsedArguments[paramName] = true;\n    } else {\n      index++;\n      const value = rawCLAs[index];\n\n      if (value === undefined) {\n        throw new HardhatError(ERRORS.ARGUMENTS.MISSING_TASK_ARGUMENT, {\n          param: ArgumentsParser.paramNameToCLA(paramName),\n          task: taskName ?? \"help\",\n        });\n      }\n\n      // We only parse the arguments of non-subtasks, and those only\n      // accept CLIArgumentTypes.\n      const type = definition.type as CLIArgumentType<any>;\n      parsedArguments[paramName] = type.parse(paramName, value);\n    }\n\n    return index;\n  }\n\n  private _parsePositionalParamArgs(\n    rawPositionalParamArgs: string[],\n    positionalParamDefinitions: Array<ParamDefinition<any>>\n  ): TaskArguments {\n    const args: TaskArguments = {};\n\n    for (let i = 0; i < positionalParamDefinitions.length; i++) {\n      const definition = positionalParamDefinitions[i];\n      // We only parse the arguments of non-subtasks, and those only\n      // accept CLIArgumentTypes.\n      const type = definition.type as CLIArgumentType<any>;\n\n      const rawArg = rawPositionalParamArgs[i];\n\n      if (rawArg === undefined) {\n        if (!definition.isOptional) {\n          throw new HardhatError(ERRORS.ARGUMENTS.MISSING_POSITIONAL_ARG, {\n            param: definition.name,\n          });\n        }\n\n        args[definition.name] = definition.defaultValue;\n      } else if (!definition.isVariadic) {\n        args[definition.name] = type.parse(definition.name, rawArg);\n      } else {\n        args[definition.name] = rawPositionalParamArgs\n          .slice(i)\n          .map((raw) => type.parse(definition.name, raw));\n      }\n    }\n\n    const lastDefinition =\n      positionalParamDefinitions[positionalParamDefinitions.length - 1];\n\n    const hasVariadicParam =\n      lastDefinition !== undefined && lastDefinition.isVariadic;\n\n    if (\n      !hasVariadicParam &&\n      rawPositionalParamArgs.length > positionalParamDefinitions.length\n    ) {\n      throw new HardhatError(ERRORS.ARGUMENTS.UNRECOGNIZED_POSITIONAL_ARG, {\n        argument: rawPositionalParamArgs[positionalParamDefinitions.length],\n      });\n    }\n\n    return args;\n  }\n}\n"]},"metadata":{},"sourceType":"script","externalDependencies":[]}