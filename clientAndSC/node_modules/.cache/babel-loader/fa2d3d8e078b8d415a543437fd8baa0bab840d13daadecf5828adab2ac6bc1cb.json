{"ast":null,"code":"\"use strict\";\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Resolver = exports.ResolvedFile = void 0;\nconst fs_extra_1 = __importDefault(require(\"fs-extra\"));\nconst path_1 = __importDefault(require(\"path\"));\nconst resolve_1 = __importDefault(require(\"resolve\"));\nconst source_names_1 = require(\"../../utils/source-names\");\nconst errors_1 = require(\"../core/errors\");\nconst errors_list_1 = require(\"../core/errors-list\");\nconst hash_1 = require(\"../util/hash\");\nconst fs_utils_1 = require(\"../util/fs-utils\");\nconst NODE_MODULES = \"node_modules\";\nclass ResolvedFile {\n  constructor(sourceName, absolutePath, content, contentHash, lastModificationDate, libraryName, libraryVersion) {\n    this.sourceName = sourceName;\n    this.absolutePath = absolutePath;\n    this.content = content;\n    this.contentHash = contentHash;\n    this.lastModificationDate = lastModificationDate;\n    (0, errors_1.assertHardhatInvariant)(libraryName === undefined && libraryVersion === undefined || libraryName !== undefined && libraryVersion !== undefined, \"Libraries should have both name and version, or neither one\");\n    if (libraryName !== undefined && libraryVersion !== undefined) {\n      this.library = {\n        name: libraryName,\n        version: libraryVersion\n      };\n    }\n  }\n  getVersionedName() {\n    return this.sourceName + (this.library !== undefined ? `@v${this.library.version}` : \"\");\n  }\n}\nexports.ResolvedFile = ResolvedFile;\nclass Resolver {\n  constructor(_projectRoot, _parser, _readFile, _transformImportName) {\n    this._projectRoot = _projectRoot;\n    this._parser = _parser;\n    this._readFile = _readFile;\n    this._transformImportName = _transformImportName;\n    this._cache = new Map();\n  }\n  /**\n   * Resolves a source name into a ResolvedFile.\n   *\n   * @param sourceName The source name as it would be provided to solc.\n   */\n  async resolveSourceName(sourceName) {\n    const cached = this._cache.get(sourceName);\n    if (cached !== undefined) {\n      return cached;\n    }\n    (0, source_names_1.validateSourceNameFormat)(sourceName);\n    let resolvedFile;\n    if (await (0, source_names_1.isLocalSourceName)(this._projectRoot, sourceName)) {\n      resolvedFile = await this._resolveLocalSourceName(sourceName);\n    } else {\n      resolvedFile = await this._resolveLibrarySourceName(sourceName);\n    }\n    this._cache.set(sourceName, resolvedFile);\n    return resolvedFile;\n  }\n  /**\n   * Resolves an import from an already resolved file.\n   * @param from The file were the import statement is present.\n   * @param importName The path in the import statement.\n   */\n  async resolveImport(from, importName) {\n    const imported = await this._transformImportName(importName);\n    const scheme = this._getUriScheme(imported);\n    if (scheme !== undefined) {\n      throw new errors_1.HardhatError(errors_list_1.ERRORS.RESOLVER.INVALID_IMPORT_PROTOCOL, {\n        from: from.sourceName,\n        imported,\n        protocol: scheme\n      });\n    }\n    if ((0, source_names_1.replaceBackslashes)(imported) !== imported) {\n      throw new errors_1.HardhatError(errors_list_1.ERRORS.RESOLVER.INVALID_IMPORT_BACKSLASH, {\n        from: from.sourceName,\n        imported\n      });\n    }\n    if ((0, source_names_1.isAbsolutePathSourceName)(imported)) {\n      throw new errors_1.HardhatError(errors_list_1.ERRORS.RESOLVER.INVALID_IMPORT_ABSOLUTE_PATH, {\n        from: from.sourceName,\n        imported\n      });\n    }\n    // Edge-case where an import can contain the current package's name in monorepos.\n    // The path can be resolved because there's a symlink in the node modules.\n    if (await (0, source_names_1.includesOwnPackageName)(imported)) {\n      throw new errors_1.HardhatError(errors_list_1.ERRORS.RESOLVER.INCLUDES_OWN_PACKAGE_NAME, {\n        from: from.sourceName,\n        imported\n      });\n    }\n    try {\n      let sourceName;\n      const isRelativeImport = this._isRelativeImport(imported);\n      if (isRelativeImport) {\n        sourceName = await this._relativeImportToSourceName(from, imported);\n      } else {\n        sourceName = (0, source_names_1.normalizeSourceName)(imported);\n      }\n      const cached = this._cache.get(sourceName);\n      if (cached !== undefined) {\n        return cached;\n      }\n      let resolvedFile;\n      // We have this special case here, because otherwise local relative\n      // imports can be treated as library imports. For example if\n      // `contracts/c.sol` imports `../non-existent/a.sol`\n      if (from.library === undefined && isRelativeImport && !this._isRelativeImportToLibrary(from, imported)) {\n        resolvedFile = await this._resolveLocalSourceName(sourceName);\n      } else {\n        resolvedFile = await this.resolveSourceName(sourceName);\n      }\n      this._cache.set(sourceName, resolvedFile);\n      return resolvedFile;\n    } catch (error) {\n      if (errors_1.HardhatError.isHardhatErrorType(error, errors_list_1.ERRORS.RESOLVER.FILE_NOT_FOUND) || errors_1.HardhatError.isHardhatErrorType(error, errors_list_1.ERRORS.RESOLVER.LIBRARY_FILE_NOT_FOUND)) {\n        if (imported !== importName) {\n          throw new errors_1.HardhatError(errors_list_1.ERRORS.RESOLVER.IMPORTED_MAPPED_FILE_NOT_FOUND, {\n            imported,\n            importName,\n            from: from.sourceName\n          }, error);\n        } else {\n          throw new errors_1.HardhatError(errors_list_1.ERRORS.RESOLVER.IMPORTED_FILE_NOT_FOUND, {\n            imported,\n            from: from.sourceName\n          }, error);\n        }\n      }\n      if (errors_1.HardhatError.isHardhatErrorType(error, errors_list_1.ERRORS.RESOLVER.WRONG_SOURCE_NAME_CASING)) {\n        throw new errors_1.HardhatError(errors_list_1.ERRORS.RESOLVER.INVALID_IMPORT_WRONG_CASING, {\n          imported,\n          from: from.sourceName\n        }, error);\n      }\n      if (errors_1.HardhatError.isHardhatErrorType(error, errors_list_1.ERRORS.RESOLVER.LIBRARY_NOT_INSTALLED)) {\n        throw new errors_1.HardhatError(errors_list_1.ERRORS.RESOLVER.IMPORTED_LIBRARY_NOT_INSTALLED, {\n          library: error.messageArguments.library,\n          from: from.sourceName\n        }, error);\n      }\n      // eslint-disable-next-line @nomiclabs/hardhat-internal-rules/only-hardhat-error\n      throw error;\n    }\n  }\n  async _resolveLocalSourceName(sourceName) {\n    await this._validateSourceNameExistenceAndCasing(this._projectRoot, sourceName, false);\n    const absolutePath = path_1.default.join(this._projectRoot, sourceName);\n    return this._resolveFile(sourceName, absolutePath);\n  }\n  async _resolveLibrarySourceName(sourceName) {\n    const libraryName = this._getLibraryName(sourceName);\n    let packageJsonPath;\n    try {\n      packageJsonPath = this._resolveNodeModulesFileFromProjectRoot(path_1.default.join(libraryName, \"package.json\"));\n    } catch (error) {\n      // if the project is using a dependency from hardhat itself but it can't\n      // be found, this means that a global installation is being used, so we\n      // resolve the dependency relative to this file\n      if (libraryName === \"hardhat\") {\n        const hardhatCoreDir = path_1.default.join(__dirname, \"..\", \"..\");\n        packageJsonPath = path_1.default.join(hardhatCoreDir, \"package.json\");\n      } else {\n        throw new errors_1.HardhatError(errors_list_1.ERRORS.RESOLVER.LIBRARY_NOT_INSTALLED, {\n          library: libraryName\n        }, error);\n      }\n    }\n    let nodeModulesPath = path_1.default.dirname(path_1.default.dirname(packageJsonPath));\n    if (this._isScopedPackage(sourceName)) {\n      nodeModulesPath = path_1.default.dirname(nodeModulesPath);\n    }\n    await this._validateSourceNameExistenceAndCasing(nodeModulesPath, sourceName, true);\n    const packageInfo = await fs_extra_1.default.readJson(packageJsonPath);\n    const libraryVersion = packageInfo.version;\n    return this._resolveFile(sourceName,\n    // We resolve to the real path here, as we may be resolving a linked library\n    await (0, fs_utils_1.getRealPath)(path_1.default.join(nodeModulesPath, sourceName)), libraryName, libraryVersion);\n  }\n  async _relativeImportToSourceName(from, imported) {\n    // This is a special case, were we turn relative imports from local files\n    // into library imports if necessary. The reason for this is that many\n    // users just do `import \"../node_modules/lib/a.sol\";`.\n    if (this._isRelativeImportToLibrary(from, imported)) {\n      return this._relativeImportToLibraryToSourceName(from, imported);\n    }\n    const sourceName = (0, source_names_1.normalizeSourceName)(path_1.default.join(path_1.default.dirname(from.sourceName), imported));\n    // If the file with the import is local, and the normalized version\n    // starts with ../ means that it's trying to get outside of the project.\n    if (from.library === undefined && sourceName.startsWith(\"../\")) {\n      throw new errors_1.HardhatError(errors_list_1.ERRORS.RESOLVER.INVALID_IMPORT_OUTSIDE_OF_PROJECT, {\n        from: from.sourceName,\n        imported\n      });\n    }\n    if (from.library !== undefined && !this._isInsideSameDir(from.sourceName, sourceName)) {\n      // If the file is being imported from a library, this means that it's\n      // trying to reach another one.\n      throw new errors_1.HardhatError(errors_list_1.ERRORS.RESOLVER.ILLEGAL_IMPORT, {\n        from: from.sourceName,\n        imported\n      });\n    }\n    return sourceName;\n  }\n  async _resolveFile(sourceName, absolutePath, libraryName, libraryVersion) {\n    const rawContent = await this._readFile(absolutePath);\n    const stats = await fs_extra_1.default.stat(absolutePath);\n    const lastModificationDate = new Date(stats.ctime);\n    const contentHash = (0, hash_1.createNonCryptographicHashBasedIdentifier)(Buffer.from(rawContent)).toString(\"hex\");\n    const parsedContent = this._parser.parse(rawContent, absolutePath, contentHash);\n    const content = {\n      rawContent,\n      ...parsedContent\n    };\n    return new ResolvedFile(sourceName, absolutePath, content, contentHash, lastModificationDate, libraryName, libraryVersion);\n  }\n  _isRelativeImport(imported) {\n    return imported.startsWith(\"./\") || imported.startsWith(\"../\");\n  }\n  _resolveNodeModulesFileFromProjectRoot(fileName) {\n    return resolve_1.default.sync(fileName, {\n      basedir: this._projectRoot,\n      preserveSymlinks: true\n    });\n  }\n  _getLibraryName(sourceName) {\n    let endIndex;\n    if (this._isScopedPackage(sourceName)) {\n      endIndex = sourceName.indexOf(\"/\", sourceName.indexOf(\"/\") + 1);\n    } else if (sourceName.indexOf(\"/\") === -1) {\n      endIndex = sourceName.length;\n    } else {\n      endIndex = sourceName.indexOf(\"/\");\n    }\n    return sourceName.slice(0, endIndex);\n  }\n  _getUriScheme(s) {\n    const re = /([a-zA-Z]+):\\/\\//;\n    const match = re.exec(s);\n    if (match === null) {\n      return undefined;\n    }\n    return match[1];\n  }\n  _isInsideSameDir(sourceNameInDir, sourceNameToTest) {\n    const firstSlash = sourceNameInDir.indexOf(\"/\");\n    const dir = firstSlash !== -1 ? sourceNameInDir.substring(0, firstSlash) : sourceNameInDir;\n    return sourceNameToTest.startsWith(dir);\n  }\n  _isScopedPackage(packageOrPackageFile) {\n    return packageOrPackageFile.startsWith(\"@\");\n  }\n  _isRelativeImportToLibrary(from, imported) {\n    return this._isRelativeImport(imported) && from.library === undefined && imported.includes(`${NODE_MODULES}/`);\n  }\n  _relativeImportToLibraryToSourceName(from, imported) {\n    const sourceName = (0, source_names_1.normalizeSourceName)(path_1.default.join(path_1.default.dirname(from.sourceName), imported));\n    const nmIndex = sourceName.indexOf(`${NODE_MODULES}/`);\n    return sourceName.substr(nmIndex + NODE_MODULES.length + 1);\n  }\n  async _validateSourceNameExistenceAndCasing(fromDir, sourceName, isLibrary) {\n    try {\n      await (0, source_names_1.validateSourceNameExistenceAndCasing)(fromDir, sourceName);\n    } catch (error) {\n      if (errors_1.HardhatError.isHardhatErrorType(error, errors_list_1.ERRORS.SOURCE_NAMES.FILE_NOT_FOUND)) {\n        throw new errors_1.HardhatError(isLibrary ? errors_list_1.ERRORS.RESOLVER.LIBRARY_FILE_NOT_FOUND : errors_list_1.ERRORS.RESOLVER.FILE_NOT_FOUND, {\n          file: sourceName\n        }, error);\n      }\n      if (errors_1.HardhatError.isHardhatErrorType(error, errors_list_1.ERRORS.SOURCE_NAMES.WRONG_CASING)) {\n        throw new errors_1.HardhatError(errors_list_1.ERRORS.RESOLVER.WRONG_SOURCE_NAME_CASING, {\n          incorrect: sourceName,\n          correct: error.messageArguments.correct\n        }, error);\n      }\n      // eslint-disable-next-line @nomiclabs/hardhat-internal-rules/only-hardhat-error\n      throw error;\n    }\n  }\n}\nexports.Resolver = Resolver;","map":{"version":3,"mappings":"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","names":["NODE_MODULES","ResolvedFile","constructor","sourceName","absolutePath","content","contentHash","lastModificationDate","libraryName","libraryVersion","undefined","library","name","version","getVersionedName","exports","Resolver","_projectRoot","_parser","_readFile","_transformImportName","Map","resolveSourceName","cached","_cache","get","resolvedFile","_resolveLocalSourceName","_resolveLibrarySourceName","set","resolveImport","from","importName","imported","scheme","_getUriScheme","errors_1","errors_list_1","RESOLVER","INVALID_IMPORT_PROTOCOL","protocol","INVALID_IMPORT_BACKSLASH","INVALID_IMPORT_ABSOLUTE_PATH","INCLUDES_OWN_PACKAGE_NAME","isRelativeImport","_isRelativeImport","_relativeImportToSourceName","_isRelativeImportToLibrary","error","isHardhatErrorType","FILE_NOT_FOUND","LIBRARY_FILE_NOT_FOUND","IMPORTED_MAPPED_FILE_NOT_FOUND","IMPORTED_FILE_NOT_FOUND","WRONG_SOURCE_NAME_CASING","INVALID_IMPORT_WRONG_CASING","LIBRARY_NOT_INSTALLED","IMPORTED_LIBRARY_NOT_INSTALLED","messageArguments","_validateSourceNameExistenceAndCasing","path_1","join","_resolveFile","_getLibraryName","packageJsonPath","_resolveNodeModulesFileFromProjectRoot","hardhatCoreDir","__dirname","nodeModulesPath","dirname","_isScopedPackage","packageInfo","fs_extra_1","readJson","_relativeImportToLibraryToSourceName","startsWith","INVALID_IMPORT_OUTSIDE_OF_PROJECT","_isInsideSameDir","ILLEGAL_IMPORT","rawContent","stats","stat","Date","ctime","Buffer","toString","parsedContent","parse","fileName","resolve_1","sync","basedir","preserveSymlinks","endIndex","indexOf","length","slice","s","re","match","exec","sourceNameInDir","sourceNameToTest","firstSlash","dir","substring","packageOrPackageFile","includes","nmIndex","substr","fromDir","isLibrary","SOURCE_NAMES","file","WRONG_CASING","incorrect","correct"],"sources":["/Users/janrobel/Documents/PersonalProjekty/nftGenerateAi/clientAndContract/node_modules/hardhat/src/internal/solidity/resolver.ts"],"sourcesContent":["import fsExtra from \"fs-extra\";\nimport path from \"path\";\nimport resolve from \"resolve\";\n\nimport {\n  FileContent,\n  LibraryInfo,\n  ResolvedFile as IResolvedFile,\n} from \"../../types/builtin-tasks\";\nimport {\n  includesOwnPackageName,\n  isAbsolutePathSourceName,\n  isLocalSourceName,\n  normalizeSourceName,\n  replaceBackslashes,\n  validateSourceNameExistenceAndCasing,\n  validateSourceNameFormat,\n} from \"../../utils/source-names\";\nimport { assertHardhatInvariant, HardhatError } from \"../core/errors\";\nimport { ERRORS } from \"../core/errors-list\";\nimport { createNonCryptographicHashBasedIdentifier } from \"../util/hash\";\n\nimport { getRealPath } from \"../util/fs-utils\";\nimport { Parser } from \"./parse\";\n\nexport interface ResolvedFilesMap {\n  [sourceName: string]: ResolvedFile;\n}\n\nconst NODE_MODULES = \"node_modules\";\n\nexport class ResolvedFile implements IResolvedFile {\n  public readonly library?: LibraryInfo;\n\n  constructor(\n    public readonly sourceName: string,\n    public readonly absolutePath: string,\n    public readonly content: FileContent,\n    public readonly contentHash: string,\n    public readonly lastModificationDate: Date,\n    libraryName?: string,\n    libraryVersion?: string\n  ) {\n    assertHardhatInvariant(\n      (libraryName === undefined && libraryVersion === undefined) ||\n        (libraryName !== undefined && libraryVersion !== undefined),\n      \"Libraries should have both name and version, or neither one\"\n    );\n\n    if (libraryName !== undefined && libraryVersion !== undefined) {\n      this.library = {\n        name: libraryName,\n        version: libraryVersion,\n      };\n    }\n  }\n\n  public getVersionedName() {\n    return (\n      this.sourceName +\n      (this.library !== undefined ? `@v${this.library.version}` : \"\")\n    );\n  }\n}\n\nexport class Resolver {\n  private readonly _cache: Map<string, ResolvedFile> = new Map();\n\n  constructor(\n    private readonly _projectRoot: string,\n    private readonly _parser: Parser,\n    private readonly _readFile: (absolutePath: string) => Promise<string>,\n    private readonly _transformImportName: (\n      importName: string\n    ) => Promise<string>\n  ) {}\n\n  /**\n   * Resolves a source name into a ResolvedFile.\n   *\n   * @param sourceName The source name as it would be provided to solc.\n   */\n  public async resolveSourceName(sourceName: string): Promise<ResolvedFile> {\n    const cached = this._cache.get(sourceName);\n    if (cached !== undefined) {\n      return cached;\n    }\n\n    validateSourceNameFormat(sourceName);\n\n    let resolvedFile: ResolvedFile;\n\n    if (await isLocalSourceName(this._projectRoot, sourceName)) {\n      resolvedFile = await this._resolveLocalSourceName(sourceName);\n    } else {\n      resolvedFile = await this._resolveLibrarySourceName(sourceName);\n    }\n\n    this._cache.set(sourceName, resolvedFile);\n    return resolvedFile;\n  }\n\n  /**\n   * Resolves an import from an already resolved file.\n   * @param from The file were the import statement is present.\n   * @param importName The path in the import statement.\n   */\n  public async resolveImport(\n    from: ResolvedFile,\n    importName: string\n  ): Promise<ResolvedFile> {\n    const imported = await this._transformImportName(importName);\n\n    const scheme = this._getUriScheme(imported);\n    if (scheme !== undefined) {\n      throw new HardhatError(ERRORS.RESOLVER.INVALID_IMPORT_PROTOCOL, {\n        from: from.sourceName,\n        imported,\n        protocol: scheme,\n      });\n    }\n\n    if (replaceBackslashes(imported) !== imported) {\n      throw new HardhatError(ERRORS.RESOLVER.INVALID_IMPORT_BACKSLASH, {\n        from: from.sourceName,\n        imported,\n      });\n    }\n\n    if (isAbsolutePathSourceName(imported)) {\n      throw new HardhatError(ERRORS.RESOLVER.INVALID_IMPORT_ABSOLUTE_PATH, {\n        from: from.sourceName,\n        imported,\n      });\n    }\n\n    // Edge-case where an import can contain the current package's name in monorepos.\n    // The path can be resolved because there's a symlink in the node modules.\n    if (await includesOwnPackageName(imported)) {\n      throw new HardhatError(ERRORS.RESOLVER.INCLUDES_OWN_PACKAGE_NAME, {\n        from: from.sourceName,\n        imported,\n      });\n    }\n\n    try {\n      let sourceName: string;\n\n      const isRelativeImport = this._isRelativeImport(imported);\n\n      if (isRelativeImport) {\n        sourceName = await this._relativeImportToSourceName(from, imported);\n      } else {\n        sourceName = normalizeSourceName(imported);\n      }\n\n      const cached = this._cache.get(sourceName);\n      if (cached !== undefined) {\n        return cached;\n      }\n\n      let resolvedFile: ResolvedFile;\n\n      // We have this special case here, because otherwise local relative\n      // imports can be treated as library imports. For example if\n      // `contracts/c.sol` imports `../non-existent/a.sol`\n      if (\n        from.library === undefined &&\n        isRelativeImport &&\n        !this._isRelativeImportToLibrary(from, imported)\n      ) {\n        resolvedFile = await this._resolveLocalSourceName(sourceName);\n      } else {\n        resolvedFile = await this.resolveSourceName(sourceName);\n      }\n\n      this._cache.set(sourceName, resolvedFile);\n      return resolvedFile;\n    } catch (error) {\n      if (\n        HardhatError.isHardhatErrorType(\n          error,\n          ERRORS.RESOLVER.FILE_NOT_FOUND\n        ) ||\n        HardhatError.isHardhatErrorType(\n          error,\n          ERRORS.RESOLVER.LIBRARY_FILE_NOT_FOUND\n        )\n      ) {\n        if (imported !== importName) {\n          throw new HardhatError(\n            ERRORS.RESOLVER.IMPORTED_MAPPED_FILE_NOT_FOUND,\n            {\n              imported,\n              importName,\n              from: from.sourceName,\n            },\n            error\n          );\n        } else {\n          throw new HardhatError(\n            ERRORS.RESOLVER.IMPORTED_FILE_NOT_FOUND,\n            {\n              imported,\n              from: from.sourceName,\n            },\n            error\n          );\n        }\n      }\n\n      if (\n        HardhatError.isHardhatErrorType(\n          error,\n          ERRORS.RESOLVER.WRONG_SOURCE_NAME_CASING\n        )\n      ) {\n        throw new HardhatError(\n          ERRORS.RESOLVER.INVALID_IMPORT_WRONG_CASING,\n          {\n            imported,\n            from: from.sourceName,\n          },\n          error\n        );\n      }\n\n      if (\n        HardhatError.isHardhatErrorType(\n          error,\n          ERRORS.RESOLVER.LIBRARY_NOT_INSTALLED\n        )\n      ) {\n        throw new HardhatError(\n          ERRORS.RESOLVER.IMPORTED_LIBRARY_NOT_INSTALLED,\n          {\n            library: error.messageArguments.library,\n            from: from.sourceName,\n          },\n          error\n        );\n      }\n\n      // eslint-disable-next-line @nomiclabs/hardhat-internal-rules/only-hardhat-error\n      throw error;\n    }\n  }\n\n  private async _resolveLocalSourceName(\n    sourceName: string\n  ): Promise<ResolvedFile> {\n    await this._validateSourceNameExistenceAndCasing(\n      this._projectRoot,\n      sourceName,\n      false\n    );\n\n    const absolutePath = path.join(this._projectRoot, sourceName);\n    return this._resolveFile(sourceName, absolutePath);\n  }\n\n  private async _resolveLibrarySourceName(\n    sourceName: string\n  ): Promise<ResolvedFile> {\n    const libraryName = this._getLibraryName(sourceName);\n\n    let packageJsonPath;\n    try {\n      packageJsonPath = this._resolveNodeModulesFileFromProjectRoot(\n        path.join(libraryName, \"package.json\")\n      );\n    } catch (error) {\n      // if the project is using a dependency from hardhat itself but it can't\n      // be found, this means that a global installation is being used, so we\n      // resolve the dependency relative to this file\n      if (libraryName === \"hardhat\") {\n        const hardhatCoreDir = path.join(__dirname, \"..\", \"..\");\n        packageJsonPath = path.join(hardhatCoreDir, \"package.json\");\n      } else {\n        throw new HardhatError(\n          ERRORS.RESOLVER.LIBRARY_NOT_INSTALLED,\n          {\n            library: libraryName,\n          },\n          error as Error\n        );\n      }\n    }\n\n    let nodeModulesPath = path.dirname(path.dirname(packageJsonPath));\n    if (this._isScopedPackage(sourceName)) {\n      nodeModulesPath = path.dirname(nodeModulesPath);\n    }\n\n    await this._validateSourceNameExistenceAndCasing(\n      nodeModulesPath,\n      sourceName,\n      true\n    );\n\n    const packageInfo: {\n      name: string;\n      version: string;\n    } = await fsExtra.readJson(packageJsonPath);\n    const libraryVersion = packageInfo.version;\n\n    return this._resolveFile(\n      sourceName,\n      // We resolve to the real path here, as we may be resolving a linked library\n      await getRealPath(path.join(nodeModulesPath, sourceName)),\n      libraryName,\n      libraryVersion\n    );\n  }\n\n  private async _relativeImportToSourceName(\n    from: ResolvedFile,\n    imported: string\n  ): Promise<string> {\n    // This is a special case, were we turn relative imports from local files\n    // into library imports if necessary. The reason for this is that many\n    // users just do `import \"../node_modules/lib/a.sol\";`.\n    if (this._isRelativeImportToLibrary(from, imported)) {\n      return this._relativeImportToLibraryToSourceName(from, imported);\n    }\n\n    const sourceName = normalizeSourceName(\n      path.join(path.dirname(from.sourceName), imported)\n    );\n\n    // If the file with the import is local, and the normalized version\n    // starts with ../ means that it's trying to get outside of the project.\n    if (from.library === undefined && sourceName.startsWith(\"../\")) {\n      throw new HardhatError(\n        ERRORS.RESOLVER.INVALID_IMPORT_OUTSIDE_OF_PROJECT,\n        { from: from.sourceName, imported }\n      );\n    }\n\n    if (\n      from.library !== undefined &&\n      !this._isInsideSameDir(from.sourceName, sourceName)\n    ) {\n      // If the file is being imported from a library, this means that it's\n      // trying to reach another one.\n      throw new HardhatError(ERRORS.RESOLVER.ILLEGAL_IMPORT, {\n        from: from.sourceName,\n        imported,\n      });\n    }\n\n    return sourceName;\n  }\n\n  private async _resolveFile(\n    sourceName: string,\n    absolutePath: string,\n    libraryName?: string,\n    libraryVersion?: string\n  ): Promise<ResolvedFile> {\n    const rawContent = await this._readFile(absolutePath);\n    const stats = await fsExtra.stat(absolutePath);\n    const lastModificationDate = new Date(stats.ctime);\n\n    const contentHash = createNonCryptographicHashBasedIdentifier(\n      Buffer.from(rawContent)\n    ).toString(\"hex\");\n\n    const parsedContent = this._parser.parse(\n      rawContent,\n      absolutePath,\n      contentHash\n    );\n\n    const content = {\n      rawContent,\n      ...parsedContent,\n    };\n\n    return new ResolvedFile(\n      sourceName,\n      absolutePath,\n      content,\n      contentHash,\n      lastModificationDate,\n      libraryName,\n      libraryVersion\n    );\n  }\n\n  private _isRelativeImport(imported: string): boolean {\n    return imported.startsWith(\"./\") || imported.startsWith(\"../\");\n  }\n\n  private _resolveNodeModulesFileFromProjectRoot(fileName: string) {\n    return resolve.sync(fileName, {\n      basedir: this._projectRoot,\n      preserveSymlinks: true,\n    });\n  }\n\n  private _getLibraryName(sourceName: string): string {\n    let endIndex: number;\n    if (this._isScopedPackage(sourceName)) {\n      endIndex = sourceName.indexOf(\"/\", sourceName.indexOf(\"/\") + 1);\n    } else if (sourceName.indexOf(\"/\") === -1) {\n      endIndex = sourceName.length;\n    } else {\n      endIndex = sourceName.indexOf(\"/\");\n    }\n\n    return sourceName.slice(0, endIndex);\n  }\n\n  private _getUriScheme(s: string): string | undefined {\n    const re = /([a-zA-Z]+):\\/\\//;\n    const match = re.exec(s);\n    if (match === null) {\n      return undefined;\n    }\n\n    return match[1];\n  }\n\n  private _isInsideSameDir(sourceNameInDir: string, sourceNameToTest: string) {\n    const firstSlash = sourceNameInDir.indexOf(\"/\");\n    const dir =\n      firstSlash !== -1\n        ? sourceNameInDir.substring(0, firstSlash)\n        : sourceNameInDir;\n\n    return sourceNameToTest.startsWith(dir);\n  }\n\n  private _isScopedPackage(packageOrPackageFile: string): boolean {\n    return packageOrPackageFile.startsWith(\"@\");\n  }\n\n  private _isRelativeImportToLibrary(\n    from: ResolvedFile,\n    imported: string\n  ): boolean {\n    return (\n      this._isRelativeImport(imported) &&\n      from.library === undefined &&\n      imported.includes(`${NODE_MODULES}/`)\n    );\n  }\n\n  private _relativeImportToLibraryToSourceName(\n    from: ResolvedFile,\n    imported: string\n  ): string {\n    const sourceName = normalizeSourceName(\n      path.join(path.dirname(from.sourceName), imported)\n    );\n\n    const nmIndex = sourceName.indexOf(`${NODE_MODULES}/`);\n    return sourceName.substr(nmIndex + NODE_MODULES.length + 1);\n  }\n\n  private async _validateSourceNameExistenceAndCasing(\n    fromDir: string,\n    sourceName: string,\n    isLibrary: boolean\n  ) {\n    try {\n      await validateSourceNameExistenceAndCasing(fromDir, sourceName);\n    } catch (error) {\n      if (\n        HardhatError.isHardhatErrorType(\n          error,\n          ERRORS.SOURCE_NAMES.FILE_NOT_FOUND\n        )\n      ) {\n        throw new HardhatError(\n          isLibrary\n            ? ERRORS.RESOLVER.LIBRARY_FILE_NOT_FOUND\n            : ERRORS.RESOLVER.FILE_NOT_FOUND,\n          { file: sourceName },\n          error\n        );\n      }\n\n      if (\n        HardhatError.isHardhatErrorType(error, ERRORS.SOURCE_NAMES.WRONG_CASING)\n      ) {\n        throw new HardhatError(\n          ERRORS.RESOLVER.WRONG_SOURCE_NAME_CASING,\n          {\n            incorrect: sourceName,\n            correct: error.messageArguments.correct,\n          },\n          error\n        );\n      }\n\n      // eslint-disable-next-line @nomiclabs/hardhat-internal-rules/only-hardhat-error\n      throw error;\n    }\n  }\n}\n"]},"metadata":{},"sourceType":"script","externalDependencies":[]}