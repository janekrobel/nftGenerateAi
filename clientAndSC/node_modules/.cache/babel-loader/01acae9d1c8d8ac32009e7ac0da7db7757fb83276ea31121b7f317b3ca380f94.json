{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.FallbackProvider = void 0;\n/**\n *  Explain all the nitty-gritty about the **FallbackProvider**.\n *\n *  @_section: api/providers/fallback-provider:Fallback Provider [about-fallback-provider]\n */\nconst index_js_1 = require(\"../utils/index.js\");\nconst abstract_provider_js_1 = require(\"./abstract-provider.js\");\nconst network_js_1 = require(\"./network.js\");\nconst BN_1 = BigInt(\"1\");\nconst BN_2 = BigInt(\"2\");\nfunction shuffle(array) {\n  for (let i = array.length - 1; i > 0; i--) {\n    const j = Math.floor(Math.random() * (i + 1));\n    const tmp = array[i];\n    array[i] = array[j];\n    array[j] = tmp;\n  }\n}\nfunction stall(duration) {\n  return new Promise(resolve => {\n    setTimeout(resolve, duration);\n  });\n}\nfunction getTime() {\n  return new Date().getTime();\n}\nfunction stringify(value) {\n  return JSON.stringify(value, (key, value) => {\n    if (typeof value === \"bigint\") {\n      return {\n        type: \"bigint\",\n        value: value.toString()\n      };\n    }\n    return value;\n  });\n}\n;\nconst defaultConfig = {\n  stallTimeout: 400,\n  priority: 1,\n  weight: 1\n};\nconst defaultState = {\n  blockNumber: -2,\n  requests: 0,\n  lateResponses: 0,\n  errorResponses: 0,\n  outOfSync: -1,\n  unsupportedEvents: 0,\n  rollingDuration: 0,\n  score: 0,\n  _network: null,\n  _updateNumber: null,\n  _totalTime: 0\n};\nasync function waitForSync(config, blockNumber) {\n  while (config.blockNumber < 0 || config.blockNumber < blockNumber) {\n    if (!config._updateNumber) {\n      config._updateNumber = (async () => {\n        const blockNumber = await config.provider.getBlockNumber();\n        if (blockNumber > config.blockNumber) {\n          config.blockNumber = blockNumber;\n        }\n        config._updateNumber = null;\n      })();\n    }\n    await config._updateNumber;\n    config.outOfSync++;\n  }\n}\nfunction _normalize(value) {\n  if (value == null) {\n    return \"null\";\n  }\n  if (Array.isArray(value)) {\n    return \"[\" + value.map(_normalize).join(\",\") + \"]\";\n  }\n  if (typeof value === \"object\" && typeof value.toJSON === \"function\") {\n    return _normalize(value.toJSON());\n  }\n  switch (typeof value) {\n    case \"boolean\":\n    case \"symbol\":\n      return value.toString();\n    case \"bigint\":\n    case \"number\":\n      return BigInt(value).toString();\n    case \"string\":\n      return JSON.stringify(value);\n    case \"object\":\n      {\n        const keys = Object.keys(value);\n        keys.sort();\n        return \"{\" + keys.map(k => `${JSON.stringify(k)}:${_normalize(value[k])}`).join(\",\") + \"}\";\n      }\n  }\n  console.log(\"Could not serialize\", value);\n  throw new Error(\"Hmm...\");\n}\nfunction normalizeResult(value) {\n  if (\"error\" in value) {\n    const error = value.error;\n    return {\n      tag: _normalize(error),\n      value: error\n    };\n  }\n  const result = value.result;\n  return {\n    tag: _normalize(result),\n    value: result\n  };\n}\n// This strategy picks the highest weight result, as long as the weight is\n// equal to or greater than quorum\nfunction checkQuorum(quorum, results) {\n  const tally = new Map();\n  for (const {\n    value,\n    tag,\n    weight\n  } of results) {\n    const t = tally.get(tag) || {\n      value,\n      weight: 0\n    };\n    t.weight += weight;\n    tally.set(tag, t);\n  }\n  let best = null;\n  for (const r of tally.values()) {\n    if (r.weight >= quorum && (!best || r.weight > best.weight)) {\n      best = r;\n    }\n  }\n  if (best) {\n    return best.value;\n  }\n  return undefined;\n}\nfunction getMedian(quorum, results) {\n  let resultWeight = 0;\n  const errorMap = new Map();\n  let bestError = null;\n  const values = [];\n  for (const {\n    value,\n    tag,\n    weight\n  } of results) {\n    if (value instanceof Error) {\n      const e = errorMap.get(tag) || {\n        value,\n        weight: 0\n      };\n      e.weight += weight;\n      errorMap.set(tag, e);\n      if (bestError == null || e.weight > bestError.weight) {\n        bestError = e;\n      }\n    } else {\n      values.push(BigInt(value));\n      resultWeight += weight;\n    }\n  }\n  if (resultWeight < quorum) {\n    // We have quorum for an error\n    if (bestError && bestError.weight >= quorum) {\n      return bestError.value;\n    }\n    // We do not have quorum for a result\n    return undefined;\n  }\n  // Get the sorted values\n  values.sort((a, b) => a < b ? -1 : b > a ? 1 : 0);\n  const mid = Math.floor(values.length / 2);\n  // Odd-length; take the middle value\n  if (values.length % 2) {\n    return values[mid];\n  }\n  // Even length; take the ceiling of the mean of the center two values\n  return (values[mid - 1] + values[mid] + BN_1) / BN_2;\n}\nfunction getAnyResult(quorum, results) {\n  // If any value or error meets quorum, that is our preferred result\n  const result = checkQuorum(quorum, results);\n  if (result !== undefined) {\n    return result;\n  }\n  // Otherwise, do we have any result?\n  for (const r of results) {\n    if (r.value) {\n      return r.value;\n    }\n  }\n  // Nope!\n  return undefined;\n}\nfunction getFuzzyMode(quorum, results) {\n  if (quorum === 1) {\n    return (0, index_js_1.getNumber)(getMedian(quorum, results), \"%internal\");\n  }\n  const tally = new Map();\n  const add = (result, weight) => {\n    const t = tally.get(result) || {\n      result,\n      weight: 0\n    };\n    t.weight += weight;\n    tally.set(result, t);\n  };\n  for (const {\n    weight,\n    value\n  } of results) {\n    const r = (0, index_js_1.getNumber)(value);\n    add(r - 1, weight);\n    add(r, weight);\n    add(r + 1, weight);\n  }\n  let bestWeight = 0;\n  let bestResult = undefined;\n  for (const {\n    weight,\n    result\n  } of tally.values()) {\n    // Use this result, if this result meets quorum and has either:\n    // - a better weight\n    // - or equal weight, but the result is larger\n    if (weight >= quorum && (weight > bestWeight || bestResult != null && weight === bestWeight && result > bestResult)) {\n      bestWeight = weight;\n      bestResult = result;\n    }\n  }\n  return bestResult;\n}\n/**\n *  A Fallback Provider.\n *\n */\nclass FallbackProvider extends abstract_provider_js_1.AbstractProvider {\n  quorum;\n  eventQuorum;\n  eventWorkers;\n  #configs;\n  #height;\n  #initialSyncPromise;\n  constructor(providers, network) {\n    super(network);\n    this.#configs = providers.map(p => {\n      if (p instanceof abstract_provider_js_1.AbstractProvider) {\n        return Object.assign({\n          provider: p\n        }, defaultConfig, defaultState);\n      } else {\n        return Object.assign({}, defaultConfig, p, defaultState);\n      }\n    });\n    this.#height = -2;\n    this.#initialSyncPromise = null;\n    this.quorum = 2; //Math.ceil(providers.length /  2);\n    this.eventQuorum = 1;\n    this.eventWorkers = 1;\n    (0, index_js_1.assertArgument)(this.quorum <= this.#configs.reduce((a, c) => a + c.weight, 0), \"quorum exceed provider wieght\", \"quorum\", this.quorum);\n  }\n  get providerConfigs() {\n    return this.#configs.map(c => {\n      const result = Object.assign({}, c);\n      for (const key in result) {\n        if (key[0] === \"_\") {\n          delete result[key];\n        }\n      }\n      return result;\n    });\n  }\n  async _detectNetwork() {\n    return network_js_1.Network.from((0, index_js_1.getBigInt)(await this._perform({\n      method: \"chainId\"\n    })));\n  }\n  // @TODO: Add support to select providers to be the event subscriber\n  //_getSubscriber(sub: Subscription): Subscriber {\n  //    throw new Error(\"@TODO\");\n  //}\n  async _translatePerform(provider, req) {\n    switch (req.method) {\n      case \"broadcastTransaction\":\n        return await provider.broadcastTransaction(req.signedTransaction);\n      case \"call\":\n        return await provider.call(Object.assign({}, req.transaction, {\n          blockTag: req.blockTag\n        }));\n      case \"chainId\":\n        return (await provider.getNetwork()).chainId;\n      case \"estimateGas\":\n        return await provider.estimateGas(req.transaction);\n      case \"getBalance\":\n        return await provider.getBalance(req.address, req.blockTag);\n      case \"getBlock\":\n        {\n          const block = \"blockHash\" in req ? req.blockHash : req.blockTag;\n          return await provider.getBlock(block, req.includeTransactions);\n        }\n      case \"getBlockNumber\":\n        return await provider.getBlockNumber();\n      case \"getCode\":\n        return await provider.getCode(req.address, req.blockTag);\n      case \"getGasPrice\":\n        return (await provider.getFeeData()).gasPrice;\n      case \"getLogs\":\n        return await provider.getLogs(req.filter);\n      case \"getStorage\":\n        return await provider.getStorage(req.address, req.position, req.blockTag);\n      case \"getTransaction\":\n        return await provider.getTransaction(req.hash);\n      case \"getTransactionCount\":\n        return await provider.getTransactionCount(req.address, req.blockTag);\n      case \"getTransactionReceipt\":\n        return await provider.getTransactionReceipt(req.hash);\n      case \"getTransactionResult\":\n        return await provider.getTransactionResult(req.hash);\n    }\n  }\n  // Grab the next (random) config that is not already part of\n  // the running set\n  #getNextConfig(running) {\n    // @TODO: Maybe do a check here to favour (heavily) providers that\n    //        do not require waitForSync and disfavour providers that\n    //        seem down-ish or are behaving slowly\n    const configs = Array.from(running).map(r => r.config);\n    // Shuffle the states, sorted by priority\n    const allConfigs = this.#configs.slice();\n    shuffle(allConfigs);\n    allConfigs.sort((a, b) => b.priority - a.priority);\n    for (const config of allConfigs) {\n      if (configs.indexOf(config) === -1) {\n        return config;\n      }\n    }\n    return null;\n  }\n  // Adds a new runner (if available) to running.\n  #addRunner(running, req) {\n    const config = this.#getNextConfig(running);\n    // No runners available\n    if (config == null) {\n      return null;\n    }\n    // Create a new runner\n    const runner = {\n      config,\n      result: null,\n      didBump: false,\n      perform: null,\n      staller: null\n    };\n    const now = getTime();\n    // Start performing this operation\n    runner.perform = (async () => {\n      try {\n        config.requests++;\n        const result = await this._translatePerform(config.provider, req);\n        runner.result = {\n          result\n        };\n      } catch (error) {\n        config.errorResponses++;\n        runner.result = {\n          error\n        };\n      }\n      const dt = getTime() - now;\n      config._totalTime += dt;\n      config.rollingDuration = 0.95 * config.rollingDuration + 0.05 * dt;\n      runner.perform = null;\n    })();\n    // Start a staller; when this times out, it's time to force\n    // kicking off another runner because we are taking too long\n    runner.staller = (async () => {\n      await stall(config.stallTimeout);\n      runner.staller = null;\n    })();\n    running.add(runner);\n    return runner;\n  }\n  // Initializes the blockNumber and network for each runner and\n  // blocks until initialized\n  async #initialSync() {\n    let initialSync = this.#initialSyncPromise;\n    if (!initialSync) {\n      const promises = [];\n      this.#configs.forEach(config => {\n        promises.push(waitForSync(config, 0));\n        promises.push((async () => {\n          config._network = await config.provider.getNetwork();\n        })());\n      });\n      this.#initialSyncPromise = initialSync = (async () => {\n        // Wait for all providers to have a block number and network\n        await Promise.all(promises);\n        // Check all the networks match\n        let chainId = null;\n        for (const config of this.#configs) {\n          const network = config._network;\n          if (chainId == null) {\n            chainId = network.chainId;\n          } else if (network.chainId !== chainId) {\n            (0, index_js_1.assert)(false, \"cannot mix providers on different networks\", \"UNSUPPORTED_OPERATION\", {\n              operation: \"new FallbackProvider\"\n            });\n          }\n        }\n      })();\n    }\n    await initialSync;\n  }\n  async #checkQuorum(running, req) {\n    // Get all the result objects\n    const results = [];\n    for (const runner of running) {\n      if (runner.result != null) {\n        const {\n          tag,\n          value\n        } = normalizeResult(runner.result);\n        results.push({\n          tag,\n          value,\n          weight: runner.config.weight\n        });\n      }\n    }\n    // Are there enough results to event meet quorum?\n    if (results.reduce((a, r) => a + r.weight, 0) < this.quorum) {\n      return undefined;\n    }\n    switch (req.method) {\n      case \"getBlockNumber\":\n        {\n          // We need to get the bootstrap block height\n          if (this.#height === -2) {\n            this.#height = Math.ceil((0, index_js_1.getNumber)(getMedian(this.quorum, this.#configs.map(c => ({\n              value: c.blockNumber,\n              tag: (0, index_js_1.getNumber)(c.blockNumber).toString(),\n              weight: c.weight\n            })))));\n          }\n          // Find the mode across all the providers, allowing for\n          // a little drift between block heights\n          const mode = getFuzzyMode(this.quorum, results);\n          if (mode === undefined) {\n            return undefined;\n          }\n          if (mode > this.#height) {\n            this.#height = mode;\n          }\n          return this.#height;\n        }\n      case \"getGasPrice\":\n      case \"estimateGas\":\n        return getMedian(this.quorum, results);\n      case \"getBlock\":\n        // Pending blocks are in the mempool and already\n        // quite untrustworthy; just grab anything\n        if (\"blockTag\" in req && req.blockTag === \"pending\") {\n          return getAnyResult(this.quorum, results);\n        }\n        return checkQuorum(this.quorum, results);\n      case \"call\":\n      case \"chainId\":\n      case \"getBalance\":\n      case \"getTransactionCount\":\n      case \"getCode\":\n      case \"getStorage\":\n      case \"getTransaction\":\n      case \"getTransactionReceipt\":\n      case \"getLogs\":\n        return checkQuorum(this.quorum, results);\n      case \"broadcastTransaction\":\n        return getAnyResult(this.quorum, results);\n    }\n    (0, index_js_1.assert)(false, \"unsupported method\", \"UNSUPPORTED_OPERATION\", {\n      operation: `_perform(${stringify(req.method)})`\n    });\n  }\n  async #waitForQuorum(running, req) {\n    if (running.size === 0) {\n      throw new Error(\"no runners?!\");\n    }\n    // Any promises that are interesting to watch for; an expired stall\n    // or a successful perform\n    const interesting = [];\n    let newRunners = 0;\n    for (const runner of running) {\n      // No responses, yet; keep an eye on it\n      if (runner.perform) {\n        interesting.push(runner.perform);\n      }\n      // Still stalling...\n      if (runner.staller) {\n        interesting.push(runner.staller);\n        continue;\n      }\n      // This runner has already triggered another runner\n      if (runner.didBump) {\n        continue;\n      }\n      // Got a response (result or error) or stalled; kick off another runner\n      runner.didBump = true;\n      newRunners++;\n    }\n    // Check if we have reached quorum on a result (or error)\n    const value = await this.#checkQuorum(running, req);\n    if (value !== undefined) {\n      if (value instanceof Error) {\n        throw value;\n      }\n      return value;\n    }\n    // Add any new runners, because a staller timed out or a result\n    // or error response came in.\n    for (let i = 0; i < newRunners; i++) {\n      this.#addRunner(running, req);\n    }\n    // All providers have returned, and we have no result\n    (0, index_js_1.assert)(interesting.length > 0, \"quorum not met\", \"SERVER_ERROR\", {\n      request: \"%sub-requests\",\n      info: {\n        request: req,\n        results: Array.from(running).map(r => stringify(r.result))\n      }\n    });\n    // Wait for someone to either complete its perform or stall out\n    await Promise.race(interesting);\n    // This is recursive, but at worst case the depth is 2x the\n    // number of providers (each has a perform and a staller)\n    return await this.#waitForQuorum(running, req);\n  }\n  async _perform(req) {\n    // Broadcasting a transaction is rare (ish) and already incurs\n    // a cost on the user, so spamming is safe-ish. Just send it to\n    // every backend.\n    if (req.method === \"broadcastTransaction\") {\n      const results = await Promise.all(this.#configs.map(async _ref => {\n        let {\n          provider,\n          weight\n        } = _ref;\n        try {\n          const result = await provider._perform(req);\n          return Object.assign(normalizeResult({\n            result\n          }), {\n            weight\n          });\n        } catch (error) {\n          return Object.assign(normalizeResult({\n            error\n          }), {\n            weight\n          });\n        }\n      }));\n      const result = getAnyResult(this.quorum, results);\n      (0, index_js_1.assert)(result !== undefined, \"problem multi-broadcasting\", \"SERVER_ERROR\", {\n        request: \"%sub-requests\",\n        info: {\n          request: req,\n          results: results.map(stringify)\n        }\n      });\n      if (result instanceof Error) {\n        throw result;\n      }\n      return result;\n    }\n    await this.#initialSync();\n    // Bootstrap enough runners to meet quorum\n    const running = new Set();\n    for (let i = 0; i < this.quorum; i++) {\n      this.#addRunner(running, req);\n    }\n    const result = await this.#waitForQuorum(running, req);\n    // Track requests sent to a provider that are still\n    // outstanding after quorum has been otherwise found\n    for (const runner of running) {\n      if (runner.perform && runner.result == null) {\n        runner.config.lateResponses++;\n      }\n    }\n    return result;\n  }\n  async destroy() {\n    for (const {\n      provider\n    } of this.#configs) {\n      provider.destroy();\n    }\n    super.destroy();\n  }\n}\nexports.FallbackProvider = FallbackProvider;","map":{"version":3,"mappings":"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","names":["BN_1","BigInt","BN_2","shuffle","array","i","length","j","Math","floor","random","tmp","stall","duration","Promise","resolve","setTimeout","getTime","Date","stringify","value","JSON","key","type","toString","defaultConfig","stallTimeout","priority","weight","defaultState","blockNumber","requests","lateResponses","errorResponses","outOfSync","unsupportedEvents","rollingDuration","score","_network","_updateNumber","_totalTime","waitForSync","config","provider","getBlockNumber","_normalize","Array","isArray","map","join","toJSON","keys","Object","sort","k","console","log","Error","normalizeResult","error","tag","result","checkQuorum","quorum","results","tally","Map","t","get","set","best","r","values","undefined","getMedian","resultWeight","errorMap","bestError","e","push","a","b","mid","getAnyResult","getFuzzyMode","add","bestWeight","bestResult","FallbackProvider","abstract_provider_js_1","eventQuorum","eventWorkers","constructor","providers","network","p","assign","reduce","c","providerConfigs","_detectNetwork","network_js_1","from","_perform","method","_translatePerform","req","broadcastTransaction","signedTransaction","call","transaction","blockTag","getNetwork","chainId","estimateGas","getBalance","address","block","blockHash","getBlock","includeTransactions","getCode","getFeeData","gasPrice","getLogs","filter","getStorage","position","getTransaction","hash","getTransactionCount","getTransactionReceipt","getTransactionResult","running","configs","allConfigs","slice","indexOf","runner","didBump","perform","staller","now","dt","initialSync","promises","forEach","all","operation","ceil","mode","size","interesting","newRunners","request","info","race","Set","destroy","exports"],"sources":["/Users/janrobel/Documents/PersonalProjekty/nftGenerateAi/clientAndContract/node_modules/ethers/src.ts/providers/provider-fallback.ts"],"sourcesContent":["/**\n *  Explain all the nitty-gritty about the **FallbackProvider**.\n *\n *  @_section: api/providers/fallback-provider:Fallback Provider [about-fallback-provider]\n */\nimport {\n    getBigInt, getNumber, assert, assertArgument\n} from \"../utils/index.js\";\n\nimport { AbstractProvider } from \"./abstract-provider.js\";\nimport { Network } from \"./network.js\"\n\nimport type { PerformActionRequest } from \"./abstract-provider.js\";\nimport type { Networkish } from \"./network.js\"\n\nconst BN_1 = BigInt(\"1\");\nconst BN_2 = BigInt(\"2\");\n\nfunction shuffle<T = any>(array: Array<T>): void {\n    for (let i = array.length - 1; i > 0; i--) {\n        const j = Math.floor(Math.random() * (i + 1));\n        const tmp = array[i];\n        array[i] = array[j];\n        array[j] = tmp;\n    }\n}\n\nfunction stall(duration: number): Promise<void> {\n    return new Promise((resolve) => { setTimeout(resolve, duration); });\n}\n\nfunction getTime(): number { return (new Date()).getTime(); }\n\nfunction stringify(value: any): string {\n    return JSON.stringify(value, (key, value) => {\n        if (typeof(value) === \"bigint\") {\n            return { type: \"bigint\", value: value.toString() };\n        }\n        return value;\n    });\n}\n\n/**\n *  A configuration entry for how to use a [[Provider]].\n */\nexport interface FallbackProviderConfig {\n\n    // The provider\n    provider: AbstractProvider;\n\n    // How long to wait for a response before getting impatient\n    // and ispatching the next provider\n    stallTimeout?: number;\n\n    // Lower values are dispatched first\n    priority?: number;\n\n    // How much this provider contributes to the quorum\n    weight?: number;\n};\n\nconst defaultConfig = { stallTimeout: 400, priority: 1, weight: 1 };\n\n// We track a bunch of extra stuff that might help debug problems or\n// optimize infrastructure later on.\n/**\n *  The statistics and state maintained for a [[Provider]].\n */\nexport interface FallbackProviderState extends Required<FallbackProviderConfig> {\n\n    // The most recent blockNumber this provider has reported (-2 if none)\n    blockNumber: number;\n\n    // The number of total requests ever sent to this provider\n    requests: number;\n\n    // The number of responses that errored\n    errorResponses: number;\n\n    // The number of responses that occured after the result resolved\n    lateResponses: number;\n\n    // How many times syncing was required to catch up the expected block\n    outOfSync: number;\n\n    // The number of requests which reported unsupported operation\n    unsupportedEvents: number;\n\n    // A rolling average (5% current duration) for response time\n    rollingDuration: number;\n\n    // The ratio of quorum-agreed results to total\n    score: number;\n}\n\ninterface Config extends FallbackProviderState {\n    _updateNumber: null | Promise<any>;\n    _network: null | Network;\n    _totalTime: number;\n}\n\nconst defaultState = {\n    blockNumber: -2, requests: 0, lateResponses: 0, errorResponses: 0,\n    outOfSync: -1, unsupportedEvents: 0, rollingDuration: 0, score: 0,\n    _network: null, _updateNumber: null, _totalTime: 0\n};\n\n\nasync function waitForSync(config: Config, blockNumber: number): Promise<void> {\n    while (config.blockNumber < 0 || config.blockNumber < blockNumber) {\n        if (!config._updateNumber) {\n            config._updateNumber = (async () => {\n                const blockNumber = await config.provider.getBlockNumber();\n                if (blockNumber > config.blockNumber) {\n                    config.blockNumber = blockNumber;\n                }\n                config._updateNumber = null;\n            })();\n        }\n        await config._updateNumber;\n        config.outOfSync++;\n    }\n}\n\n/**\n *  Additional options to configure a [[FallbackProvider]].\n */\nexport type FallbackProviderOptions = {\n    // How many providers must agree on a value before reporting\n    // back the response\n    quorum: number;\n\n    // How many providers must have reported the same event\n    // for it to be emitted\n    eventQuorum: number;\n\n    // How many providers to dispatch each event to simultaneously.\n    // Set this to 0 to use getLog polling, which implies eventQuorum\n    // is equal to quorum.\n    eventWorkers: number;\n};\n\ntype RunnerResult = { result: any } | { error: Error };\n\ntype RunnerState = {\n    config: Config;\n    staller: null | Promise<void>;\n    didBump: boolean;\n    perform: null | Promise<any>;\n    result: null | RunnerResult;\n}\n\nfunction _normalize(value: any): string {\n    if (value == null) { return \"null\"; }\n\n    if (Array.isArray(value)) {\n        return \"[\" + (value.map(_normalize)).join(\",\") + \"]\";\n    }\n\n    if (typeof(value) === \"object\" && typeof(value.toJSON) === \"function\") {\n        return _normalize(value.toJSON());\n    }\n\n    switch (typeof(value)) {\n        case \"boolean\": case \"symbol\":\n            return value.toString();\n        case \"bigint\": case \"number\":\n            return BigInt(value).toString();\n        case \"string\":\n            return JSON.stringify(value);\n        case \"object\": {\n            const keys = Object.keys(value);\n            keys.sort();\n            return \"{\" + keys.map((k) => `${ JSON.stringify(k) }:${ _normalize(value[k]) }`).join(\",\") + \"}\";\n        }\n    }\n\n    console.log(\"Could not serialize\", value);\n    throw new Error(\"Hmm...\");\n}\n\nfunction normalizeResult(value: RunnerResult): { tag: string, value: any } {\n\n    if (\"error\" in value) {\n        const error = value.error;\n        return { tag: _normalize(error), value: error };\n    }\n\n    const result = value.result;\n    return { tag: _normalize(result), value: result };\n}\n\ntype TallyResult = {\n    tag: string;\n    value: any;\n    weight: number;\n};\n\n// This strategy picks the highest weight result, as long as the weight is\n// equal to or greater than quorum\nfunction checkQuorum(quorum: number, results: Array<TallyResult>): any | Error {\n    const tally: Map<string, { value: any, weight: number }> = new Map();\n    for (const { value, tag, weight } of results) {\n        const t = tally.get(tag) || { value, weight: 0 };\n        t.weight += weight;\n        tally.set(tag, t);\n    }\n\n    let best: null | { value: any, weight: number } = null;\n\n    for (const r of tally.values()) {\n        if (r.weight >= quorum && (!best || r.weight > best.weight)) {\n            best = r;\n        }\n    }\n\n    if (best) { return best.value; }\n\n    return undefined;\n}\n\nfunction getMedian(quorum: number, results: Array<TallyResult>): undefined | bigint | Error {\n    let resultWeight = 0;\n\n    const errorMap: Map<string, { weight: number, value: Error }> = new Map();\n    let bestError: null | { weight: number, value: Error } = null;\n\n    const values: Array<bigint> = [ ];\n    for (const { value, tag, weight } of results) {\n        if (value instanceof Error) {\n            const e = errorMap.get(tag) || { value, weight: 0 };\n            e.weight += weight;\n            errorMap.set(tag, e);\n\n            if (bestError == null || e.weight > bestError.weight) { bestError = e; }\n        } else {\n            values.push(BigInt(value));\n            resultWeight += weight;\n        }\n    }\n\n    if (resultWeight < quorum) {\n        // We have quorum for an error\n        if (bestError && bestError.weight >= quorum) { return bestError.value; }\n\n        // We do not have quorum for a result\n        return undefined;\n    }\n\n    // Get the sorted values\n    values.sort((a, b) => ((a < b) ? -1: (b > a) ? 1: 0));\n\n    const mid = Math.floor(values.length / 2);\n\n    // Odd-length; take the middle value\n    if (values.length % 2) { return values[mid]; }\n\n    // Even length; take the ceiling of the mean of the center two values\n    return (values[mid - 1] + values[mid] + BN_1) / BN_2;\n}\n\nfunction getAnyResult(quorum: number, results: Array<TallyResult>): undefined | any | Error {\n    // If any value or error meets quorum, that is our preferred result\n    const result = checkQuorum(quorum, results);\n    if (result !== undefined) { return result; }\n\n    // Otherwise, do we have any result?\n    for (const r of results) {\n        if (r.value) { return r.value; }\n    }\n\n    // Nope!\n    return undefined;\n}\n\nfunction getFuzzyMode(quorum: number, results: Array<TallyResult>): undefined | number {\n    if (quorum === 1) { return getNumber(<bigint>getMedian(quorum, results), \"%internal\"); }\n\n    const tally: Map<number, { result: number, weight: number }> = new Map();\n    const add = (result: number, weight: number) => {\n        const t = tally.get(result) || { result, weight: 0 };\n        t.weight += weight;\n        tally.set(result, t);\n    };\n\n    for (const { weight, value } of results) {\n        const r = getNumber(value);\n        add(r - 1, weight);\n        add(r, weight);\n        add(r + 1, weight);\n    }\n\n    let bestWeight = 0;\n    let bestResult = undefined;\n\n    for (const { weight, result } of tally.values()) {\n        // Use this result, if this result meets quorum and has either:\n        // - a better weight\n        // - or equal weight, but the result is larger\n        if (weight >= quorum && (weight > bestWeight || (bestResult != null && weight === bestWeight && result > bestResult))) {\n            bestWeight = weight;\n            bestResult = result;\n        }\n    }\n\n    return bestResult;\n}\n\n/**\n *  A Fallback Provider.\n *\n */\nexport class FallbackProvider extends AbstractProvider {\n\n    readonly quorum: number;\n    readonly eventQuorum: number;\n    readonly eventWorkers: number;\n\n    readonly #configs: Array<Config>;\n\n    #height: number;\n    #initialSyncPromise: null | Promise<void>;\n\n    constructor(providers: Array<AbstractProvider | FallbackProviderConfig>, network?: Networkish) {\n        super(network);\n        this.#configs = providers.map((p) => {\n            if (p instanceof AbstractProvider) {\n                return Object.assign({ provider: p }, defaultConfig, defaultState );\n            } else {\n                return Object.assign({ }, defaultConfig, p, defaultState );\n            }\n        });\n\n        this.#height = -2;\n        this.#initialSyncPromise = null;\n\n        this.quorum = 2; //Math.ceil(providers.length /  2);\n        this.eventQuorum = 1;\n        this.eventWorkers = 1;\n\n        assertArgument(this.quorum <= this.#configs.reduce((a, c) => (a + c.weight), 0),\n            \"quorum exceed provider wieght\", \"quorum\", this.quorum);\n    }\n\n    get providerConfigs(): Array<FallbackProviderState> {\n        return this.#configs.map((c) => {\n            const result: any = Object.assign({ }, c);\n            for (const key in result) {\n                if (key[0] === \"_\") { delete result[key]; }\n            }\n            return result;\n        });\n    }\n\n    async _detectNetwork(): Promise<Network> {\n        return Network.from(getBigInt(await this._perform({ method: \"chainId\" })));\n    }\n\n    // @TODO: Add support to select providers to be the event subscriber\n    //_getSubscriber(sub: Subscription): Subscriber {\n    //    throw new Error(\"@TODO\");\n    //}\n\n    async _translatePerform(provider: AbstractProvider, req: PerformActionRequest): Promise<any> {\n        switch (req.method) {\n            case \"broadcastTransaction\":\n                return await provider.broadcastTransaction(req.signedTransaction);\n            case \"call\":\n                return await provider.call(Object.assign({ }, req.transaction, { blockTag: req.blockTag }));\n            case \"chainId\":\n                return (await provider.getNetwork()).chainId;\n            case \"estimateGas\":\n                return await provider.estimateGas(req.transaction);\n            case \"getBalance\":\n                return await provider.getBalance(req.address, req.blockTag);\n            case \"getBlock\": {\n                const block = (\"blockHash\" in req) ? req.blockHash: req.blockTag;\n                return await provider.getBlock(block, req.includeTransactions);\n            }\n            case \"getBlockNumber\":\n                return await provider.getBlockNumber();\n            case \"getCode\":\n                return await provider.getCode(req.address, req.blockTag);\n            case \"getGasPrice\":\n                return (await provider.getFeeData()).gasPrice;\n            case \"getLogs\":\n                return await provider.getLogs(req.filter);\n            case \"getStorage\":\n                return await provider.getStorage(req.address, req.position, req.blockTag);\n            case \"getTransaction\":\n                return await provider.getTransaction(req.hash);\n            case \"getTransactionCount\":\n                return await provider.getTransactionCount(req.address, req.blockTag);\n            case \"getTransactionReceipt\":\n                return await provider.getTransactionReceipt(req.hash);\n            case \"getTransactionResult\":\n                return await provider.getTransactionResult(req.hash);\n        }\n    }\n\n    // Grab the next (random) config that is not already part of\n    // the running set\n    #getNextConfig(running: Set<RunnerState>): null | Config {\n        // @TODO: Maybe do a check here to favour (heavily) providers that\n        //        do not require waitForSync and disfavour providers that\n        //        seem down-ish or are behaving slowly\n\n        const configs = Array.from(running).map((r) => r.config)\n\n        // Shuffle the states, sorted by priority\n        const allConfigs = this.#configs.slice();\n        shuffle(allConfigs);\n        allConfigs.sort((a, b) => (b.priority - a.priority));\n\n        for (const config of allConfigs) {\n            if (configs.indexOf(config) === -1) { return config; }\n        }\n\n        return null;\n    }\n\n    // Adds a new runner (if available) to running.\n    #addRunner(running: Set<RunnerState>, req: PerformActionRequest): null | RunnerState {\n        const config = this.#getNextConfig(running);\n\n        // No runners available\n        if (config == null) { return null; }\n\n        // Create a new runner\n        const runner: RunnerState = {\n            config, result: null, didBump: false,\n            perform: null, staller: null\n        };\n\n        const now = getTime();\n\n        // Start performing this operation\n        runner.perform = (async () => {\n            try {\n                config.requests++;\n                const result = await this._translatePerform(config.provider, req);\n                runner.result = { result };\n            } catch (error: any) {\n                config.errorResponses++;\n                runner.result = { error };\n            }\n\n            const dt = (getTime() - now);\n            config._totalTime += dt;\n\n            config.rollingDuration = 0.95 * config.rollingDuration + 0.05 * dt;\n\n            runner.perform = null;\n        })();\n\n        // Start a staller; when this times out, it's time to force\n        // kicking off another runner because we are taking too long\n        runner.staller = (async () => {\n            await stall(config.stallTimeout);\n            runner.staller = null;\n        })();\n\n        running.add(runner);\n        return runner;\n    }\n\n    // Initializes the blockNumber and network for each runner and\n    // blocks until initialized\n    async #initialSync(): Promise<void> {\n        let initialSync = this.#initialSyncPromise;\n        if (!initialSync) {\n            const promises: Array<Promise<any>> = [ ];\n            this.#configs.forEach((config) => {\n                promises.push(waitForSync(config, 0));\n                promises.push((async () => {\n                    config._network = await config.provider.getNetwork();\n                })());\n            });\n\n            this.#initialSyncPromise = initialSync = (async () => {\n                // Wait for all providers to have a block number and network\n                await Promise.all(promises);\n\n                // Check all the networks match\n                let chainId: null | bigint = null;\n                for (const config of this.#configs) {\n                    const network = <Network>(config._network);\n                    if (chainId == null) {\n                        chainId = network.chainId;\n                    } else if (network.chainId !== chainId) {\n                        assert(false, \"cannot mix providers on different networks\", \"UNSUPPORTED_OPERATION\", {\n                            operation: \"new FallbackProvider\"\n                        });\n                    }\n                }\n            })();\n        }\n\n        await initialSync\n    }\n\n\n    async #checkQuorum(running: Set<RunnerState>, req: PerformActionRequest): Promise<any> {\n        // Get all the result objects\n        const results: Array<TallyResult> = [ ];\n        for (const runner of running) {\n            if (runner.result != null) {\n                const { tag, value } = normalizeResult(runner.result);\n                results.push({ tag, value, weight: runner.config.weight });\n            }\n        }\n\n        // Are there enough results to event meet quorum?\n        if (results.reduce((a, r) => (a + r.weight), 0) < this.quorum) {\n            return undefined;\n        }\n\n        switch (req.method) {\n            case \"getBlockNumber\": {\n                // We need to get the bootstrap block height\n                if (this.#height === -2) {\n                    this.#height = Math.ceil(getNumber(<bigint>getMedian(this.quorum, this.#configs.map((c) => ({\n                        value: c.blockNumber,\n                        tag: getNumber(c.blockNumber).toString(),\n                        weight: c.weight\n                    })))));\n                }\n\n                // Find the mode across all the providers, allowing for\n                // a little drift between block heights\n                const mode = getFuzzyMode(this.quorum, results);\n                if (mode === undefined) { return undefined; }\n                if (mode > this.#height) { this.#height = mode; }\n                return this.#height;\n            }\n\n            case \"getGasPrice\":\n            case \"estimateGas\":\n                return getMedian(this.quorum, results);\n\n            case \"getBlock\":\n                // Pending blocks are in the mempool and already\n                // quite untrustworthy; just grab anything\n                if (\"blockTag\" in req && req.blockTag === \"pending\") {\n                    return getAnyResult(this.quorum, results);\n                }\n                return checkQuorum(this.quorum, results);\n\n            case \"call\":\n            case \"chainId\":\n            case \"getBalance\":\n            case \"getTransactionCount\":\n            case \"getCode\":\n            case \"getStorage\":\n            case \"getTransaction\":\n            case \"getTransactionReceipt\":\n            case \"getLogs\":\n                return checkQuorum(this.quorum, results);\n\n            case \"broadcastTransaction\":\n                return getAnyResult(this.quorum, results);\n        }\n\n        assert(false, \"unsupported method\", \"UNSUPPORTED_OPERATION\", {\n            operation: `_perform(${ stringify((<any>req).method) })`\n        });\n    }\n\n    async #waitForQuorum(running: Set<RunnerState>, req: PerformActionRequest): Promise<any> {\n        if (running.size === 0) { throw new Error(\"no runners?!\"); }\n\n        // Any promises that are interesting to watch for; an expired stall\n        // or a successful perform\n        const interesting: Array<Promise<void>> = [ ];\n\n        let newRunners = 0;\n        for (const runner of running) {\n\n            // No responses, yet; keep an eye on it\n            if (runner.perform) {\n                interesting.push(runner.perform);\n            }\n\n            // Still stalling...\n            if (runner.staller) {\n                interesting.push(runner.staller);\n                continue;\n            }\n\n            // This runner has already triggered another runner\n            if (runner.didBump) { continue; }\n\n            // Got a response (result or error) or stalled; kick off another runner\n            runner.didBump = true;\n            newRunners++;\n        }\n\n        // Check if we have reached quorum on a result (or error)\n        const value = await this.#checkQuorum(running, req);\n        if (value !== undefined) {\n            if (value instanceof Error) { throw value; }\n            return value;\n        }\n\n        // Add any new runners, because a staller timed out or a result\n        // or error response came in.\n        for (let i = 0; i < newRunners; i++) {\n            this.#addRunner(running, req)\n        }\n\n        // All providers have returned, and we have no result\n\n        assert(interesting.length > 0, \"quorum not met\", \"SERVER_ERROR\", {\n            request: \"%sub-requests\",\n            info: { request: req, results: Array.from(running).map((r) => stringify(r.result)) }\n        });\n\n        // Wait for someone to either complete its perform or stall out\n        await Promise.race(interesting);\n\n        // This is recursive, but at worst case the depth is 2x the\n        // number of providers (each has a perform and a staller)\n        return await this.#waitForQuorum(running, req);\n    }\n\n    async _perform<T = any>(req: PerformActionRequest): Promise<T> {\n        // Broadcasting a transaction is rare (ish) and already incurs\n        // a cost on the user, so spamming is safe-ish. Just send it to\n        // every backend.\n        if (req.method === \"broadcastTransaction\") {\n            const results = await Promise.all(this.#configs.map(async ({ provider, weight }) => {\n                try {\n                    const result = await provider._perform(req);\n                    return Object.assign(normalizeResult({ result }), { weight });\n                } catch (error: any) {\n                    return Object.assign(normalizeResult({ error }), { weight });\n                }\n            }));\n\n            const result = getAnyResult(this.quorum, results);\n            assert(result !== undefined, \"problem multi-broadcasting\", \"SERVER_ERROR\", {\n                request: \"%sub-requests\",\n                info: { request: req, results: results.map(stringify) }\n            })\n            if (result instanceof Error) { throw result; }\n            return result;\n        }\n\n        await this.#initialSync();\n\n        // Bootstrap enough runners to meet quorum\n        const running: Set<RunnerState> = new Set();\n        for (let i = 0; i < this.quorum; i++) {\n            this.#addRunner(running, req);\n        }\n\n        const result = await this.#waitForQuorum(running, req);\n\n        // Track requests sent to a provider that are still\n        // outstanding after quorum has been otherwise found\n        for (const runner of running) {\n            if (runner.perform && runner.result == null) {\n                runner.config.lateResponses++;\n            }\n        }\n\n        return result;\n    }\n\n    async destroy(): Promise<void> {\n        for (const { provider } of this.#configs) {\n            provider.destroy();\n        }\n        super.destroy();\n    }\n}\n"]},"metadata":{},"sourceType":"script","externalDependencies":[]}