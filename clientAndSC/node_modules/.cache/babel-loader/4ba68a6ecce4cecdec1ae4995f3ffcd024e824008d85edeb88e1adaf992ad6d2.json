{"ast":null,"code":"\"use strict\";\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.JsonRpcServer = void 0;\nconst debug_1 = __importDefault(require(\"debug\"));\nconst http_1 = __importDefault(require(\"http\"));\nconst http_2 = require(\"../../core/providers/http\");\nconst handler_1 = require(\"./handler\");\nconst log = (0, debug_1.default)(\"hardhat:core:hardhat-network:jsonrpc\");\nclass JsonRpcServer {\n  constructor(config) {\n    var _this = this;\n    this.getProvider = function () {\n      let name = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : \"json-rpc\";\n      const {\n        Client\n      } = require(\"undici\");\n      const {\n        address,\n        port\n      } = _this._httpServer.address();\n      const dispatcher = new Client(`http://${address}:${port}/`, {\n        keepAliveTimeout: 10,\n        keepAliveMaxTimeout: 10\n      });\n      return new http_2.HttpProvider(`http://${address}:${port}/`, name, {}, 20000, dispatcher);\n    };\n    this.listen = () => {\n      return new Promise(resolve => {\n        log(`Starting JSON-RPC server on port ${this._config.port}`);\n        this._httpServer.listen(this._config.port, this._config.hostname, () => {\n          // We get the address and port directly from the server in order to handle random port allocation with `0`.\n          const address = this._httpServer.address(); // TCP sockets return AddressInfo\n          resolve(address);\n        });\n      });\n    };\n    this.waitUntilClosed = async () => {\n      const httpServerClosed = new Promise(resolve => {\n        this._httpServer.once(\"close\", resolve);\n      });\n      const wsServerClosed = new Promise(resolve => {\n        this._wsServer.once(\"close\", resolve);\n      });\n      await Promise.all([httpServerClosed, wsServerClosed]);\n    };\n    this.close = async () => {\n      await Promise.all([new Promise((resolve, reject) => {\n        log(\"Closing JSON-RPC server\");\n        this._httpServer.close(err => {\n          if (err !== null && err !== undefined) {\n            log(\"Failed to close JSON-RPC server\");\n            reject(err);\n            return;\n          }\n          log(\"JSON-RPC server closed\");\n          resolve();\n        });\n      }), new Promise((resolve, reject) => {\n        log(\"Closing websocket server\");\n        this._wsServer.close(err => {\n          if (err !== null && err !== undefined) {\n            log(\"Failed to close websocket server\");\n            reject(err);\n            return;\n          }\n          log(\"Websocket server closed\");\n          resolve();\n        });\n      })]);\n    };\n    const {\n      Server: WSServer\n    } = require(\"ws\");\n    this._config = config;\n    const handler = new handler_1.JsonRpcHandler(config.provider);\n    this._httpServer = http_1.default.createServer();\n    this._wsServer = new WSServer({\n      server: this._httpServer\n    });\n    this._httpServer.on(\"request\", handler.handleHttp);\n    this._wsServer.on(\"connection\", handler.handleWs);\n  }\n}\nexports.JsonRpcServer = JsonRpcServer;","map":{"version":3,"mappings":"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","names":["log","JsonRpcServer","constructor","config","name","Client","require","address","port","_httpServer","dispatcher","keepAliveTimeout","keepAliveMaxTimeout","http_2","Promise","resolve","_config","listen","hostname","httpServerClosed","once","wsServerClosed","_wsServer","all","reject","close","err","undefined","Server","WSServer","handler","handler_1","provider","http_1","createServer","server","on","handleHttp","handleWs","exports"],"sources":["/Users/janrobel/Documents/PersonalProjekty/nftGenerateAi/clientAndContract/node_modules/hardhat/src/internal/hardhat-network/jsonrpc/server.ts"],"sourcesContent":["import type { Client as ClientT } from \"undici\";\nimport type WsT from \"ws\";\n\nimport debug from \"debug\";\nimport http, { Server } from \"http\";\nimport { AddressInfo } from \"net\";\n\nimport {\n  EIP1193Provider,\n  JsonRpcServer as IJsonRpcServer,\n} from \"../../../types\";\nimport { HttpProvider } from \"../../core/providers/http\";\n\nimport { JsonRpcHandler } from \"./handler\";\n\nconst log = debug(\"hardhat:core:hardhat-network:jsonrpc\");\n\nexport interface JsonRpcServerConfig {\n  hostname: string;\n  port: number;\n\n  provider: EIP1193Provider;\n}\n\nexport class JsonRpcServer implements IJsonRpcServer {\n  private _config: JsonRpcServerConfig;\n  private _httpServer: Server;\n  private _wsServer: WsT.Server;\n\n  constructor(config: JsonRpcServerConfig) {\n    const { Server: WSServer } = require(\"ws\") as typeof WsT;\n\n    this._config = config;\n\n    const handler = new JsonRpcHandler(config.provider);\n\n    this._httpServer = http.createServer();\n    this._wsServer = new WSServer({\n      server: this._httpServer,\n    });\n\n    this._httpServer.on(\"request\", handler.handleHttp);\n    this._wsServer.on(\"connection\", handler.handleWs);\n  }\n\n  public getProvider = (name = \"json-rpc\"): EIP1193Provider => {\n    const { Client } = require(\"undici\") as { Client: typeof ClientT };\n    const { address, port } = this._httpServer.address() as AddressInfo;\n\n    const dispatcher = new Client(`http://${address}:${port}/`, {\n      keepAliveTimeout: 10,\n      keepAliveMaxTimeout: 10,\n    });\n\n    return new HttpProvider(\n      `http://${address}:${port}/`,\n      name,\n      {},\n      20000,\n      dispatcher\n    );\n  };\n\n  public listen = (): Promise<{ address: string; port: number }> => {\n    return new Promise((resolve) => {\n      log(`Starting JSON-RPC server on port ${this._config.port}`);\n      this._httpServer.listen(this._config.port, this._config.hostname, () => {\n        // We get the address and port directly from the server in order to handle random port allocation with `0`.\n        const address = this._httpServer.address() as AddressInfo; // TCP sockets return AddressInfo\n        resolve(address);\n      });\n    });\n  };\n\n  public waitUntilClosed = async () => {\n    const httpServerClosed = new Promise((resolve) => {\n      this._httpServer.once(\"close\", resolve);\n    });\n\n    const wsServerClosed = new Promise((resolve) => {\n      this._wsServer.once(\"close\", resolve);\n    });\n\n    await Promise.all([httpServerClosed, wsServerClosed]);\n  };\n\n  public close = async () => {\n    await Promise.all([\n      new Promise<void>((resolve, reject) => {\n        log(\"Closing JSON-RPC server\");\n        this._httpServer.close((err) => {\n          if (err !== null && err !== undefined) {\n            log(\"Failed to close JSON-RPC server\");\n            reject(err);\n            return;\n          }\n\n          log(\"JSON-RPC server closed\");\n          resolve();\n        });\n      }),\n      new Promise<void>((resolve, reject) => {\n        log(\"Closing websocket server\");\n        this._wsServer.close((err) => {\n          if (err !== null && err !== undefined) {\n            log(\"Failed to close websocket server\");\n            reject(err);\n            return;\n          }\n\n          log(\"Websocket server closed\");\n          resolve();\n        });\n      }),\n    ]);\n  };\n}\n"]},"metadata":{},"sourceType":"script","externalDependencies":[]}