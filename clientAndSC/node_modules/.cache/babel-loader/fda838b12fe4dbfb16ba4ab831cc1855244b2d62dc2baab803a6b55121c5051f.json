{"ast":null,"code":"import { __assign, __awaiter, __generator } from \"tslib\";\nimport { API, eventToSentryRequest } from '@sentry/core';\nimport { Status } from '@sentry/types';\nimport { logger, parseRetryAfterHeader, PromiseBuffer, SentryError } from '@sentry/utils';\nimport * as fs from 'fs';\nimport * as url from 'url';\nimport { SDK_NAME, SDK_VERSION } from '../version';\n/** Base Transport class implementation */\nvar BaseTransport = /** @class */function () {\n  /** Create instance and set this.dsn */\n  function BaseTransport(options) {\n    this.options = options;\n    /** A simple buffer holding all requests. */\n    this._buffer = new PromiseBuffer(30);\n    /** Locks transport after receiving 429 response */\n    this._disabledUntil = new Date(Date.now());\n    this._api = new API(options.dsn);\n  }\n  /**\n   * @inheritDoc\n   */\n  BaseTransport.prototype.sendEvent = function (_) {\n    throw new SentryError('Transport Class has to implement `sendEvent` method.');\n  };\n  /**\n   * @inheritDoc\n   */\n  BaseTransport.prototype.close = function (timeout) {\n    return this._buffer.drain(timeout);\n  };\n  /** Returns a build request option object used by request */\n  BaseTransport.prototype._getRequestOptions = function (uri) {\n    var headers = __assign(__assign({}, this._api.getRequestHeaders(SDK_NAME, SDK_VERSION)), this.options.headers);\n    var hostname = uri.hostname,\n      pathname = uri.pathname,\n      port = uri.port,\n      protocol = uri.protocol;\n    // See https://github.com/nodejs/node/blob/38146e717fed2fabe3aacb6540d839475e0ce1c6/lib/internal/url.js#L1268-L1290\n    // We ignore the query string on purpose\n    var path = \"\" + pathname;\n    return __assign({\n      agent: this.client,\n      headers: headers,\n      hostname: hostname,\n      method: 'POST',\n      path: path,\n      port: port,\n      protocol: protocol\n    }, this.options.caCerts && {\n      ca: fs.readFileSync(this.options.caCerts)\n    });\n  };\n  /** JSDoc */\n  BaseTransport.prototype._sendWithModule = function (httpModule, event) {\n    return __awaiter(this, void 0, void 0, function () {\n      var _this = this;\n      return __generator(this, function (_a) {\n        if (new Date(Date.now()) < this._disabledUntil) {\n          return [2 /*return*/, Promise.reject(new SentryError(\"Transport locked till \" + this._disabledUntil + \" due to too many requests.\"))];\n        }\n        if (!this._buffer.isReady()) {\n          return [2 /*return*/, Promise.reject(new SentryError('Not adding Promise due to buffer limit reached.'))];\n        }\n        return [2 /*return*/, this._buffer.add(new Promise(function (resolve, reject) {\n          var sentryReq = eventToSentryRequest(event, _this._api);\n          var options = _this._getRequestOptions(new url.URL(sentryReq.url));\n          var req = httpModule.request(options, function (res) {\n            var statusCode = res.statusCode || 500;\n            var status = Status.fromHttpCode(statusCode);\n            res.setEncoding('utf8');\n            if (status === Status.Success) {\n              resolve({\n                status: status\n              });\n            } else {\n              if (status === Status.RateLimit) {\n                var now = Date.now();\n                /**\n                 * \"Key-value pairs of header names and values. Header names are lower-cased.\"\n                 * https://nodejs.org/api/http.html#http_message_headers\n                 */\n                var retryAfterHeader = res.headers ? res.headers['retry-after'] : '';\n                retryAfterHeader = Array.isArray(retryAfterHeader) ? retryAfterHeader[0] : retryAfterHeader;\n                _this._disabledUntil = new Date(now + parseRetryAfterHeader(now, retryAfterHeader));\n                logger.warn(\"Too many requests, backing off till: \" + _this._disabledUntil);\n              }\n              var rejectionMessage = \"HTTP Error (\" + statusCode + \")\";\n              if (res.headers && res.headers['x-sentry-error']) {\n                rejectionMessage += \": \" + res.headers['x-sentry-error'];\n              }\n              reject(new SentryError(rejectionMessage));\n            }\n            // Force the socket to drain\n            res.on('data', function () {\n              // Drain\n            });\n            res.on('end', function () {\n              // Drain\n            });\n          });\n          req.on('error', reject);\n          req.end(sentryReq.body);\n        }))];\n      });\n    });\n  };\n  return BaseTransport;\n}();\nexport { BaseTransport };","map":{"version":3,"mappings":"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","names":["API","eventToSentryRequest","Status","logger","parseRetryAfterHeader","PromiseBuffer","SentryError","fs","url","SDK_NAME","SDK_VERSION","options","Date","now","_api","dsn","BaseTransport","_","timeout","_buffer","drain","uri","headers","getRequestHeaders","pathname","port","protocol","path","agent","client","hostname","method","caCerts","ca","readFileSync","httpModule","event","_disabledUntil","Promise","reject","isReady","add","resolve","sentryReq","_this","_getRequestOptions","URL","req","request","res","statusCode","status","fromHttpCode","setEncoding","Success","RateLimit","retryAfterHeader","Array","isArray","warn","rejectionMessage","on","end","body"],"sources":["/Users/janrobel/Documents/PersonalProjekty/nftGenerateAi/clientAndContract/node_modules/@sentry/node/src/transports/base.ts"],"sourcesContent":["import { API, eventToSentryRequest } from '@sentry/core';\nimport { Event, Response, Status, Transport, TransportOptions } from '@sentry/types';\nimport { logger, parseRetryAfterHeader, PromiseBuffer, SentryError } from '@sentry/utils';\nimport * as fs from 'fs';\nimport * as http from 'http';\nimport * as https from 'https';\nimport * as url from 'url';\n\nimport { SDK_NAME, SDK_VERSION } from '../version';\n\n/**\n * Internal used interface for typescript.\n * @hidden\n */\nexport interface HTTPModule {\n  /**\n   * Request wrapper\n   * @param options These are {@see TransportOptions}\n   * @param callback Callback when request is finished\n   */\n  request(\n    options: http.RequestOptions | https.RequestOptions | string | url.URL,\n    callback?: (res: http.IncomingMessage) => void,\n  ): http.ClientRequest;\n\n  // This is the type for nodejs versions that handle the URL argument\n  // (v10.9.0+), but we do not use it just yet because we support older node\n  // versions:\n\n  // request(\n  //   url: string | url.URL,\n  //   options: http.RequestOptions | https.RequestOptions,\n  //   callback?: (res: http.IncomingMessage) => void,\n  // ): http.ClientRequest;\n}\n\n/** Base Transport class implementation */\nexport abstract class BaseTransport implements Transport {\n  /** The Agent used for corresponding transport */\n  public module?: HTTPModule;\n\n  /** The Agent used for corresponding transport */\n  public client?: http.Agent | https.Agent;\n\n  /** API object */\n  protected _api: API;\n\n  /** A simple buffer holding all requests. */\n  protected readonly _buffer: PromiseBuffer<Response> = new PromiseBuffer(30);\n\n  /** Locks transport after receiving 429 response */\n  private _disabledUntil: Date = new Date(Date.now());\n\n  /** Create instance and set this.dsn */\n  public constructor(public options: TransportOptions) {\n    this._api = new API(options.dsn);\n  }\n\n  /**\n   * @inheritDoc\n   */\n  public sendEvent(_: Event): PromiseLike<Response> {\n    throw new SentryError('Transport Class has to implement `sendEvent` method.');\n  }\n\n  /**\n   * @inheritDoc\n   */\n  public close(timeout?: number): PromiseLike<boolean> {\n    return this._buffer.drain(timeout);\n  }\n\n  /** Returns a build request option object used by request */\n  protected _getRequestOptions(uri: url.URL): http.RequestOptions | https.RequestOptions {\n    const headers = {\n      ...this._api.getRequestHeaders(SDK_NAME, SDK_VERSION),\n      ...this.options.headers,\n    };\n    const { hostname, pathname, port, protocol } = uri;\n    // See https://github.com/nodejs/node/blob/38146e717fed2fabe3aacb6540d839475e0ce1c6/lib/internal/url.js#L1268-L1290\n    // We ignore the query string on purpose\n    const path = `${pathname}`;\n\n    return {\n      agent: this.client,\n      headers,\n      hostname,\n      method: 'POST',\n      path,\n      port,\n      protocol,\n      ...(this.options.caCerts && {\n        ca: fs.readFileSync(this.options.caCerts),\n      }),\n    };\n  }\n\n  /** JSDoc */\n  protected async _sendWithModule(httpModule: HTTPModule, event: Event): Promise<Response> {\n    if (new Date(Date.now()) < this._disabledUntil) {\n      return Promise.reject(new SentryError(`Transport locked till ${this._disabledUntil} due to too many requests.`));\n    }\n\n    if (!this._buffer.isReady()) {\n      return Promise.reject(new SentryError('Not adding Promise due to buffer limit reached.'));\n    }\n    return this._buffer.add(\n      new Promise<Response>((resolve, reject) => {\n        const sentryReq = eventToSentryRequest(event, this._api);\n        const options = this._getRequestOptions(new url.URL(sentryReq.url));\n\n        const req = httpModule.request(options, (res: http.IncomingMessage) => {\n          const statusCode = res.statusCode || 500;\n          const status = Status.fromHttpCode(statusCode);\n\n          res.setEncoding('utf8');\n\n          if (status === Status.Success) {\n            resolve({ status });\n          } else {\n            if (status === Status.RateLimit) {\n              const now = Date.now();\n              /**\n               * \"Key-value pairs of header names and values. Header names are lower-cased.\"\n               * https://nodejs.org/api/http.html#http_message_headers\n               */\n              let retryAfterHeader = res.headers ? res.headers['retry-after'] : '';\n              retryAfterHeader = (Array.isArray(retryAfterHeader) ? retryAfterHeader[0] : retryAfterHeader) as string;\n              this._disabledUntil = new Date(now + parseRetryAfterHeader(now, retryAfterHeader));\n              logger.warn(`Too many requests, backing off till: ${this._disabledUntil}`);\n            }\n\n            let rejectionMessage = `HTTP Error (${statusCode})`;\n            if (res.headers && res.headers['x-sentry-error']) {\n              rejectionMessage += `: ${res.headers['x-sentry-error']}`;\n            }\n\n            reject(new SentryError(rejectionMessage));\n          }\n\n          // Force the socket to drain\n          res.on('data', () => {\n            // Drain\n          });\n          res.on('end', () => {\n            // Drain\n          });\n        });\n        req.on('error', reject);\n        req.end(sentryReq.body);\n      }),\n    );\n  }\n}\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}