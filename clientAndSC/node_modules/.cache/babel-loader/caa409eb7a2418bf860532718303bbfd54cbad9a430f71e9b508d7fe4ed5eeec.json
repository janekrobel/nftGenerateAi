{"ast":null,"code":"\"use strict\";\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.JsonRpcHandler = void 0;\nconst raw_body_1 = __importDefault(require(\"raw-body\"));\nconst errors_1 = require(\"../../core/providers/errors\");\nconst jsonrpc_1 = require(\"../../util/jsonrpc\");\n/* eslint-disable @nomiclabs/hardhat-internal-rules/only-hardhat-error */\nclass JsonRpcHandler {\n  constructor(_provider) {\n    this._provider = _provider;\n    this.handleHttp = async (req, res) => {\n      this._setCorsHeaders(res);\n      if (req.method === \"OPTIONS\") {\n        this._sendEmptyResponse(res);\n        return;\n      }\n      let jsonHttpRequest;\n      try {\n        jsonHttpRequest = await _readJsonHttpRequest(req);\n      } catch (error) {\n        this._sendResponse(res, _handleError(error));\n        return;\n      }\n      if (Array.isArray(jsonHttpRequest)) {\n        const responses = await Promise.all(jsonHttpRequest.map(singleReq => this._handleSingleRequest(singleReq)));\n        this._sendResponse(res, responses);\n        return;\n      }\n      const rpcResp = await this._handleSingleRequest(jsonHttpRequest);\n      this._sendResponse(res, rpcResp);\n    };\n    this.handleWs = async ws => {\n      const subscriptions = [];\n      let isClosed = false;\n      const listener = payload => {\n        // Don't attempt to send a message to the websocket if we already know it is closed,\n        // or the current websocket connection isn't interested in the particular subscription.\n        if (isClosed || !subscriptions.includes(payload.subscription)) {\n          return;\n        }\n        try {\n          ws.send(JSON.stringify({\n            jsonrpc: \"2.0\",\n            method: \"eth_subscription\",\n            params: payload\n          }));\n        } catch (error) {\n          _handleError(error);\n        }\n      };\n      // Handle eth_subscribe notifications.\n      this._provider.addListener(\"notification\", listener);\n      ws.on(\"message\", async msg => {\n        let rpcReq;\n        let rpcResp;\n        try {\n          rpcReq = _readWsRequest(msg);\n          rpcResp = Array.isArray(rpcReq) ? await Promise.all(rpcReq.map(req => this._handleSingleWsRequest(req, subscriptions))) : await this._handleSingleWsRequest(rpcReq, subscriptions);\n        } catch (error) {\n          rpcResp = _handleError(error);\n        }\n        ws.send(JSON.stringify(rpcResp));\n      });\n      ws.on(\"close\", () => {\n        // Remove eth_subscribe listener.\n        this._provider.removeListener(\"notification\", listener);\n        // Clear any active subscriptions for the closed websocket connection.\n        isClosed = true;\n        subscriptions.forEach(async subscriptionId => {\n          await this._provider.request({\n            method: \"eth_unsubscribe\",\n            params: [subscriptionId]\n          });\n        });\n      });\n    };\n    this._handleRequest = async req => {\n      const result = await this._provider.request({\n        method: req.method,\n        params: req.params\n      });\n      return {\n        jsonrpc: \"2.0\",\n        id: req.id,\n        result\n      };\n    };\n  }\n  _sendEmptyResponse(res) {\n    res.writeHead(200);\n    res.end();\n  }\n  _setCorsHeaders(res) {\n    res.setHeader(\"Access-Control-Allow-Origin\", \"*\");\n    res.setHeader(\"Access-Control-Request-Method\", \"*\");\n    res.setHeader(\"Access-Control-Allow-Methods\", \"OPTIONS, GET\");\n    res.setHeader(\"Access-Control-Allow-Headers\", \"*\");\n  }\n  _sendResponse(res, rpcResp) {\n    res.statusCode = 200;\n    res.setHeader(\"Content-Type\", \"application/json\");\n    res.end(JSON.stringify(rpcResp));\n  }\n  async _handleSingleRequest(req) {\n    if (!(0, jsonrpc_1.isValidJsonRequest)(req)) {\n      return _handleError(new errors_1.InvalidRequestError(\"Invalid request\"));\n    }\n    const rpcReq = req;\n    let rpcResp;\n    try {\n      rpcResp = await this._handleRequest(rpcReq);\n    } catch (error) {\n      rpcResp = _handleError(error);\n    }\n    // Validate the RPC response.\n    if (!(0, jsonrpc_1.isValidJsonResponse)(rpcResp)) {\n      // Malformed response coming from the provider, report to user as an internal error.\n      rpcResp = _handleError(new errors_1.InternalError(\"Internal error\"));\n    }\n    if (rpcReq !== undefined) {\n      rpcResp.id = rpcReq.id !== undefined ? rpcReq.id : null;\n    }\n    return rpcResp;\n  }\n  async _handleSingleWsRequest(rpcReq, subscriptions) {\n    const rpcResp = await this._handleSingleRequest(rpcReq);\n    // If eth_subscribe was successful, keep track of the subscription id,\n    // so we can cleanup on websocket close.\n    if (rpcReq.method === \"eth_subscribe\" && (0, jsonrpc_1.isSuccessfulJsonResponse)(rpcResp)) {\n      subscriptions.push(rpcResp.result);\n    }\n    return rpcResp;\n  }\n}\nexports.JsonRpcHandler = JsonRpcHandler;\nconst _readJsonHttpRequest = async req => {\n  let json;\n  try {\n    const buf = await (0, raw_body_1.default)(req);\n    const text = buf.toString();\n    json = JSON.parse(text);\n  } catch (error) {\n    if (error instanceof Error) {\n      throw new errors_1.InvalidJsonInputError(`Parse error: ${error.message}`);\n    }\n    // eslint-disable-next-line @nomiclabs/hardhat-internal-rules/only-hardhat-error\n    throw error;\n  }\n  return json;\n};\nconst _readWsRequest = msg => {\n  let json;\n  try {\n    json = JSON.parse(msg);\n  } catch (error) {\n    if (error instanceof Error) {\n      throw new errors_1.InvalidJsonInputError(`Parse error: ${error.message}`);\n    }\n    // eslint-disable-next-line @nomiclabs/hardhat-internal-rules/only-hardhat-error\n    throw error;\n  }\n  return json;\n};\nconst _handleError = error => {\n  // extract the relevant fields from the error before wrapping it\n  let txHash;\n  let returnData;\n  if (error.transactionHash !== undefined) {\n    txHash = error.transactionHash;\n  }\n  if (error.data !== undefined) {\n    returnData = error.data;\n  }\n  // In case of non-hardhat error, treat it as internal and associate the appropriate error code.\n  if (!errors_1.ProviderError.isProviderError(error)) {\n    error = new errors_1.InternalError(error);\n  }\n  const response = {\n    jsonrpc: \"2.0\",\n    id: null,\n    error: {\n      code: error.code,\n      message: error.message\n    }\n  };\n  response.error.data = {\n    message: error.message\n  };\n  if (txHash !== undefined) {\n    response.error.data.txHash = txHash;\n  }\n  if (returnData !== undefined) {\n    response.error.data.data = returnData;\n  }\n  return response;\n};","map":{"version":3,"mappings":"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","names":["JsonRpcHandler","constructor","_provider","req","res","_setCorsHeaders","method","_sendEmptyResponse","jsonHttpRequest","_readJsonHttpRequest","error","_sendResponse","_handleError","Array","isArray","responses","Promise","all","map","singleReq","_handleSingleRequest","rpcResp","ws","subscriptions","isClosed","listener","payload","includes","subscription","send","JSON","stringify","jsonrpc","params","addListener","on","msg","rpcReq","_readWsRequest","_handleSingleWsRequest","removeListener","forEach","subscriptionId","request","result","id","writeHead","end","setHeader","statusCode","errors_1","_handleRequest","undefined","push","exports","json","buf","text","toString","parse","Error","message","txHash","returnData","transactionHash","data","isProviderError","response","code"],"sources":["/Users/janrobel/Documents/PersonalProjekty/nftGenerateAi/clientAndContract/node_modules/hardhat/src/internal/hardhat-network/jsonrpc/handler.ts"],"sourcesContent":["import { IncomingMessage, ServerResponse } from \"http\";\nimport getRawBody from \"raw-body\";\nimport WebSocket from \"ws\";\n\nimport { EIP1193Provider } from \"../../../types\";\nimport {\n  InternalError,\n  InvalidJsonInputError,\n  InvalidRequestError,\n  ProviderError,\n} from \"../../core/providers/errors\";\nimport {\n  FailedJsonRpcResponse,\n  isSuccessfulJsonResponse,\n  isValidJsonRequest,\n  isValidJsonResponse,\n  JsonRpcRequest,\n  JsonRpcResponse,\n} from \"../../util/jsonrpc\";\n\n/* eslint-disable @nomiclabs/hardhat-internal-rules/only-hardhat-error */\n\nexport class JsonRpcHandler {\n  constructor(private readonly _provider: EIP1193Provider) {}\n\n  public handleHttp = async (req: IncomingMessage, res: ServerResponse) => {\n    this._setCorsHeaders(res);\n    if (req.method === \"OPTIONS\") {\n      this._sendEmptyResponse(res);\n      return;\n    }\n\n    let jsonHttpRequest: any;\n    try {\n      jsonHttpRequest = await _readJsonHttpRequest(req);\n    } catch (error) {\n      this._sendResponse(res, _handleError(error));\n      return;\n    }\n\n    if (Array.isArray(jsonHttpRequest)) {\n      const responses = await Promise.all(\n        jsonHttpRequest.map((singleReq: any) =>\n          this._handleSingleRequest(singleReq)\n        )\n      );\n\n      this._sendResponse(res, responses);\n      return;\n    }\n\n    const rpcResp = await this._handleSingleRequest(jsonHttpRequest);\n\n    this._sendResponse(res, rpcResp);\n  };\n\n  public handleWs = async (ws: WebSocket) => {\n    const subscriptions: string[] = [];\n    let isClosed = false;\n\n    const listener = (payload: { subscription: string; result: any }) => {\n      // Don't attempt to send a message to the websocket if we already know it is closed,\n      // or the current websocket connection isn't interested in the particular subscription.\n      if (isClosed || !subscriptions.includes(payload.subscription)) {\n        return;\n      }\n\n      try {\n        ws.send(\n          JSON.stringify({\n            jsonrpc: \"2.0\",\n            method: \"eth_subscription\",\n            params: payload,\n          })\n        );\n      } catch (error) {\n        _handleError(error);\n      }\n    };\n\n    // Handle eth_subscribe notifications.\n    this._provider.addListener(\"notification\", listener);\n\n    ws.on(\"message\", async (msg) => {\n      let rpcReq: JsonRpcRequest | JsonRpcRequest[];\n      let rpcResp: JsonRpcResponse | JsonRpcResponse[];\n\n      try {\n        rpcReq = _readWsRequest(msg as string);\n\n        rpcResp = Array.isArray(rpcReq)\n          ? await Promise.all(\n              rpcReq.map((req) =>\n                this._handleSingleWsRequest(req, subscriptions)\n              )\n            )\n          : await this._handleSingleWsRequest(rpcReq, subscriptions);\n      } catch (error) {\n        rpcResp = _handleError(error);\n      }\n\n      ws.send(JSON.stringify(rpcResp));\n    });\n\n    ws.on(\"close\", () => {\n      // Remove eth_subscribe listener.\n      this._provider.removeListener(\"notification\", listener);\n\n      // Clear any active subscriptions for the closed websocket connection.\n      isClosed = true;\n      subscriptions.forEach(async (subscriptionId) => {\n        await this._provider.request({\n          method: \"eth_unsubscribe\",\n          params: [subscriptionId],\n        });\n      });\n    });\n  };\n\n  private _sendEmptyResponse(res: ServerResponse) {\n    res.writeHead(200);\n    res.end();\n  }\n\n  private _setCorsHeaders(res: ServerResponse) {\n    res.setHeader(\"Access-Control-Allow-Origin\", \"*\");\n    res.setHeader(\"Access-Control-Request-Method\", \"*\");\n    res.setHeader(\"Access-Control-Allow-Methods\", \"OPTIONS, GET\");\n    res.setHeader(\"Access-Control-Allow-Headers\", \"*\");\n  }\n\n  private _sendResponse(\n    res: ServerResponse,\n    rpcResp: JsonRpcResponse | JsonRpcResponse[]\n  ) {\n    res.statusCode = 200;\n    res.setHeader(\"Content-Type\", \"application/json\");\n    res.end(JSON.stringify(rpcResp));\n  }\n\n  private async _handleSingleRequest(\n    req: JsonRpcRequest\n  ): Promise<JsonRpcResponse> {\n    if (!isValidJsonRequest(req)) {\n      return _handleError(new InvalidRequestError(\"Invalid request\"));\n    }\n\n    const rpcReq: JsonRpcRequest = req;\n    let rpcResp: JsonRpcResponse | undefined;\n\n    try {\n      rpcResp = await this._handleRequest(rpcReq);\n    } catch (error) {\n      rpcResp = _handleError(error);\n    }\n\n    // Validate the RPC response.\n    if (!isValidJsonResponse(rpcResp)) {\n      // Malformed response coming from the provider, report to user as an internal error.\n      rpcResp = _handleError(new InternalError(\"Internal error\"));\n    }\n\n    if (rpcReq !== undefined) {\n      rpcResp.id = rpcReq.id !== undefined ? rpcReq.id : null;\n    }\n\n    return rpcResp;\n  }\n\n  private async _handleSingleWsRequest(\n    rpcReq: JsonRpcRequest,\n    subscriptions: string[]\n  ) {\n    const rpcResp = await this._handleSingleRequest(rpcReq);\n\n    // If eth_subscribe was successful, keep track of the subscription id,\n    // so we can cleanup on websocket close.\n    if (\n      rpcReq.method === \"eth_subscribe\" &&\n      isSuccessfulJsonResponse(rpcResp)\n    ) {\n      subscriptions.push(rpcResp.result);\n    }\n\n    return rpcResp;\n  }\n\n  private _handleRequest = async (\n    req: JsonRpcRequest\n  ): Promise<JsonRpcResponse> => {\n    const result = await this._provider.request({\n      method: req.method,\n      params: req.params,\n    });\n\n    return {\n      jsonrpc: \"2.0\",\n      id: req.id,\n      result,\n    };\n  };\n}\n\nconst _readJsonHttpRequest = async (req: IncomingMessage): Promise<any> => {\n  let json;\n\n  try {\n    const buf = await getRawBody(req);\n    const text = buf.toString();\n\n    json = JSON.parse(text);\n  } catch (error) {\n    if (error instanceof Error) {\n      throw new InvalidJsonInputError(`Parse error: ${error.message}`);\n    }\n\n    // eslint-disable-next-line @nomiclabs/hardhat-internal-rules/only-hardhat-error\n    throw error;\n  }\n\n  return json;\n};\n\nconst _readWsRequest = (msg: string): JsonRpcRequest | JsonRpcRequest[] => {\n  let json: any;\n  try {\n    json = JSON.parse(msg);\n  } catch (error) {\n    if (error instanceof Error) {\n      throw new InvalidJsonInputError(`Parse error: ${error.message}`);\n    }\n\n    // eslint-disable-next-line @nomiclabs/hardhat-internal-rules/only-hardhat-error\n    throw error;\n  }\n\n  return json;\n};\n\nconst _handleError = (error: any): JsonRpcResponse => {\n  // extract the relevant fields from the error before wrapping it\n  let txHash: string | undefined;\n  let returnData: string | undefined;\n\n  if (error.transactionHash !== undefined) {\n    txHash = error.transactionHash;\n  }\n  if (error.data !== undefined) {\n    returnData = error.data;\n  }\n\n  // In case of non-hardhat error, treat it as internal and associate the appropriate error code.\n  if (!ProviderError.isProviderError(error)) {\n    error = new InternalError(error);\n  }\n\n  const response: FailedJsonRpcResponse = {\n    jsonrpc: \"2.0\",\n    id: null,\n    error: {\n      code: error.code,\n      message: error.message,\n    },\n  };\n\n  response.error.data = {\n    message: error.message,\n  };\n\n  if (txHash !== undefined) {\n    response.error.data.txHash = txHash;\n  }\n\n  if (returnData !== undefined) {\n    response.error.data.data = returnData;\n  }\n\n  return response;\n};\n"]},"metadata":{},"sourceType":"script","externalDependencies":[]}