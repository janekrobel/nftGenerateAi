{"ast":null,"code":"\"use strict\";\n\n/**\n *  About ENS Resolver\n *\n *  @_section: api/providers/ens-resolver:ENS Resolver  [about-ens-rsolver]\n */\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.EnsResolver = exports.BasicMulticoinProviderPlugin = exports.MulticoinProviderPlugin = void 0;\nconst index_js_1 = require(\"../constants/index.js\");\nconst index_js_2 = require(\"../contract/index.js\");\nconst index_js_3 = require(\"../hash/index.js\");\nconst index_js_4 = require(\"../utils/index.js\");\n// @TODO: This should use the fetch-data:ipfs gateway\n// Trim off the ipfs:// prefix and return the default gateway URL\nfunction getIpfsLink(link) {\n  if (link.match(/^ipfs:\\/\\/ipfs\\//i)) {\n    link = link.substring(12);\n  } else if (link.match(/^ipfs:\\/\\//i)) {\n    link = link.substring(7);\n  } else {\n    (0, index_js_4.assertArgument)(false, \"unsupported IPFS format\", \"link\", link);\n  }\n  return `https:/\\/gateway.ipfs.io/ipfs/${link}`;\n}\n;\n;\n/**\n *  A provider plugin super-class for processing multicoin address types.\n */\nclass MulticoinProviderPlugin {\n  name;\n  constructor(name) {\n    (0, index_js_4.defineProperties)(this, {\n      name\n    });\n  }\n  connect(proivder) {\n    return this;\n  }\n  supportsCoinType(coinType) {\n    return false;\n  }\n  async encodeAddress(coinType, address) {\n    throw new Error(\"unsupported coin\");\n  }\n  async decodeAddress(coinType, data) {\n    throw new Error(\"unsupported coin\");\n  }\n}\nexports.MulticoinProviderPlugin = MulticoinProviderPlugin;\nconst BasicMulticoinPluginId = \"org.ethers.plugins.provider.BasicMulticoin\";\n/**\n *  A basic multicoin provider plugin.\n */\nclass BasicMulticoinProviderPlugin extends MulticoinProviderPlugin {\n  constructor() {\n    super(BasicMulticoinPluginId);\n  }\n}\nexports.BasicMulticoinProviderPlugin = BasicMulticoinProviderPlugin;\nconst matcherIpfs = new RegExp(\"^(ipfs):/\\/(.*)$\", \"i\");\nconst matchers = [new RegExp(\"^(https):/\\/(.*)$\", \"i\"), new RegExp(\"^(data):(.*)$\", \"i\"), matcherIpfs, new RegExp(\"^eip155:[0-9]+/(erc[0-9]+):(.*)$\", \"i\")];\n/**\n *  A connected object to a resolved ENS name resolver, which can be\n *  used to query additional details.\n */\nclass EnsResolver {\n  /**\n   *  The connected provider.\n   */\n  provider;\n  /**\n   *  The address of the resolver.\n   */\n  address;\n  /**\n   *  The name this resovler was resolved against.\n   */\n  name;\n  // For EIP-2544 names, the ancestor that provided the resolver\n  #supports2544;\n  #resolver;\n  constructor(provider, address, name) {\n    (0, index_js_4.defineProperties)(this, {\n      provider,\n      address,\n      name\n    });\n    this.#supports2544 = null;\n    this.#resolver = new index_js_2.Contract(address, [\"function supportsInterface(bytes4) view returns (bool)\", \"function resolve(bytes, bytes) view returns (bytes)\", \"function addr(bytes32) view returns (address)\", \"function addr(bytes32, uint) view returns (address)\", \"function text(bytes32, string) view returns (string)\", \"function contenthash(bytes32) view returns (bytes)\"], provider);\n  }\n  /**\n   *  Resolves to true if the resolver supports wildcard resolution.\n   */\n  async supportsWildcard() {\n    if (this.#supports2544 == null) {\n      this.#supports2544 = (async () => {\n        try {\n          return await this.#resolver.supportsInterface(\"0x9061b923\");\n        } catch (error) {\n          // Wildcard resolvers must understand supportsInterface\n          // and return true.\n          if ((0, index_js_4.isError)(error, \"CALL_EXCEPTION\")) {\n            return false;\n          }\n          // Let future attempts try again...\n          this.#supports2544 = null;\n          throw error;\n        }\n      })();\n    }\n    return await this.#supports2544;\n  }\n  async #fetch(funcName, params) {\n    params = (params || []).slice();\n    const iface = this.#resolver.interface;\n    // The first parameters is always the nodehash\n    params.unshift((0, index_js_3.namehash)(this.name));\n    let fragment = null;\n    if (await this.supportsWildcard()) {\n      fragment = iface.getFunction(funcName);\n      (0, index_js_4.assert)(fragment, \"missing fragment\", \"UNKNOWN_ERROR\", {\n        info: {\n          funcName\n        }\n      });\n      params = [(0, index_js_3.dnsEncode)(this.name), iface.encodeFunctionData(fragment, params)];\n      funcName = \"resolve(bytes,bytes)\";\n    }\n    params.push({\n      ccipReadEnable: true\n    });\n    try {\n      const result = await this.#resolver[funcName](...params);\n      if (fragment) {\n        return iface.decodeFunctionResult(fragment, result)[0];\n      }\n      return result;\n    } catch (error) {\n      if (!(0, index_js_4.isError)(error, \"CALL_EXCEPTION\")) {\n        throw error;\n      }\n    }\n    return null;\n  }\n  /**\n   *  Resolves to the address for %%coinType%% or null if the\n   *  provided %%coinType%% has not been configured.\n   */\n  async getAddress(coinType) {\n    if (coinType == null) {\n      coinType = 60;\n    }\n    if (coinType === 60) {\n      try {\n        const result = await this.#fetch(\"addr(bytes32)\");\n        // No address\n        if (result == null || result === index_js_1.ZeroAddress) {\n          return null;\n        }\n        return result;\n      } catch (error) {\n        if ((0, index_js_4.isError)(error, \"CALL_EXCEPTION\")) {\n          return null;\n        }\n        throw error;\n      }\n    }\n    let coinPlugin = null;\n    for (const plugin of this.provider.plugins) {\n      if (!(plugin instanceof MulticoinProviderPlugin)) {\n        continue;\n      }\n      if (plugin.supportsCoinType(coinType)) {\n        coinPlugin = plugin;\n        break;\n      }\n    }\n    if (coinPlugin == null) {\n      return null;\n    }\n    // keccak256(\"addr(bytes32,uint256\")\n    const data = await this.#fetch(\"addr(bytes32,uint)\", [coinType]);\n    // No address\n    if (data == null || data === \"0x\") {\n      return null;\n    }\n    // Compute the address\n    const address = await coinPlugin.encodeAddress(coinType, data);\n    if (address != null) {\n      return address;\n    }\n    (0, index_js_4.assert)(false, `invalid coin data`, \"UNSUPPORTED_OPERATION\", {\n      operation: `getAddress(${coinType})`,\n      info: {\n        coinType,\n        data\n      }\n    });\n  }\n  /**\n   *  Resovles to the EIP-643 text record for %%key%%, or ``null``\n   *  if unconfigured.\n   */\n  async getText(key) {\n    const data = await this.#fetch(\"text(bytes32,string)\", [key]);\n    if (data == null || data === \"0x\") {\n      return null;\n    }\n    return data;\n  }\n  /**\n   *  Rsolves to the content-hash or ``null`` if unconfigured.\n   */\n  async getContentHash() {\n    // keccak256(\"contenthash()\")\n    const data = await this.#fetch(\"contenthash(bytes32)\");\n    // No contenthash\n    if (data == null || data === \"0x\") {\n      return null;\n    }\n    // IPFS (CID: 1, Type: 70=DAG-PB, 72=libp2p-key)\n    const ipfs = data.match(/^0x(e3010170|e5010172)(([0-9a-f][0-9a-f])([0-9a-f][0-9a-f])([0-9a-f]*))$/);\n    if (ipfs) {\n      const scheme = ipfs[1] === \"e3010170\" ? \"ipfs\" : \"ipns\";\n      const length = parseInt(ipfs[4], 16);\n      if (ipfs[5].length === length * 2) {\n        return `${scheme}:/\\/${(0, index_js_4.encodeBase58)(\"0x\" + ipfs[2])}`;\n      }\n    }\n    // Swarm (CID: 1, Type: swarm-manifest; hash/length hard-coded to keccak256/32)\n    const swarm = data.match(/^0xe40101fa011b20([0-9a-f]*)$/);\n    if (swarm && swarm[1].length === 64) {\n      return `bzz:/\\/${swarm[1]}`;\n    }\n    (0, index_js_4.assert)(false, `invalid or unsupported content hash data`, \"UNSUPPORTED_OPERATION\", {\n      operation: \"getContentHash()\",\n      info: {\n        data\n      }\n    });\n  }\n  /**\n   *  Resolves to the avatar url or ``null`` if the avatar is either\n   *  unconfigured or incorrectly configured (e.g. references an NFT\n   *  not owned by the address).\n   *\n   *  If diagnosing issues with configurations, the [[_getAvatar]]\n   *  method may be useful.\n   */\n  async getAvatar() {\n    const avatar = await this._getAvatar();\n    return avatar.url;\n  }\n  /**\n   *  When resolving an avatar, there are many steps involved, such\n   *  fetching metadata and possibly validating ownership of an\n   *  NFT.\n   *\n   *  This method can be used to examine each step and the value it\n   *  was working from.\n   */\n  async _getAvatar() {\n    const linkage = [{\n      type: \"name\",\n      value: this.name\n    }];\n    try {\n      // test data for ricmoo.eth\n      //const avatar = \"eip155:1/erc721:0x265385c7f4132228A0d54EB1A9e7460b91c0cC68/29233\";\n      const avatar = await this.getText(\"avatar\");\n      if (avatar == null) {\n        linkage.push({\n          type: \"!avatar\",\n          value: \"\"\n        });\n        return {\n          url: null,\n          linkage\n        };\n      }\n      linkage.push({\n        type: \"avatar\",\n        value: avatar\n      });\n      for (let i = 0; i < matchers.length; i++) {\n        const match = avatar.match(matchers[i]);\n        if (match == null) {\n          continue;\n        }\n        const scheme = match[1].toLowerCase();\n        switch (scheme) {\n          case \"https\":\n          case \"data\":\n            linkage.push({\n              type: \"url\",\n              value: avatar\n            });\n            return {\n              linkage,\n              url: avatar\n            };\n          case \"ipfs\":\n            {\n              const url = getIpfsLink(avatar);\n              linkage.push({\n                type: \"ipfs\",\n                value: avatar\n              });\n              linkage.push({\n                type: \"url\",\n                value: url\n              });\n              return {\n                linkage,\n                url\n              };\n            }\n          case \"erc721\":\n          case \"erc1155\":\n            {\n              // Depending on the ERC type, use tokenURI(uint256) or url(uint256)\n              const selector = scheme === \"erc721\" ? \"tokenURI(uint256)\" : \"uri(uint256)\";\n              linkage.push({\n                type: scheme,\n                value: avatar\n              });\n              // The owner of this name\n              const owner = await this.getAddress();\n              if (owner == null) {\n                linkage.push({\n                  type: \"!owner\",\n                  value: \"\"\n                });\n                return {\n                  url: null,\n                  linkage\n                };\n              }\n              const comps = (match[2] || \"\").split(\"/\");\n              if (comps.length !== 2) {\n                linkage.push({\n                  type: `!${scheme}caip`,\n                  value: match[2] || \"\"\n                });\n                return {\n                  url: null,\n                  linkage\n                };\n              }\n              const tokenId = comps[1];\n              const contract = new index_js_2.Contract(comps[0], [\n              // ERC-721\n              \"function tokenURI(uint) view returns (string)\", \"function ownerOf(uint) view returns (address)\",\n              // ERC-1155\n              \"function uri(uint) view returns (string)\", \"function balanceOf(address, uint256) view returns (uint)\"], this.provider);\n              // Check that this account owns the token\n              if (scheme === \"erc721\") {\n                const tokenOwner = await contract.ownerOf(tokenId);\n                if (owner !== tokenOwner) {\n                  linkage.push({\n                    type: \"!owner\",\n                    value: tokenOwner\n                  });\n                  return {\n                    url: null,\n                    linkage\n                  };\n                }\n                linkage.push({\n                  type: \"owner\",\n                  value: tokenOwner\n                });\n              } else if (scheme === \"erc1155\") {\n                const balance = await contract.balanceOf(owner, tokenId);\n                if (!balance) {\n                  linkage.push({\n                    type: \"!balance\",\n                    value: \"0\"\n                  });\n                  return {\n                    url: null,\n                    linkage\n                  };\n                }\n                linkage.push({\n                  type: \"balance\",\n                  value: balance.toString()\n                });\n              }\n              // Call the token contract for the metadata URL\n              let metadataUrl = await contract[selector](tokenId);\n              if (metadataUrl == null || metadataUrl === \"0x\") {\n                linkage.push({\n                  type: \"!metadata-url\",\n                  value: \"\"\n                });\n                return {\n                  url: null,\n                  linkage\n                };\n              }\n              linkage.push({\n                type: \"metadata-url-base\",\n                value: metadataUrl\n              });\n              // ERC-1155 allows a generic {id} in the URL\n              if (scheme === \"erc1155\") {\n                metadataUrl = metadataUrl.replace(\"{id}\", (0, index_js_4.toBeHex)(tokenId, 32).substring(2));\n                linkage.push({\n                  type: \"metadata-url-expanded\",\n                  value: metadataUrl\n                });\n              }\n              // Transform IPFS metadata links\n              if (metadataUrl.match(/^ipfs:/i)) {\n                metadataUrl = getIpfsLink(metadataUrl);\n              }\n              linkage.push({\n                type: \"metadata-url\",\n                value: metadataUrl\n              });\n              // Get the token metadata\n              let metadata = {};\n              const response = await new index_js_4.FetchRequest(metadataUrl).send();\n              response.assertOk();\n              try {\n                metadata = response.bodyJson;\n              } catch (error) {\n                try {\n                  linkage.push({\n                    type: \"!metadata\",\n                    value: response.bodyText\n                  });\n                } catch (error) {\n                  const bytes = response.body;\n                  if (bytes) {\n                    linkage.push({\n                      type: \"!metadata\",\n                      value: (0, index_js_4.hexlify)(bytes)\n                    });\n                  }\n                  return {\n                    url: null,\n                    linkage\n                  };\n                }\n                return {\n                  url: null,\n                  linkage\n                };\n              }\n              if (!metadata) {\n                linkage.push({\n                  type: \"!metadata\",\n                  value: \"\"\n                });\n                return {\n                  url: null,\n                  linkage\n                };\n              }\n              linkage.push({\n                type: \"metadata\",\n                value: JSON.stringify(metadata)\n              });\n              // Pull the image URL out\n              let imageUrl = metadata.image;\n              if (typeof imageUrl !== \"string\") {\n                linkage.push({\n                  type: \"!imageUrl\",\n                  value: \"\"\n                });\n                return {\n                  url: null,\n                  linkage\n                };\n              }\n              if (imageUrl.match(/^(https:\\/\\/|data:)/i)) {\n                // Allow\n              } else {\n                // Transform IPFS link to gateway\n                const ipfs = imageUrl.match(matcherIpfs);\n                if (ipfs == null) {\n                  linkage.push({\n                    type: \"!imageUrl-ipfs\",\n                    value: imageUrl\n                  });\n                  return {\n                    url: null,\n                    linkage\n                  };\n                }\n                linkage.push({\n                  type: \"imageUrl-ipfs\",\n                  value: imageUrl\n                });\n                imageUrl = getIpfsLink(imageUrl);\n              }\n              linkage.push({\n                type: \"url\",\n                value: imageUrl\n              });\n              return {\n                linkage,\n                url: imageUrl\n              };\n            }\n        }\n      }\n    } catch (error) {}\n    return {\n      linkage,\n      url: null\n    };\n  }\n  static async getEnsAddress(provider) {\n    const network = await provider.getNetwork();\n    const ensPlugin = network.getPlugin(\"org.ethers.plugins.network.Ens\");\n    // No ENS...\n    (0, index_js_4.assert)(ensPlugin, \"network does not support ENS\", \"UNSUPPORTED_OPERATION\", {\n      operation: \"getEnsAddress\",\n      info: {\n        network\n      }\n    });\n    return ensPlugin.address;\n  }\n  static async #getResolver(provider, name) {\n    const ensAddr = await EnsResolver.getEnsAddress(provider);\n    try {\n      const contract = new index_js_2.Contract(ensAddr, [\"function resolver(bytes32) view returns (address)\"], provider);\n      const addr = await contract.resolver((0, index_js_3.namehash)(name), {\n        enableCcipRead: true\n      });\n      if (addr === index_js_1.ZeroAddress) {\n        return null;\n      }\n      return addr;\n    } catch (error) {\n      // ENS registry cannot throw errors on resolver(bytes32),\n      // so probably a link error\n      throw error;\n    }\n    return null;\n  }\n  /**\n   *  Resolve to the ENS resolver for %%name%% using %%provider%% or\n   *  ``null`` if unconfigured.\n   */\n  static async fromName(provider, name) {\n    let currentName = name;\n    while (true) {\n      if (currentName === \"\" || currentName === \".\") {\n        return null;\n      }\n      // Optimization since the eth node cannot change and does\n      // not have a wildcar resolver\n      if (name !== \"eth\" && currentName === \"eth\") {\n        return null;\n      }\n      // Check the current node for a resolver\n      const addr = await EnsResolver.#getResolver(provider, currentName);\n      // Found a resolver!\n      if (addr != null) {\n        const resolver = new EnsResolver(provider, addr, name);\n        // Legacy resolver found, using EIP-2544 so it isn't safe to use\n        if (currentName !== name && !(await resolver.supportsWildcard())) {\n          return null;\n        }\n        return resolver;\n      }\n      // Get the parent node\n      currentName = currentName.split(\".\").slice(1).join(\".\");\n    }\n  }\n}\nexports.EnsResolver = EnsResolver;","map":{"version":3,"mappings":"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","names":["getIpfsLink","link","match","substring","MulticoinProviderPlugin","name","constructor","connect","proivder","supportsCoinType","coinType","encodeAddress","address","Error","decodeAddress","data","exports","BasicMulticoinPluginId","BasicMulticoinProviderPlugin","matcherIpfs","RegExp","matchers","EnsResolver","provider","index_js_2","supportsWildcard","supportsInterface","error","funcName","params","slice","iface","interface","unshift","fragment","getFunction","info","encodeFunctionData","push","ccipReadEnable","result","decodeFunctionResult","getAddress","index_js_1","coinPlugin","plugin","plugins","operation","getText","key","getContentHash","ipfs","scheme","length","parseInt","swarm","getAvatar","avatar","_getAvatar","url","linkage","type","value","i","toLowerCase","selector","owner","comps","split","tokenId","contract","tokenOwner","ownerOf","balance","balanceOf","toString","metadataUrl","replace","metadata","response","index_js_4","send","assertOk","bodyJson","bodyText","bytes","body","JSON","stringify","imageUrl","image","getEnsAddress","network","getNetwork","ensPlugin","getPlugin","ensAddr","addr","resolver","enableCcipRead","fromName","currentName","join"],"sources":["/Users/janrobel/Documents/PersonalProjekty/nftGenerateAi/clientAndContract/node_modules/ethers/src.ts/providers/ens-resolver.ts"],"sourcesContent":["/**\n *  About ENS Resolver\n *\n *  @_section: api/providers/ens-resolver:ENS Resolver  [about-ens-rsolver]\n */\n\nimport { ZeroAddress } from \"../constants/index.js\";\nimport { Contract } from \"../contract/index.js\";\nimport { dnsEncode, namehash } from \"../hash/index.js\";\nimport {\n    hexlify, toBeHex,\n    defineProperties, encodeBase58,\n    assert, assertArgument, isError,\n    FetchRequest\n} from \"../utils/index.js\";\n\nimport type { FunctionFragment } from \"../abi/index.js\";\n\nimport type { BytesLike } from \"../utils/index.js\";\n\nimport type { AbstractProvider, AbstractProviderPlugin } from \"./abstract-provider.js\";\nimport type { EnsPlugin } from \"./plugins-network.js\";\nimport type { Provider } from \"./provider.js\";\n\n// @TODO: This should use the fetch-data:ipfs gateway\n// Trim off the ipfs:// prefix and return the default gateway URL\nfunction getIpfsLink(link: string): string {\n    if (link.match(/^ipfs:\\/\\/ipfs\\//i)) {\n        link = link.substring(12);\n    } else if (link.match(/^ipfs:\\/\\//i)) {\n        link = link.substring(7);\n    } else {\n        assertArgument(false, \"unsupported IPFS format\", \"link\", link);\n    }\n\n    return `https:/\\/gateway.ipfs.io/ipfs/${ link }`;\n}\n\n/**\n *  The type of data found during a steip during avatar resolution.\n */\nexport type AvatarLinkageType = \"name\" | \"avatar\" | \"!avatar\" | \"url\" | \"data\" | \"ipfs\" |\n    \"erc721\" | \"erc1155\" | \"!erc721-caip\" | \"!erc1155-caip\" |\n    \"!owner\" | \"owner\" | \"!balance\" | \"balance\" |\n    \"metadata-url-base\" | \"metadata-url-expanded\" | \"metadata-url\" | \"!metadata-url\" |\n    \"!metadata\" | \"metadata\" |\n    \"!imageUrl\" | \"imageUrl-ipfs\" | \"imageUrl\" | \"!imageUrl-ipfs\";\n\n/**\n *  An individual record for each step during avatar resolution.\n */\nexport interface AvatarLinkage {\n    type: AvatarLinkageType;\n    value: string;\n};\n\n/**\n *  When resolving an avatar for an ENS name, there are many\n *  steps involved, fetching metadata, validating results, et cetera.\n *\n *  Some applications may wish to analyse this data, or use this data\n *  to diagnose promblems, so an **AvatarResult** provides details of\n *  each completed step during avatar resolution.\n */\nexport interface AvatarResult {\n    linkage: Array<AvatarLinkage>;\n    url: null | string;\n};\n\n/**\n *  A provider plugin super-class for processing multicoin address types.\n */\nexport abstract class MulticoinProviderPlugin implements AbstractProviderPlugin {\n    readonly name!: string;\n\n    constructor(name: string) {\n        defineProperties<MulticoinProviderPlugin>(this, { name });\n    }\n\n    connect(proivder: Provider): MulticoinProviderPlugin {\n        return this;\n    }\n\n    supportsCoinType(coinType: number): boolean {\n        return false;\n    }\n\n    async encodeAddress(coinType: number, address: string): Promise<string> {\n        throw new Error(\"unsupported coin\");\n    }\n\n    async decodeAddress(coinType: number, data: BytesLike): Promise<string> {\n        throw new Error(\"unsupported coin\");\n    }\n}\n\nconst BasicMulticoinPluginId = \"org.ethers.plugins.provider.BasicMulticoin\";\n\n/**\n *  A basic multicoin provider plugin.\n */\nexport class BasicMulticoinProviderPlugin extends MulticoinProviderPlugin {\n    constructor() {\n        super(BasicMulticoinPluginId);\n    }\n}\n\nconst matcherIpfs = new RegExp(\"^(ipfs):/\\/(.*)$\", \"i\");\nconst matchers = [\n    new RegExp(\"^(https):/\\/(.*)$\", \"i\"),\n    new RegExp(\"^(data):(.*)$\", \"i\"),\n    matcherIpfs,\n    new RegExp(\"^eip155:[0-9]+/(erc[0-9]+):(.*)$\", \"i\"),\n];\n\n/**\n *  A connected object to a resolved ENS name resolver, which can be\n *  used to query additional details.\n */\nexport class EnsResolver {\n    /**\n     *  The connected provider.\n     */\n    provider!: AbstractProvider;\n\n    /**\n     *  The address of the resolver.\n     */\n    address!: string;\n\n    /**\n     *  The name this resovler was resolved against.\n     */\n    name!: string;\n\n    // For EIP-2544 names, the ancestor that provided the resolver\n    #supports2544: null | Promise<boolean>;\n\n    #resolver: Contract;\n\n    constructor(provider: AbstractProvider, address: string, name: string) {\n        defineProperties<EnsResolver>(this, { provider, address, name });\n        this.#supports2544 = null;\n\n        this.#resolver = new Contract(address, [\n            \"function supportsInterface(bytes4) view returns (bool)\",\n            \"function resolve(bytes, bytes) view returns (bytes)\",\n            \"function addr(bytes32) view returns (address)\",\n            \"function addr(bytes32, uint) view returns (address)\",\n            \"function text(bytes32, string) view returns (string)\",\n            \"function contenthash(bytes32) view returns (bytes)\",\n        ], provider);\n\n    }\n\n    /**\n     *  Resolves to true if the resolver supports wildcard resolution.\n     */\n    async supportsWildcard(): Promise<boolean> {\n        if (this.#supports2544 == null) {\n            this.#supports2544 = (async () => {\n                try {\n                    return await this.#resolver.supportsInterface(\"0x9061b923\");\n                } catch (error) {\n                    // Wildcard resolvers must understand supportsInterface\n                    // and return true.\n                    if (isError(error, \"CALL_EXCEPTION\")) { return false; }\n\n                    // Let future attempts try again...\n                    this.#supports2544 = null;\n\n                    throw error;\n                }\n            })();\n        }\n\n        return await this.#supports2544;\n    }\n\n    async #fetch(funcName: string, params?: Array<any>): Promise<null | any> {\n        params = (params || []).slice();\n        const iface = this.#resolver.interface;\n\n        // The first parameters is always the nodehash\n        params.unshift(namehash(this.name))\n\n        let fragment: null | FunctionFragment = null;\n        if (await this.supportsWildcard()) {\n            fragment = iface.getFunction(funcName);\n            assert(fragment, \"missing fragment\", \"UNKNOWN_ERROR\", {\n                info: { funcName }\n            });\n\n            params = [\n                dnsEncode(this.name),\n                iface.encodeFunctionData(fragment, params)\n            ];\n\n            funcName = \"resolve(bytes,bytes)\";\n        }\n\n        params.push({\n            ccipReadEnable: true\n        });\n\n        try {\n            const result = await this.#resolver[funcName](...params);\n\n            if (fragment) {\n                return iface.decodeFunctionResult(fragment, result)[0];\n            }\n\n            return result;\n        } catch (error: any) {\n            if (!isError(error, \"CALL_EXCEPTION\")) { throw error; }\n        }\n\n        return null;\n    }\n\n    /**\n     *  Resolves to the address for %%coinType%% or null if the\n     *  provided %%coinType%% has not been configured.\n     */\n    async getAddress(coinType?: number): Promise<null | string> {\n        if (coinType == null) { coinType = 60; }\n        if (coinType === 60) {\n            try {\n                const result = await this.#fetch(\"addr(bytes32)\");\n\n                // No address\n                if (result == null || result === ZeroAddress) { return null; }\n\n                return result;\n            } catch (error: any) {\n                if (isError(error, \"CALL_EXCEPTION\")) { return null; }\n                throw error;\n            }\n        }\n\n        let coinPlugin: null | MulticoinProviderPlugin = null;\n        for (const plugin of this.provider.plugins) {\n            if (!(plugin instanceof MulticoinProviderPlugin)) { continue; }\n            if (plugin.supportsCoinType(coinType)) {\n                coinPlugin = plugin;\n                break;\n            }\n        }\n\n        if (coinPlugin == null) { return null; }\n\n        // keccak256(\"addr(bytes32,uint256\")\n        const data = await this.#fetch(\"addr(bytes32,uint)\", [ coinType ]);\n\n        // No address\n        if (data == null || data === \"0x\") { return null; }\n\n        // Compute the address\n        const address = await coinPlugin.encodeAddress(coinType, data);\n\n        if (address != null) { return address; }\n\n        assert(false, `invalid coin data`, \"UNSUPPORTED_OPERATION\", {\n            operation: `getAddress(${ coinType })`,\n            info: { coinType, data }\n        });\n    }\n\n    /**\n     *  Resovles to the EIP-643 text record for %%key%%, or ``null``\n     *  if unconfigured.\n     */\n    async getText(key: string): Promise<null | string> {\n        const data = await this.#fetch(\"text(bytes32,string)\", [ key ]);\n        if (data == null || data === \"0x\") { return null; }\n        return data;\n    }\n\n    /**\n     *  Rsolves to the content-hash or ``null`` if unconfigured.\n     */\n    async getContentHash(): Promise<null | string> {\n        // keccak256(\"contenthash()\")\n        const data = await this.#fetch(\"contenthash(bytes32)\");\n\n        // No contenthash\n        if (data == null || data === \"0x\") { return null; }\n\n        // IPFS (CID: 1, Type: 70=DAG-PB, 72=libp2p-key)\n        const ipfs = data.match(/^0x(e3010170|e5010172)(([0-9a-f][0-9a-f])([0-9a-f][0-9a-f])([0-9a-f]*))$/);\n        if (ipfs) {\n            const scheme = (ipfs[1] === \"e3010170\") ? \"ipfs\": \"ipns\";\n            const length = parseInt(ipfs[4], 16);\n            if (ipfs[5].length === length * 2) {\n                return `${ scheme }:/\\/${ encodeBase58(\"0x\" + ipfs[2])}`;\n            }\n        }\n\n        // Swarm (CID: 1, Type: swarm-manifest; hash/length hard-coded to keccak256/32)\n        const swarm = data.match(/^0xe40101fa011b20([0-9a-f]*)$/)\n        if (swarm && swarm[1].length === 64) {\n            return `bzz:/\\/${ swarm[1] }`;\n        }\n\n        assert(false, `invalid or unsupported content hash data`, \"UNSUPPORTED_OPERATION\", {\n            operation: \"getContentHash()\",\n            info: { data }\n        });\n    }\n\n    /**\n     *  Resolves to the avatar url or ``null`` if the avatar is either\n     *  unconfigured or incorrectly configured (e.g. references an NFT\n     *  not owned by the address).\n     *\n     *  If diagnosing issues with configurations, the [[_getAvatar]]\n     *  method may be useful.\n     */\n    async getAvatar(): Promise<null | string> {\n        const avatar = await this._getAvatar();\n        return avatar.url;\n    }\n\n    /**\n     *  When resolving an avatar, there are many steps involved, such\n     *  fetching metadata and possibly validating ownership of an\n     *  NFT.\n     *\n     *  This method can be used to examine each step and the value it\n     *  was working from.\n     */\n    async _getAvatar(): Promise<AvatarResult> {\n        const linkage: Array<AvatarLinkage> = [ { type: \"name\", value: this.name } ];\n        try {\n            // test data for ricmoo.eth\n            //const avatar = \"eip155:1/erc721:0x265385c7f4132228A0d54EB1A9e7460b91c0cC68/29233\";\n            const avatar = await this.getText(\"avatar\");\n            if (avatar == null) {\n                linkage.push({ type: \"!avatar\", value: \"\" });\n                return { url: null, linkage };\n            }\n            linkage.push({ type: \"avatar\", value: avatar });\n\n            for (let i = 0; i < matchers.length; i++) {\n                const match = avatar.match(matchers[i]);\n                if (match == null) { continue; }\n\n                const scheme = match[1].toLowerCase();\n\n                switch (scheme) {\n                    case \"https\":\n                    case \"data\":\n                        linkage.push({ type: \"url\", value: avatar });\n                        return { linkage, url: avatar };\n                    case \"ipfs\": {\n                        const url = getIpfsLink(avatar);\n                        linkage.push({ type: \"ipfs\", value: avatar });\n                        linkage.push({ type: \"url\", value: url });\n                        return { linkage, url };\n                    }\n\n                    case \"erc721\":\n                    case \"erc1155\": {\n                        // Depending on the ERC type, use tokenURI(uint256) or url(uint256)\n                        const selector = (scheme === \"erc721\") ? \"tokenURI(uint256)\": \"uri(uint256)\";\n                        linkage.push({ type: scheme, value: avatar });\n\n                        // The owner of this name\n                        const owner = await this.getAddress();\n                        if (owner == null) {\n                            linkage.push({ type: \"!owner\", value: \"\" });\n                            return { url: null, linkage };\n                        }\n\n                        const comps = (match[2] || \"\").split(\"/\");\n                        if (comps.length !== 2) {\n                            linkage.push({ type: <any>`!${ scheme }caip`, value: (match[2] || \"\") });\n                            return { url: null, linkage };\n                        }\n\n                        const tokenId = comps[1];\n\n                        const contract = new Contract(comps[0], [\n                            // ERC-721\n                            \"function tokenURI(uint) view returns (string)\",\n                            \"function ownerOf(uint) view returns (address)\",\n\n                            // ERC-1155\n                            \"function uri(uint) view returns (string)\",\n                            \"function balanceOf(address, uint256) view returns (uint)\"\n                        ], this.provider);\n\n                        // Check that this account owns the token\n                        if (scheme === \"erc721\") {\n                            const tokenOwner = await contract.ownerOf(tokenId);\n\n                            if (owner !== tokenOwner) {\n                                linkage.push({ type: \"!owner\", value: tokenOwner });\n                                return { url: null, linkage };\n                            }\n                            linkage.push({ type: \"owner\", value: tokenOwner });\n\n                        } else if (scheme === \"erc1155\") {\n                            const balance = await contract.balanceOf(owner, tokenId);\n                            if (!balance) {\n                                linkage.push({ type: \"!balance\", value: \"0\" });\n                                return { url: null, linkage };\n                            }\n                            linkage.push({ type: \"balance\", value: balance.toString() });\n                        }\n\n                        // Call the token contract for the metadata URL\n                        let metadataUrl = await contract[selector](tokenId);\n                        if (metadataUrl == null || metadataUrl === \"0x\") {\n                            linkage.push({ type: \"!metadata-url\", value: \"\" });\n                            return { url: null, linkage };\n                        }\n\n                        linkage.push({ type: \"metadata-url-base\", value: metadataUrl });\n\n                        // ERC-1155 allows a generic {id} in the URL\n                        if (scheme === \"erc1155\") {\n                            metadataUrl = metadataUrl.replace(\"{id}\", toBeHex(tokenId, 32).substring(2));\n                            linkage.push({ type: \"metadata-url-expanded\", value: metadataUrl });\n                        }\n\n                        // Transform IPFS metadata links\n                        if (metadataUrl.match(/^ipfs:/i)) {\n                            metadataUrl = getIpfsLink(metadataUrl);\n                        }\n                        linkage.push({ type: \"metadata-url\", value: metadataUrl });\n\n                        // Get the token metadata\n                        let metadata: any = { };\n                        const response = await (new FetchRequest(metadataUrl)).send();\n                        response.assertOk();\n\n                        try {\n                            metadata = response.bodyJson;\n                        } catch (error) {\n                            try {\n                                linkage.push({ type: \"!metadata\", value: response.bodyText });\n                            } catch (error) {\n                                const bytes = response.body;\n                                if (bytes) {\n                                    linkage.push({ type: \"!metadata\", value: hexlify(bytes) });\n                                }\n                                return { url: null, linkage };\n                            }\n                            return { url: null, linkage };\n                        }\n\n                        if (!metadata) {\n                            linkage.push({ type: \"!metadata\", value: \"\" });\n                            return { url: null, linkage };\n                        }\n\n                        linkage.push({ type: \"metadata\", value: JSON.stringify(metadata) });\n\n                        // Pull the image URL out\n                        let imageUrl = metadata.image;\n                        if (typeof(imageUrl) !== \"string\") {\n                            linkage.push({ type: \"!imageUrl\", value: \"\" });\n                            return { url: null, linkage };\n                        }\n\n                        if (imageUrl.match(/^(https:\\/\\/|data:)/i)) {\n                            // Allow\n                        } else {\n                            // Transform IPFS link to gateway\n                            const ipfs = imageUrl.match(matcherIpfs);\n                            if (ipfs == null) {\n                                linkage.push({ type: \"!imageUrl-ipfs\", value: imageUrl });\n                                return { url: null, linkage };\n                            }\n\n                            linkage.push({ type: \"imageUrl-ipfs\", value: imageUrl });\n                            imageUrl = getIpfsLink(imageUrl);\n                        }\n\n                        linkage.push({ type: \"url\", value: imageUrl });\n\n                        return { linkage, url: imageUrl };\n                    }\n                }\n            }\n        } catch (error) { }\n\n        return { linkage, url: null };\n    }\n\n    static async getEnsAddress(provider: Provider): Promise<string> {\n        const network = await provider.getNetwork();\n\n        const ensPlugin = network.getPlugin<EnsPlugin>(\"org.ethers.plugins.network.Ens\");\n\n        // No ENS...\n        assert(ensPlugin, \"network does not support ENS\", \"UNSUPPORTED_OPERATION\", {\n            operation: \"getEnsAddress\", info: { network } });\n\n        return ensPlugin.address;\n    }\n\n    static async #getResolver(provider: Provider, name: string): Promise<null | string> {\n        const ensAddr = await EnsResolver.getEnsAddress(provider);\n\n        try {\n            const contract = new Contract(ensAddr, [\n                \"function resolver(bytes32) view returns (address)\"\n            ], provider);\n\n            const addr = await contract.resolver(namehash(name), {\n                enableCcipRead: true\n            });\n\n            if (addr === ZeroAddress) { return null; }\n            return addr;\n\n        } catch (error) {\n            // ENS registry cannot throw errors on resolver(bytes32),\n            // so probably a link error\n            throw error;\n        }\n\n        return null;\n    }\n\n    /**\n     *  Resolve to the ENS resolver for %%name%% using %%provider%% or\n     *  ``null`` if unconfigured.\n     */\n    static async fromName(provider: AbstractProvider, name: string): Promise<null | EnsResolver> {\n\n        let currentName = name;\n        while (true) {\n            if (currentName === \"\" || currentName === \".\") { return null; }\n\n            // Optimization since the eth node cannot change and does\n            // not have a wildcar resolver\n            if (name !== \"eth\" && currentName === \"eth\") { return null; }\n\n            // Check the current node for a resolver\n            const addr = await EnsResolver.#getResolver(provider, currentName);\n\n            // Found a resolver!\n            if (addr != null) {\n                const resolver = new EnsResolver(provider, addr, name);\n\n                // Legacy resolver found, using EIP-2544 so it isn't safe to use\n                if (currentName !== name && !(await resolver.supportsWildcard())) { return null; }\n\n                return resolver;\n            }\n\n            // Get the parent node\n            currentName = currentName.split(\".\").slice(1).join(\".\");\n        }\n    }\n}\n"]},"metadata":{},"sourceType":"script","externalDependencies":[]}