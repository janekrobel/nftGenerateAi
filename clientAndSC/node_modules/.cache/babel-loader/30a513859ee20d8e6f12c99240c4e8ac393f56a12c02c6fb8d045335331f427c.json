{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.getTsConfigDefaults = exports.ComputeAsCommonRootOfFiles = exports.loadCompiler = exports.resolveAndLoadCompiler = exports.readConfig = exports.findAndReadConfig = void 0;\nconst path_1 = require(\"path\");\nconst index_1 = require(\"./index\");\nconst ts_internals_1 = require(\"./ts-internals\");\nconst tsconfigs_1 = require(\"./tsconfigs\");\nconst util_1 = require(\"./util\");\n/**\n * TypeScript compiler option values required by `ts-node` which cannot be overridden.\n */\nconst TS_NODE_COMPILER_OPTIONS = {\n  sourceMap: true,\n  inlineSourceMap: false,\n  inlineSources: true,\n  declaration: false,\n  noEmit: false,\n  outDir: '.ts-node'\n};\n/*\n * Do post-processing on config options to support `ts-node`.\n */\nfunction fixConfig(ts, config) {\n  // Delete options that *should not* be passed through.\n  delete config.options.out;\n  delete config.options.outFile;\n  delete config.options.composite;\n  delete config.options.declarationDir;\n  delete config.options.declarationMap;\n  delete config.options.emitDeclarationOnly;\n  // Target ES5 output by default (instead of ES3).\n  if (config.options.target === undefined) {\n    config.options.target = ts.ScriptTarget.ES5;\n  }\n  // Target CommonJS modules by default (instead of magically switching to ES6 when the target is ES6).\n  if (config.options.module === undefined) {\n    config.options.module = ts.ModuleKind.CommonJS;\n  }\n  return config;\n}\n/** @internal */\nfunction findAndReadConfig(rawOptions) {\n  var _a, _b, _c, _d, _e;\n  const cwd = (0, path_1.resolve)((_c = (_b = (_a = rawOptions.cwd) !== null && _a !== void 0 ? _a : rawOptions.dir) !== null && _b !== void 0 ? _b : index_1.DEFAULTS.cwd) !== null && _c !== void 0 ? _c : process.cwd());\n  const compilerName = (_d = rawOptions.compiler) !== null && _d !== void 0 ? _d : index_1.DEFAULTS.compiler;\n  // Compute minimum options to read the config file.\n  let projectLocalResolveDir = (0, util_1.getBasePathForProjectLocalDependencyResolution)(undefined, rawOptions.projectSearchDir, rawOptions.project, cwd);\n  let {\n    compiler,\n    ts\n  } = resolveAndLoadCompiler(compilerName, projectLocalResolveDir);\n  // Read config file and merge new options between env and CLI options.\n  const {\n    configFilePath,\n    config,\n    tsNodeOptionsFromTsconfig,\n    optionBasePaths\n  } = readConfig(cwd, ts, rawOptions);\n  const options = (0, util_1.assign)({}, index_1.DEFAULTS, tsNodeOptionsFromTsconfig || {}, {\n    optionBasePaths\n  }, rawOptions);\n  options.require = [...(tsNodeOptionsFromTsconfig.require || []), ...(rawOptions.require || [])];\n  // Re-resolve the compiler in case it has changed.\n  // Compiler is loaded relative to tsconfig.json, so tsconfig discovery may cause us to load a\n  // different compiler than we did above, even if the name has not changed.\n  if (configFilePath) {\n    projectLocalResolveDir = (0, util_1.getBasePathForProjectLocalDependencyResolution)(configFilePath, rawOptions.projectSearchDir, rawOptions.project, cwd);\n    ({\n      compiler\n    } = resolveCompiler(options.compiler, (_e = optionBasePaths.compiler) !== null && _e !== void 0 ? _e : projectLocalResolveDir));\n  }\n  return {\n    options,\n    config,\n    projectLocalResolveDir,\n    optionBasePaths,\n    configFilePath,\n    cwd,\n    compiler\n  };\n}\nexports.findAndReadConfig = findAndReadConfig;\n/**\n * Load TypeScript configuration. Returns the parsed TypeScript config and\n * any `ts-node` options specified in the config file.\n *\n * Even when a tsconfig.json is not loaded, this function still handles merging\n * compilerOptions from various sources: API, environment variables, etc.\n *\n * @internal\n */\nfunction readConfig(cwd, ts, rawApiOptions) {\n  var _a, _b, _c;\n  // Ordered [a, b, c] where config a extends b extends c\n  const configChain = [];\n  let config = {\n    compilerOptions: {}\n  };\n  let basePath = cwd;\n  let configFilePath = undefined;\n  const projectSearchDir = (0, path_1.resolve)(cwd, (_a = rawApiOptions.projectSearchDir) !== null && _a !== void 0 ? _a : cwd);\n  const {\n    fileExists = ts.sys.fileExists,\n    readFile = ts.sys.readFile,\n    skipProject = index_1.DEFAULTS.skipProject,\n    project = index_1.DEFAULTS.project,\n    tsTrace = index_1.DEFAULTS.tsTrace\n  } = rawApiOptions;\n  // Read project configuration when available.\n  if (!skipProject) {\n    if (project) {\n      const resolved = (0, path_1.resolve)(cwd, project);\n      const nested = (0, path_1.join)(resolved, 'tsconfig.json');\n      configFilePath = fileExists(nested) ? nested : resolved;\n    } else {\n      configFilePath = ts.findConfigFile(projectSearchDir, fileExists);\n    }\n    if (configFilePath) {\n      let pathToNextConfigInChain = configFilePath;\n      const tsInternals = (0, ts_internals_1.createTsInternals)(ts);\n      const errors = [];\n      // Follow chain of \"extends\"\n      while (true) {\n        const result = ts.readConfigFile(pathToNextConfigInChain, readFile);\n        // Return diagnostics.\n        if (result.error) {\n          return {\n            configFilePath,\n            config: {\n              errors: [result.error],\n              fileNames: [],\n              options: {}\n            },\n            tsNodeOptionsFromTsconfig: {},\n            optionBasePaths: {}\n          };\n        }\n        const c = result.config;\n        const bp = (0, path_1.dirname)(pathToNextConfigInChain);\n        configChain.push({\n          config: c,\n          basePath: bp,\n          configPath: pathToNextConfigInChain\n        });\n        if (c.extends == null) break;\n        const resolvedExtendedConfigPath = tsInternals.getExtendsConfigPath(c.extends, {\n          fileExists,\n          readDirectory: ts.sys.readDirectory,\n          readFile,\n          useCaseSensitiveFileNames: ts.sys.useCaseSensitiveFileNames,\n          trace: tsTrace\n        }, bp, errors, ts.createCompilerDiagnostic);\n        if (errors.length) {\n          return {\n            configFilePath,\n            config: {\n              errors,\n              fileNames: [],\n              options: {}\n            },\n            tsNodeOptionsFromTsconfig: {},\n            optionBasePaths: {}\n          };\n        }\n        if (resolvedExtendedConfigPath == null) break;\n        pathToNextConfigInChain = resolvedExtendedConfigPath;\n      }\n      ({\n        config,\n        basePath\n      } = configChain[0]);\n    }\n  }\n  // Merge and fix ts-node options that come from tsconfig.json(s)\n  const tsNodeOptionsFromTsconfig = {};\n  const optionBasePaths = {};\n  for (let i = configChain.length - 1; i >= 0; i--) {\n    const {\n      config,\n      basePath,\n      configPath\n    } = configChain[i];\n    const options = filterRecognizedTsConfigTsNodeOptions(config['ts-node']).recognized;\n    // Some options are relative to the config file, so must be converted to absolute paths here\n    if (options.require) {\n      // Modules are found relative to the tsconfig file, not the `dir` option\n      const tsconfigRelativeResolver = (0, util_1.createProjectLocalResolveHelper)((0, path_1.dirname)(configPath));\n      options.require = options.require.map(path => tsconfigRelativeResolver(path, false));\n    }\n    if (options.scopeDir) {\n      options.scopeDir = (0, path_1.resolve)(basePath, options.scopeDir);\n    }\n    // Downstream code uses the basePath; we do not do that here.\n    if (options.moduleTypes) {\n      optionBasePaths.moduleTypes = basePath;\n    }\n    if (options.transpiler != null) {\n      optionBasePaths.transpiler = basePath;\n    }\n    if (options.compiler != null) {\n      optionBasePaths.compiler = basePath;\n    }\n    if (options.swc != null) {\n      optionBasePaths.swc = basePath;\n    }\n    (0, util_1.assign)(tsNodeOptionsFromTsconfig, options);\n  }\n  // Remove resolution of \"files\".\n  const files = (_c = (_b = rawApiOptions.files) !== null && _b !== void 0 ? _b : tsNodeOptionsFromTsconfig.files) !== null && _c !== void 0 ? _c : index_1.DEFAULTS.files;\n  // Only if a config file is *not* loaded, load an implicit configuration from @tsconfig/bases\n  const skipDefaultCompilerOptions = configFilePath != null;\n  const defaultCompilerOptionsForNodeVersion = skipDefaultCompilerOptions ? undefined : {\n    ...(0, tsconfigs_1.getDefaultTsconfigJsonForNodeVersion)(ts).compilerOptions,\n    types: ['node']\n  };\n  // Merge compilerOptions from all sources\n  config.compilerOptions = Object.assign({},\n  // automatically-applied options from @tsconfig/bases\n  defaultCompilerOptionsForNodeVersion,\n  // tsconfig.json \"compilerOptions\"\n  config.compilerOptions,\n  // from env var\n  index_1.DEFAULTS.compilerOptions,\n  // tsconfig.json \"ts-node\": \"compilerOptions\"\n  tsNodeOptionsFromTsconfig.compilerOptions,\n  // passed programmatically\n  rawApiOptions.compilerOptions,\n  // overrides required by ts-node, cannot be changed\n  TS_NODE_COMPILER_OPTIONS);\n  const fixedConfig = fixConfig(ts, ts.parseJsonConfigFileContent(config, {\n    fileExists,\n    readFile,\n    // Only used for globbing \"files\", \"include\", \"exclude\"\n    // When `files` option disabled, we want to avoid the fs calls\n    readDirectory: files ? ts.sys.readDirectory : () => [],\n    useCaseSensitiveFileNames: ts.sys.useCaseSensitiveFileNames\n  }, basePath, undefined, configFilePath));\n  return {\n    configFilePath,\n    config: fixedConfig,\n    tsNodeOptionsFromTsconfig,\n    optionBasePaths\n  };\n}\nexports.readConfig = readConfig;\n/**\n * Load the typescript compiler. It is required to load the tsconfig but might\n * be changed by the tsconfig, so we have to do this twice.\n * @internal\n */\nfunction resolveAndLoadCompiler(name, relativeToPath) {\n  const {\n    compiler\n  } = resolveCompiler(name, relativeToPath);\n  const ts = loadCompiler(compiler);\n  return {\n    compiler,\n    ts\n  };\n}\nexports.resolveAndLoadCompiler = resolveAndLoadCompiler;\nfunction resolveCompiler(name, relativeToPath) {\n  const projectLocalResolveHelper = (0, util_1.createProjectLocalResolveHelper)(relativeToPath);\n  const compiler = projectLocalResolveHelper(name || 'typescript', true);\n  return {\n    compiler\n  };\n}\n/** @internal */\nfunction loadCompiler(compiler) {\n  return (0, util_1.attemptRequireWithV8CompileCache)(require, compiler);\n}\nexports.loadCompiler = loadCompiler;\n/**\n * Given the raw \"ts-node\" sub-object from a tsconfig, return an object with only the properties\n * recognized by \"ts-node\"\n */\nfunction filterRecognizedTsConfigTsNodeOptions(jsonObject) {\n  if (jsonObject == null) return {\n    recognized: {},\n    unrecognized: {}\n  };\n  const {\n    compiler,\n    compilerHost,\n    compilerOptions,\n    emit,\n    files,\n    ignore,\n    ignoreDiagnostics,\n    logError,\n    preferTsExts,\n    pretty,\n    require,\n    skipIgnore,\n    transpileOnly,\n    typeCheck,\n    transpiler,\n    scope,\n    scopeDir,\n    moduleTypes,\n    experimentalReplAwait,\n    swc,\n    experimentalResolver,\n    esm,\n    experimentalSpecifierResolution,\n    experimentalTsImportSpecifiers,\n    ...unrecognized\n  } = jsonObject;\n  const filteredTsConfigOptions = {\n    compiler,\n    compilerHost,\n    compilerOptions,\n    emit,\n    experimentalReplAwait,\n    files,\n    ignore,\n    ignoreDiagnostics,\n    logError,\n    preferTsExts,\n    pretty,\n    require,\n    skipIgnore,\n    transpileOnly,\n    typeCheck,\n    transpiler,\n    scope,\n    scopeDir,\n    moduleTypes,\n    swc,\n    experimentalResolver,\n    esm,\n    experimentalSpecifierResolution,\n    experimentalTsImportSpecifiers\n  };\n  // Use the typechecker to make sure this implementation has the correct set of properties\n  const catchExtraneousProps = null;\n  const catchMissingProps = null;\n  return {\n    recognized: filteredTsConfigOptions,\n    unrecognized\n  };\n}\n/** @internal */\nexports.ComputeAsCommonRootOfFiles = Symbol();\n/**\n * Some TS compiler options have defaults which are not provided by TS's config parsing functions.\n * This function centralizes the logic for computing those defaults.\n * @internal\n */\nfunction getTsConfigDefaults(config, basePath, _files, _include, _exclude) {\n  const {\n    composite = false\n  } = config.options;\n  let rootDir = config.options.rootDir;\n  if (rootDir == null) {\n    if (composite) rootDir = basePath;\n    // Return this symbol to avoid computing from `files`, which would require fs calls\n    else rootDir = exports.ComputeAsCommonRootOfFiles;\n  }\n  const {\n    outDir = rootDir\n  } = config.options;\n  // Docs are wrong: https://www.typescriptlang.org/tsconfig#include\n  // Docs say **, but it's actually **/*; compiler throws error for **\n  const include = _files ? [] : ['**/*'];\n  const files = _files !== null && _files !== void 0 ? _files : [];\n  // Docs are misleading: https://www.typescriptlang.org/tsconfig#exclude\n  // Docs say it excludes node_modules, bower_components, jspm_packages, but actually those are excluded via behavior of \"include\"\n  const exclude = _exclude !== null && _exclude !== void 0 ? _exclude : [outDir]; // TODO technically, outDir is absolute path, but exclude should be relative glob pattern?\n  // TODO compute baseUrl\n  return {\n    rootDir,\n    outDir,\n    include,\n    files,\n    exclude,\n    composite\n  };\n}\nexports.getTsConfigDefaults = getTsConfigDefaults;","map":{"version":3,"mappings":"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","names":["TS_NODE_COMPILER_OPTIONS","sourceMap","inlineSourceMap","inlineSources","declaration","noEmit","outDir","fixConfig","ts","config","options","out","outFile","composite","declarationDir","declarationMap","emitDeclarationOnly","target","undefined","ScriptTarget","ES5","module","ModuleKind","CommonJS","findAndReadConfig","rawOptions","cwd","dir","index_1","process","compilerName","compiler","projectLocalResolveDir","projectSearchDir","project","resolveAndLoadCompiler","configFilePath","tsNodeOptionsFromTsconfig","optionBasePaths","readConfig","require","resolveCompiler","exports","rawApiOptions","configChain","compilerOptions","basePath","fileExists","sys","readFile","skipProject","tsTrace","resolved","nested","findConfigFile","pathToNextConfigInChain","tsInternals","errors","result","readConfigFile","error","fileNames","c","bp","push","configPath","extends","resolvedExtendedConfigPath","getExtendsConfigPath","readDirectory","useCaseSensitiveFileNames","trace","createCompilerDiagnostic","length","i","filterRecognizedTsConfigTsNodeOptions","recognized","tsconfigRelativeResolver","map","path","scopeDir","moduleTypes","transpiler","swc","files","skipDefaultCompilerOptions","defaultCompilerOptionsForNodeVersion","types","Object","assign","fixedConfig","parseJsonConfigFileContent","name","relativeToPath","loadCompiler","projectLocalResolveHelper","jsonObject","unrecognized","compilerHost","emit","ignore","ignoreDiagnostics","logError","preferTsExts","pretty","skipIgnore","transpileOnly","typeCheck","scope","experimentalReplAwait","experimentalResolver","esm","experimentalSpecifierResolution","experimentalTsImportSpecifiers","filteredTsConfigOptions","catchExtraneousProps","catchMissingProps","Symbol","getTsConfigDefaults","_files","_include","_exclude","rootDir","include","exclude"],"sources":["/Users/janrobel/Documents/PersonalProjekty/nftGenerateAi/clientAndContract/node_modules/ts-node/src/configuration.ts"],"sourcesContent":["import { resolve, dirname, join } from 'path';\nimport type * as _ts from 'typescript';\nimport {\n  CreateOptions,\n  DEFAULTS,\n  OptionBasePaths,\n  RegisterOptions,\n  TSCommon,\n  TsConfigOptions,\n} from './index';\nimport type { TSInternal } from './ts-compiler-types';\nimport { createTsInternals } from './ts-internals';\nimport { getDefaultTsconfigJsonForNodeVersion } from './tsconfigs';\nimport {\n  assign,\n  attemptRequireWithV8CompileCache,\n  createProjectLocalResolveHelper,\n  getBasePathForProjectLocalDependencyResolution,\n} from './util';\n\n/**\n * TypeScript compiler option values required by `ts-node` which cannot be overridden.\n */\nconst TS_NODE_COMPILER_OPTIONS = {\n  sourceMap: true,\n  inlineSourceMap: false,\n  inlineSources: true,\n  declaration: false,\n  noEmit: false,\n  outDir: '.ts-node',\n};\n\n/*\n * Do post-processing on config options to support `ts-node`.\n */\nfunction fixConfig(ts: TSCommon, config: _ts.ParsedCommandLine) {\n  // Delete options that *should not* be passed through.\n  delete config.options.out;\n  delete config.options.outFile;\n  delete config.options.composite;\n  delete config.options.declarationDir;\n  delete config.options.declarationMap;\n  delete config.options.emitDeclarationOnly;\n\n  // Target ES5 output by default (instead of ES3).\n  if (config.options.target === undefined) {\n    config.options.target = ts.ScriptTarget.ES5;\n  }\n\n  // Target CommonJS modules by default (instead of magically switching to ES6 when the target is ES6).\n  if (config.options.module === undefined) {\n    config.options.module = ts.ModuleKind.CommonJS;\n  }\n\n  return config;\n}\n\n/** @internal */\nexport function findAndReadConfig(rawOptions: CreateOptions) {\n  const cwd = resolve(\n    rawOptions.cwd ?? rawOptions.dir ?? DEFAULTS.cwd ?? process.cwd()\n  );\n  const compilerName = rawOptions.compiler ?? DEFAULTS.compiler;\n\n  // Compute minimum options to read the config file.\n  let projectLocalResolveDir = getBasePathForProjectLocalDependencyResolution(\n    undefined,\n    rawOptions.projectSearchDir,\n    rawOptions.project,\n    cwd\n  );\n  let { compiler, ts } = resolveAndLoadCompiler(\n    compilerName,\n    projectLocalResolveDir\n  );\n\n  // Read config file and merge new options between env and CLI options.\n  const { configFilePath, config, tsNodeOptionsFromTsconfig, optionBasePaths } =\n    readConfig(cwd, ts, rawOptions);\n\n  const options = assign<RegisterOptions>(\n    {},\n    DEFAULTS,\n    tsNodeOptionsFromTsconfig || {},\n    { optionBasePaths },\n    rawOptions\n  );\n  options.require = [\n    ...(tsNodeOptionsFromTsconfig.require || []),\n    ...(rawOptions.require || []),\n  ];\n\n  // Re-resolve the compiler in case it has changed.\n  // Compiler is loaded relative to tsconfig.json, so tsconfig discovery may cause us to load a\n  // different compiler than we did above, even if the name has not changed.\n  if (configFilePath) {\n    projectLocalResolveDir = getBasePathForProjectLocalDependencyResolution(\n      configFilePath,\n      rawOptions.projectSearchDir,\n      rawOptions.project,\n      cwd\n    );\n    ({ compiler } = resolveCompiler(\n      options.compiler,\n      optionBasePaths.compiler ?? projectLocalResolveDir\n    ));\n  }\n\n  return {\n    options,\n    config,\n    projectLocalResolveDir,\n    optionBasePaths,\n    configFilePath,\n    cwd,\n    compiler,\n  };\n}\n\n/**\n * Load TypeScript configuration. Returns the parsed TypeScript config and\n * any `ts-node` options specified in the config file.\n *\n * Even when a tsconfig.json is not loaded, this function still handles merging\n * compilerOptions from various sources: API, environment variables, etc.\n *\n * @internal\n */\nexport function readConfig(\n  cwd: string,\n  ts: TSCommon,\n  rawApiOptions: CreateOptions\n): {\n  /**\n   * Path of tsconfig file if one was loaded\n   */\n  configFilePath: string | undefined;\n  /**\n   * Parsed TypeScript configuration with compilerOptions merged from all other sources (env vars, etc)\n   */\n  config: _ts.ParsedCommandLine;\n  /**\n   * ts-node options pulled from `tsconfig.json`, NOT merged with any other sources.  Merging must happen outside\n   * this function.\n   */\n  tsNodeOptionsFromTsconfig: TsConfigOptions;\n  optionBasePaths: OptionBasePaths;\n} {\n  // Ordered [a, b, c] where config a extends b extends c\n  const configChain: Array<{\n    config: any;\n    basePath: string;\n    configPath: string;\n  }> = [];\n  let config: any = { compilerOptions: {} };\n  let basePath = cwd;\n  let configFilePath: string | undefined = undefined;\n  const projectSearchDir = resolve(cwd, rawApiOptions.projectSearchDir ?? cwd);\n\n  const {\n    fileExists = ts.sys.fileExists,\n    readFile = ts.sys.readFile,\n    skipProject = DEFAULTS.skipProject,\n    project = DEFAULTS.project,\n    tsTrace = DEFAULTS.tsTrace,\n  } = rawApiOptions;\n\n  // Read project configuration when available.\n  if (!skipProject) {\n    if (project) {\n      const resolved = resolve(cwd, project);\n      const nested = join(resolved, 'tsconfig.json');\n      configFilePath = fileExists(nested) ? nested : resolved;\n    } else {\n      configFilePath = ts.findConfigFile(projectSearchDir, fileExists);\n    }\n\n    if (configFilePath) {\n      let pathToNextConfigInChain = configFilePath;\n      const tsInternals = createTsInternals(ts);\n      const errors: Array<_ts.Diagnostic> = [];\n\n      // Follow chain of \"extends\"\n      while (true) {\n        const result = ts.readConfigFile(pathToNextConfigInChain, readFile);\n\n        // Return diagnostics.\n        if (result.error) {\n          return {\n            configFilePath,\n            config: { errors: [result.error], fileNames: [], options: {} },\n            tsNodeOptionsFromTsconfig: {},\n            optionBasePaths: {},\n          };\n        }\n\n        const c = result.config;\n        const bp = dirname(pathToNextConfigInChain);\n        configChain.push({\n          config: c,\n          basePath: bp,\n          configPath: pathToNextConfigInChain,\n        });\n\n        if (c.extends == null) break;\n        const resolvedExtendedConfigPath = tsInternals.getExtendsConfigPath(\n          c.extends,\n          {\n            fileExists,\n            readDirectory: ts.sys.readDirectory,\n            readFile,\n            useCaseSensitiveFileNames: ts.sys.useCaseSensitiveFileNames,\n            trace: tsTrace,\n          },\n          bp,\n          errors,\n          (ts as unknown as TSInternal).createCompilerDiagnostic\n        );\n        if (errors.length) {\n          return {\n            configFilePath,\n            config: { errors, fileNames: [], options: {} },\n            tsNodeOptionsFromTsconfig: {},\n            optionBasePaths: {},\n          };\n        }\n        if (resolvedExtendedConfigPath == null) break;\n        pathToNextConfigInChain = resolvedExtendedConfigPath;\n      }\n\n      ({ config, basePath } = configChain[0]);\n    }\n  }\n\n  // Merge and fix ts-node options that come from tsconfig.json(s)\n  const tsNodeOptionsFromTsconfig: TsConfigOptions = {};\n  const optionBasePaths: OptionBasePaths = {};\n  for (let i = configChain.length - 1; i >= 0; i--) {\n    const { config, basePath, configPath } = configChain[i];\n    const options = filterRecognizedTsConfigTsNodeOptions(\n      config['ts-node']\n    ).recognized;\n\n    // Some options are relative to the config file, so must be converted to absolute paths here\n    if (options.require) {\n      // Modules are found relative to the tsconfig file, not the `dir` option\n      const tsconfigRelativeResolver = createProjectLocalResolveHelper(\n        dirname(configPath)\n      );\n      options.require = options.require.map((path: string) =>\n        tsconfigRelativeResolver(path, false)\n      );\n    }\n    if (options.scopeDir) {\n      options.scopeDir = resolve(basePath, options.scopeDir!);\n    }\n\n    // Downstream code uses the basePath; we do not do that here.\n    if (options.moduleTypes) {\n      optionBasePaths.moduleTypes = basePath;\n    }\n    if (options.transpiler != null) {\n      optionBasePaths.transpiler = basePath;\n    }\n    if (options.compiler != null) {\n      optionBasePaths.compiler = basePath;\n    }\n    if (options.swc != null) {\n      optionBasePaths.swc = basePath;\n    }\n\n    assign(tsNodeOptionsFromTsconfig, options);\n  }\n\n  // Remove resolution of \"files\".\n  const files =\n    rawApiOptions.files ?? tsNodeOptionsFromTsconfig.files ?? DEFAULTS.files;\n\n  // Only if a config file is *not* loaded, load an implicit configuration from @tsconfig/bases\n  const skipDefaultCompilerOptions = configFilePath != null;\n  const defaultCompilerOptionsForNodeVersion = skipDefaultCompilerOptions\n    ? undefined\n    : {\n        ...getDefaultTsconfigJsonForNodeVersion(ts).compilerOptions,\n        types: ['node'],\n      };\n\n  // Merge compilerOptions from all sources\n  config.compilerOptions = Object.assign(\n    {},\n    // automatically-applied options from @tsconfig/bases\n    defaultCompilerOptionsForNodeVersion,\n    // tsconfig.json \"compilerOptions\"\n    config.compilerOptions,\n    // from env var\n    DEFAULTS.compilerOptions,\n    // tsconfig.json \"ts-node\": \"compilerOptions\"\n    tsNodeOptionsFromTsconfig.compilerOptions,\n    // passed programmatically\n    rawApiOptions.compilerOptions,\n    // overrides required by ts-node, cannot be changed\n    TS_NODE_COMPILER_OPTIONS\n  );\n\n  const fixedConfig = fixConfig(\n    ts,\n    ts.parseJsonConfigFileContent(\n      config,\n      {\n        fileExists,\n        readFile,\n        // Only used for globbing \"files\", \"include\", \"exclude\"\n        // When `files` option disabled, we want to avoid the fs calls\n        readDirectory: files ? ts.sys.readDirectory : () => [],\n        useCaseSensitiveFileNames: ts.sys.useCaseSensitiveFileNames,\n      },\n      basePath,\n      undefined,\n      configFilePath\n    )\n  );\n\n  return {\n    configFilePath,\n    config: fixedConfig,\n    tsNodeOptionsFromTsconfig,\n    optionBasePaths,\n  };\n}\n\n/**\n * Load the typescript compiler. It is required to load the tsconfig but might\n * be changed by the tsconfig, so we have to do this twice.\n * @internal\n */\nexport function resolveAndLoadCompiler(\n  name: string | undefined,\n  relativeToPath: string\n) {\n  const { compiler } = resolveCompiler(name, relativeToPath);\n  const ts = loadCompiler(compiler);\n  return { compiler, ts };\n}\n\nfunction resolveCompiler(name: string | undefined, relativeToPath: string) {\n  const projectLocalResolveHelper =\n    createProjectLocalResolveHelper(relativeToPath);\n  const compiler = projectLocalResolveHelper(name || 'typescript', true);\n  return { compiler };\n}\n\n/** @internal */\nexport function loadCompiler(compiler: string): TSCommon {\n  return attemptRequireWithV8CompileCache(require, compiler);\n}\n\n/**\n * Given the raw \"ts-node\" sub-object from a tsconfig, return an object with only the properties\n * recognized by \"ts-node\"\n */\nfunction filterRecognizedTsConfigTsNodeOptions(jsonObject: any): {\n  recognized: TsConfigOptions;\n  unrecognized: any;\n} {\n  if (jsonObject == null) return { recognized: {}, unrecognized: {} };\n  const {\n    compiler,\n    compilerHost,\n    compilerOptions,\n    emit,\n    files,\n    ignore,\n    ignoreDiagnostics,\n    logError,\n    preferTsExts,\n    pretty,\n    require,\n    skipIgnore,\n    transpileOnly,\n    typeCheck,\n    transpiler,\n    scope,\n    scopeDir,\n    moduleTypes,\n    experimentalReplAwait,\n    swc,\n    experimentalResolver,\n    esm,\n    experimentalSpecifierResolution,\n    experimentalTsImportSpecifiers,\n    ...unrecognized\n  } = jsonObject as TsConfigOptions;\n  const filteredTsConfigOptions = {\n    compiler,\n    compilerHost,\n    compilerOptions,\n    emit,\n    experimentalReplAwait,\n    files,\n    ignore,\n    ignoreDiagnostics,\n    logError,\n    preferTsExts,\n    pretty,\n    require,\n    skipIgnore,\n    transpileOnly,\n    typeCheck,\n    transpiler,\n    scope,\n    scopeDir,\n    moduleTypes,\n    swc,\n    experimentalResolver,\n    esm,\n    experimentalSpecifierResolution,\n    experimentalTsImportSpecifiers,\n  };\n  // Use the typechecker to make sure this implementation has the correct set of properties\n  const catchExtraneousProps: keyof TsConfigOptions =\n    null as any as keyof typeof filteredTsConfigOptions;\n  const catchMissingProps: keyof typeof filteredTsConfigOptions =\n    null as any as keyof TsConfigOptions;\n  return { recognized: filteredTsConfigOptions, unrecognized };\n}\n\n/** @internal */\nexport const ComputeAsCommonRootOfFiles = Symbol();\n\n/**\n * Some TS compiler options have defaults which are not provided by TS's config parsing functions.\n * This function centralizes the logic for computing those defaults.\n * @internal\n */\nexport function getTsConfigDefaults(\n  config: _ts.ParsedCommandLine,\n  basePath: string,\n  _files: string[] | undefined,\n  _include: string[] | undefined,\n  _exclude: string[] | undefined\n) {\n  const { composite = false } = config.options;\n  let rootDir: string | typeof ComputeAsCommonRootOfFiles =\n    config.options.rootDir!;\n  if (rootDir == null) {\n    if (composite) rootDir = basePath;\n    // Return this symbol to avoid computing from `files`, which would require fs calls\n    else rootDir = ComputeAsCommonRootOfFiles;\n  }\n  const { outDir = rootDir } = config.options;\n  // Docs are wrong: https://www.typescriptlang.org/tsconfig#include\n  // Docs say **, but it's actually **/*; compiler throws error for **\n  const include = _files ? [] : ['**/*'];\n  const files = _files ?? [];\n  // Docs are misleading: https://www.typescriptlang.org/tsconfig#exclude\n  // Docs say it excludes node_modules, bower_components, jspm_packages, but actually those are excluded via behavior of \"include\"\n  const exclude = _exclude ?? [outDir]; // TODO technically, outDir is absolute path, but exclude should be relative glob pattern?\n\n  // TODO compute baseUrl\n\n  return { rootDir, outDir, include, files, exclude, composite };\n}\n"]},"metadata":{},"sourceType":"script","externalDependencies":[]}