{"ast":null,"code":"'use strict';\n\nconst {\n  redirectStatus,\n  badPorts,\n  referrerPolicy: referrerPolicyTokens\n} = require('./constants');\nconst {\n  performance\n} = require('perf_hooks');\nconst {\n  isBlobLike,\n  toUSVString,\n  ReadableStreamFrom\n} = require('../core/util');\nconst assert = require('assert');\nconst {\n  isUint8Array\n} = require('util/types');\n\n// https://nodejs.org/api/crypto.html#determining-if-crypto-support-is-unavailable\n/** @type {import('crypto')|undefined} */\nlet crypto;\ntry {\n  crypto = require('crypto');\n} catch {}\nfunction responseURL(response) {\n  // https://fetch.spec.whatwg.org/#responses\n  // A response has an associated URL. It is a pointer to the last URL\n  // in response’s URL list and null if response’s URL list is empty.\n  const urlList = response.urlList;\n  const length = urlList.length;\n  return length === 0 ? null : urlList[length - 1].toString();\n}\n\n// https://fetch.spec.whatwg.org/#concept-response-location-url\nfunction responseLocationURL(response, requestFragment) {\n  // 1. If response’s status is not a redirect status, then return null.\n  if (!redirectStatus.includes(response.status)) {\n    return null;\n  }\n\n  // 2. Let location be the result of extracting header list values given\n  // `Location` and response’s header list.\n  let location = response.headersList.get('location');\n\n  // 3. If location is a value, then set location to the result of parsing\n  // location with response’s URL.\n  location = location ? new URL(location, responseURL(response)) : null;\n\n  // 4. If location is a URL whose fragment is null, then set location’s\n  // fragment to requestFragment.\n  if (location && !location.hash) {\n    location.hash = requestFragment;\n  }\n\n  // 5. Return location.\n  return location;\n}\n\n/** @returns {URL} */\nfunction requestCurrentURL(request) {\n  return request.urlList[request.urlList.length - 1];\n}\nfunction requestBadPort(request) {\n  // 1. Let url be request’s current URL.\n  const url = requestCurrentURL(request);\n\n  // 2. If url’s scheme is an HTTP(S) scheme and url’s port is a bad port,\n  // then return blocked.\n  if (/^https?:/.test(url.protocol) && badPorts.includes(url.port)) {\n    return 'blocked';\n  }\n\n  // 3. Return allowed.\n  return 'allowed';\n}\nfunction isErrorLike(object) {\n  return object instanceof Error || object?.constructor?.name === 'Error' || object?.constructor?.name === 'DOMException';\n}\n\n// Check whether |statusText| is a ByteString and\n// matches the Reason-Phrase token production.\n// RFC 2616: https://tools.ietf.org/html/rfc2616\n// RFC 7230: https://tools.ietf.org/html/rfc7230\n// \"reason-phrase = *( HTAB / SP / VCHAR / obs-text )\"\n// https://github.com/chromium/chromium/blob/94.0.4604.1/third_party/blink/renderer/core/fetch/response.cc#L116\nfunction isValidReasonPhrase(statusText) {\n  for (let i = 0; i < statusText.length; ++i) {\n    const c = statusText.charCodeAt(i);\n    if (!(c === 0x09 ||\n    // HTAB\n    c >= 0x20 && c <= 0x7e ||\n    // SP / VCHAR\n    c >= 0x80 && c <= 0xff\n    // obs-text\n    )) {\n      return false;\n    }\n  }\n  return true;\n}\nfunction isTokenChar(c) {\n  return !(c >= 0x7f || c <= 0x20 || c === '(' || c === ')' || c === '<' || c === '>' || c === '@' || c === ',' || c === ';' || c === ':' || c === '\\\\' || c === '\"' || c === '/' || c === '[' || c === ']' || c === '?' || c === '=' || c === '{' || c === '}');\n}\n\n// See RFC 7230, Section 3.2.6.\n// https://github.com/chromium/chromium/blob/d7da0240cae77824d1eda25745c4022757499131/third_party/blink/renderer/platform/network/http_parsers.cc#L321\nfunction isValidHTTPToken(characters) {\n  if (!characters || typeof characters !== 'string') {\n    return false;\n  }\n  for (let i = 0; i < characters.length; ++i) {\n    const c = characters.charCodeAt(i);\n    if (c > 0x7f || !isTokenChar(c)) {\n      return false;\n    }\n  }\n  return true;\n}\n\n// https://fetch.spec.whatwg.org/#header-name\n// https://github.com/chromium/chromium/blob/b3d37e6f94f87d59e44662d6078f6a12de845d17/net/http/http_util.cc#L342\nfunction isValidHeaderName(potentialValue) {\n  if (potentialValue.length === 0) {\n    return false;\n  }\n  return isValidHTTPToken(potentialValue);\n}\n\n/**\n * @see https://fetch.spec.whatwg.org/#header-value\n * @param {string} potentialValue\n */\nfunction isValidHeaderValue(potentialValue) {\n  // - Has no leading or trailing HTTP tab or space bytes.\n  // - Contains no 0x00 (NUL) or HTTP newline bytes.\n  if (potentialValue.startsWith('\\t') || potentialValue.startsWith(' ') || potentialValue.endsWith('\\t') || potentialValue.endsWith(' ')) {\n    return false;\n  }\n  if (potentialValue.includes('\\0') || potentialValue.includes('\\r') || potentialValue.includes('\\n')) {\n    return false;\n  }\n  return true;\n}\n\n// https://w3c.github.io/webappsec-referrer-policy/#set-requests-referrer-policy-on-redirect\nfunction setRequestReferrerPolicyOnRedirect(request, actualResponse) {\n  //  Given a request request and a response actualResponse, this algorithm\n  //  updates request’s referrer policy according to the Referrer-Policy\n  //  header (if any) in actualResponse.\n\n  // 1. Let policy be the result of executing § 8.1 Parse a referrer policy\n  // from a Referrer-Policy header on actualResponse.\n\n  // 8.1 Parse a referrer policy from a Referrer-Policy header\n  // 1. Let policy-tokens be the result of extracting header list values given `Referrer-Policy` and response’s header list.\n  const {\n    headersList\n  } = actualResponse;\n  // 2. Let policy be the empty string.\n  // 3. For each token in policy-tokens, if token is a referrer policy and token is not the empty string, then set policy to token.\n  // 4. Return policy.\n  const policyHeader = (headersList.get('referrer-policy') ?? '').split(',');\n\n  // Note: As the referrer-policy can contain multiple policies\n  // separated by comma, we need to loop through all of them\n  // and pick the first valid one.\n  // Ref: https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Referrer-Policy#specify_a_fallback_policy\n  let policy = '';\n  if (policyHeader.length > 0) {\n    // The right-most policy takes precedence.\n    // The left-most policy is the fallback.\n    for (let i = policyHeader.length; i !== 0; i--) {\n      const token = policyHeader[i - 1].trim();\n      if (referrerPolicyTokens.includes(token)) {\n        policy = token;\n        break;\n      }\n    }\n  }\n\n  // 2. If policy is not the empty string, then set request’s referrer policy to policy.\n  if (policy !== '') {\n    request.referrerPolicy = policy;\n  }\n}\n\n// https://fetch.spec.whatwg.org/#cross-origin-resource-policy-check\nfunction crossOriginResourcePolicyCheck() {\n  // TODO\n  return 'allowed';\n}\n\n// https://fetch.spec.whatwg.org/#concept-cors-check\nfunction corsCheck() {\n  // TODO\n  return 'success';\n}\n\n// https://fetch.spec.whatwg.org/#concept-tao-check\nfunction TAOCheck() {\n  // TODO\n  return 'success';\n}\nfunction appendFetchMetadata(httpRequest) {\n  //  https://w3c.github.io/webappsec-fetch-metadata/#sec-fetch-dest-header\n  //  TODO\n\n  //  https://w3c.github.io/webappsec-fetch-metadata/#sec-fetch-mode-header\n\n  //  1. Assert: r’s url is a potentially trustworthy URL.\n  //  TODO\n\n  //  2. Let header be a Structured Header whose value is a token.\n  let header = null;\n\n  //  3. Set header’s value to r’s mode.\n  header = httpRequest.mode;\n\n  //  4. Set a structured field value `Sec-Fetch-Mode`/header in r’s header list.\n  httpRequest.headersList.set('sec-fetch-mode', header);\n\n  //  https://w3c.github.io/webappsec-fetch-metadata/#sec-fetch-site-header\n  //  TODO\n\n  //  https://w3c.github.io/webappsec-fetch-metadata/#sec-fetch-user-header\n  //  TODO\n}\n\n// https://fetch.spec.whatwg.org/#append-a-request-origin-header\nfunction appendRequestOriginHeader(request) {\n  // 1. Let serializedOrigin be the result of byte-serializing a request origin with request.\n  let serializedOrigin = request.origin;\n\n  // 2. If request’s response tainting is \"cors\" or request’s mode is \"websocket\", then append (`Origin`, serializedOrigin) to request’s header list.\n  if (request.responseTainting === 'cors' || request.mode === 'websocket') {\n    if (serializedOrigin) {\n      request.headersList.append('Origin', serializedOrigin);\n    }\n\n    // 3. Otherwise, if request’s method is neither `GET` nor `HEAD`, then:\n  } else if (request.method !== 'GET' && request.method !== 'HEAD') {\n    // 1. Switch on request’s referrer policy:\n    switch (request.referrerPolicy) {\n      case 'no-referrer':\n        // Set serializedOrigin to `null`.\n        serializedOrigin = null;\n        break;\n      case 'no-referrer-when-downgrade':\n      case 'strict-origin':\n      case 'strict-origin-when-cross-origin':\n        // If request’s origin is a tuple origin, its scheme is \"https\", and request’s current URL’s scheme is not \"https\", then set serializedOrigin to `null`.\n        if (/^https:/.test(request.origin) && !/^https:/.test(requestCurrentURL(request))) {\n          serializedOrigin = null;\n        }\n        break;\n      case 'same-origin':\n        // If request’s origin is not same origin with request’s current URL’s origin, then set serializedOrigin to `null`.\n        if (!sameOrigin(request, requestCurrentURL(request))) {\n          serializedOrigin = null;\n        }\n        break;\n      default:\n      // Do nothing.\n    }\n\n    if (serializedOrigin) {\n      // 2. Append (`Origin`, serializedOrigin) to request’s header list.\n      request.headersList.append('Origin', serializedOrigin);\n    }\n  }\n}\nfunction coarsenedSharedCurrentTime(crossOriginIsolatedCapability) {\n  // TODO\n  return performance.now();\n}\n\n// https://fetch.spec.whatwg.org/#create-an-opaque-timing-info\nfunction createOpaqueTimingInfo(timingInfo) {\n  return {\n    startTime: timingInfo.startTime ?? 0,\n    redirectStartTime: 0,\n    redirectEndTime: 0,\n    postRedirectStartTime: timingInfo.startTime ?? 0,\n    finalServiceWorkerStartTime: 0,\n    finalNetworkResponseStartTime: 0,\n    finalNetworkRequestStartTime: 0,\n    endTime: 0,\n    encodedBodySize: 0,\n    decodedBodySize: 0,\n    finalConnectionTimingInfo: null\n  };\n}\n\n// https://html.spec.whatwg.org/multipage/origin.html#policy-container\nfunction makePolicyContainer() {\n  // TODO\n  return {};\n}\n\n// https://html.spec.whatwg.org/multipage/origin.html#clone-a-policy-container\nfunction clonePolicyContainer() {\n  // TODO\n  return {};\n}\n\n// https://w3c.github.io/webappsec-referrer-policy/#determine-requests-referrer\nfunction determineRequestsReferrer(request) {\n  // 1. Let policy be request's referrer policy.\n  const policy = request.referrerPolicy;\n\n  // Return no-referrer when empty or policy says so\n  if (policy == null || policy === '' || policy === 'no-referrer') {\n    return 'no-referrer';\n  }\n\n  // 2. Let environment be the request client\n  const environment = request.client;\n  let referrerSource = null;\n\n  /**\n   * 3, Switch on request’s referrer:\n    \"client\"\n      If environment’s global object is a Window object, then\n        Let document be the associated Document of environment’s global object.\n        If document’s origin is an opaque origin, return no referrer.\n        While document is an iframe srcdoc document,\n        let document be document’s browsing context’s browsing context container’s node document.\n        Let referrerSource be document’s URL.\n       Otherwise, let referrerSource be environment’s creation URL.\n     a URL\n    Let referrerSource be request’s referrer.\n   */\n  if (request.referrer === 'client') {\n    // Not defined in Node but part of the spec\n    if (request.client?.globalObject?.constructor?.name === 'Window') {\n      // eslint-disable-line\n      const origin = environment.globalObject.self?.origin ?? environment.globalObject.location?.origin;\n\n      // If document’s origin is an opaque origin, return no referrer.\n      if (origin == null || origin === 'null') return 'no-referrer';\n\n      // Let referrerSource be document’s URL.\n      referrerSource = new URL(environment.globalObject.location.href);\n    } else {\n      // 3(a)(II) If environment's global object is not Window,\n      // Let referrerSource be environments creationURL\n      if (environment?.globalObject?.location == null) {\n        return 'no-referrer';\n      }\n      referrerSource = new URL(environment.globalObject.location.href);\n    }\n  } else if (request.referrer instanceof URL) {\n    // 3(b) If requests's referrer is a URL instance, then make\n    // referrerSource be requests's referrer.\n    referrerSource = request.referrer;\n  } else {\n    // If referrerSource neither client nor instance of URL\n    // then return \"no-referrer\".\n    return 'no-referrer';\n  }\n  const urlProtocol = referrerSource.protocol;\n\n  // If url's scheme is a local scheme (i.e. one of \"about\", \"data\", \"javascript\", \"file\")\n  // then return \"no-referrer\".\n  if (urlProtocol === 'about:' || urlProtocol === 'data:' || urlProtocol === 'blob:') {\n    return 'no-referrer';\n  }\n  let temp;\n  let referrerOrigin;\n  // 4. Let requests's referrerURL be the result of stripping referrer\n  // source for use as referrer (using util function, without origin only)\n  const referrerUrl = (temp = stripURLForReferrer(referrerSource)).length > 4096\n  // 5. Let referrerOrigin be the result of stripping referrer\n  // source for use as referrer (using util function, with originOnly true)\n  ? referrerOrigin = stripURLForReferrer(referrerSource, true)\n  // 6. If result of seralizing referrerUrl is a string whose length is greater than\n  // 4096, then set referrerURL to referrerOrigin\n  : temp;\n  const areSameOrigin = sameOrigin(request, referrerUrl);\n  const isNonPotentiallyTrustWorthy = isURLPotentiallyTrustworthy(referrerUrl) && !isURLPotentiallyTrustworthy(request.url);\n\n  // NOTE: How to treat step 7?\n  // 8. Execute the switch statements corresponding to the value of policy:\n  switch (policy) {\n    case 'origin':\n      return referrerOrigin != null ? referrerOrigin : stripURLForReferrer(referrerSource, true);\n    case 'unsafe-url':\n      return referrerUrl;\n    case 'same-origin':\n      return areSameOrigin ? referrerOrigin : 'no-referrer';\n    case 'origin-when-cross-origin':\n      return areSameOrigin ? referrerUrl : referrerOrigin;\n    case 'strict-origin-when-cross-origin':\n      /**\n         * 1. If the origin of referrerURL and the origin of request’s current URL are the same,\n         * then return referrerURL.\n         * 2. If referrerURL is a potentially trustworthy URL and request’s current URL is not a\n         * potentially trustworthy URL, then return no referrer.\n         * 3. Return referrerOrigin\n      */\n      if (areSameOrigin) return referrerOrigin;\n    // else return isNonPotentiallyTrustWorthy ? 'no-referrer' : referrerOrigin\n    case 'strict-origin': // eslint-disable-line\n    /**\n       * 1. If referrerURL is a potentially trustworthy URL and\n       * request’s current URL is not a potentially trustworthy URL,\n       * then return no referrer.\n       * 2. Return referrerOrigin\n      */\n    case 'no-referrer-when-downgrade': // eslint-disable-line\n    /**\n     * 1. If referrerURL is a potentially trustworthy URL and\n     * request’s current URL is not a potentially trustworthy URL,\n     * then return no referrer.\n     * 2. Return referrerOrigin\n    */\n\n    default:\n      // eslint-disable-line\n      return isNonPotentiallyTrustWorthy ? 'no-referrer' : referrerOrigin;\n  }\n  function stripURLForReferrer(url) {\n    let originOnly = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n    const urlObject = new URL(url.href);\n    urlObject.username = '';\n    urlObject.password = '';\n    urlObject.hash = '';\n    return originOnly ? urlObject.origin : urlObject.href;\n  }\n}\nfunction isURLPotentiallyTrustworthy(url) {\n  if (!(url instanceof URL)) {\n    return false;\n  }\n\n  // If child of about, return true\n  if (url.href === 'about:blank' || url.href === 'about:srcdoc') {\n    return true;\n  }\n\n  // If scheme is data, return true\n  if (url.protocol === 'data:') return true;\n\n  // If file, return true\n  if (url.protocol === 'file:') return true;\n  return isOriginPotentiallyTrustworthy(url.origin);\n  function isOriginPotentiallyTrustworthy(origin) {\n    // If origin is explicitly null, return false\n    if (origin == null || origin === 'null') return false;\n    const originAsURL = new URL(origin);\n\n    // If secure, return true\n    if (originAsURL.protocol === 'https:' || originAsURL.protocol === 'wss:') {\n      return true;\n    }\n\n    // If localhost or variants, return true\n    if (/^127(?:\\.[0-9]+){0,2}\\.[0-9]+$|^\\[(?:0*:)*?:?0*1\\]$/.test(originAsURL.hostname) || originAsURL.hostname === 'localhost' || originAsURL.hostname.includes('localhost.') || originAsURL.hostname.endsWith('.localhost')) {\n      return true;\n    }\n\n    // If any other, return false\n    return false;\n  }\n}\n\n/**\n * @see https://w3c.github.io/webappsec-subresource-integrity/#does-response-match-metadatalist\n * @param {Uint8Array} bytes\n * @param {string} metadataList\n */\nfunction bytesMatch(bytes, metadataList) {\n  // If node is not built with OpenSSL support, we cannot check\n  // a request's integrity, so allow it by default (the spec will\n  // allow requests if an invalid hash is given, as precedence).\n  /* istanbul ignore if: only if node is built with --without-ssl */\n  if (crypto === undefined) {\n    return true;\n  }\n\n  // 1. Let parsedMetadata be the result of parsing metadataList.\n  const parsedMetadata = parseMetadata(metadataList);\n\n  // 2. If parsedMetadata is no metadata, return true.\n  if (parsedMetadata === 'no metadata') {\n    return true;\n  }\n\n  // 3. If parsedMetadata is the empty set, return true.\n  if (parsedMetadata.length === 0) {\n    return true;\n  }\n\n  // 4. Let metadata be the result of getting the strongest\n  //    metadata from parsedMetadata.\n  const list = parsedMetadata.sort((c, d) => d.algo.localeCompare(c.algo));\n  // get the strongest algorithm\n  const strongest = list[0].algo;\n  // get all entries that use the strongest algorithm; ignore weaker\n  const metadata = list.filter(item => item.algo === strongest);\n\n  // 5. For each item in metadata:\n  for (const item of metadata) {\n    // 1. Let algorithm be the alg component of item.\n    const algorithm = item.algo;\n\n    // 2. Let expectedValue be the val component of item.\n    const expectedValue = item.hash;\n\n    // 3. Let actualValue be the result of applying algorithm to bytes.\n    const actualValue = crypto.createHash(algorithm).update(bytes).digest('base64');\n\n    // 4. If actualValue is a case-sensitive match for expectedValue,\n    //    return true.\n    if (actualValue === expectedValue) {\n      return true;\n    }\n  }\n\n  // 6. Return false.\n  return false;\n}\n\n// https://w3c.github.io/webappsec-subresource-integrity/#grammardef-hash-with-options\n// https://www.w3.org/TR/CSP2/#source-list-syntax\n// https://www.rfc-editor.org/rfc/rfc5234#appendix-B.1\nconst parseHashWithOptions = /((?<algo>sha256|sha384|sha512)-(?<hash>[A-z0-9+/]{1}.*={0,2}))( +[\\x21-\\x7e]?)?/i;\n\n/**\n * @see https://w3c.github.io/webappsec-subresource-integrity/#parse-metadata\n * @param {string} metadata\n */\nfunction parseMetadata(metadata) {\n  // 1. Let result be the empty set.\n  /** @type {{ algo: string, hash: string }[]} */\n  const result = [];\n\n  // 2. Let empty be equal to true.\n  let empty = true;\n  const supportedHashes = crypto.getHashes();\n\n  // 3. For each token returned by splitting metadata on spaces:\n  for (const token of metadata.split(' ')) {\n    // 1. Set empty to false.\n    empty = false;\n\n    // 2. Parse token as a hash-with-options.\n    const parsedToken = parseHashWithOptions.exec(token);\n\n    // 3. If token does not parse, continue to the next token.\n    if (parsedToken === null || parsedToken.groups === undefined) {\n      // Note: Chromium blocks the request at this point, but Firefox\n      // gives a warning that an invalid integrity was given. The\n      // correct behavior is to ignore these, and subsequently not\n      // check the integrity of the resource.\n      continue;\n    }\n\n    // 4. Let algorithm be the hash-algo component of token.\n    const algorithm = parsedToken.groups.algo;\n\n    // 5. If algorithm is a hash function recognized by the user\n    //    agent, add the parsed token to result.\n    if (supportedHashes.includes(algorithm.toLowerCase())) {\n      result.push(parsedToken.groups);\n    }\n  }\n\n  // 4. Return no metadata if empty is true, otherwise return result.\n  if (empty === true) {\n    return 'no metadata';\n  }\n  return result;\n}\n\n// https://w3c.github.io/webappsec-upgrade-insecure-requests/#upgrade-request\nfunction tryUpgradeRequestToAPotentiallyTrustworthyURL(request) {\n  // TODO\n}\n\n/**\n * @link {https://html.spec.whatwg.org/multipage/origin.html#same-origin}\n * @param {URL} A\n * @param {URL} B\n */\nfunction sameOrigin(A, B) {\n  // 1. If A and B are the same opaque origin, then return true.\n  // \"opaque origin\" is an internal value we cannot access, ignore.\n\n  // 2. If A and B are both tuple origins and their schemes,\n  //    hosts, and port are identical, then return true.\n  if (A.protocol === B.protocol && A.hostname === B.hostname && A.port === B.port) {\n    return true;\n  }\n\n  // 3. Return false.\n  return false;\n}\nfunction createDeferredPromise() {\n  let res;\n  let rej;\n  const promise = new Promise((resolve, reject) => {\n    res = resolve;\n    rej = reject;\n  });\n  return {\n    promise,\n    resolve: res,\n    reject: rej\n  };\n}\nfunction isAborted(fetchParams) {\n  return fetchParams.controller.state === 'aborted';\n}\nfunction isCancelled(fetchParams) {\n  return fetchParams.controller.state === 'aborted' || fetchParams.controller.state === 'terminated';\n}\n\n// https://fetch.spec.whatwg.org/#concept-method-normalize\nfunction normalizeMethod(method) {\n  return /^(DELETE|GET|HEAD|OPTIONS|POST|PUT)$/i.test(method) ? method.toUpperCase() : method;\n}\n\n// https://infra.spec.whatwg.org/#serialize-a-javascript-value-to-a-json-string\nfunction serializeJavascriptValueToJSONString(value) {\n  // 1. Let result be ? Call(%JSON.stringify%, undefined, « value »).\n  const result = JSON.stringify(value);\n\n  // 2. If result is undefined, then throw a TypeError.\n  if (result === undefined) {\n    throw new TypeError('Value is not JSON serializable');\n  }\n\n  // 3. Assert: result is a string.\n  assert(typeof result === 'string');\n\n  // 4. Return result.\n  return result;\n}\n\n// https://tc39.es/ecma262/#sec-%25iteratorprototype%25-object\nconst esIteratorPrototype = Object.getPrototypeOf(Object.getPrototypeOf([][Symbol.iterator]()));\n\n/**\n * @see https://webidl.spec.whatwg.org/#dfn-iterator-prototype-object\n * @param {() => unknown[]} iterator\n * @param {string} name name of the instance\n * @param {'key'|'value'|'key+value'} kind\n */\nfunction makeIterator(iterator, name, kind) {\n  const object = {\n    index: 0,\n    kind,\n    target: iterator\n  };\n  const i = {\n    next() {\n      // 1. Let interface be the interface for which the iterator prototype object exists.\n\n      // 2. Let thisValue be the this value.\n\n      // 3. Let object be ? ToObject(thisValue).\n\n      // 4. If object is a platform object, then perform a security\n      //    check, passing:\n\n      // 5. If object is not a default iterator object for interface,\n      //    then throw a TypeError.\n      if (Object.getPrototypeOf(this) !== i) {\n        throw new TypeError(`'next' called on an object that does not implement interface ${name} Iterator.`);\n      }\n\n      // 6. Let index be object’s index.\n      // 7. Let kind be object’s kind.\n      // 8. Let values be object’s target's value pairs to iterate over.\n      const {\n        index,\n        kind,\n        target\n      } = object;\n      const values = target();\n\n      // 9. Let len be the length of values.\n      const len = values.length;\n\n      // 10. If index is greater than or equal to len, then return\n      //     CreateIterResultObject(undefined, true).\n      if (index >= len) {\n        return {\n          value: undefined,\n          done: true\n        };\n      }\n\n      // 11. Let pair be the entry in values at index index.\n      const pair = values[index];\n\n      // 12. Set object’s index to index + 1.\n      object.index = index + 1;\n\n      // 13. Return the iterator result for pair and kind.\n      return iteratorResult(pair, kind);\n    },\n    // The class string of an iterator prototype object for a given interface is the\n    // result of concatenating the identifier of the interface and the string \" Iterator\".\n    [Symbol.toStringTag]: `${name} Iterator`\n  };\n\n  // The [[Prototype]] internal slot of an iterator prototype object must be %IteratorPrototype%.\n  Object.setPrototypeOf(i, esIteratorPrototype);\n  // esIteratorPrototype needs to be the prototype of i\n  // which is the prototype of an empty object. Yes, it's confusing.\n  return Object.setPrototypeOf({}, i);\n}\n\n// https://webidl.spec.whatwg.org/#iterator-result\nfunction iteratorResult(pair, kind) {\n  let result;\n\n  // 1. Let result be a value determined by the value of kind:\n  switch (kind) {\n    case 'key':\n      {\n        // 1. Let idlKey be pair’s key.\n        // 2. Let key be the result of converting idlKey to an\n        //    ECMAScript value.\n        // 3. result is key.\n        result = pair[0];\n        break;\n      }\n    case 'value':\n      {\n        // 1. Let idlValue be pair’s value.\n        // 2. Let value be the result of converting idlValue to\n        //    an ECMAScript value.\n        // 3. result is value.\n        result = pair[1];\n        break;\n      }\n    case 'key+value':\n      {\n        // 1. Let idlKey be pair’s key.\n        // 2. Let idlValue be pair’s value.\n        // 3. Let key be the result of converting idlKey to an\n        //    ECMAScript value.\n        // 4. Let value be the result of converting idlValue to\n        //    an ECMAScript value.\n        // 5. Let array be ! ArrayCreate(2).\n        // 6. Call ! CreateDataProperty(array, \"0\", key).\n        // 7. Call ! CreateDataProperty(array, \"1\", value).\n        // 8. result is array.\n        result = pair;\n        break;\n      }\n  }\n\n  // 2. Return CreateIterResultObject(result, false).\n  return {\n    value: result,\n    done: false\n  };\n}\n\n/**\n * @see https://fetch.spec.whatwg.org/#body-fully-read\n */\nfunction fullyReadBody(body, processBody, processBodyError) {\n  // 1. If taskDestination is null, then set taskDestination to\n  //    the result of starting a new parallel queue.\n\n  // 2. Let successSteps given a byte sequence bytes be to queue a\n  //    fetch task to run processBody given bytes, with taskDestination.\n  const successSteps = bytes => queueMicrotask(() => processBody(bytes));\n\n  // 3. Let errorSteps be to queue a fetch task to run processBodyError,\n  //    with taskDestination.\n  const errorSteps = error => queueMicrotask(() => processBodyError(error));\n\n  // 4. Let reader be the result of getting a reader for body’s stream.\n  //    If that threw an exception, then run errorSteps with that\n  //    exception and return.\n  let reader;\n  try {\n    reader = body.stream.getReader();\n  } catch (e) {\n    errorSteps(e);\n    return;\n  }\n\n  // 5. Read all bytes from reader, given successSteps and errorSteps.\n  readAllBytes(reader, successSteps, errorSteps);\n}\n\n/** @type {ReadableStream} */\nlet ReadableStream = globalThis.ReadableStream;\nfunction isReadableStreamLike(stream) {\n  if (!ReadableStream) {\n    ReadableStream = require('stream/web').ReadableStream;\n  }\n  return stream instanceof ReadableStream || stream[Symbol.toStringTag] === 'ReadableStream' && typeof stream.tee === 'function';\n}\nconst MAXIMUM_ARGUMENT_LENGTH = 65535;\n\n/**\n * @see https://infra.spec.whatwg.org/#isomorphic-decode\n * @param {number[]|Uint8Array} input\n */\nfunction isomorphicDecode(input) {\n  // 1. To isomorphic decode a byte sequence input, return a string whose code point\n  //    length is equal to input’s length and whose code points have the same values\n  //    as the values of input’s bytes, in the same order.\n\n  if (input.length < MAXIMUM_ARGUMENT_LENGTH) {\n    return String.fromCharCode(...input);\n  }\n  return input.reduce((previous, current) => previous + String.fromCharCode(current), '');\n}\n\n/**\n * @param {ReadableStreamController<Uint8Array>} controller\n */\nfunction readableStreamClose(controller) {\n  try {\n    controller.close();\n  } catch (err) {\n    // TODO: add comment explaining why this error occurs.\n    if (!err.message.includes('Controller is already closed')) {\n      throw err;\n    }\n  }\n}\n\n/**\n * @see https://infra.spec.whatwg.org/#isomorphic-encode\n * @param {string} input\n */\nfunction isomorphicEncode(input) {\n  // 1. Assert: input contains no code points greater than U+00FF.\n  for (let i = 0; i < input.length; i++) {\n    assert(input.charCodeAt(i) <= 0xFF);\n  }\n\n  // 2. Return a byte sequence whose length is equal to input’s code\n  //    point length and whose bytes have the same values as the\n  //    values of input’s code points, in the same order\n  return input;\n}\n\n/**\n * @see https://streams.spec.whatwg.org/#readablestreamdefaultreader-read-all-bytes\n * @see https://streams.spec.whatwg.org/#read-loop\n * @param {ReadableStreamDefaultReader} reader\n * @param {(bytes: Uint8Array) => void} successSteps\n * @param {(error: Error) => void} failureSteps\n */\nasync function readAllBytes(reader, successSteps, failureSteps) {\n  const bytes = [];\n  let byteLength = 0;\n  while (true) {\n    let done;\n    let chunk;\n    try {\n      ({\n        done,\n        value: chunk\n      } = await reader.read());\n    } catch (e) {\n      // 1. Call failureSteps with e.\n      failureSteps(e);\n      return;\n    }\n    if (done) {\n      // 1. Call successSteps with bytes.\n      successSteps(Buffer.concat(bytes, byteLength));\n      return;\n    }\n\n    // 1. If chunk is not a Uint8Array object, call failureSteps\n    //    with a TypeError and abort these steps.\n    if (!isUint8Array(chunk)) {\n      failureSteps(new TypeError('Received non-Uint8Array chunk'));\n      return;\n    }\n\n    // 2. Append the bytes represented by chunk to bytes.\n    bytes.push(chunk);\n    byteLength += chunk.length;\n\n    // 3. Read-loop given reader, bytes, successSteps, and failureSteps.\n  }\n}\n\n/**\n * Fetch supports node >= 16.8.0, but Object.hasOwn was added in v16.9.0.\n */\nconst hasOwn = Object.hasOwn || ((dict, key) => Object.prototype.hasOwnProperty.call(dict, key));\nmodule.exports = {\n  isAborted,\n  isCancelled,\n  createDeferredPromise,\n  ReadableStreamFrom,\n  toUSVString,\n  tryUpgradeRequestToAPotentiallyTrustworthyURL,\n  coarsenedSharedCurrentTime,\n  determineRequestsReferrer,\n  makePolicyContainer,\n  clonePolicyContainer,\n  appendFetchMetadata,\n  appendRequestOriginHeader,\n  TAOCheck,\n  corsCheck,\n  crossOriginResourcePolicyCheck,\n  createOpaqueTimingInfo,\n  setRequestReferrerPolicyOnRedirect,\n  isValidHTTPToken,\n  requestBadPort,\n  requestCurrentURL,\n  responseURL,\n  responseLocationURL,\n  isBlobLike,\n  isURLPotentiallyTrustworthy,\n  isValidReasonPhrase,\n  sameOrigin,\n  normalizeMethod,\n  serializeJavascriptValueToJSONString,\n  makeIterator,\n  isValidHeaderName,\n  isValidHeaderValue,\n  hasOwn,\n  isErrorLike,\n  fullyReadBody,\n  bytesMatch,\n  isReadableStreamLike,\n  readableStreamClose,\n  isomorphicEncode,\n  isomorphicDecode\n};","map":{"version":3,"names":["redirectStatus","badPorts","referrerPolicy","referrerPolicyTokens","require","performance","isBlobLike","toUSVString","ReadableStreamFrom","assert","isUint8Array","crypto","responseURL","response","urlList","length","toString","responseLocationURL","requestFragment","includes","status","location","headersList","get","URL","hash","requestCurrentURL","request","requestBadPort","url","test","protocol","port","isErrorLike","object","Error","constructor","name","isValidReasonPhrase","statusText","i","c","charCodeAt","isTokenChar","isValidHTTPToken","characters","isValidHeaderName","potentialValue","isValidHeaderValue","startsWith","endsWith","setRequestReferrerPolicyOnRedirect","actualResponse","policyHeader","split","policy","token","trim","crossOriginResourcePolicyCheck","corsCheck","TAOCheck","appendFetchMetadata","httpRequest","header","mode","set","appendRequestOriginHeader","serializedOrigin","origin","responseTainting","append","method","sameOrigin","coarsenedSharedCurrentTime","crossOriginIsolatedCapability","now","createOpaqueTimingInfo","timingInfo","startTime","redirectStartTime","redirectEndTime","postRedirectStartTime","finalServiceWorkerStartTime","finalNetworkResponseStartTime","finalNetworkRequestStartTime","endTime","encodedBodySize","decodedBodySize","finalConnectionTimingInfo","makePolicyContainer","clonePolicyContainer","determineRequestsReferrer","environment","client","referrerSource","referrer","globalObject","self","href","urlProtocol","temp","referrerOrigin","referrerUrl","stripURLForReferrer","areSameOrigin","isNonPotentiallyTrustWorthy","isURLPotentiallyTrustworthy","originOnly","urlObject","username","password","isOriginPotentiallyTrustworthy","originAsURL","hostname","bytesMatch","bytes","metadataList","undefined","parsedMetadata","parseMetadata","list","sort","d","algo","localeCompare","strongest","metadata","filter","item","algorithm","expectedValue","actualValue","createHash","update","digest","parseHashWithOptions","result","empty","supportedHashes","getHashes","parsedToken","exec","groups","toLowerCase","push","tryUpgradeRequestToAPotentiallyTrustworthyURL","A","B","createDeferredPromise","res","rej","promise","Promise","resolve","reject","isAborted","fetchParams","controller","state","isCancelled","normalizeMethod","toUpperCase","serializeJavascriptValueToJSONString","value","JSON","stringify","TypeError","esIteratorPrototype","Object","getPrototypeOf","Symbol","iterator","makeIterator","kind","index","target","next","values","len","done","pair","iteratorResult","toStringTag","setPrototypeOf","fullyReadBody","body","processBody","processBodyError","successSteps","queueMicrotask","errorSteps","error","reader","stream","getReader","e","readAllBytes","ReadableStream","globalThis","isReadableStreamLike","tee","MAXIMUM_ARGUMENT_LENGTH","isomorphicDecode","input","String","fromCharCode","reduce","previous","current","readableStreamClose","close","err","message","isomorphicEncode","failureSteps","byteLength","chunk","read","Buffer","concat","hasOwn","dict","key","prototype","hasOwnProperty","call","module","exports"],"sources":["/Users/janrobel/Documents/PersonalProjekty/nftGenerateAi/clientAndContract/node_modules/undici/lib/fetch/util.js"],"sourcesContent":["'use strict'\n\nconst { redirectStatus, badPorts, referrerPolicy: referrerPolicyTokens } = require('./constants')\nconst { performance } = require('perf_hooks')\nconst { isBlobLike, toUSVString, ReadableStreamFrom } = require('../core/util')\nconst assert = require('assert')\nconst { isUint8Array } = require('util/types')\n\n// https://nodejs.org/api/crypto.html#determining-if-crypto-support-is-unavailable\n/** @type {import('crypto')|undefined} */\nlet crypto\n\ntry {\n  crypto = require('crypto')\n} catch {\n\n}\n\nfunction responseURL (response) {\n  // https://fetch.spec.whatwg.org/#responses\n  // A response has an associated URL. It is a pointer to the last URL\n  // in response’s URL list and null if response’s URL list is empty.\n  const urlList = response.urlList\n  const length = urlList.length\n  return length === 0 ? null : urlList[length - 1].toString()\n}\n\n// https://fetch.spec.whatwg.org/#concept-response-location-url\nfunction responseLocationURL (response, requestFragment) {\n  // 1. If response’s status is not a redirect status, then return null.\n  if (!redirectStatus.includes(response.status)) {\n    return null\n  }\n\n  // 2. Let location be the result of extracting header list values given\n  // `Location` and response’s header list.\n  let location = response.headersList.get('location')\n\n  // 3. If location is a value, then set location to the result of parsing\n  // location with response’s URL.\n  location = location ? new URL(location, responseURL(response)) : null\n\n  // 4. If location is a URL whose fragment is null, then set location’s\n  // fragment to requestFragment.\n  if (location && !location.hash) {\n    location.hash = requestFragment\n  }\n\n  // 5. Return location.\n  return location\n}\n\n/** @returns {URL} */\nfunction requestCurrentURL (request) {\n  return request.urlList[request.urlList.length - 1]\n}\n\nfunction requestBadPort (request) {\n  // 1. Let url be request’s current URL.\n  const url = requestCurrentURL(request)\n\n  // 2. If url’s scheme is an HTTP(S) scheme and url’s port is a bad port,\n  // then return blocked.\n  if (/^https?:/.test(url.protocol) && badPorts.includes(url.port)) {\n    return 'blocked'\n  }\n\n  // 3. Return allowed.\n  return 'allowed'\n}\n\nfunction isErrorLike (object) {\n  return object instanceof Error || (\n    object?.constructor?.name === 'Error' ||\n    object?.constructor?.name === 'DOMException'\n  )\n}\n\n// Check whether |statusText| is a ByteString and\n// matches the Reason-Phrase token production.\n// RFC 2616: https://tools.ietf.org/html/rfc2616\n// RFC 7230: https://tools.ietf.org/html/rfc7230\n// \"reason-phrase = *( HTAB / SP / VCHAR / obs-text )\"\n// https://github.com/chromium/chromium/blob/94.0.4604.1/third_party/blink/renderer/core/fetch/response.cc#L116\nfunction isValidReasonPhrase (statusText) {\n  for (let i = 0; i < statusText.length; ++i) {\n    const c = statusText.charCodeAt(i)\n    if (\n      !(\n        (\n          c === 0x09 || // HTAB\n          (c >= 0x20 && c <= 0x7e) || // SP / VCHAR\n          (c >= 0x80 && c <= 0xff)\n        ) // obs-text\n      )\n    ) {\n      return false\n    }\n  }\n  return true\n}\n\nfunction isTokenChar (c) {\n  return !(\n    c >= 0x7f ||\n    c <= 0x20 ||\n    c === '(' ||\n    c === ')' ||\n    c === '<' ||\n    c === '>' ||\n    c === '@' ||\n    c === ',' ||\n    c === ';' ||\n    c === ':' ||\n    c === '\\\\' ||\n    c === '\"' ||\n    c === '/' ||\n    c === '[' ||\n    c === ']' ||\n    c === '?' ||\n    c === '=' ||\n    c === '{' ||\n    c === '}'\n  )\n}\n\n// See RFC 7230, Section 3.2.6.\n// https://github.com/chromium/chromium/blob/d7da0240cae77824d1eda25745c4022757499131/third_party/blink/renderer/platform/network/http_parsers.cc#L321\nfunction isValidHTTPToken (characters) {\n  if (!characters || typeof characters !== 'string') {\n    return false\n  }\n  for (let i = 0; i < characters.length; ++i) {\n    const c = characters.charCodeAt(i)\n    if (c > 0x7f || !isTokenChar(c)) {\n      return false\n    }\n  }\n  return true\n}\n\n// https://fetch.spec.whatwg.org/#header-name\n// https://github.com/chromium/chromium/blob/b3d37e6f94f87d59e44662d6078f6a12de845d17/net/http/http_util.cc#L342\nfunction isValidHeaderName (potentialValue) {\n  if (potentialValue.length === 0) {\n    return false\n  }\n\n  return isValidHTTPToken(potentialValue)\n}\n\n/**\n * @see https://fetch.spec.whatwg.org/#header-value\n * @param {string} potentialValue\n */\nfunction isValidHeaderValue (potentialValue) {\n  // - Has no leading or trailing HTTP tab or space bytes.\n  // - Contains no 0x00 (NUL) or HTTP newline bytes.\n  if (\n    potentialValue.startsWith('\\t') ||\n    potentialValue.startsWith(' ') ||\n    potentialValue.endsWith('\\t') ||\n    potentialValue.endsWith(' ')\n  ) {\n    return false\n  }\n\n  if (\n    potentialValue.includes('\\0') ||\n    potentialValue.includes('\\r') ||\n    potentialValue.includes('\\n')\n  ) {\n    return false\n  }\n\n  return true\n}\n\n// https://w3c.github.io/webappsec-referrer-policy/#set-requests-referrer-policy-on-redirect\nfunction setRequestReferrerPolicyOnRedirect (request, actualResponse) {\n  //  Given a request request and a response actualResponse, this algorithm\n  //  updates request’s referrer policy according to the Referrer-Policy\n  //  header (if any) in actualResponse.\n\n  // 1. Let policy be the result of executing § 8.1 Parse a referrer policy\n  // from a Referrer-Policy header on actualResponse.\n\n  // 8.1 Parse a referrer policy from a Referrer-Policy header\n  // 1. Let policy-tokens be the result of extracting header list values given `Referrer-Policy` and response’s header list.\n  const { headersList } = actualResponse\n  // 2. Let policy be the empty string.\n  // 3. For each token in policy-tokens, if token is a referrer policy and token is not the empty string, then set policy to token.\n  // 4. Return policy.\n  const policyHeader = (headersList.get('referrer-policy') ?? '').split(',')\n\n  // Note: As the referrer-policy can contain multiple policies\n  // separated by comma, we need to loop through all of them\n  // and pick the first valid one.\n  // Ref: https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Referrer-Policy#specify_a_fallback_policy\n  let policy = ''\n  if (policyHeader.length > 0) {\n    // The right-most policy takes precedence.\n    // The left-most policy is the fallback.\n    for (let i = policyHeader.length; i !== 0; i--) {\n      const token = policyHeader[i - 1].trim()\n      if (referrerPolicyTokens.includes(token)) {\n        policy = token\n        break\n      }\n    }\n  }\n\n  // 2. If policy is not the empty string, then set request’s referrer policy to policy.\n  if (policy !== '') {\n    request.referrerPolicy = policy\n  }\n}\n\n// https://fetch.spec.whatwg.org/#cross-origin-resource-policy-check\nfunction crossOriginResourcePolicyCheck () {\n  // TODO\n  return 'allowed'\n}\n\n// https://fetch.spec.whatwg.org/#concept-cors-check\nfunction corsCheck () {\n  // TODO\n  return 'success'\n}\n\n// https://fetch.spec.whatwg.org/#concept-tao-check\nfunction TAOCheck () {\n  // TODO\n  return 'success'\n}\n\nfunction appendFetchMetadata (httpRequest) {\n  //  https://w3c.github.io/webappsec-fetch-metadata/#sec-fetch-dest-header\n  //  TODO\n\n  //  https://w3c.github.io/webappsec-fetch-metadata/#sec-fetch-mode-header\n\n  //  1. Assert: r’s url is a potentially trustworthy URL.\n  //  TODO\n\n  //  2. Let header be a Structured Header whose value is a token.\n  let header = null\n\n  //  3. Set header’s value to r’s mode.\n  header = httpRequest.mode\n\n  //  4. Set a structured field value `Sec-Fetch-Mode`/header in r’s header list.\n  httpRequest.headersList.set('sec-fetch-mode', header)\n\n  //  https://w3c.github.io/webappsec-fetch-metadata/#sec-fetch-site-header\n  //  TODO\n\n  //  https://w3c.github.io/webappsec-fetch-metadata/#sec-fetch-user-header\n  //  TODO\n}\n\n// https://fetch.spec.whatwg.org/#append-a-request-origin-header\nfunction appendRequestOriginHeader (request) {\n  // 1. Let serializedOrigin be the result of byte-serializing a request origin with request.\n  let serializedOrigin = request.origin\n\n  // 2. If request’s response tainting is \"cors\" or request’s mode is \"websocket\", then append (`Origin`, serializedOrigin) to request’s header list.\n  if (request.responseTainting === 'cors' || request.mode === 'websocket') {\n    if (serializedOrigin) {\n      request.headersList.append('Origin', serializedOrigin)\n    }\n\n  // 3. Otherwise, if request’s method is neither `GET` nor `HEAD`, then:\n  } else if (request.method !== 'GET' && request.method !== 'HEAD') {\n    // 1. Switch on request’s referrer policy:\n    switch (request.referrerPolicy) {\n      case 'no-referrer':\n        // Set serializedOrigin to `null`.\n        serializedOrigin = null\n        break\n      case 'no-referrer-when-downgrade':\n      case 'strict-origin':\n      case 'strict-origin-when-cross-origin':\n        // If request’s origin is a tuple origin, its scheme is \"https\", and request’s current URL’s scheme is not \"https\", then set serializedOrigin to `null`.\n        if (/^https:/.test(request.origin) && !/^https:/.test(requestCurrentURL(request))) {\n          serializedOrigin = null\n        }\n        break\n      case 'same-origin':\n        // If request’s origin is not same origin with request’s current URL’s origin, then set serializedOrigin to `null`.\n        if (!sameOrigin(request, requestCurrentURL(request))) {\n          serializedOrigin = null\n        }\n        break\n      default:\n        // Do nothing.\n    }\n\n    if (serializedOrigin) {\n      // 2. Append (`Origin`, serializedOrigin) to request’s header list.\n      request.headersList.append('Origin', serializedOrigin)\n    }\n  }\n}\n\nfunction coarsenedSharedCurrentTime (crossOriginIsolatedCapability) {\n  // TODO\n  return performance.now()\n}\n\n// https://fetch.spec.whatwg.org/#create-an-opaque-timing-info\nfunction createOpaqueTimingInfo (timingInfo) {\n  return {\n    startTime: timingInfo.startTime ?? 0,\n    redirectStartTime: 0,\n    redirectEndTime: 0,\n    postRedirectStartTime: timingInfo.startTime ?? 0,\n    finalServiceWorkerStartTime: 0,\n    finalNetworkResponseStartTime: 0,\n    finalNetworkRequestStartTime: 0,\n    endTime: 0,\n    encodedBodySize: 0,\n    decodedBodySize: 0,\n    finalConnectionTimingInfo: null\n  }\n}\n\n// https://html.spec.whatwg.org/multipage/origin.html#policy-container\nfunction makePolicyContainer () {\n  // TODO\n  return {}\n}\n\n// https://html.spec.whatwg.org/multipage/origin.html#clone-a-policy-container\nfunction clonePolicyContainer () {\n  // TODO\n  return {}\n}\n\n// https://w3c.github.io/webappsec-referrer-policy/#determine-requests-referrer\nfunction determineRequestsReferrer (request) {\n  // 1. Let policy be request's referrer policy.\n  const policy = request.referrerPolicy\n\n  // Return no-referrer when empty or policy says so\n  if (policy == null || policy === '' || policy === 'no-referrer') {\n    return 'no-referrer'\n  }\n\n  // 2. Let environment be the request client\n  const environment = request.client\n  let referrerSource = null\n\n  /**\n   * 3, Switch on request’s referrer:\n    \"client\"\n      If environment’s global object is a Window object, then\n        Let document be the associated Document of environment’s global object.\n        If document’s origin is an opaque origin, return no referrer.\n        While document is an iframe srcdoc document,\n        let document be document’s browsing context’s browsing context container’s node document.\n        Let referrerSource be document’s URL.\n\n      Otherwise, let referrerSource be environment’s creation URL.\n\n    a URL\n    Let referrerSource be request’s referrer.\n   */\n  if (request.referrer === 'client') {\n    // Not defined in Node but part of the spec\n    if (request.client?.globalObject?.constructor?.name === 'Window' ) { // eslint-disable-line\n      const origin = environment.globalObject.self?.origin ?? environment.globalObject.location?.origin\n\n      // If document’s origin is an opaque origin, return no referrer.\n      if (origin == null || origin === 'null') return 'no-referrer'\n\n      // Let referrerSource be document’s URL.\n      referrerSource = new URL(environment.globalObject.location.href)\n    } else {\n      // 3(a)(II) If environment's global object is not Window,\n      // Let referrerSource be environments creationURL\n      if (environment?.globalObject?.location == null) {\n        return 'no-referrer'\n      }\n\n      referrerSource = new URL(environment.globalObject.location.href)\n    }\n  } else if (request.referrer instanceof URL) {\n    // 3(b) If requests's referrer is a URL instance, then make\n    // referrerSource be requests's referrer.\n    referrerSource = request.referrer\n  } else {\n    // If referrerSource neither client nor instance of URL\n    // then return \"no-referrer\".\n    return 'no-referrer'\n  }\n\n  const urlProtocol = referrerSource.protocol\n\n  // If url's scheme is a local scheme (i.e. one of \"about\", \"data\", \"javascript\", \"file\")\n  // then return \"no-referrer\".\n  if (\n    urlProtocol === 'about:' || urlProtocol === 'data:' ||\n    urlProtocol === 'blob:'\n  ) {\n    return 'no-referrer'\n  }\n\n  let temp\n  let referrerOrigin\n  // 4. Let requests's referrerURL be the result of stripping referrer\n  // source for use as referrer (using util function, without origin only)\n  const referrerUrl = (temp = stripURLForReferrer(referrerSource)).length > 4096\n  // 5. Let referrerOrigin be the result of stripping referrer\n  // source for use as referrer (using util function, with originOnly true)\n    ? (referrerOrigin = stripURLForReferrer(referrerSource, true))\n  // 6. If result of seralizing referrerUrl is a string whose length is greater than\n  // 4096, then set referrerURL to referrerOrigin\n    : temp\n  const areSameOrigin = sameOrigin(request, referrerUrl)\n  const isNonPotentiallyTrustWorthy = isURLPotentiallyTrustworthy(referrerUrl) &&\n    !isURLPotentiallyTrustworthy(request.url)\n\n  // NOTE: How to treat step 7?\n  // 8. Execute the switch statements corresponding to the value of policy:\n  switch (policy) {\n    case 'origin': return referrerOrigin != null ? referrerOrigin : stripURLForReferrer(referrerSource, true)\n    case 'unsafe-url': return referrerUrl\n    case 'same-origin':\n      return areSameOrigin ? referrerOrigin : 'no-referrer'\n    case 'origin-when-cross-origin':\n      return areSameOrigin ? referrerUrl : referrerOrigin\n    case 'strict-origin-when-cross-origin':\n      /**\n         * 1. If the origin of referrerURL and the origin of request’s current URL are the same,\n         * then return referrerURL.\n         * 2. If referrerURL is a potentially trustworthy URL and request’s current URL is not a\n         * potentially trustworthy URL, then return no referrer.\n         * 3. Return referrerOrigin\n      */\n      if (areSameOrigin) return referrerOrigin\n      // else return isNonPotentiallyTrustWorthy ? 'no-referrer' : referrerOrigin\n    case 'strict-origin': // eslint-disable-line\n      /**\n         * 1. If referrerURL is a potentially trustworthy URL and\n         * request’s current URL is not a potentially trustworthy URL,\n         * then return no referrer.\n         * 2. Return referrerOrigin\n        */\n    case 'no-referrer-when-downgrade': // eslint-disable-line\n      /**\n       * 1. If referrerURL is a potentially trustworthy URL and\n       * request’s current URL is not a potentially trustworthy URL,\n       * then return no referrer.\n       * 2. Return referrerOrigin\n      */\n\n    default: // eslint-disable-line\n      return isNonPotentiallyTrustWorthy ? 'no-referrer' : referrerOrigin\n  }\n\n  function stripURLForReferrer (url, originOnly = false) {\n    const urlObject = new URL(url.href)\n    urlObject.username = ''\n    urlObject.password = ''\n    urlObject.hash = ''\n\n    return originOnly ? urlObject.origin : urlObject.href\n  }\n}\n\nfunction isURLPotentiallyTrustworthy (url) {\n  if (!(url instanceof URL)) {\n    return false\n  }\n\n  // If child of about, return true\n  if (url.href === 'about:blank' || url.href === 'about:srcdoc') {\n    return true\n  }\n\n  // If scheme is data, return true\n  if (url.protocol === 'data:') return true\n\n  // If file, return true\n  if (url.protocol === 'file:') return true\n\n  return isOriginPotentiallyTrustworthy(url.origin)\n\n  function isOriginPotentiallyTrustworthy (origin) {\n    // If origin is explicitly null, return false\n    if (origin == null || origin === 'null') return false\n\n    const originAsURL = new URL(origin)\n\n    // If secure, return true\n    if (originAsURL.protocol === 'https:' || originAsURL.protocol === 'wss:') {\n      return true\n    }\n\n    // If localhost or variants, return true\n    if (/^127(?:\\.[0-9]+){0,2}\\.[0-9]+$|^\\[(?:0*:)*?:?0*1\\]$/.test(originAsURL.hostname) ||\n     (originAsURL.hostname === 'localhost' || originAsURL.hostname.includes('localhost.')) ||\n     (originAsURL.hostname.endsWith('.localhost'))) {\n      return true\n    }\n\n    // If any other, return false\n    return false\n  }\n}\n\n/**\n * @see https://w3c.github.io/webappsec-subresource-integrity/#does-response-match-metadatalist\n * @param {Uint8Array} bytes\n * @param {string} metadataList\n */\nfunction bytesMatch (bytes, metadataList) {\n  // If node is not built with OpenSSL support, we cannot check\n  // a request's integrity, so allow it by default (the spec will\n  // allow requests if an invalid hash is given, as precedence).\n  /* istanbul ignore if: only if node is built with --without-ssl */\n  if (crypto === undefined) {\n    return true\n  }\n\n  // 1. Let parsedMetadata be the result of parsing metadataList.\n  const parsedMetadata = parseMetadata(metadataList)\n\n  // 2. If parsedMetadata is no metadata, return true.\n  if (parsedMetadata === 'no metadata') {\n    return true\n  }\n\n  // 3. If parsedMetadata is the empty set, return true.\n  if (parsedMetadata.length === 0) {\n    return true\n  }\n\n  // 4. Let metadata be the result of getting the strongest\n  //    metadata from parsedMetadata.\n  const list = parsedMetadata.sort((c, d) => d.algo.localeCompare(c.algo))\n  // get the strongest algorithm\n  const strongest = list[0].algo\n  // get all entries that use the strongest algorithm; ignore weaker\n  const metadata = list.filter((item) => item.algo === strongest)\n\n  // 5. For each item in metadata:\n  for (const item of metadata) {\n    // 1. Let algorithm be the alg component of item.\n    const algorithm = item.algo\n\n    // 2. Let expectedValue be the val component of item.\n    const expectedValue = item.hash\n\n    // 3. Let actualValue be the result of applying algorithm to bytes.\n    const actualValue = crypto.createHash(algorithm).update(bytes).digest('base64')\n\n    // 4. If actualValue is a case-sensitive match for expectedValue,\n    //    return true.\n    if (actualValue === expectedValue) {\n      return true\n    }\n  }\n\n  // 6. Return false.\n  return false\n}\n\n// https://w3c.github.io/webappsec-subresource-integrity/#grammardef-hash-with-options\n// https://www.w3.org/TR/CSP2/#source-list-syntax\n// https://www.rfc-editor.org/rfc/rfc5234#appendix-B.1\nconst parseHashWithOptions = /((?<algo>sha256|sha384|sha512)-(?<hash>[A-z0-9+/]{1}.*={0,2}))( +[\\x21-\\x7e]?)?/i\n\n/**\n * @see https://w3c.github.io/webappsec-subresource-integrity/#parse-metadata\n * @param {string} metadata\n */\nfunction parseMetadata (metadata) {\n  // 1. Let result be the empty set.\n  /** @type {{ algo: string, hash: string }[]} */\n  const result = []\n\n  // 2. Let empty be equal to true.\n  let empty = true\n\n  const supportedHashes = crypto.getHashes()\n\n  // 3. For each token returned by splitting metadata on spaces:\n  for (const token of metadata.split(' ')) {\n    // 1. Set empty to false.\n    empty = false\n\n    // 2. Parse token as a hash-with-options.\n    const parsedToken = parseHashWithOptions.exec(token)\n\n    // 3. If token does not parse, continue to the next token.\n    if (parsedToken === null || parsedToken.groups === undefined) {\n      // Note: Chromium blocks the request at this point, but Firefox\n      // gives a warning that an invalid integrity was given. The\n      // correct behavior is to ignore these, and subsequently not\n      // check the integrity of the resource.\n      continue\n    }\n\n    // 4. Let algorithm be the hash-algo component of token.\n    const algorithm = parsedToken.groups.algo\n\n    // 5. If algorithm is a hash function recognized by the user\n    //    agent, add the parsed token to result.\n    if (supportedHashes.includes(algorithm.toLowerCase())) {\n      result.push(parsedToken.groups)\n    }\n  }\n\n  // 4. Return no metadata if empty is true, otherwise return result.\n  if (empty === true) {\n    return 'no metadata'\n  }\n\n  return result\n}\n\n// https://w3c.github.io/webappsec-upgrade-insecure-requests/#upgrade-request\nfunction tryUpgradeRequestToAPotentiallyTrustworthyURL (request) {\n  // TODO\n}\n\n/**\n * @link {https://html.spec.whatwg.org/multipage/origin.html#same-origin}\n * @param {URL} A\n * @param {URL} B\n */\nfunction sameOrigin (A, B) {\n  // 1. If A and B are the same opaque origin, then return true.\n  // \"opaque origin\" is an internal value we cannot access, ignore.\n\n  // 2. If A and B are both tuple origins and their schemes,\n  //    hosts, and port are identical, then return true.\n  if (A.protocol === B.protocol && A.hostname === B.hostname && A.port === B.port) {\n    return true\n  }\n\n  // 3. Return false.\n  return false\n}\n\nfunction createDeferredPromise () {\n  let res\n  let rej\n  const promise = new Promise((resolve, reject) => {\n    res = resolve\n    rej = reject\n  })\n\n  return { promise, resolve: res, reject: rej }\n}\n\nfunction isAborted (fetchParams) {\n  return fetchParams.controller.state === 'aborted'\n}\n\nfunction isCancelled (fetchParams) {\n  return fetchParams.controller.state === 'aborted' ||\n    fetchParams.controller.state === 'terminated'\n}\n\n// https://fetch.spec.whatwg.org/#concept-method-normalize\nfunction normalizeMethod (method) {\n  return /^(DELETE|GET|HEAD|OPTIONS|POST|PUT)$/i.test(method)\n    ? method.toUpperCase()\n    : method\n}\n\n// https://infra.spec.whatwg.org/#serialize-a-javascript-value-to-a-json-string\nfunction serializeJavascriptValueToJSONString (value) {\n  // 1. Let result be ? Call(%JSON.stringify%, undefined, « value »).\n  const result = JSON.stringify(value)\n\n  // 2. If result is undefined, then throw a TypeError.\n  if (result === undefined) {\n    throw new TypeError('Value is not JSON serializable')\n  }\n\n  // 3. Assert: result is a string.\n  assert(typeof result === 'string')\n\n  // 4. Return result.\n  return result\n}\n\n// https://tc39.es/ecma262/#sec-%25iteratorprototype%25-object\nconst esIteratorPrototype = Object.getPrototypeOf(Object.getPrototypeOf([][Symbol.iterator]()))\n\n/**\n * @see https://webidl.spec.whatwg.org/#dfn-iterator-prototype-object\n * @param {() => unknown[]} iterator\n * @param {string} name name of the instance\n * @param {'key'|'value'|'key+value'} kind\n */\nfunction makeIterator (iterator, name, kind) {\n  const object = {\n    index: 0,\n    kind,\n    target: iterator\n  }\n\n  const i = {\n    next () {\n      // 1. Let interface be the interface for which the iterator prototype object exists.\n\n      // 2. Let thisValue be the this value.\n\n      // 3. Let object be ? ToObject(thisValue).\n\n      // 4. If object is a platform object, then perform a security\n      //    check, passing:\n\n      // 5. If object is not a default iterator object for interface,\n      //    then throw a TypeError.\n      if (Object.getPrototypeOf(this) !== i) {\n        throw new TypeError(\n          `'next' called on an object that does not implement interface ${name} Iterator.`\n        )\n      }\n\n      // 6. Let index be object’s index.\n      // 7. Let kind be object’s kind.\n      // 8. Let values be object’s target's value pairs to iterate over.\n      const { index, kind, target } = object\n      const values = target()\n\n      // 9. Let len be the length of values.\n      const len = values.length\n\n      // 10. If index is greater than or equal to len, then return\n      //     CreateIterResultObject(undefined, true).\n      if (index >= len) {\n        return { value: undefined, done: true }\n      }\n\n      // 11. Let pair be the entry in values at index index.\n      const pair = values[index]\n\n      // 12. Set object’s index to index + 1.\n      object.index = index + 1\n\n      // 13. Return the iterator result for pair and kind.\n      return iteratorResult(pair, kind)\n    },\n    // The class string of an iterator prototype object for a given interface is the\n    // result of concatenating the identifier of the interface and the string \" Iterator\".\n    [Symbol.toStringTag]: `${name} Iterator`\n  }\n\n  // The [[Prototype]] internal slot of an iterator prototype object must be %IteratorPrototype%.\n  Object.setPrototypeOf(i, esIteratorPrototype)\n  // esIteratorPrototype needs to be the prototype of i\n  // which is the prototype of an empty object. Yes, it's confusing.\n  return Object.setPrototypeOf({}, i)\n}\n\n// https://webidl.spec.whatwg.org/#iterator-result\nfunction iteratorResult (pair, kind) {\n  let result\n\n  // 1. Let result be a value determined by the value of kind:\n  switch (kind) {\n    case 'key': {\n      // 1. Let idlKey be pair’s key.\n      // 2. Let key be the result of converting idlKey to an\n      //    ECMAScript value.\n      // 3. result is key.\n      result = pair[0]\n      break\n    }\n    case 'value': {\n      // 1. Let idlValue be pair’s value.\n      // 2. Let value be the result of converting idlValue to\n      //    an ECMAScript value.\n      // 3. result is value.\n      result = pair[1]\n      break\n    }\n    case 'key+value': {\n      // 1. Let idlKey be pair’s key.\n      // 2. Let idlValue be pair’s value.\n      // 3. Let key be the result of converting idlKey to an\n      //    ECMAScript value.\n      // 4. Let value be the result of converting idlValue to\n      //    an ECMAScript value.\n      // 5. Let array be ! ArrayCreate(2).\n      // 6. Call ! CreateDataProperty(array, \"0\", key).\n      // 7. Call ! CreateDataProperty(array, \"1\", value).\n      // 8. result is array.\n      result = pair\n      break\n    }\n  }\n\n  // 2. Return CreateIterResultObject(result, false).\n  return { value: result, done: false }\n}\n\n/**\n * @see https://fetch.spec.whatwg.org/#body-fully-read\n */\nfunction fullyReadBody (body, processBody, processBodyError) {\n  // 1. If taskDestination is null, then set taskDestination to\n  //    the result of starting a new parallel queue.\n\n  // 2. Let successSteps given a byte sequence bytes be to queue a\n  //    fetch task to run processBody given bytes, with taskDestination.\n  const successSteps = (bytes) => queueMicrotask(() => processBody(bytes))\n\n  // 3. Let errorSteps be to queue a fetch task to run processBodyError,\n  //    with taskDestination.\n  const errorSteps = (error) => queueMicrotask(() => processBodyError(error))\n\n  // 4. Let reader be the result of getting a reader for body’s stream.\n  //    If that threw an exception, then run errorSteps with that\n  //    exception and return.\n  let reader\n\n  try {\n    reader = body.stream.getReader()\n  } catch (e) {\n    errorSteps(e)\n    return\n  }\n\n  // 5. Read all bytes from reader, given successSteps and errorSteps.\n  readAllBytes(reader, successSteps, errorSteps)\n}\n\n/** @type {ReadableStream} */\nlet ReadableStream = globalThis.ReadableStream\n\nfunction isReadableStreamLike (stream) {\n  if (!ReadableStream) {\n    ReadableStream = require('stream/web').ReadableStream\n  }\n\n  return stream instanceof ReadableStream || (\n    stream[Symbol.toStringTag] === 'ReadableStream' &&\n    typeof stream.tee === 'function'\n  )\n}\n\nconst MAXIMUM_ARGUMENT_LENGTH = 65535\n\n/**\n * @see https://infra.spec.whatwg.org/#isomorphic-decode\n * @param {number[]|Uint8Array} input\n */\nfunction isomorphicDecode (input) {\n  // 1. To isomorphic decode a byte sequence input, return a string whose code point\n  //    length is equal to input’s length and whose code points have the same values\n  //    as the values of input’s bytes, in the same order.\n\n  if (input.length < MAXIMUM_ARGUMENT_LENGTH) {\n    return String.fromCharCode(...input)\n  }\n\n  return input.reduce((previous, current) => previous + String.fromCharCode(current), '')\n}\n\n/**\n * @param {ReadableStreamController<Uint8Array>} controller\n */\nfunction readableStreamClose (controller) {\n  try {\n    controller.close()\n  } catch (err) {\n    // TODO: add comment explaining why this error occurs.\n    if (!err.message.includes('Controller is already closed')) {\n      throw err\n    }\n  }\n}\n\n/**\n * @see https://infra.spec.whatwg.org/#isomorphic-encode\n * @param {string} input\n */\nfunction isomorphicEncode (input) {\n  // 1. Assert: input contains no code points greater than U+00FF.\n  for (let i = 0; i < input.length; i++) {\n    assert(input.charCodeAt(i) <= 0xFF)\n  }\n\n  // 2. Return a byte sequence whose length is equal to input’s code\n  //    point length and whose bytes have the same values as the\n  //    values of input’s code points, in the same order\n  return input\n}\n\n/**\n * @see https://streams.spec.whatwg.org/#readablestreamdefaultreader-read-all-bytes\n * @see https://streams.spec.whatwg.org/#read-loop\n * @param {ReadableStreamDefaultReader} reader\n * @param {(bytes: Uint8Array) => void} successSteps\n * @param {(error: Error) => void} failureSteps\n */\nasync function readAllBytes (reader, successSteps, failureSteps) {\n  const bytes = []\n  let byteLength = 0\n\n  while (true) {\n    let done\n    let chunk\n\n    try {\n      ({ done, value: chunk } = await reader.read())\n    } catch (e) {\n      // 1. Call failureSteps with e.\n      failureSteps(e)\n      return\n    }\n\n    if (done) {\n      // 1. Call successSteps with bytes.\n      successSteps(Buffer.concat(bytes, byteLength))\n      return\n    }\n\n    // 1. If chunk is not a Uint8Array object, call failureSteps\n    //    with a TypeError and abort these steps.\n    if (!isUint8Array(chunk)) {\n      failureSteps(new TypeError('Received non-Uint8Array chunk'))\n      return\n    }\n\n    // 2. Append the bytes represented by chunk to bytes.\n    bytes.push(chunk)\n    byteLength += chunk.length\n\n    // 3. Read-loop given reader, bytes, successSteps, and failureSteps.\n  }\n}\n\n/**\n * Fetch supports node >= 16.8.0, but Object.hasOwn was added in v16.9.0.\n */\nconst hasOwn = Object.hasOwn || ((dict, key) => Object.prototype.hasOwnProperty.call(dict, key))\n\nmodule.exports = {\n  isAborted,\n  isCancelled,\n  createDeferredPromise,\n  ReadableStreamFrom,\n  toUSVString,\n  tryUpgradeRequestToAPotentiallyTrustworthyURL,\n  coarsenedSharedCurrentTime,\n  determineRequestsReferrer,\n  makePolicyContainer,\n  clonePolicyContainer,\n  appendFetchMetadata,\n  appendRequestOriginHeader,\n  TAOCheck,\n  corsCheck,\n  crossOriginResourcePolicyCheck,\n  createOpaqueTimingInfo,\n  setRequestReferrerPolicyOnRedirect,\n  isValidHTTPToken,\n  requestBadPort,\n  requestCurrentURL,\n  responseURL,\n  responseLocationURL,\n  isBlobLike,\n  isURLPotentiallyTrustworthy,\n  isValidReasonPhrase,\n  sameOrigin,\n  normalizeMethod,\n  serializeJavascriptValueToJSONString,\n  makeIterator,\n  isValidHeaderName,\n  isValidHeaderValue,\n  hasOwn,\n  isErrorLike,\n  fullyReadBody,\n  bytesMatch,\n  isReadableStreamLike,\n  readableStreamClose,\n  isomorphicEncode,\n  isomorphicDecode\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}