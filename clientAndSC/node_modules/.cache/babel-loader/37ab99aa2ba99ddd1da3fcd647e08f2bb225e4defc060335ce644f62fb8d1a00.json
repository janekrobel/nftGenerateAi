{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.DependencyGraph = void 0;\nclass DependencyGraph {\n  constructor() {\n    this._resolvedFiles = new Map();\n    this._dependenciesPerFile = new Map();\n    this._visitedFiles = new Set();\n  }\n  static async createFromResolvedFiles(resolver, resolvedFiles) {\n    const graph = new DependencyGraph();\n    // TODO refactor this to make the results deterministic\n    await Promise.all(resolvedFiles.map(resolvedFile => graph._addDependenciesFrom(resolver, resolvedFile)));\n    return graph;\n  }\n  getResolvedFiles() {\n    return Array.from(this._resolvedFiles.values());\n  }\n  has(file) {\n    return this._resolvedFiles.has(file.sourceName);\n  }\n  isEmpty() {\n    return this._resolvedFiles.size === 0;\n  }\n  entries() {\n    return Array.from(this._dependenciesPerFile.entries()).map(_ref => {\n      let [key, value] = _ref;\n      return [this._resolvedFiles.get(key), value];\n    });\n  }\n  getDependencies(file) {\n    const dependencies = this._dependenciesPerFile.get(file.sourceName) ?? new Set();\n    return [...dependencies];\n  }\n  getTransitiveDependencies(file) {\n    const visited = new Set();\n    const transitiveDependencies = this._getTransitiveDependencies(file, visited, []);\n    return [...transitiveDependencies];\n  }\n  getConnectedComponents() {\n    const undirectedGraph = {};\n    for (const [sourceName, dependencies] of this._dependenciesPerFile.entries()) {\n      undirectedGraph[sourceName] = undirectedGraph[sourceName] ?? new Set();\n      for (const dependency of dependencies) {\n        undirectedGraph[dependency.sourceName] = undirectedGraph[dependency.sourceName] ?? new Set();\n        undirectedGraph[sourceName].add(dependency.sourceName);\n        undirectedGraph[dependency.sourceName].add(sourceName);\n      }\n    }\n    const components = [];\n    const visited = new Set();\n    for (const node of Object.keys(undirectedGraph)) {\n      if (visited.has(node)) {\n        continue;\n      }\n      visited.add(node);\n      const component = new Set([node]);\n      const stack = [...undirectedGraph[node]];\n      while (stack.length > 0) {\n        const newNode = stack.pop();\n        if (visited.has(newNode)) {\n          continue;\n        }\n        visited.add(newNode);\n        component.add(newNode);\n        [...undirectedGraph[newNode]].forEach(adjacent => {\n          if (!visited.has(adjacent)) {\n            stack.push(adjacent);\n          }\n        });\n      }\n      components.push(component);\n    }\n    const connectedComponents = [];\n    for (const component of components) {\n      const dependencyGraph = new DependencyGraph();\n      for (const sourceName of component) {\n        const file = this._resolvedFiles.get(sourceName);\n        const dependencies = this._dependenciesPerFile.get(sourceName);\n        dependencyGraph._resolvedFiles.set(sourceName, file);\n        dependencyGraph._dependenciesPerFile.set(sourceName, dependencies);\n      }\n      connectedComponents.push(dependencyGraph);\n    }\n    return connectedComponents;\n  }\n  _getTransitiveDependencies(file, visited, path) {\n    if (visited.has(file)) {\n      return new Set();\n    }\n    visited.add(file);\n    const directDependencies = this.getDependencies(file).map(dependency => ({\n      dependency,\n      path\n    }));\n    const transitiveDependencies = new Set(directDependencies);\n    for (const {\n      dependency\n    } of transitiveDependencies) {\n      this._getTransitiveDependencies(dependency, visited, path.concat(dependency)).forEach(x => transitiveDependencies.add(x));\n    }\n    return transitiveDependencies;\n  }\n  async _addDependenciesFrom(resolver, file) {\n    if (this._visitedFiles.has(file.absolutePath)) {\n      return;\n    }\n    this._visitedFiles.add(file.absolutePath);\n    const dependencies = new Set();\n    this._resolvedFiles.set(file.sourceName, file);\n    this._dependenciesPerFile.set(file.sourceName, dependencies);\n    // TODO refactor this to make the results deterministic\n    await Promise.all(file.content.imports.map(async imp => {\n      const dependency = await resolver.resolveImport(file, imp);\n      dependencies.add(dependency);\n      await this._addDependenciesFrom(resolver, dependency);\n    }));\n  }\n}\nexports.DependencyGraph = DependencyGraph;","map":{"version":3,"mappings":"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","names":["DependencyGraph","constructor","Map","Set","createFromResolvedFiles","resolver","resolvedFiles","graph","Promise","all","map","resolvedFile","_addDependenciesFrom","getResolvedFiles","Array","from","_resolvedFiles","values","has","file","sourceName","isEmpty","size","entries","_dependenciesPerFile","key","value","get","getDependencies","dependencies","getTransitiveDependencies","visited","transitiveDependencies","_getTransitiveDependencies","getConnectedComponents","undirectedGraph","dependency","add","components","node","Object","keys","component","stack","length","newNode","pop","forEach","adjacent","push","connectedComponents","dependencyGraph","set","path","directDependencies","concat","x","_visitedFiles","absolutePath","content","imports","imp","resolveImport","exports"],"sources":["/Users/janrobel/Documents/PersonalProjekty/nftGenerateAi/clientAndContract/node_modules/hardhat/src/internal/solidity/dependencyGraph.ts"],"sourcesContent":["import * as taskTypes from \"../../types/builtin-tasks\";\n\nimport { ResolvedFile, Resolver } from \"./resolver\";\n\nexport class DependencyGraph implements taskTypes.DependencyGraph {\n  public static async createFromResolvedFiles(\n    resolver: Resolver,\n    resolvedFiles: ResolvedFile[]\n  ): Promise<DependencyGraph> {\n    const graph = new DependencyGraph();\n\n    // TODO refactor this to make the results deterministic\n    await Promise.all(\n      resolvedFiles.map((resolvedFile) =>\n        graph._addDependenciesFrom(resolver, resolvedFile)\n      )\n    );\n\n    return graph;\n  }\n\n  private _resolvedFiles = new Map<string, ResolvedFile>();\n  private _dependenciesPerFile = new Map<string, Set<ResolvedFile>>();\n\n  private readonly _visitedFiles = new Set<string>();\n\n  private constructor() {}\n\n  public getResolvedFiles(): ResolvedFile[] {\n    return Array.from(this._resolvedFiles.values());\n  }\n\n  public has(file: ResolvedFile): boolean {\n    return this._resolvedFiles.has(file.sourceName);\n  }\n\n  public isEmpty(): boolean {\n    return this._resolvedFiles.size === 0;\n  }\n\n  public entries(): Array<[ResolvedFile, Set<ResolvedFile>]> {\n    return Array.from(this._dependenciesPerFile.entries()).map(\n      ([key, value]) => [this._resolvedFiles.get(key)!, value]\n    );\n  }\n\n  public getDependencies(file: ResolvedFile): ResolvedFile[] {\n    const dependencies =\n      this._dependenciesPerFile.get(file.sourceName) ?? new Set();\n\n    return [...dependencies];\n  }\n\n  public getTransitiveDependencies(\n    file: ResolvedFile\n  ): taskTypes.TransitiveDependency[] {\n    const visited = new Set<ResolvedFile>();\n\n    const transitiveDependencies = this._getTransitiveDependencies(\n      file,\n      visited,\n      []\n    );\n\n    return [...transitiveDependencies];\n  }\n\n  public getConnectedComponents(): DependencyGraph[] {\n    const undirectedGraph: Record<string, Set<string>> = {};\n\n    for (const [\n      sourceName,\n      dependencies,\n    ] of this._dependenciesPerFile.entries()) {\n      undirectedGraph[sourceName] = undirectedGraph[sourceName] ?? new Set();\n      for (const dependency of dependencies) {\n        undirectedGraph[dependency.sourceName] =\n          undirectedGraph[dependency.sourceName] ?? new Set();\n        undirectedGraph[sourceName].add(dependency.sourceName);\n        undirectedGraph[dependency.sourceName].add(sourceName);\n      }\n    }\n\n    const components: Array<Set<string>> = [];\n    const visited = new Set<string>();\n\n    for (const node of Object.keys(undirectedGraph)) {\n      if (visited.has(node)) {\n        continue;\n      }\n      visited.add(node);\n      const component = new Set([node]);\n      const stack = [...undirectedGraph[node]];\n      while (stack.length > 0) {\n        const newNode = stack.pop()!;\n        if (visited.has(newNode)) {\n          continue;\n        }\n        visited.add(newNode);\n        component.add(newNode);\n        [...undirectedGraph[newNode]].forEach((adjacent) => {\n          if (!visited.has(adjacent)) {\n            stack.push(adjacent);\n          }\n        });\n      }\n\n      components.push(component);\n    }\n\n    const connectedComponents: DependencyGraph[] = [];\n    for (const component of components) {\n      const dependencyGraph = new DependencyGraph();\n\n      for (const sourceName of component) {\n        const file = this._resolvedFiles.get(sourceName)!;\n        const dependencies = this._dependenciesPerFile.get(sourceName)!;\n\n        dependencyGraph._resolvedFiles.set(sourceName, file);\n        dependencyGraph._dependenciesPerFile.set(sourceName, dependencies);\n      }\n      connectedComponents.push(dependencyGraph);\n    }\n\n    return connectedComponents;\n  }\n\n  private _getTransitiveDependencies(\n    file: ResolvedFile,\n    visited: Set<ResolvedFile>,\n    path: ResolvedFile[]\n  ): Set<taskTypes.TransitiveDependency> {\n    if (visited.has(file)) {\n      return new Set();\n    }\n    visited.add(file);\n\n    const directDependencies: taskTypes.TransitiveDependency[] =\n      this.getDependencies(file).map((dependency) => ({\n        dependency,\n        path,\n      }));\n\n    const transitiveDependencies = new Set<taskTypes.TransitiveDependency>(\n      directDependencies\n    );\n\n    for (const { dependency } of transitiveDependencies) {\n      this._getTransitiveDependencies(\n        dependency,\n        visited,\n        path.concat(dependency)\n      ).forEach((x) => transitiveDependencies.add(x));\n    }\n\n    return transitiveDependencies;\n  }\n\n  private async _addDependenciesFrom(\n    resolver: Resolver,\n    file: ResolvedFile\n  ): Promise<void> {\n    if (this._visitedFiles.has(file.absolutePath)) {\n      return;\n    }\n\n    this._visitedFiles.add(file.absolutePath);\n\n    const dependencies = new Set<ResolvedFile>();\n    this._resolvedFiles.set(file.sourceName, file);\n    this._dependenciesPerFile.set(file.sourceName, dependencies);\n\n    // TODO refactor this to make the results deterministic\n    await Promise.all(\n      file.content.imports.map(async (imp) => {\n        const dependency = await resolver.resolveImport(file, imp);\n        dependencies.add(dependency);\n\n        await this._addDependenciesFrom(resolver, dependency);\n      })\n    );\n  }\n}\n"]},"metadata":{},"sourceType":"script","externalDependencies":[]}