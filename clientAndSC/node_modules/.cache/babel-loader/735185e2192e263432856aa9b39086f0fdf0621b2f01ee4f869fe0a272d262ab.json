{"ast":null,"code":"\"use strict\";\n\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  Object.defineProperty(o, k2, {\n    enumerable: true,\n    get: function () {\n      return m[k];\n    }\n  });\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, \"default\", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o[\"default\"] = v;\n});\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n  __setModuleDefault(result, mod);\n  return result;\n};\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.any = exports.json = exports.inputFile = exports.float = exports.int = exports.boolean = exports.string = void 0;\nconst fs = __importStar(require(\"fs\"));\nconst fs_extra_1 = __importDefault(require(\"fs-extra\"));\nconst errors_1 = require(\"../errors\");\nconst errors_list_1 = require(\"../errors-list\");\n/**\n * String type.\n *\n * Accepts any kind of string.\n */\nexports.string = {\n  name: \"string\",\n  parse: (argName, strValue) => strValue,\n  /**\n   * Check if argument value is of type \"string\"\n   *\n   * @param argName {string} argument's name - used for context in case of error.\n   * @param value {any} argument's value to validate.\n   *\n   * @throws HH301 if value is not of type \"string\"\n   */\n  validate: (argName, value) => {\n    const isString = typeof value === \"string\";\n    if (!isString) {\n      throw new errors_1.HardhatError(errors_list_1.ERRORS.ARGUMENTS.INVALID_VALUE_FOR_TYPE, {\n        value,\n        name: argName,\n        type: exports.string.name\n      });\n    }\n  }\n};\n/**\n * Boolean type.\n *\n * Accepts only 'true' or 'false' (case-insensitive).\n * @throws HH301\n */\nexports.boolean = {\n  name: \"boolean\",\n  parse: (argName, strValue) => {\n    if (strValue.toLowerCase() === \"true\") {\n      return true;\n    }\n    if (strValue.toLowerCase() === \"false\") {\n      return false;\n    }\n    throw new errors_1.HardhatError(errors_list_1.ERRORS.ARGUMENTS.INVALID_VALUE_FOR_TYPE, {\n      value: strValue,\n      name: argName,\n      type: \"boolean\"\n    });\n  },\n  /**\n   * Check if argument value is of type \"boolean\"\n   *\n   * @param argName {string} argument's name - used for context in case of error.\n   * @param value {any} argument's value to validate.\n   *\n   * @throws HH301 if value is not of type \"boolean\"\n   */\n  validate: (argName, value) => {\n    const isBoolean = typeof value === \"boolean\";\n    if (!isBoolean) {\n      throw new errors_1.HardhatError(errors_list_1.ERRORS.ARGUMENTS.INVALID_VALUE_FOR_TYPE, {\n        value,\n        name: argName,\n        type: exports.boolean.name\n      });\n    }\n  }\n};\n/**\n * Int type.\n * Accepts either a decimal string integer or hexadecimal string integer.\n * @throws HH301\n */\nexports.int = {\n  name: \"int\",\n  parse: (argName, strValue) => {\n    const decimalPattern = /^\\d+(?:[eE]\\d+)?$/;\n    const hexPattern = /^0[xX][\\dABCDEabcde]+$/;\n    if (strValue.match(decimalPattern) === null && strValue.match(hexPattern) === null) {\n      throw new errors_1.HardhatError(errors_list_1.ERRORS.ARGUMENTS.INVALID_VALUE_FOR_TYPE, {\n        value: strValue,\n        name: argName,\n        type: exports.int.name\n      });\n    }\n    return Number(strValue);\n  },\n  /**\n   * Check if argument value is of type \"int\"\n   *\n   * @param argName {string} argument's name - used for context in case of error.\n   * @param value {any} argument's value to validate.\n   *\n   * @throws HH301 if value is not of type \"int\"\n   */\n  validate: (argName, value) => {\n    const isInt = Number.isInteger(value);\n    if (!isInt) {\n      throw new errors_1.HardhatError(errors_list_1.ERRORS.ARGUMENTS.INVALID_VALUE_FOR_TYPE, {\n        value,\n        name: argName,\n        type: exports.int.name\n      });\n    }\n  }\n};\n/**\n * Float type.\n * Accepts either a decimal string number or hexadecimal string number.\n * @throws HH301\n */\nexports.float = {\n  name: \"float\",\n  parse: (argName, strValue) => {\n    const decimalPattern = /^(?:\\d+(?:\\.\\d*)?|\\.\\d+)(?:[eE]\\d+)?$/;\n    const hexPattern = /^0[xX][\\dABCDEabcde]+$/;\n    if (strValue.match(decimalPattern) === null && strValue.match(hexPattern) === null) {\n      throw new errors_1.HardhatError(errors_list_1.ERRORS.ARGUMENTS.INVALID_VALUE_FOR_TYPE, {\n        value: strValue,\n        name: argName,\n        type: exports.float.name\n      });\n    }\n    return Number(strValue);\n  },\n  /**\n   * Check if argument value is of type \"float\".\n   * Both decimal and integer number values are valid.\n   *\n   * @param argName {string} argument's name - used for context in case of error.\n   * @param value {any} argument's value to validate.\n   *\n   * @throws HH301 if value is not of type \"number\"\n   */\n  validate: (argName, value) => {\n    const isFloatOrInteger = typeof value === \"number\" && !isNaN(value);\n    if (!isFloatOrInteger) {\n      throw new errors_1.HardhatError(errors_list_1.ERRORS.ARGUMENTS.INVALID_VALUE_FOR_TYPE, {\n        value,\n        name: argName,\n        type: exports.float.name\n      });\n    }\n  }\n};\n/**\n * Input file type.\n * Accepts a path to a readable file..\n * @throws HH302\n */\nexports.inputFile = {\n  name: \"inputFile\",\n  parse(argName, strValue) {\n    try {\n      fs.accessSync(strValue, fs_extra_1.default.constants.R_OK);\n      const stats = fs.lstatSync(strValue);\n      if (stats.isDirectory()) {\n        // This is caught and encapsulated in a hardhat error.\n        // eslint-disable-next-line @nomiclabs/hardhat-internal-rules/only-hardhat-error\n        throw new Error(`${strValue} is a directory, not a file`);\n      }\n    } catch (error) {\n      if (error instanceof Error) {\n        throw new errors_1.HardhatError(errors_list_1.ERRORS.ARGUMENTS.INVALID_INPUT_FILE, {\n          name: argName,\n          value: strValue\n        }, error);\n      }\n      // eslint-disable-next-line @nomiclabs/hardhat-internal-rules/only-hardhat-error\n      throw error;\n    }\n    return strValue;\n  },\n  /**\n   * Check if argument value is of type \"inputFile\"\n   * File string validation succeeds if it can be parsed, ie. is a valid accessible file dir\n   *\n   * @param argName {string} argument's name - used for context in case of error.\n   * @param value {any} argument's value to validate.\n   *\n   * @throws HH301 if value is not of type \"inputFile\"\n   */\n  validate: (argName, value) => {\n    try {\n      exports.inputFile.parse(argName, value);\n    } catch (error) {\n      // the input value is considered invalid, throw error.\n      if (error instanceof Error) {\n        throw new errors_1.HardhatError(errors_list_1.ERRORS.ARGUMENTS.INVALID_VALUE_FOR_TYPE, {\n          value,\n          name: argName,\n          type: exports.inputFile.name\n        }, error);\n      }\n      // eslint-disable-next-line @nomiclabs/hardhat-internal-rules/only-hardhat-error\n      throw error;\n    }\n  }\n};\nexports.json = {\n  name: \"json\",\n  parse(argName, strValue) {\n    try {\n      return JSON.parse(strValue);\n    } catch (error) {\n      if (error instanceof Error) {\n        throw new errors_1.HardhatError(errors_list_1.ERRORS.ARGUMENTS.INVALID_JSON_ARGUMENT, {\n          param: argName,\n          error: error.message\n        }, error);\n      }\n      // eslint-disable-next-line @nomiclabs/hardhat-internal-rules/only-hardhat-error\n      throw error;\n    }\n  },\n  /**\n   * Check if argument value is of type \"json\". We consider everything except\n   * undefined to be json.\n   *\n   * @param argName {string} argument's name - used for context in case of error.\n   * @param value {any} argument's value to validate.\n   *\n   * @throws HH301 if value is not of type \"json\"\n   */\n  validate: (argName, value) => {\n    if (value === undefined) {\n      throw new errors_1.HardhatError(errors_list_1.ERRORS.ARGUMENTS.INVALID_VALUE_FOR_TYPE, {\n        value,\n        name: argName,\n        type: exports.json.name\n      });\n    }\n  }\n};\nexports.any = {\n  name: \"any\",\n  validate(_argName, _argumentValue) {}\n};","map":{"version":3,"mappings":"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","names":["exports","name","parse","argName","strValue","validate","value","isString","errors_1","errors_list_1","ARGUMENTS","INVALID_VALUE_FOR_TYPE","type","toLowerCase","isBoolean","decimalPattern","hexPattern","match","Number","isInt","isInteger","isFloatOrInteger","isNaN","fs","accessSync","fs_extra_1","constants","R_OK","stats","lstatSync","isDirectory","Error","error","INVALID_INPUT_FILE","JSON","INVALID_JSON_ARGUMENT","param","message","undefined","_argName","_argumentValue"],"sources":["/Users/janrobel/Documents/PersonalProjekty/nftGenerateAi/clientAndContract/node_modules/hardhat/src/internal/core/params/argumentTypes.ts"],"sourcesContent":["import * as fs from \"fs\";\nimport fsExtra from \"fs-extra\";\n\nimport { ArgumentType, CLIArgumentType } from \"../../../types\";\nimport { HardhatError } from \"../errors\";\nimport { ERRORS } from \"../errors-list\";\n\n/**\n * String type.\n *\n * Accepts any kind of string.\n */\nexport const string: CLIArgumentType<string> = {\n  name: \"string\",\n  parse: (argName, strValue) => strValue,\n  /**\n   * Check if argument value is of type \"string\"\n   *\n   * @param argName {string} argument's name - used for context in case of error.\n   * @param value {any} argument's value to validate.\n   *\n   * @throws HH301 if value is not of type \"string\"\n   */\n  validate: (argName: string, value: any): void => {\n    const isString = typeof value === \"string\";\n\n    if (!isString) {\n      throw new HardhatError(ERRORS.ARGUMENTS.INVALID_VALUE_FOR_TYPE, {\n        value,\n        name: argName,\n        type: string.name,\n      });\n    }\n  },\n};\n\n/**\n * Boolean type.\n *\n * Accepts only 'true' or 'false' (case-insensitive).\n * @throws HH301\n */\nexport const boolean: CLIArgumentType<boolean> = {\n  name: \"boolean\",\n  parse: (argName, strValue) => {\n    if (strValue.toLowerCase() === \"true\") {\n      return true;\n    }\n    if (strValue.toLowerCase() === \"false\") {\n      return false;\n    }\n\n    throw new HardhatError(ERRORS.ARGUMENTS.INVALID_VALUE_FOR_TYPE, {\n      value: strValue,\n      name: argName,\n      type: \"boolean\",\n    });\n  },\n  /**\n   * Check if argument value is of type \"boolean\"\n   *\n   * @param argName {string} argument's name - used for context in case of error.\n   * @param value {any} argument's value to validate.\n   *\n   * @throws HH301 if value is not of type \"boolean\"\n   */\n  validate: (argName: string, value: any): void => {\n    const isBoolean = typeof value === \"boolean\";\n\n    if (!isBoolean) {\n      throw new HardhatError(ERRORS.ARGUMENTS.INVALID_VALUE_FOR_TYPE, {\n        value,\n        name: argName,\n        type: boolean.name,\n      });\n    }\n  },\n};\n\n/**\n * Int type.\n * Accepts either a decimal string integer or hexadecimal string integer.\n * @throws HH301\n */\nexport const int: CLIArgumentType<number> = {\n  name: \"int\",\n  parse: (argName, strValue) => {\n    const decimalPattern = /^\\d+(?:[eE]\\d+)?$/;\n    const hexPattern = /^0[xX][\\dABCDEabcde]+$/;\n\n    if (\n      strValue.match(decimalPattern) === null &&\n      strValue.match(hexPattern) === null\n    ) {\n      throw new HardhatError(ERRORS.ARGUMENTS.INVALID_VALUE_FOR_TYPE, {\n        value: strValue,\n        name: argName,\n        type: int.name,\n      });\n    }\n\n    return Number(strValue);\n  },\n  /**\n   * Check if argument value is of type \"int\"\n   *\n   * @param argName {string} argument's name - used for context in case of error.\n   * @param value {any} argument's value to validate.\n   *\n   * @throws HH301 if value is not of type \"int\"\n   */\n  validate: (argName: string, value: any): void => {\n    const isInt = Number.isInteger(value);\n    if (!isInt) {\n      throw new HardhatError(ERRORS.ARGUMENTS.INVALID_VALUE_FOR_TYPE, {\n        value,\n        name: argName,\n        type: int.name,\n      });\n    }\n  },\n};\n\n/**\n * Float type.\n * Accepts either a decimal string number or hexadecimal string number.\n * @throws HH301\n */\nexport const float: CLIArgumentType<number> = {\n  name: \"float\",\n  parse: (argName, strValue) => {\n    const decimalPattern = /^(?:\\d+(?:\\.\\d*)?|\\.\\d+)(?:[eE]\\d+)?$/;\n    const hexPattern = /^0[xX][\\dABCDEabcde]+$/;\n\n    if (\n      strValue.match(decimalPattern) === null &&\n      strValue.match(hexPattern) === null\n    ) {\n      throw new HardhatError(ERRORS.ARGUMENTS.INVALID_VALUE_FOR_TYPE, {\n        value: strValue,\n        name: argName,\n        type: float.name,\n      });\n    }\n\n    return Number(strValue);\n  },\n  /**\n   * Check if argument value is of type \"float\".\n   * Both decimal and integer number values are valid.\n   *\n   * @param argName {string} argument's name - used for context in case of error.\n   * @param value {any} argument's value to validate.\n   *\n   * @throws HH301 if value is not of type \"number\"\n   */\n  validate: (argName: string, value: any): void => {\n    const isFloatOrInteger = typeof value === \"number\" && !isNaN(value);\n\n    if (!isFloatOrInteger) {\n      throw new HardhatError(ERRORS.ARGUMENTS.INVALID_VALUE_FOR_TYPE, {\n        value,\n        name: argName,\n        type: float.name,\n      });\n    }\n  },\n};\n\n/**\n * Input file type.\n * Accepts a path to a readable file..\n * @throws HH302\n */\nexport const inputFile: CLIArgumentType<string> = {\n  name: \"inputFile\",\n  parse(argName: string, strValue: string): string {\n    try {\n      fs.accessSync(strValue, fsExtra.constants.R_OK);\n      const stats = fs.lstatSync(strValue);\n\n      if (stats.isDirectory()) {\n        // This is caught and encapsulated in a hardhat error.\n        // eslint-disable-next-line @nomiclabs/hardhat-internal-rules/only-hardhat-error\n        throw new Error(`${strValue} is a directory, not a file`);\n      }\n    } catch (error) {\n      if (error instanceof Error) {\n        throw new HardhatError(\n          ERRORS.ARGUMENTS.INVALID_INPUT_FILE,\n          {\n            name: argName,\n            value: strValue,\n          },\n          error\n        );\n      }\n\n      // eslint-disable-next-line @nomiclabs/hardhat-internal-rules/only-hardhat-error\n      throw error;\n    }\n\n    return strValue;\n  },\n\n  /**\n   * Check if argument value is of type \"inputFile\"\n   * File string validation succeeds if it can be parsed, ie. is a valid accessible file dir\n   *\n   * @param argName {string} argument's name - used for context in case of error.\n   * @param value {any} argument's value to validate.\n   *\n   * @throws HH301 if value is not of type \"inputFile\"\n   */\n  validate: (argName: string, value: any): void => {\n    try {\n      inputFile.parse(argName, value);\n    } catch (error) {\n      // the input value is considered invalid, throw error.\n      if (error instanceof Error) {\n        throw new HardhatError(\n          ERRORS.ARGUMENTS.INVALID_VALUE_FOR_TYPE,\n          {\n            value,\n            name: argName,\n            type: inputFile.name,\n          },\n          error\n        );\n      }\n\n      // eslint-disable-next-line @nomiclabs/hardhat-internal-rules/only-hardhat-error\n      throw error;\n    }\n  },\n};\n\nexport const json: CLIArgumentType<any> = {\n  name: \"json\",\n  parse(argName: string, strValue: string): any {\n    try {\n      return JSON.parse(strValue);\n    } catch (error) {\n      if (error instanceof Error) {\n        throw new HardhatError(\n          ERRORS.ARGUMENTS.INVALID_JSON_ARGUMENT,\n          {\n            param: argName,\n            error: error.message,\n          },\n          error\n        );\n      }\n\n      // eslint-disable-next-line @nomiclabs/hardhat-internal-rules/only-hardhat-error\n      throw error;\n    }\n  },\n\n  /**\n   * Check if argument value is of type \"json\". We consider everything except\n   * undefined to be json.\n   *\n   * @param argName {string} argument's name - used for context in case of error.\n   * @param value {any} argument's value to validate.\n   *\n   * @throws HH301 if value is not of type \"json\"\n   */\n  validate: (argName: string, value: any): void => {\n    if (value === undefined) {\n      throw new HardhatError(ERRORS.ARGUMENTS.INVALID_VALUE_FOR_TYPE, {\n        value,\n        name: argName,\n        type: json.name,\n      });\n    }\n  },\n};\n\nexport const any: ArgumentType<any> = {\n  name: \"any\",\n  validate(_argName: string, _argumentValue: any) {},\n};\n"]},"metadata":{},"sourceType":"script","externalDependencies":[]}