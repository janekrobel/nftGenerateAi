{"ast":null,"code":"// Ported from https://github.com/nodejs/undici/pull/907\n\n'use strict';\n\nconst assert = require('assert');\nconst {\n  Readable\n} = require('stream');\nconst {\n  RequestAbortedError,\n  NotSupportedError\n} = require('../core/errors');\nconst util = require('../core/util');\nconst {\n  ReadableStreamFrom,\n  toUSVString\n} = require('../core/util');\nlet Blob;\nconst kConsume = Symbol('kConsume');\nconst kReading = Symbol('kReading');\nconst kBody = Symbol('kBody');\nconst kAbort = Symbol('abort');\nconst kContentType = Symbol('kContentType');\nmodule.exports = class BodyReadable extends Readable {\n  constructor(resume, abort) {\n    let contentType = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : '';\n    super({\n      autoDestroy: true,\n      read: resume,\n      highWaterMark: 64 * 1024 // Same as nodejs fs streams.\n    });\n\n    this._readableState.dataEmitted = false;\n    this[kAbort] = abort;\n    this[kConsume] = null;\n    this[kBody] = null;\n    this[kContentType] = contentType;\n\n    // Is stream being consumed through Readable API?\n    // This is an optimization so that we avoid checking\n    // for 'data' and 'readable' listeners in the hot path\n    // inside push().\n    this[kReading] = false;\n  }\n  destroy(err) {\n    if (this.destroyed) {\n      // Node < 16\n      return this;\n    }\n    if (!err && !this._readableState.endEmitted) {\n      err = new RequestAbortedError();\n    }\n    if (err) {\n      this[kAbort]();\n    }\n    return super.destroy(err);\n  }\n  emit(ev) {\n    if (ev === 'data') {\n      // Node < 16.7\n      this._readableState.dataEmitted = true;\n    } else if (ev === 'error') {\n      // Node < 16\n      this._readableState.errorEmitted = true;\n    }\n    for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n      args[_key - 1] = arguments[_key];\n    }\n    return super.emit(ev, ...args);\n  }\n  on(ev) {\n    if (ev === 'data' || ev === 'readable') {\n      this[kReading] = true;\n    }\n    for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {\n      args[_key2 - 1] = arguments[_key2];\n    }\n    return super.on(ev, ...args);\n  }\n  addListener(ev) {\n    for (var _len3 = arguments.length, args = new Array(_len3 > 1 ? _len3 - 1 : 0), _key3 = 1; _key3 < _len3; _key3++) {\n      args[_key3 - 1] = arguments[_key3];\n    }\n    return this.on(ev, ...args);\n  }\n  off(ev) {\n    for (var _len4 = arguments.length, args = new Array(_len4 > 1 ? _len4 - 1 : 0), _key4 = 1; _key4 < _len4; _key4++) {\n      args[_key4 - 1] = arguments[_key4];\n    }\n    const ret = super.off(ev, ...args);\n    if (ev === 'data' || ev === 'readable') {\n      this[kReading] = this.listenerCount('data') > 0 || this.listenerCount('readable') > 0;\n    }\n    return ret;\n  }\n  removeListener(ev) {\n    for (var _len5 = arguments.length, args = new Array(_len5 > 1 ? _len5 - 1 : 0), _key5 = 1; _key5 < _len5; _key5++) {\n      args[_key5 - 1] = arguments[_key5];\n    }\n    return this.off(ev, ...args);\n  }\n  push(chunk) {\n    if (this[kConsume] && chunk !== null && this.readableLength === 0) {\n      consumePush(this[kConsume], chunk);\n      return this[kReading] ? super.push(chunk) : true;\n    }\n    return super.push(chunk);\n  }\n\n  // https://fetch.spec.whatwg.org/#dom-body-text\n  async text() {\n    return consume(this, 'text');\n  }\n\n  // https://fetch.spec.whatwg.org/#dom-body-json\n  async json() {\n    return consume(this, 'json');\n  }\n\n  // https://fetch.spec.whatwg.org/#dom-body-blob\n  async blob() {\n    return consume(this, 'blob');\n  }\n\n  // https://fetch.spec.whatwg.org/#dom-body-arraybuffer\n  async arrayBuffer() {\n    return consume(this, 'arrayBuffer');\n  }\n\n  // https://fetch.spec.whatwg.org/#dom-body-formdata\n  async formData() {\n    // TODO: Implement.\n    throw new NotSupportedError();\n  }\n\n  // https://fetch.spec.whatwg.org/#dom-body-bodyused\n  get bodyUsed() {\n    return util.isDisturbed(this);\n  }\n\n  // https://fetch.spec.whatwg.org/#dom-body-body\n  get body() {\n    if (!this[kBody]) {\n      this[kBody] = ReadableStreamFrom(this);\n      if (this[kConsume]) {\n        // TODO: Is this the best way to force a lock?\n        this[kBody].getReader(); // Ensure stream is locked.\n        assert(this[kBody].locked);\n      }\n    }\n    return this[kBody];\n  }\n  async dump(opts) {\n    let limit = opts && Number.isFinite(opts.limit) ? opts.limit : 262144;\n    try {\n      for await (const chunk of this) {\n        limit -= Buffer.byteLength(chunk);\n        if (limit < 0) {\n          return;\n        }\n      }\n    } catch {\n      // Do nothing...\n    }\n  }\n};\n\n// https://streams.spec.whatwg.org/#readablestream-locked\nfunction isLocked(self) {\n  // Consume is an implicit lock.\n  return self[kBody] && self[kBody].locked === true || self[kConsume];\n}\n\n// https://fetch.spec.whatwg.org/#body-unusable\nfunction isUnusable(self) {\n  return util.isDisturbed(self) || isLocked(self);\n}\nasync function consume(stream, type) {\n  if (isUnusable(stream)) {\n    throw new TypeError('unusable');\n  }\n  assert(!stream[kConsume]);\n  return new Promise((resolve, reject) => {\n    stream[kConsume] = {\n      type,\n      stream,\n      resolve,\n      reject,\n      length: 0,\n      body: []\n    };\n    stream.on('error', function (err) {\n      consumeFinish(this[kConsume], err);\n    }).on('close', function () {\n      if (this[kConsume].body !== null) {\n        consumeFinish(this[kConsume], new RequestAbortedError());\n      }\n    });\n    process.nextTick(consumeStart, stream[kConsume]);\n  });\n}\nfunction consumeStart(consume) {\n  if (consume.body === null) {\n    return;\n  }\n  const {\n    _readableState: state\n  } = consume.stream;\n  for (const chunk of state.buffer) {\n    consumePush(consume, chunk);\n  }\n  if (state.endEmitted) {\n    consumeEnd(this[kConsume]);\n  } else {\n    consume.stream.on('end', function () {\n      consumeEnd(this[kConsume]);\n    });\n  }\n  consume.stream.resume();\n  while (consume.stream.read() != null) {\n    // Loop\n  }\n}\nfunction consumeEnd(consume) {\n  const {\n    type,\n    body,\n    resolve,\n    stream,\n    length\n  } = consume;\n  try {\n    if (type === 'text') {\n      resolve(toUSVString(Buffer.concat(body)));\n    } else if (type === 'json') {\n      resolve(JSON.parse(Buffer.concat(body)));\n    } else if (type === 'arrayBuffer') {\n      const dst = new Uint8Array(length);\n      let pos = 0;\n      for (const buf of body) {\n        dst.set(buf, pos);\n        pos += buf.byteLength;\n      }\n      resolve(dst);\n    } else if (type === 'blob') {\n      if (!Blob) {\n        Blob = require('buffer').Blob;\n      }\n      resolve(new Blob(body, {\n        type: stream[kContentType]\n      }));\n    }\n    consumeFinish(consume);\n  } catch (err) {\n    stream.destroy(err);\n  }\n}\nfunction consumePush(consume, chunk) {\n  consume.length += chunk.length;\n  consume.body.push(chunk);\n}\nfunction consumeFinish(consume, err) {\n  if (consume.body === null) {\n    return;\n  }\n  if (err) {\n    consume.reject(err);\n  } else {\n    consume.resolve();\n  }\n  consume.type = null;\n  consume.stream = null;\n  consume.resolve = null;\n  consume.reject = null;\n  consume.length = 0;\n  consume.body = null;\n}","map":{"version":3,"names":["assert","require","Readable","RequestAbortedError","NotSupportedError","util","ReadableStreamFrom","toUSVString","Blob","kConsume","Symbol","kReading","kBody","kAbort","kContentType","module","exports","BodyReadable","constructor","resume","abort","contentType","autoDestroy","read","highWaterMark","_readableState","dataEmitted","destroy","err","destroyed","endEmitted","emit","ev","errorEmitted","args","on","addListener","off","ret","listenerCount","removeListener","push","chunk","readableLength","consumePush","text","consume","json","blob","arrayBuffer","formData","bodyUsed","isDisturbed","body","getReader","locked","dump","opts","limit","Number","isFinite","Buffer","byteLength","isLocked","self","isUnusable","stream","type","TypeError","Promise","resolve","reject","length","consumeFinish","process","nextTick","consumeStart","state","buffer","consumeEnd","concat","JSON","parse","dst","Uint8Array","pos","buf","set"],"sources":["/Users/janrobel/Documents/PersonalProjekty/nftGenerateAi/clientAndContract/node_modules/undici/lib/api/readable.js"],"sourcesContent":["// Ported from https://github.com/nodejs/undici/pull/907\n\n'use strict'\n\nconst assert = require('assert')\nconst { Readable } = require('stream')\nconst { RequestAbortedError, NotSupportedError } = require('../core/errors')\nconst util = require('../core/util')\nconst { ReadableStreamFrom, toUSVString } = require('../core/util')\n\nlet Blob\n\nconst kConsume = Symbol('kConsume')\nconst kReading = Symbol('kReading')\nconst kBody = Symbol('kBody')\nconst kAbort = Symbol('abort')\nconst kContentType = Symbol('kContentType')\n\nmodule.exports = class BodyReadable extends Readable {\n  constructor (resume, abort, contentType = '') {\n    super({\n      autoDestroy: true,\n      read: resume,\n      highWaterMark: 64 * 1024 // Same as nodejs fs streams.\n    })\n\n    this._readableState.dataEmitted = false\n\n    this[kAbort] = abort\n    this[kConsume] = null\n    this[kBody] = null\n    this[kContentType] = contentType\n\n    // Is stream being consumed through Readable API?\n    // This is an optimization so that we avoid checking\n    // for 'data' and 'readable' listeners in the hot path\n    // inside push().\n    this[kReading] = false\n  }\n\n  destroy (err) {\n    if (this.destroyed) {\n      // Node < 16\n      return this\n    }\n\n    if (!err && !this._readableState.endEmitted) {\n      err = new RequestAbortedError()\n    }\n\n    if (err) {\n      this[kAbort]()\n    }\n\n    return super.destroy(err)\n  }\n\n  emit (ev, ...args) {\n    if (ev === 'data') {\n      // Node < 16.7\n      this._readableState.dataEmitted = true\n    } else if (ev === 'error') {\n      // Node < 16\n      this._readableState.errorEmitted = true\n    }\n    return super.emit(ev, ...args)\n  }\n\n  on (ev, ...args) {\n    if (ev === 'data' || ev === 'readable') {\n      this[kReading] = true\n    }\n    return super.on(ev, ...args)\n  }\n\n  addListener (ev, ...args) {\n    return this.on(ev, ...args)\n  }\n\n  off (ev, ...args) {\n    const ret = super.off(ev, ...args)\n    if (ev === 'data' || ev === 'readable') {\n      this[kReading] = (\n        this.listenerCount('data') > 0 ||\n        this.listenerCount('readable') > 0\n      )\n    }\n    return ret\n  }\n\n  removeListener (ev, ...args) {\n    return this.off(ev, ...args)\n  }\n\n  push (chunk) {\n    if (this[kConsume] && chunk !== null && this.readableLength === 0) {\n      consumePush(this[kConsume], chunk)\n      return this[kReading] ? super.push(chunk) : true\n    }\n    return super.push(chunk)\n  }\n\n  // https://fetch.spec.whatwg.org/#dom-body-text\n  async text () {\n    return consume(this, 'text')\n  }\n\n  // https://fetch.spec.whatwg.org/#dom-body-json\n  async json () {\n    return consume(this, 'json')\n  }\n\n  // https://fetch.spec.whatwg.org/#dom-body-blob\n  async blob () {\n    return consume(this, 'blob')\n  }\n\n  // https://fetch.spec.whatwg.org/#dom-body-arraybuffer\n  async arrayBuffer () {\n    return consume(this, 'arrayBuffer')\n  }\n\n  // https://fetch.spec.whatwg.org/#dom-body-formdata\n  async formData () {\n    // TODO: Implement.\n    throw new NotSupportedError()\n  }\n\n  // https://fetch.spec.whatwg.org/#dom-body-bodyused\n  get bodyUsed () {\n    return util.isDisturbed(this)\n  }\n\n  // https://fetch.spec.whatwg.org/#dom-body-body\n  get body () {\n    if (!this[kBody]) {\n      this[kBody] = ReadableStreamFrom(this)\n      if (this[kConsume]) {\n        // TODO: Is this the best way to force a lock?\n        this[kBody].getReader() // Ensure stream is locked.\n        assert(this[kBody].locked)\n      }\n    }\n    return this[kBody]\n  }\n\n  async dump (opts) {\n    let limit = opts && Number.isFinite(opts.limit) ? opts.limit : 262144\n    try {\n      for await (const chunk of this) {\n        limit -= Buffer.byteLength(chunk)\n        if (limit < 0) {\n          return\n        }\n      }\n    } catch {\n      // Do nothing...\n    }\n  }\n}\n\n// https://streams.spec.whatwg.org/#readablestream-locked\nfunction isLocked (self) {\n  // Consume is an implicit lock.\n  return (self[kBody] && self[kBody].locked === true) || self[kConsume]\n}\n\n// https://fetch.spec.whatwg.org/#body-unusable\nfunction isUnusable (self) {\n  return util.isDisturbed(self) || isLocked(self)\n}\n\nasync function consume (stream, type) {\n  if (isUnusable(stream)) {\n    throw new TypeError('unusable')\n  }\n\n  assert(!stream[kConsume])\n\n  return new Promise((resolve, reject) => {\n    stream[kConsume] = {\n      type,\n      stream,\n      resolve,\n      reject,\n      length: 0,\n      body: []\n    }\n\n    stream\n      .on('error', function (err) {\n        consumeFinish(this[kConsume], err)\n      })\n      .on('close', function () {\n        if (this[kConsume].body !== null) {\n          consumeFinish(this[kConsume], new RequestAbortedError())\n        }\n      })\n\n    process.nextTick(consumeStart, stream[kConsume])\n  })\n}\n\nfunction consumeStart (consume) {\n  if (consume.body === null) {\n    return\n  }\n\n  const { _readableState: state } = consume.stream\n\n  for (const chunk of state.buffer) {\n    consumePush(consume, chunk)\n  }\n\n  if (state.endEmitted) {\n    consumeEnd(this[kConsume])\n  } else {\n    consume.stream.on('end', function () {\n      consumeEnd(this[kConsume])\n    })\n  }\n\n  consume.stream.resume()\n\n  while (consume.stream.read() != null) {\n    // Loop\n  }\n}\n\nfunction consumeEnd (consume) {\n  const { type, body, resolve, stream, length } = consume\n\n  try {\n    if (type === 'text') {\n      resolve(toUSVString(Buffer.concat(body)))\n    } else if (type === 'json') {\n      resolve(JSON.parse(Buffer.concat(body)))\n    } else if (type === 'arrayBuffer') {\n      const dst = new Uint8Array(length)\n\n      let pos = 0\n      for (const buf of body) {\n        dst.set(buf, pos)\n        pos += buf.byteLength\n      }\n\n      resolve(dst)\n    } else if (type === 'blob') {\n      if (!Blob) {\n        Blob = require('buffer').Blob\n      }\n      resolve(new Blob(body, { type: stream[kContentType] }))\n    }\n\n    consumeFinish(consume)\n  } catch (err) {\n    stream.destroy(err)\n  }\n}\n\nfunction consumePush (consume, chunk) {\n  consume.length += chunk.length\n  consume.body.push(chunk)\n}\n\nfunction consumeFinish (consume, err) {\n  if (consume.body === null) {\n    return\n  }\n\n  if (err) {\n    consume.reject(err)\n  } else {\n    consume.resolve()\n  }\n\n  consume.type = null\n  consume.stream = null\n  consume.resolve = null\n  consume.reject = null\n  consume.length = 0\n  consume.body = null\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}