{"ast":null,"code":"\"use strict\";\n\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  Object.defineProperty(o, k2, {\n    enumerable: true,\n    get: function () {\n      return m[k];\n    }\n  });\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, \"default\", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o[\"default\"] = v;\n});\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n  __setModuleDefault(result, mod);\n  return result;\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.AbiHelpers = void 0;\nconst abi = __importStar(require(\"@ethersproject/abi\"));\nclass AbiHelpers {\n  /**\n   * Try to compute the selector for the function/event/error\n   * with the given name and param types. Return undefined\n   * if it cannot do it. This can happen if some ParamType is\n   * not understood by @ethersproject/abi\n   */\n  static computeSelector(name, inputs) {\n    try {\n      const fragment = abi.FunctionFragment.from({\n        type: \"function\",\n        constant: true,\n        name,\n        inputs: inputs.map(i => abi.ParamType.from(i))\n      });\n      const selectorHex = abi.Interface.getSighash(fragment);\n      return Buffer.from(selectorHex.slice(2), \"hex\");\n    } catch {\n      return;\n    }\n  }\n  static formatValues(values) {\n    return values.map(x => AbiHelpers._formatValue(x)).join(\", \");\n  }\n  static _formatValue(value) {\n    // print nested values as [value1, value2, ...]\n    if (Array.isArray(value)) {\n      return `[${value.map(v => AbiHelpers._formatValue(v)).join(\", \")}]`;\n    }\n    // surround string values with quotes\n    if (typeof value === \"string\") {\n      return `\"${value}\"`;\n    }\n    return value.toString();\n  }\n}\nexports.AbiHelpers = AbiHelpers;","map":{"version":3,"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;AAEA,MAAaA,UAAU;EACrB;;;;;;EAMO,OAAOC,eAAe,CAC3BC,IAAY,EACZC,MAAa;IAEb,IAAI;MACF,MAAMC,QAAQ,GAAGC,GAAG,CAACC,gBAAgB,CAACC,IAAI,CAAC;QACzCC,IAAI,EAAE,UAAU;QAChBC,QAAQ,EAAE,IAAI;QACdP,IAAI;QACJC,MAAM,EAAEA,MAAM,CAACO,GAAG,CAAEC,CAAC,IAAKN,GAAG,CAACO,SAAS,CAACL,IAAI,CAACI,CAAC,CAAC;OAChD,CAAC;MACF,MAAME,WAAW,GAAGR,GAAG,CAACS,SAAS,CAACC,UAAU,CAACX,QAAQ,CAAC;MAEtD,OAAOY,MAAM,CAACT,IAAI,CAACM,WAAW,CAACI,KAAK,CAAC,CAAC,CAAC,EAAE,KAAK,CAAC;KAChD,CAAC,MAAM;MACN;;EAEJ;EAEO,OAAOC,YAAY,CAACC,MAAa;IACtC,OAAOA,MAAM,CAACT,GAAG,CAAEU,CAAC,IAAKpB,UAAU,CAACqB,YAAY,CAACD,CAAC,CAAC,CAAC,CAACE,IAAI,CAAC,IAAI,CAAC;EACjE;EAEQ,OAAOD,YAAY,CAACE,KAAU;IACpC;IACA,IAAIC,KAAK,CAACC,OAAO,CAACF,KAAK,CAAC,EAAE;MACxB,OAAO,IAAIA,KAAK,CAACb,GAAG,CAAEgB,CAAC,IAAK1B,UAAU,CAACqB,YAAY,CAACK,CAAC,CAAC,CAAC,CAACJ,IAAI,CAAC,IAAI,CAAC,GAAG;;IAGvE;IACA,IAAI,OAAOC,KAAK,KAAK,QAAQ,EAAE;MAC7B,OAAO,IAAIA,KAAK,GAAG;;IAGrB,OAAOA,KAAK,CAACI,QAAQ,EAAE;EACzB;;AA1CFC","names":["AbiHelpers","computeSelector","name","inputs","fragment","abi","FunctionFragment","from","type","constant","map","i","ParamType","selectorHex","Interface","getSighash","Buffer","slice","formatValues","values","x","_formatValue","join","value","Array","isArray","v","toString","exports"],"sources":["/Users/janrobel/Documents/PersonalProjekty/nftGenerateAi/clientAndContract/node_modules/hardhat/src/internal/util/abi-helpers.ts"],"sourcesContent":["import * as abi from \"@ethersproject/abi\";\n\nexport class AbiHelpers {\n  /**\n   * Try to compute the selector for the function/event/error\n   * with the given name and param types. Return undefined\n   * if it cannot do it. This can happen if some ParamType is\n   * not understood by @ethersproject/abi\n   */\n  public static computeSelector(\n    name: string,\n    inputs: any[]\n  ): Buffer | undefined {\n    try {\n      const fragment = abi.FunctionFragment.from({\n        type: \"function\",\n        constant: true,\n        name,\n        inputs: inputs.map((i) => abi.ParamType.from(i)),\n      });\n      const selectorHex = abi.Interface.getSighash(fragment);\n\n      return Buffer.from(selectorHex.slice(2), \"hex\");\n    } catch {\n      return;\n    }\n  }\n\n  public static formatValues(values: any[]): string {\n    return values.map((x) => AbiHelpers._formatValue(x)).join(\", \");\n  }\n\n  private static _formatValue(value: any): string {\n    // print nested values as [value1, value2, ...]\n    if (Array.isArray(value)) {\n      return `[${value.map((v) => AbiHelpers._formatValue(v)).join(\", \")}]`;\n    }\n\n    // surround string values with quotes\n    if (typeof value === \"string\") {\n      return `\"${value}\"`;\n    }\n\n    return value.toString();\n  }\n}\n"]},"metadata":{},"sourceType":"script","externalDependencies":[]}