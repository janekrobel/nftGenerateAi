{"ast":null,"code":"'use strict';\n\nconst {\n  finished\n} = require('stream');\nconst {\n  InvalidArgumentError,\n  InvalidReturnValueError,\n  RequestAbortedError\n} = require('../core/errors');\nconst util = require('../core/util');\nconst {\n  AsyncResource\n} = require('async_hooks');\nconst {\n  addSignal,\n  removeSignal\n} = require('./abort-signal');\nclass StreamHandler extends AsyncResource {\n  constructor(opts, factory, callback) {\n    if (!opts || typeof opts !== 'object') {\n      throw new InvalidArgumentError('invalid opts');\n    }\n    const {\n      signal,\n      method,\n      opaque,\n      body,\n      onInfo,\n      responseHeaders\n    } = opts;\n    try {\n      if (typeof callback !== 'function') {\n        throw new InvalidArgumentError('invalid callback');\n      }\n      if (typeof factory !== 'function') {\n        throw new InvalidArgumentError('invalid factory');\n      }\n      if (signal && typeof signal.on !== 'function' && typeof signal.addEventListener !== 'function') {\n        throw new InvalidArgumentError('signal must be an EventEmitter or EventTarget');\n      }\n      if (method === 'CONNECT') {\n        throw new InvalidArgumentError('invalid method');\n      }\n      if (onInfo && typeof onInfo !== 'function') {\n        throw new InvalidArgumentError('invalid onInfo callback');\n      }\n      super('UNDICI_STREAM');\n    } catch (err) {\n      if (util.isStream(body)) {\n        util.destroy(body.on('error', util.nop), err);\n      }\n      throw err;\n    }\n    this.responseHeaders = responseHeaders || null;\n    this.opaque = opaque || null;\n    this.factory = factory;\n    this.callback = callback;\n    this.res = null;\n    this.abort = null;\n    this.context = null;\n    this.trailers = null;\n    this.body = body;\n    this.onInfo = onInfo || null;\n    if (util.isStream(body)) {\n      body.on('error', err => {\n        this.onError(err);\n      });\n    }\n    addSignal(this, signal);\n  }\n  onConnect(abort, context) {\n    if (!this.callback) {\n      throw new RequestAbortedError();\n    }\n    this.abort = abort;\n    this.context = context;\n  }\n  onHeaders(statusCode, rawHeaders, resume) {\n    const {\n      factory,\n      opaque,\n      context\n    } = this;\n    if (statusCode < 200) {\n      if (this.onInfo) {\n        const headers = this.responseHeaders === 'raw' ? util.parseRawHeaders(rawHeaders) : util.parseHeaders(rawHeaders);\n        this.onInfo({\n          statusCode,\n          headers\n        });\n      }\n      return;\n    }\n    this.factory = null;\n    const headers = this.responseHeaders === 'raw' ? util.parseRawHeaders(rawHeaders) : util.parseHeaders(rawHeaders);\n    const res = this.runInAsyncScope(factory, null, {\n      statusCode,\n      headers,\n      opaque,\n      context\n    });\n    if (!res || typeof res.write !== 'function' || typeof res.end !== 'function' || typeof res.on !== 'function') {\n      throw new InvalidReturnValueError('expected Writable');\n    }\n    res.on('drain', resume);\n    // TODO: Avoid finished. It registers an unnecessary amount of listeners.\n    finished(res, {\n      readable: false\n    }, err => {\n      const {\n        callback,\n        res,\n        opaque,\n        trailers,\n        abort\n      } = this;\n      this.res = null;\n      if (err || !res.readable) {\n        util.destroy(res, err);\n      }\n      this.callback = null;\n      this.runInAsyncScope(callback, null, err || null, {\n        opaque,\n        trailers\n      });\n      if (err) {\n        abort();\n      }\n    });\n    this.res = res;\n    const needDrain = res.writableNeedDrain !== undefined ? res.writableNeedDrain : res._writableState && res._writableState.needDrain;\n    return needDrain !== true;\n  }\n  onData(chunk) {\n    const {\n      res\n    } = this;\n    return res.write(chunk);\n  }\n  onComplete(trailers) {\n    const {\n      res\n    } = this;\n    removeSignal(this);\n    this.trailers = util.parseHeaders(trailers);\n    res.end();\n  }\n  onError(err) {\n    const {\n      res,\n      callback,\n      opaque,\n      body\n    } = this;\n    removeSignal(this);\n    this.factory = null;\n    if (res) {\n      this.res = null;\n      util.destroy(res, err);\n    } else if (callback) {\n      this.callback = null;\n      queueMicrotask(() => {\n        this.runInAsyncScope(callback, null, err, {\n          opaque\n        });\n      });\n    }\n    if (body) {\n      this.body = null;\n      util.destroy(body, err);\n    }\n  }\n}\nfunction stream(opts, factory, callback) {\n  if (callback === undefined) {\n    return new Promise((resolve, reject) => {\n      stream.call(this, opts, factory, (err, data) => {\n        return err ? reject(err) : resolve(data);\n      });\n    });\n  }\n  try {\n    this.dispatch(opts, new StreamHandler(opts, factory, callback));\n  } catch (err) {\n    if (typeof callback !== 'function') {\n      throw err;\n    }\n    const opaque = opts && opts.opaque;\n    queueMicrotask(() => callback(err, {\n      opaque\n    }));\n  }\n}\nmodule.exports = stream;","map":{"version":3,"names":["finished","require","InvalidArgumentError","InvalidReturnValueError","RequestAbortedError","util","AsyncResource","addSignal","removeSignal","StreamHandler","constructor","opts","factory","callback","signal","method","opaque","body","onInfo","responseHeaders","on","addEventListener","err","isStream","destroy","nop","res","abort","context","trailers","onError","onConnect","onHeaders","statusCode","rawHeaders","resume","headers","parseRawHeaders","parseHeaders","runInAsyncScope","write","end","readable","needDrain","writableNeedDrain","undefined","_writableState","onData","chunk","onComplete","queueMicrotask","stream","Promise","resolve","reject","call","data","dispatch","module","exports"],"sources":["/Users/janrobel/Documents/PersonalProjekty/nftGenerateAi/clientAndContract/node_modules/undici/lib/api/api-stream.js"],"sourcesContent":["'use strict'\n\nconst { finished } = require('stream')\nconst {\n  InvalidArgumentError,\n  InvalidReturnValueError,\n  RequestAbortedError\n} = require('../core/errors')\nconst util = require('../core/util')\nconst { AsyncResource } = require('async_hooks')\nconst { addSignal, removeSignal } = require('./abort-signal')\n\nclass StreamHandler extends AsyncResource {\n  constructor (opts, factory, callback) {\n    if (!opts || typeof opts !== 'object') {\n      throw new InvalidArgumentError('invalid opts')\n    }\n\n    const { signal, method, opaque, body, onInfo, responseHeaders } = opts\n\n    try {\n      if (typeof callback !== 'function') {\n        throw new InvalidArgumentError('invalid callback')\n      }\n\n      if (typeof factory !== 'function') {\n        throw new InvalidArgumentError('invalid factory')\n      }\n\n      if (signal && typeof signal.on !== 'function' && typeof signal.addEventListener !== 'function') {\n        throw new InvalidArgumentError('signal must be an EventEmitter or EventTarget')\n      }\n\n      if (method === 'CONNECT') {\n        throw new InvalidArgumentError('invalid method')\n      }\n\n      if (onInfo && typeof onInfo !== 'function') {\n        throw new InvalidArgumentError('invalid onInfo callback')\n      }\n\n      super('UNDICI_STREAM')\n    } catch (err) {\n      if (util.isStream(body)) {\n        util.destroy(body.on('error', util.nop), err)\n      }\n      throw err\n    }\n\n    this.responseHeaders = responseHeaders || null\n    this.opaque = opaque || null\n    this.factory = factory\n    this.callback = callback\n    this.res = null\n    this.abort = null\n    this.context = null\n    this.trailers = null\n    this.body = body\n    this.onInfo = onInfo || null\n\n    if (util.isStream(body)) {\n      body.on('error', (err) => {\n        this.onError(err)\n      })\n    }\n\n    addSignal(this, signal)\n  }\n\n  onConnect (abort, context) {\n    if (!this.callback) {\n      throw new RequestAbortedError()\n    }\n\n    this.abort = abort\n    this.context = context\n  }\n\n  onHeaders (statusCode, rawHeaders, resume) {\n    const { factory, opaque, context } = this\n\n    if (statusCode < 200) {\n      if (this.onInfo) {\n        const headers = this.responseHeaders === 'raw' ? util.parseRawHeaders(rawHeaders) : util.parseHeaders(rawHeaders)\n        this.onInfo({ statusCode, headers })\n      }\n      return\n    }\n\n    this.factory = null\n    const headers = this.responseHeaders === 'raw' ? util.parseRawHeaders(rawHeaders) : util.parseHeaders(rawHeaders)\n    const res = this.runInAsyncScope(factory, null, {\n      statusCode,\n      headers,\n      opaque,\n      context\n    })\n\n    if (\n      !res ||\n      typeof res.write !== 'function' ||\n      typeof res.end !== 'function' ||\n      typeof res.on !== 'function'\n    ) {\n      throw new InvalidReturnValueError('expected Writable')\n    }\n\n    res.on('drain', resume)\n    // TODO: Avoid finished. It registers an unnecessary amount of listeners.\n    finished(res, { readable: false }, (err) => {\n      const { callback, res, opaque, trailers, abort } = this\n\n      this.res = null\n      if (err || !res.readable) {\n        util.destroy(res, err)\n      }\n\n      this.callback = null\n      this.runInAsyncScope(callback, null, err || null, { opaque, trailers })\n\n      if (err) {\n        abort()\n      }\n    })\n\n    this.res = res\n\n    const needDrain = res.writableNeedDrain !== undefined\n      ? res.writableNeedDrain\n      : res._writableState && res._writableState.needDrain\n\n    return needDrain !== true\n  }\n\n  onData (chunk) {\n    const { res } = this\n\n    return res.write(chunk)\n  }\n\n  onComplete (trailers) {\n    const { res } = this\n\n    removeSignal(this)\n\n    this.trailers = util.parseHeaders(trailers)\n\n    res.end()\n  }\n\n  onError (err) {\n    const { res, callback, opaque, body } = this\n\n    removeSignal(this)\n\n    this.factory = null\n\n    if (res) {\n      this.res = null\n      util.destroy(res, err)\n    } else if (callback) {\n      this.callback = null\n      queueMicrotask(() => {\n        this.runInAsyncScope(callback, null, err, { opaque })\n      })\n    }\n\n    if (body) {\n      this.body = null\n      util.destroy(body, err)\n    }\n  }\n}\n\nfunction stream (opts, factory, callback) {\n  if (callback === undefined) {\n    return new Promise((resolve, reject) => {\n      stream.call(this, opts, factory, (err, data) => {\n        return err ? reject(err) : resolve(data)\n      })\n    })\n  }\n\n  try {\n    this.dispatch(opts, new StreamHandler(opts, factory, callback))\n  } catch (err) {\n    if (typeof callback !== 'function') {\n      throw err\n    }\n    const opaque = opts && opts.opaque\n    queueMicrotask(() => callback(err, { opaque }))\n  }\n}\n\nmodule.exports = stream\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}