{"ast":null,"code":"\"use strict\";\n\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  Object.defineProperty(o, k2, {\n    enumerable: true,\n    get: function () {\n      return m[k];\n    }\n  });\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, \"default\", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o[\"default\"] = v;\n});\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n  __setModuleDefault(result, mod);\n  return result;\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.HttpProvider = void 0;\nconst events_1 = require(\"events\");\nconst constants_1 = require(\"../../constants\");\nconst jsonrpc_1 = require(\"../../util/jsonrpc\");\nconst packageInfo_1 = require(\"../../util/packageInfo\");\nconst errors_1 = require(\"../errors\");\nconst errors_list_1 = require(\"../errors-list\");\nconst proxy_1 = require(\"../../util/proxy\");\nconst errors_2 = require(\"./errors\");\nfunction isErrorResponse(response) {\n  return typeof response.error !== \"undefined\";\n}\nconst MAX_RETRIES = 6;\nconst MAX_RETRY_AWAIT_SECONDS = 5;\nconst TOO_MANY_REQUEST_STATUS = 429;\nconst hardhatVersion = (0, packageInfo_1.getHardhatVersion)();\nclass HttpProvider extends events_1.EventEmitter {\n  constructor(_url, _networkName) {\n    let _extraHeaders = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    let _timeout = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 20000;\n    let client = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : undefined;\n    super();\n    this._url = _url;\n    this._networkName = _networkName;\n    this._extraHeaders = _extraHeaders;\n    this._timeout = _timeout;\n    this._nextRequestId = 1;\n    const {\n      Pool,\n      ProxyAgent\n    } = require(\"undici\");\n    const url = new URL(this._url);\n    this._path = url.pathname;\n    this._authHeader = url.username === \"\" ? undefined : `Basic ${Buffer.from(`${url.username}:${url.password}`, \"utf-8\").toString(\"base64\")}`;\n    try {\n      this._dispatcher = client ?? new Pool(url.origin);\n      if (process.env.http_proxy !== undefined && (0, proxy_1.shouldUseProxy)(url.origin)) {\n        this._dispatcher = new ProxyAgent(process.env.http_proxy);\n      }\n    } catch (e) {\n      if (e instanceof TypeError && e.message === \"Invalid URL\") {\n        e.message += ` ${url.origin}`;\n      }\n      // eslint-disable-next-line @nomiclabs/hardhat-internal-rules/only-hardhat-error\n      throw e;\n    }\n  }\n  get url() {\n    return this._url;\n  }\n  async request(args) {\n    // We create the error here to capture the stack traces at this point,\n    // the async call that follows would probably loose of the stack trace\n    const error = new errors_2.ProviderError(\"HttpProviderError\", -1);\n    const jsonRpcRequest = this._getJsonRpcRequest(args.method, args.params);\n    const jsonRpcResponse = await this._fetchJsonRpcResponse(jsonRpcRequest);\n    if (isErrorResponse(jsonRpcResponse)) {\n      error.message = jsonRpcResponse.error.message;\n      error.code = jsonRpcResponse.error.code;\n      error.data = jsonRpcResponse.error.data;\n      // eslint-disable-next-line @nomiclabs/hardhat-internal-rules/only-hardhat-error\n      throw error;\n    }\n    if (args.method === \"hardhat_reset\") {\n      this.emit(constants_1.HARDHAT_NETWORK_RESET_EVENT);\n    }\n    if (args.method === \"evm_revert\") {\n      this.emit(constants_1.HARDHAT_NETWORK_REVERT_SNAPSHOT_EVENT);\n    }\n    return jsonRpcResponse.result;\n  }\n  /**\n   * Sends a batch of requests. Fails if any of them fails.\n   */\n  async sendBatch(batch) {\n    // We create the errors here to capture the stack traces at this point,\n    // the async call that follows would probably loose of the stack trace\n    const error = new errors_2.ProviderError(\"HttpProviderError\", -1);\n    // we need this to sort the responses\n    const idToIndexMap = {};\n    const requests = batch.map((r, i) => {\n      const jsonRpcRequest = this._getJsonRpcRequest(r.method, r.params);\n      idToIndexMap[jsonRpcRequest.id] = i;\n      return jsonRpcRequest;\n    });\n    const jsonRpcResponses = await this._fetchJsonRpcResponse(requests);\n    for (const response of jsonRpcResponses) {\n      if (isErrorResponse(response)) {\n        error.message = response.error.message;\n        error.code = response.error.code;\n        error.data = response.error.data;\n        // eslint-disable-next-line @nomiclabs/hardhat-internal-rules/only-hardhat-error\n        throw error;\n      }\n    }\n    // We already know that it has this type, but TS can't infer it.\n    const responses = jsonRpcResponses;\n    // we use the id to sort the responses so that they match the order of the requests\n    const sortedResponses = responses.map(response => [idToIndexMap[response.id], response.result]).sort((_ref, _ref2) => {\n      let [indexA] = _ref;\n      let [indexB] = _ref2;\n      return indexA - indexB;\n    }).map(_ref3 => {\n      let [, result] = _ref3;\n      return result;\n    });\n    return sortedResponses;\n  }\n  async _fetchJsonRpcResponse(request) {\n    let retryNumber = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n    const {\n      request: sendRequest\n    } = await Promise.resolve().then(() => __importStar(require(\"undici\")));\n    const url = new URL(this._url);\n    try {\n      const response = await sendRequest(url, {\n        dispatcher: this._dispatcher,\n        method: \"POST\",\n        body: JSON.stringify(request),\n        maxRedirections: 10,\n        headersTimeout: process.env.DO_NOT_SET_THIS_ENV_VAR____IS_HARDHAT_CI !== undefined ? 0 : this._timeout,\n        headers: {\n          \"Content-Type\": \"application/json\",\n          \"User-Agent\": `hardhat ${hardhatVersion}`,\n          Authorization: this._authHeader,\n          ...this._extraHeaders\n        }\n      });\n      if (this._isRateLimitResponse(response)) {\n        // \"The Fetch Standard allows users to skip consuming the response body\n        // by relying on garbage collection to release connection resources.\n        // Undici does not do the same. Therefore, it is important to always\n        // either consume or cancel the response body.\"\n        // https://undici.nodejs.org/#/?id=garbage-collection\n        // It's not clear how to \"cancel\", so we'll just consume:\n        await response.body.text();\n        const seconds = this._getRetryAfterSeconds(response);\n        if (seconds !== undefined && this._shouldRetry(retryNumber, seconds)) {\n          return await this._retry(request, seconds, retryNumber);\n        }\n        // eslint-disable-next-line @nomiclabs/hardhat-internal-rules/only-hardhat-error\n        throw new errors_2.ProviderError(`Too Many Requests error received from ${url.hostname}`, -32005 // Limit exceeded according to EIP1474\n        );\n      }\n\n      return (0, jsonrpc_1.parseJsonResponse)(await response.body.text());\n    } catch (error) {\n      if (error.code === \"ECONNREFUSED\") {\n        throw new errors_1.HardhatError(errors_list_1.ERRORS.NETWORK.NODE_IS_NOT_RUNNING, {\n          network: this._networkName\n        }, error);\n      }\n      if (error.type === \"request-timeout\") {\n        throw new errors_1.HardhatError(errors_list_1.ERRORS.NETWORK.NETWORK_TIMEOUT, {}, error);\n      }\n      // eslint-disable-next-line @nomiclabs/hardhat-internal-rules/only-hardhat-error\n      throw error;\n    }\n  }\n  async _retry(request, seconds, retryNumber) {\n    await new Promise(resolve => setTimeout(resolve, 1000 * seconds));\n    return this._fetchJsonRpcResponse(request, retryNumber + 1);\n  }\n  _getJsonRpcRequest(method) {\n    let params = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n    return {\n      jsonrpc: \"2.0\",\n      method,\n      params,\n      id: this._nextRequestId++\n    };\n  }\n  _shouldRetry(retryNumber, retryAfterSeconds) {\n    if (retryNumber > MAX_RETRIES) {\n      return false;\n    }\n    if (retryAfterSeconds > MAX_RETRY_AWAIT_SECONDS) {\n      return false;\n    }\n    return true;\n  }\n  _isRateLimitResponse(response) {\n    return response.statusCode === TOO_MANY_REQUEST_STATUS;\n  }\n  _getRetryAfterSeconds(response) {\n    const header = response.headers[\"retry-after\"];\n    if (header === undefined || header === null) {\n      return undefined;\n    }\n    const parsed = parseInt(header, 10);\n    if (isNaN(parsed)) {\n      return undefined;\n    }\n    return parsed;\n  }\n}\nexports.HttpProvider = HttpProvider;","map":{"version":3,"mappings":"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","names":["isErrorResponse","response","error","MAX_RETRIES","MAX_RETRY_AWAIT_SECONDS","TOO_MANY_REQUEST_STATUS","hardhatVersion","HttpProvider","events_1","constructor","_url","_networkName","_extraHeaders","_timeout","client","undefined","Pool","ProxyAgent","require","url","URL","_path","pathname","_authHeader","username","Buffer","from","password","toString","_dispatcher","origin","process","env","http_proxy","e","TypeError","message","request","args","errors_2","jsonRpcRequest","_getJsonRpcRequest","method","params","jsonRpcResponse","_fetchJsonRpcResponse","code","data","emit","constants_1","result","sendBatch","batch","idToIndexMap","requests","map","r","i","id","jsonRpcResponses","responses","sortedResponses","sort","indexA","indexB","retryNumber","sendRequest","dispatcher","body","JSON","stringify","maxRedirections","headersTimeout","DO_NOT_SET_THIS_ENV_VAR____IS_HARDHAT_CI","headers","Authorization","_isRateLimitResponse","text","seconds","_getRetryAfterSeconds","_shouldRetry","_retry","hostname","errors_1","errors_list_1","NETWORK","NODE_IS_NOT_RUNNING","network","type","NETWORK_TIMEOUT","Promise","resolve","setTimeout","jsonrpc","_nextRequestId","retryAfterSeconds","statusCode","header","parsed","parseInt","isNaN","exports"],"sources":["/Users/janrobel/Documents/PersonalProjekty/nftGenerateAi/clientAndContract/node_modules/hardhat/src/internal/core/providers/http.ts"],"sourcesContent":["import type * as Undici from \"undici\";\n\nimport { EventEmitter } from \"events\";\n\nimport { EIP1193Provider, RequestArguments } from \"../../../types\";\nimport {\n  HARDHAT_NETWORK_RESET_EVENT,\n  HARDHAT_NETWORK_REVERT_SNAPSHOT_EVENT,\n} from \"../../constants\";\nimport {\n  FailedJsonRpcResponse,\n  JsonRpcRequest,\n  JsonRpcResponse,\n  parseJsonResponse,\n  SuccessfulJsonRpcResponse,\n} from \"../../util/jsonrpc\";\nimport { getHardhatVersion } from \"../../util/packageInfo\";\nimport { HardhatError } from \"../errors\";\nimport { ERRORS } from \"../errors-list\";\nimport { shouldUseProxy } from \"../../util/proxy\";\n\nimport { ProviderError } from \"./errors\";\n\nfunction isErrorResponse(response: any): response is FailedJsonRpcResponse {\n  return typeof response.error !== \"undefined\";\n}\n\nconst MAX_RETRIES = 6;\nconst MAX_RETRY_AWAIT_SECONDS = 5;\n\nconst TOO_MANY_REQUEST_STATUS = 429;\n\nconst hardhatVersion = getHardhatVersion();\n\nexport class HttpProvider extends EventEmitter implements EIP1193Provider {\n  private _nextRequestId = 1;\n  private _dispatcher: Undici.Dispatcher;\n  private _path: string;\n  private _authHeader: string | undefined;\n\n  constructor(\n    private readonly _url: string,\n    private readonly _networkName: string,\n    private readonly _extraHeaders: { [name: string]: string } = {},\n    private readonly _timeout = 20000,\n    client: Undici.Dispatcher | undefined = undefined\n  ) {\n    super();\n\n    const { Pool, ProxyAgent } = require(\"undici\") as typeof Undici;\n\n    const url = new URL(this._url);\n    this._path = url.pathname;\n    this._authHeader =\n      url.username === \"\"\n        ? undefined\n        : `Basic ${Buffer.from(\n            `${url.username}:${url.password}`,\n            \"utf-8\"\n          ).toString(\"base64\")}`;\n    try {\n      this._dispatcher = client ?? new Pool(url.origin);\n\n      if (process.env.http_proxy !== undefined && shouldUseProxy(url.origin)) {\n        this._dispatcher = new ProxyAgent(process.env.http_proxy);\n      }\n    } catch (e) {\n      if (e instanceof TypeError && e.message === \"Invalid URL\") {\n        e.message += ` ${url.origin}`;\n      }\n      // eslint-disable-next-line @nomiclabs/hardhat-internal-rules/only-hardhat-error\n      throw e;\n    }\n  }\n\n  public get url(): string {\n    return this._url;\n  }\n\n  public async request(args: RequestArguments): Promise<unknown> {\n    // We create the error here to capture the stack traces at this point,\n    // the async call that follows would probably loose of the stack trace\n    const error = new ProviderError(\"HttpProviderError\", -1);\n\n    const jsonRpcRequest = this._getJsonRpcRequest(\n      args.method,\n      args.params as any[]\n    );\n    const jsonRpcResponse = await this._fetchJsonRpcResponse(jsonRpcRequest);\n\n    if (isErrorResponse(jsonRpcResponse)) {\n      error.message = jsonRpcResponse.error.message;\n      error.code = jsonRpcResponse.error.code;\n      error.data = jsonRpcResponse.error.data;\n      // eslint-disable-next-line @nomiclabs/hardhat-internal-rules/only-hardhat-error\n      throw error;\n    }\n\n    if (args.method === \"hardhat_reset\") {\n      this.emit(HARDHAT_NETWORK_RESET_EVENT);\n    }\n    if (args.method === \"evm_revert\") {\n      this.emit(HARDHAT_NETWORK_REVERT_SNAPSHOT_EVENT);\n    }\n\n    return jsonRpcResponse.result;\n  }\n\n  /**\n   * Sends a batch of requests. Fails if any of them fails.\n   */\n  public async sendBatch(\n    batch: Array<{ method: string; params: any[] }>\n  ): Promise<any[]> {\n    // We create the errors here to capture the stack traces at this point,\n    // the async call that follows would probably loose of the stack trace\n    const error = new ProviderError(\"HttpProviderError\", -1);\n\n    // we need this to sort the responses\n    const idToIndexMap: Record<string, number> = {};\n\n    const requests = batch.map((r, i) => {\n      const jsonRpcRequest = this._getJsonRpcRequest(r.method, r.params);\n      idToIndexMap[jsonRpcRequest.id] = i;\n      return jsonRpcRequest;\n    });\n\n    const jsonRpcResponses = await this._fetchJsonRpcResponse(requests);\n\n    for (const response of jsonRpcResponses) {\n      if (isErrorResponse(response)) {\n        error.message = response.error.message;\n        error.code = response.error.code;\n        error.data = response.error.data;\n        // eslint-disable-next-line @nomiclabs/hardhat-internal-rules/only-hardhat-error\n        throw error;\n      }\n    }\n\n    // We already know that it has this type, but TS can't infer it.\n    const responses = jsonRpcResponses as SuccessfulJsonRpcResponse[];\n\n    // we use the id to sort the responses so that they match the order of the requests\n    const sortedResponses = responses\n      .map(\n        (response) =>\n          [idToIndexMap[response.id], response.result] as [number, any]\n      )\n      .sort(([indexA], [indexB]) => indexA - indexB)\n      .map(([, result]) => result);\n\n    return sortedResponses;\n  }\n\n  private async _fetchJsonRpcResponse(\n    request: JsonRpcRequest,\n    retryNumber?: number\n  ): Promise<JsonRpcResponse>;\n  private async _fetchJsonRpcResponse(\n    request: JsonRpcRequest[],\n    retryNumber?: number\n  ): Promise<JsonRpcResponse[]>;\n  private async _fetchJsonRpcResponse(\n    request: JsonRpcRequest | JsonRpcRequest[],\n    retryNumber?: number\n  ): Promise<JsonRpcResponse | JsonRpcResponse[]>;\n  private async _fetchJsonRpcResponse(\n    request: JsonRpcRequest | JsonRpcRequest[],\n    retryNumber = 0\n  ): Promise<JsonRpcResponse | JsonRpcResponse[]> {\n    const { request: sendRequest } = await import(\"undici\");\n    const url = new URL(this._url);\n\n    try {\n      const response = await sendRequest(url, {\n        dispatcher: this._dispatcher,\n        method: \"POST\",\n        body: JSON.stringify(request),\n        maxRedirections: 10,\n        headersTimeout:\n          process.env.DO_NOT_SET_THIS_ENV_VAR____IS_HARDHAT_CI !== undefined\n            ? 0\n            : this._timeout,\n        headers: {\n          \"Content-Type\": \"application/json\",\n          \"User-Agent\": `hardhat ${hardhatVersion}`,\n          Authorization: this._authHeader,\n          ...this._extraHeaders,\n        },\n      });\n\n      if (this._isRateLimitResponse(response)) {\n        // \"The Fetch Standard allows users to skip consuming the response body\n        // by relying on garbage collection to release connection resources.\n        // Undici does not do the same. Therefore, it is important to always\n        // either consume or cancel the response body.\"\n        // https://undici.nodejs.org/#/?id=garbage-collection\n        // It's not clear how to \"cancel\", so we'll just consume:\n        await response.body.text();\n        const seconds = this._getRetryAfterSeconds(response);\n        if (seconds !== undefined && this._shouldRetry(retryNumber, seconds)) {\n          return await this._retry(request, seconds, retryNumber);\n        }\n\n        // eslint-disable-next-line @nomiclabs/hardhat-internal-rules/only-hardhat-error\n        throw new ProviderError(\n          `Too Many Requests error received from ${url.hostname}`,\n          -32005 // Limit exceeded according to EIP1474\n        );\n      }\n\n      return parseJsonResponse(await response.body.text());\n    } catch (error: any) {\n      if (error.code === \"ECONNREFUSED\") {\n        throw new HardhatError(\n          ERRORS.NETWORK.NODE_IS_NOT_RUNNING,\n          { network: this._networkName },\n          error\n        );\n      }\n\n      if (error.type === \"request-timeout\") {\n        throw new HardhatError(ERRORS.NETWORK.NETWORK_TIMEOUT, {}, error);\n      }\n\n      // eslint-disable-next-line @nomiclabs/hardhat-internal-rules/only-hardhat-error\n      throw error;\n    }\n  }\n\n  private async _retry(\n    request: JsonRpcRequest | JsonRpcRequest[],\n    seconds: number,\n    retryNumber: number\n  ) {\n    await new Promise((resolve) => setTimeout(resolve, 1000 * seconds));\n    return this._fetchJsonRpcResponse(request, retryNumber + 1);\n  }\n\n  private _getJsonRpcRequest(\n    method: string,\n    params: any[] = []\n  ): JsonRpcRequest {\n    return {\n      jsonrpc: \"2.0\",\n      method,\n      params,\n      id: this._nextRequestId++,\n    };\n  }\n\n  private _shouldRetry(retryNumber: number, retryAfterSeconds: number) {\n    if (retryNumber > MAX_RETRIES) {\n      return false;\n    }\n\n    if (retryAfterSeconds > MAX_RETRY_AWAIT_SECONDS) {\n      return false;\n    }\n\n    return true;\n  }\n\n  private _isRateLimitResponse(response: Undici.Dispatcher.ResponseData) {\n    return response.statusCode === TOO_MANY_REQUEST_STATUS;\n  }\n\n  private _getRetryAfterSeconds(\n    response: Undici.Dispatcher.ResponseData\n  ): number | undefined {\n    const header = response.headers[\"retry-after\"];\n\n    if (header === undefined || header === null) {\n      return undefined;\n    }\n\n    const parsed = parseInt(header, 10);\n    if (isNaN(parsed)) {\n      return undefined;\n    }\n\n    return parsed;\n  }\n}\n"]},"metadata":{},"sourceType":"script","externalDependencies":[]}