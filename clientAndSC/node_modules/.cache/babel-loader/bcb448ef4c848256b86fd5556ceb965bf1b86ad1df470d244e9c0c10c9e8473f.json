{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.createResolverFunctions = void 0;\nconst path_1 = require(\"path\");\n/**\n * @internal\n * In a factory because these are shared across both CompilerHost and LanguageService codepaths\n */\nfunction createResolverFunctions(kwargs) {\n  const {\n    host,\n    ts,\n    config,\n    cwd,\n    getCanonicalFileName,\n    projectLocalResolveHelper,\n    options,\n    extensions\n  } = kwargs;\n  const moduleResolutionCache = ts.createModuleResolutionCache(cwd, getCanonicalFileName, config.options);\n  const knownInternalFilenames = new Set();\n  /** \"Buckets\" (module directories) whose contents should be marked \"internal\" */\n  const internalBuckets = new Set();\n  // Get bucket for a source filename.  Bucket is the containing `./node_modules/*/` directory\n  // For '/project/node_modules/foo/node_modules/bar/lib/index.js' bucket is '/project/node_modules/foo/node_modules/bar/'\n  // For '/project/node_modules/foo/node_modules/@scope/bar/lib/index.js' bucket is '/project/node_modules/foo/node_modules/@scope/bar/'\n  const moduleBucketRe = /.*\\/node_modules\\/(?:@[^\\/]+\\/)?[^\\/]+\\//;\n  function getModuleBucket(filename) {\n    const find = moduleBucketRe.exec(filename);\n    if (find) return find[0];\n    return '';\n  }\n  // Mark that this file and all siblings in its bucket should be \"internal\"\n  function markBucketOfFilenameInternal(filename) {\n    internalBuckets.add(getModuleBucket(filename));\n  }\n  function isFileInInternalBucket(filename) {\n    return internalBuckets.has(getModuleBucket(filename));\n  }\n  function isFileKnownToBeInternal(filename) {\n    return knownInternalFilenames.has(filename);\n  }\n  /**\n   * If we need to emit JS for a file, force TS to consider it non-external\n   */\n  const fixupResolvedModule = resolvedModule => {\n    const {\n      resolvedFileName\n    } = resolvedModule;\n    if (resolvedFileName === undefined) return;\n    // [MUST_UPDATE_FOR_NEW_FILE_EXTENSIONS]\n    // .ts,.mts,.cts is always switched to internal\n    // .js is switched on-demand\n    if (resolvedModule.isExternalLibraryImport && (resolvedFileName.endsWith('.ts') && !resolvedFileName.endsWith('.d.ts') || resolvedFileName.endsWith('.cts') && !resolvedFileName.endsWith('.d.cts') || resolvedFileName.endsWith('.mts') && !resolvedFileName.endsWith('.d.mts') || isFileKnownToBeInternal(resolvedFileName) || isFileInInternalBucket(resolvedFileName))) {\n      resolvedModule.isExternalLibraryImport = false;\n    }\n    if (!resolvedModule.isExternalLibraryImport) {\n      knownInternalFilenames.add(resolvedFileName);\n    }\n  };\n  /*\n   * NOTE:\n   * Older ts versions do not pass `redirectedReference` nor `options`.\n   * We must pass `redirectedReference` to newer ts versions, but cannot rely on `options`, hence the weird argument name\n   */\n  const resolveModuleNames = (moduleNames, containingFile, reusedNames, redirectedReference, optionsOnlyWithNewerTsVersions, containingSourceFile) => {\n    return moduleNames.map((moduleName, i) => {\n      var _a, _b;\n      const mode = containingSourceFile ? (_b = (_a = ts).getModeForResolutionAtIndex) === null || _b === void 0 ? void 0 : _b.call(_a, containingSourceFile, i) : undefined;\n      let {\n        resolvedModule\n      } = ts.resolveModuleName(moduleName, containingFile, config.options, host, moduleResolutionCache, redirectedReference, mode);\n      if (!resolvedModule && options.experimentalTsImportSpecifiers) {\n        const lastDotIndex = moduleName.lastIndexOf('.');\n        const ext = lastDotIndex >= 0 ? moduleName.slice(lastDotIndex) : '';\n        if (ext) {\n          const replacements = extensions.tsResolverEquivalents.get(ext);\n          for (const replacementExt of replacements !== null && replacements !== void 0 ? replacements : []) {\n            ({\n              resolvedModule\n            } = ts.resolveModuleName(moduleName.slice(0, -ext.length) + replacementExt, containingFile, config.options, host, moduleResolutionCache, redirectedReference, mode));\n            if (resolvedModule) break;\n          }\n        }\n      }\n      if (resolvedModule) {\n        fixupResolvedModule(resolvedModule);\n      }\n      return resolvedModule;\n    });\n  };\n  // language service never calls this, but TS docs recommend that we implement it\n  const getResolvedModuleWithFailedLookupLocationsFromCache = (moduleName, containingFile, resolutionMode) => {\n    const ret = ts.resolveModuleNameFromCache(moduleName, containingFile, moduleResolutionCache, resolutionMode);\n    if (ret && ret.resolvedModule) {\n      fixupResolvedModule(ret.resolvedModule);\n    }\n    return ret;\n  };\n  const resolveTypeReferenceDirectives = (typeDirectiveNames, containingFile, redirectedReference, options, containingFileMode // new impliedNodeFormat is accepted by compilerHost\n  ) => {\n    // Note: seems to be called with empty typeDirectiveNames array for all files.\n    // TODO consider using `ts.loadWithTypeDirectiveCache`\n    return typeDirectiveNames.map(typeDirectiveName => {\n      // Copy-pasted from TS source:\n      const nameIsString = typeof typeDirectiveName === 'string';\n      const mode = nameIsString ? undefined : ts.getModeForFileReference(typeDirectiveName, containingFileMode);\n      const strName = nameIsString ? typeDirectiveName : typeDirectiveName.fileName.toLowerCase();\n      let {\n        resolvedTypeReferenceDirective\n      } = ts.resolveTypeReferenceDirective(strName, containingFile, config.options, host, redirectedReference, undefined, mode);\n      if (typeDirectiveName === 'node' && !resolvedTypeReferenceDirective) {\n        // Resolve @types/node relative to project first, then __dirname (copy logic from elsewhere / refactor into reusable function)\n        let typesNodePackageJsonPath;\n        try {\n          typesNodePackageJsonPath = projectLocalResolveHelper('@types/node/package.json', true);\n        } catch {} // gracefully do nothing when @types/node is not installed for any reason\n        if (typesNodePackageJsonPath) {\n          const typeRoots = [(0, path_1.resolve)(typesNodePackageJsonPath, '../..')];\n          ({\n            resolvedTypeReferenceDirective\n          } = ts.resolveTypeReferenceDirective(typeDirectiveName, containingFile, {\n            ...config.options,\n            typeRoots\n          }, host, redirectedReference));\n        }\n      }\n      if (resolvedTypeReferenceDirective) {\n        fixupResolvedModule(resolvedTypeReferenceDirective);\n      }\n      return resolvedTypeReferenceDirective;\n    });\n  };\n  return {\n    resolveModuleNames,\n    getResolvedModuleWithFailedLookupLocationsFromCache,\n    resolveTypeReferenceDirectives,\n    isFileKnownToBeInternal,\n    markBucketOfFilenameInternal\n  };\n}\nexports.createResolverFunctions = createResolverFunctions;","map":{"version":3,"mappings":"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","names":["createResolverFunctions","kwargs","host","ts","config","cwd","getCanonicalFileName","projectLocalResolveHelper","options","extensions","moduleResolutionCache","createModuleResolutionCache","knownInternalFilenames","Set","internalBuckets","moduleBucketRe","getModuleBucket","filename","find","exec","markBucketOfFilenameInternal","add","isFileInInternalBucket","has","isFileKnownToBeInternal","fixupResolvedModule","resolvedModule","resolvedFileName","undefined","isExternalLibraryImport","endsWith","resolveModuleNames","moduleNames","containingFile","reusedNames","redirectedReference","optionsOnlyWithNewerTsVersions","containingSourceFile","map","moduleName","i","mode","getModeForResolutionAtIndex","resolveModuleName","experimentalTsImportSpecifiers","lastDotIndex","lastIndexOf","ext","slice","replacements","tsResolverEquivalents","get","replacementExt","length","getResolvedModuleWithFailedLookupLocationsFromCache","resolutionMode","ret","resolveModuleNameFromCache","resolveTypeReferenceDirectives","typeDirectiveNames","containingFileMode","typeDirectiveName","nameIsString","getModeForFileReference","strName","fileName","toLowerCase","resolvedTypeReferenceDirective","resolveTypeReferenceDirective","typesNodePackageJsonPath","typeRoots","exports"],"sources":["/Users/janrobel/Documents/PersonalProjekty/nftGenerateAi/clientAndContract/node_modules/ts-node/src/resolver-functions.ts"],"sourcesContent":["import { resolve } from 'path';\nimport type { CreateOptions } from '.';\nimport type { Extensions } from './file-extensions';\nimport type { TSCommon, TSInternal } from './ts-compiler-types';\nimport type { ProjectLocalResolveHelper } from './util';\n\n/**\n * @internal\n * In a factory because these are shared across both CompilerHost and LanguageService codepaths\n */\nexport function createResolverFunctions(kwargs: {\n  ts: TSCommon;\n  host: TSCommon.ModuleResolutionHost;\n  cwd: string;\n  getCanonicalFileName: (filename: string) => string;\n  config: TSCommon.ParsedCommandLine;\n  projectLocalResolveHelper: ProjectLocalResolveHelper;\n  options: CreateOptions;\n  extensions: Extensions;\n}) {\n  const {\n    host,\n    ts,\n    config,\n    cwd,\n    getCanonicalFileName,\n    projectLocalResolveHelper,\n    options,\n    extensions,\n  } = kwargs;\n  const moduleResolutionCache = ts.createModuleResolutionCache(\n    cwd,\n    getCanonicalFileName,\n    config.options\n  );\n  const knownInternalFilenames = new Set<string>();\n  /** \"Buckets\" (module directories) whose contents should be marked \"internal\" */\n  const internalBuckets = new Set<string>();\n\n  // Get bucket for a source filename.  Bucket is the containing `./node_modules/*/` directory\n  // For '/project/node_modules/foo/node_modules/bar/lib/index.js' bucket is '/project/node_modules/foo/node_modules/bar/'\n  // For '/project/node_modules/foo/node_modules/@scope/bar/lib/index.js' bucket is '/project/node_modules/foo/node_modules/@scope/bar/'\n  const moduleBucketRe = /.*\\/node_modules\\/(?:@[^\\/]+\\/)?[^\\/]+\\//;\n  function getModuleBucket(filename: string) {\n    const find = moduleBucketRe.exec(filename);\n    if (find) return find[0];\n    return '';\n  }\n\n  // Mark that this file and all siblings in its bucket should be \"internal\"\n  function markBucketOfFilenameInternal(filename: string) {\n    internalBuckets.add(getModuleBucket(filename));\n  }\n\n  function isFileInInternalBucket(filename: string) {\n    return internalBuckets.has(getModuleBucket(filename));\n  }\n\n  function isFileKnownToBeInternal(filename: string) {\n    return knownInternalFilenames.has(filename);\n  }\n\n  /**\n   * If we need to emit JS for a file, force TS to consider it non-external\n   */\n  const fixupResolvedModule = (\n    resolvedModule:\n      | TSCommon.ResolvedModule\n      | TSCommon.ResolvedTypeReferenceDirective\n  ) => {\n    const { resolvedFileName } = resolvedModule;\n    if (resolvedFileName === undefined) return;\n    // [MUST_UPDATE_FOR_NEW_FILE_EXTENSIONS]\n    // .ts,.mts,.cts is always switched to internal\n    // .js is switched on-demand\n    if (\n      resolvedModule.isExternalLibraryImport &&\n      ((resolvedFileName.endsWith('.ts') &&\n        !resolvedFileName.endsWith('.d.ts')) ||\n        (resolvedFileName.endsWith('.cts') &&\n          !resolvedFileName.endsWith('.d.cts')) ||\n        (resolvedFileName.endsWith('.mts') &&\n          !resolvedFileName.endsWith('.d.mts')) ||\n        isFileKnownToBeInternal(resolvedFileName) ||\n        isFileInInternalBucket(resolvedFileName))\n    ) {\n      resolvedModule.isExternalLibraryImport = false;\n    }\n    if (!resolvedModule.isExternalLibraryImport) {\n      knownInternalFilenames.add(resolvedFileName);\n    }\n  };\n  /*\n   * NOTE:\n   * Older ts versions do not pass `redirectedReference` nor `options`.\n   * We must pass `redirectedReference` to newer ts versions, but cannot rely on `options`, hence the weird argument name\n   */\n  const resolveModuleNames: TSCommon.LanguageServiceHost['resolveModuleNames'] =\n    (\n      moduleNames: string[],\n      containingFile: string,\n      reusedNames: string[] | undefined,\n      redirectedReference: TSCommon.ResolvedProjectReference | undefined,\n      optionsOnlyWithNewerTsVersions: TSCommon.CompilerOptions,\n      containingSourceFile?: TSCommon.SourceFile\n    ): (TSCommon.ResolvedModule | undefined)[] => {\n      return moduleNames.map((moduleName, i) => {\n        const mode = containingSourceFile\n          ? (ts as any as TSInternal).getModeForResolutionAtIndex?.(\n              containingSourceFile,\n              i\n            )\n          : undefined;\n        let { resolvedModule } = ts.resolveModuleName(\n          moduleName,\n          containingFile,\n          config.options,\n          host,\n          moduleResolutionCache,\n          redirectedReference,\n          mode\n        );\n        if (!resolvedModule && options.experimentalTsImportSpecifiers) {\n          const lastDotIndex = moduleName.lastIndexOf('.');\n          const ext = lastDotIndex >= 0 ? moduleName.slice(lastDotIndex) : '';\n          if (ext) {\n            const replacements = extensions.tsResolverEquivalents.get(ext);\n            for (const replacementExt of replacements ?? []) {\n              ({ resolvedModule } = ts.resolveModuleName(\n                moduleName.slice(0, -ext.length) + replacementExt,\n                containingFile,\n                config.options,\n                host,\n                moduleResolutionCache,\n                redirectedReference,\n                mode\n              ));\n              if (resolvedModule) break;\n            }\n          }\n        }\n        if (resolvedModule) {\n          fixupResolvedModule(resolvedModule);\n        }\n        return resolvedModule;\n      });\n    };\n\n  // language service never calls this, but TS docs recommend that we implement it\n  const getResolvedModuleWithFailedLookupLocationsFromCache: TSCommon.LanguageServiceHost['getResolvedModuleWithFailedLookupLocationsFromCache'] =\n    (\n      moduleName,\n      containingFile,\n      resolutionMode?: TSCommon.ModuleKind.CommonJS | TSCommon.ModuleKind.ESNext\n    ): TSCommon.ResolvedModuleWithFailedLookupLocations | undefined => {\n      const ret = ts.resolveModuleNameFromCache(\n        moduleName,\n        containingFile,\n        moduleResolutionCache,\n        resolutionMode\n      );\n      if (ret && ret.resolvedModule) {\n        fixupResolvedModule(ret.resolvedModule);\n      }\n      return ret;\n    };\n\n  const resolveTypeReferenceDirectives: TSCommon.LanguageServiceHost['resolveTypeReferenceDirectives'] =\n    (\n      typeDirectiveNames: string[] | readonly TSCommon.FileReference[],\n      containingFile: string,\n      redirectedReference: TSCommon.ResolvedProjectReference | undefined,\n      options: TSCommon.CompilerOptions,\n      containingFileMode?: TSCommon.SourceFile['impliedNodeFormat'] | undefined // new impliedNodeFormat is accepted by compilerHost\n    ): (TSCommon.ResolvedTypeReferenceDirective | undefined)[] => {\n      // Note: seems to be called with empty typeDirectiveNames array for all files.\n      // TODO consider using `ts.loadWithTypeDirectiveCache`\n      return typeDirectiveNames.map((typeDirectiveName) => {\n        // Copy-pasted from TS source:\n        const nameIsString = typeof typeDirectiveName === 'string';\n        const mode = nameIsString\n          ? undefined\n          : (ts as any as TSInternal).getModeForFileReference!(\n              typeDirectiveName,\n              containingFileMode\n            );\n        const strName = nameIsString\n          ? typeDirectiveName\n          : typeDirectiveName.fileName.toLowerCase();\n        let { resolvedTypeReferenceDirective } =\n          ts.resolveTypeReferenceDirective(\n            strName,\n            containingFile,\n            config.options,\n            host,\n            redirectedReference,\n            undefined,\n            mode\n          );\n        if (typeDirectiveName === 'node' && !resolvedTypeReferenceDirective) {\n          // Resolve @types/node relative to project first, then __dirname (copy logic from elsewhere / refactor into reusable function)\n          let typesNodePackageJsonPath: string | undefined;\n          try {\n            typesNodePackageJsonPath = projectLocalResolveHelper(\n              '@types/node/package.json',\n              true\n            );\n          } catch {} // gracefully do nothing when @types/node is not installed for any reason\n          if (typesNodePackageJsonPath) {\n            const typeRoots = [resolve(typesNodePackageJsonPath, '../..')];\n            ({ resolvedTypeReferenceDirective } =\n              ts.resolveTypeReferenceDirective(\n                typeDirectiveName,\n                containingFile,\n                {\n                  ...config.options,\n                  typeRoots,\n                },\n                host,\n                redirectedReference\n              ));\n          }\n        }\n        if (resolvedTypeReferenceDirective) {\n          fixupResolvedModule(resolvedTypeReferenceDirective);\n        }\n        return resolvedTypeReferenceDirective;\n      });\n    };\n\n  return {\n    resolveModuleNames,\n    getResolvedModuleWithFailedLookupLocationsFromCache,\n    resolveTypeReferenceDirectives,\n    isFileKnownToBeInternal,\n    markBucketOfFilenameInternal,\n  };\n}\n"]},"metadata":{},"sourceType":"script","externalDependencies":[]}