{"ast":null,"code":"/*istanbul ignore start*/\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.applyPatch = applyPatch;\nexports.applyPatches = applyPatches;\n\n/*istanbul ignore end*/\nvar /*istanbul ignore start*/\n_parse = require(\"./parse\")\n/*istanbul ignore end*/;\n\nvar /*istanbul ignore start*/\n_distanceIterator = _interopRequireDefault(require(\"../util/distance-iterator\"))\n/*istanbul ignore end*/;\n\n/*istanbul ignore start*/\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    \"default\": obj\n  };\n}\n\n/*istanbul ignore end*/\nfunction applyPatch(source, uniDiff) {\n  /*istanbul ignore start*/\n  var /*istanbul ignore end*/\n  options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  if (typeof uniDiff === 'string') {\n    uniDiff = /*istanbul ignore start*/\n    (0, /*istanbul ignore end*/\n\n    /*istanbul ignore start*/\n    _parse\n    /*istanbul ignore end*/. /*istanbul ignore start*/\n    parsePatch\n    /*istanbul ignore end*/)(uniDiff);\n  }\n  if (Array.isArray(uniDiff)) {\n    if (uniDiff.length > 1) {\n      throw new Error('applyPatch only works with a single input.');\n    }\n    uniDiff = uniDiff[0];\n  } // Apply the diff to the input\n\n  var lines = source.split(/\\r\\n|[\\n\\v\\f\\r\\x85]/),\n    delimiters = source.match(/\\r\\n|[\\n\\v\\f\\r\\x85]/g) || [],\n    hunks = uniDiff.hunks,\n    compareLine = options.compareLine || function (lineNumber, line, operation, patchContent) /*istanbul ignore start*/\n    {\n      return (/*istanbul ignore end*/\n        line === patchContent\n      );\n    },\n    errorCount = 0,\n    fuzzFactor = options.fuzzFactor || 0,\n    minLine = 0,\n    offset = 0,\n    removeEOFNL,\n    addEOFNL;\n  /**\n   * Checks if the hunk exactly fits on the provided location\n   */\n\n  function hunkFits(hunk, toPos) {\n    for (var j = 0; j < hunk.lines.length; j++) {\n      var line = hunk.lines[j],\n        operation = line.length > 0 ? line[0] : ' ',\n        content = line.length > 0 ? line.substr(1) : line;\n      if (operation === ' ' || operation === '-') {\n        // Context sanity check\n        if (!compareLine(toPos + 1, lines[toPos], operation, content)) {\n          errorCount++;\n          if (errorCount > fuzzFactor) {\n            return false;\n          }\n        }\n        toPos++;\n      }\n    }\n    return true;\n  } // Search best fit offsets for each hunk based on the previous ones\n\n  for (var i = 0; i < hunks.length; i++) {\n    var hunk = hunks[i],\n      maxLine = lines.length - hunk.oldLines,\n      localOffset = 0,\n      toPos = offset + hunk.oldStart - 1;\n    var iterator = /*istanbul ignore start*/\n    (0, /*istanbul ignore end*/\n\n    /*istanbul ignore start*/\n    _distanceIterator\n    /*istanbul ignore end*/[/*istanbul ignore start*/\n    \"default\"\n    /*istanbul ignore end*/])(toPos, minLine, maxLine);\n    for (; localOffset !== undefined; localOffset = iterator()) {\n      if (hunkFits(hunk, toPos + localOffset)) {\n        hunk.offset = offset += localOffset;\n        break;\n      }\n    }\n    if (localOffset === undefined) {\n      return false;\n    } // Set lower text limit to end of the current hunk, so next ones don't try\n    // to fit over already patched text\n\n    minLine = hunk.offset + hunk.oldStart + hunk.oldLines;\n  } // Apply patch hunks\n\n  var diffOffset = 0;\n  for (var _i = 0; _i < hunks.length; _i++) {\n    var _hunk = hunks[_i],\n      _toPos = _hunk.oldStart + _hunk.offset + diffOffset - 1;\n    diffOffset += _hunk.newLines - _hunk.oldLines;\n    for (var j = 0; j < _hunk.lines.length; j++) {\n      var line = _hunk.lines[j],\n        operation = line.length > 0 ? line[0] : ' ',\n        content = line.length > 0 ? line.substr(1) : line,\n        delimiter = _hunk.linedelimiters[j];\n      if (operation === ' ') {\n        _toPos++;\n      } else if (operation === '-') {\n        lines.splice(_toPos, 1);\n        delimiters.splice(_toPos, 1);\n        /* istanbul ignore else */\n      } else if (operation === '+') {\n        lines.splice(_toPos, 0, content);\n        delimiters.splice(_toPos, 0, delimiter);\n        _toPos++;\n      } else if (operation === '\\\\') {\n        var previousOperation = _hunk.lines[j - 1] ? _hunk.lines[j - 1][0] : null;\n        if (previousOperation === '+') {\n          removeEOFNL = true;\n        } else if (previousOperation === '-') {\n          addEOFNL = true;\n        }\n      }\n    }\n  } // Handle EOFNL insertion/removal\n\n  if (removeEOFNL) {\n    while (!lines[lines.length - 1]) {\n      lines.pop();\n      delimiters.pop();\n    }\n  } else if (addEOFNL) {\n    lines.push('');\n    delimiters.push('\\n');\n  }\n  for (var _k = 0; _k < lines.length - 1; _k++) {\n    lines[_k] = lines[_k] + delimiters[_k];\n  }\n  return lines.join('');\n} // Wrapper that supports multiple file patches via callbacks.\n\nfunction applyPatches(uniDiff, options) {\n  if (typeof uniDiff === 'string') {\n    uniDiff = /*istanbul ignore start*/\n    (0, /*istanbul ignore end*/\n\n    /*istanbul ignore start*/\n    _parse\n    /*istanbul ignore end*/. /*istanbul ignore start*/\n    parsePatch\n    /*istanbul ignore end*/)(uniDiff);\n  }\n  var currentIndex = 0;\n  function processIndex() {\n    var index = uniDiff[currentIndex++];\n    if (!index) {\n      return options.complete();\n    }\n    options.loadFile(index, function (err, data) {\n      if (err) {\n        return options.complete(err);\n      }\n      var updatedContent = applyPatch(data, index, options);\n      options.patched(index, updatedContent, function (err) {\n        if (err) {\n          return options.complete(err);\n        }\n        processIndex();\n      });\n    });\n  }\n  processIndex();\n}","map":{"version":3,"mappings":"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","names":["_parse","_distanceIterator","applyPatch","source","uniDiff","options","parsePatch","Array","isArray","length","Error","lines","split","delimiters","match","hunks","compareLine","lineNumber","line","operation","patchContent","errorCount","fuzzFactor","minLine","offset","removeEOFNL","addEOFNL","hunkFits","hunk","toPos","j","content","substr","i","maxLine","oldLines","localOffset","oldStart","iterator","distanceIterator","undefined","diffOffset","newLines","delimiter","linedelimiters","splice","previousOperation","pop","push","_k","join","applyPatches","currentIndex","processIndex","index","complete","loadFile","err","data","updatedContent","patched"],"sources":["/Users/janrobel/Documents/PersonalProjekty/nftGenerateAi/clientAndContract/node_modules/diff/src/patch/apply.js"],"sourcesContent":["import {parsePatch} from './parse';\nimport distanceIterator from '../util/distance-iterator';\n\nexport function applyPatch(source, uniDiff, options = {}) {\n  if (typeof uniDiff === 'string') {\n    uniDiff = parsePatch(uniDiff);\n  }\n\n  if (Array.isArray(uniDiff)) {\n    if (uniDiff.length > 1) {\n      throw new Error('applyPatch only works with a single input.');\n    }\n\n    uniDiff = uniDiff[0];\n  }\n\n  // Apply the diff to the input\n  let lines = source.split(/\\r\\n|[\\n\\v\\f\\r\\x85]/),\n      delimiters = source.match(/\\r\\n|[\\n\\v\\f\\r\\x85]/g) || [],\n      hunks = uniDiff.hunks,\n\n      compareLine = options.compareLine || ((lineNumber, line, operation, patchContent) => line === patchContent),\n      errorCount = 0,\n      fuzzFactor = options.fuzzFactor || 0,\n      minLine = 0,\n      offset = 0,\n\n      removeEOFNL,\n      addEOFNL;\n\n  /**\n   * Checks if the hunk exactly fits on the provided location\n   */\n  function hunkFits(hunk, toPos) {\n    for (let j = 0; j < hunk.lines.length; j++) {\n      let line = hunk.lines[j],\n          operation = (line.length > 0 ? line[0] : ' '),\n          content = (line.length > 0 ? line.substr(1) : line);\n\n      if (operation === ' ' || operation === '-') {\n        // Context sanity check\n        if (!compareLine(toPos + 1, lines[toPos], operation, content)) {\n          errorCount++;\n\n          if (errorCount > fuzzFactor) {\n            return false;\n          }\n        }\n        toPos++;\n      }\n    }\n\n    return true;\n  }\n\n  // Search best fit offsets for each hunk based on the previous ones\n  for (let i = 0; i < hunks.length; i++) {\n    let hunk = hunks[i],\n        maxLine = lines.length - hunk.oldLines,\n        localOffset = 0,\n        toPos = offset + hunk.oldStart - 1;\n\n    let iterator = distanceIterator(toPos, minLine, maxLine);\n\n    for (; localOffset !== undefined; localOffset = iterator()) {\n      if (hunkFits(hunk, toPos + localOffset)) {\n        hunk.offset = offset += localOffset;\n        break;\n      }\n    }\n\n    if (localOffset === undefined) {\n      return false;\n    }\n\n    // Set lower text limit to end of the current hunk, so next ones don't try\n    // to fit over already patched text\n    minLine = hunk.offset + hunk.oldStart + hunk.oldLines;\n  }\n\n  // Apply patch hunks\n  let diffOffset = 0;\n  for (let i = 0; i < hunks.length; i++) {\n    let hunk = hunks[i],\n        toPos = hunk.oldStart + hunk.offset + diffOffset - 1;\n    diffOffset += hunk.newLines - hunk.oldLines;\n\n    for (let j = 0; j < hunk.lines.length; j++) {\n      let line = hunk.lines[j],\n          operation = (line.length > 0 ? line[0] : ' '),\n          content = (line.length > 0 ? line.substr(1) : line),\n          delimiter = hunk.linedelimiters[j];\n\n      if (operation === ' ') {\n        toPos++;\n      } else if (operation === '-') {\n        lines.splice(toPos, 1);\n        delimiters.splice(toPos, 1);\n      /* istanbul ignore else */\n      } else if (operation === '+') {\n        lines.splice(toPos, 0, content);\n        delimiters.splice(toPos, 0, delimiter);\n        toPos++;\n      } else if (operation === '\\\\') {\n        let previousOperation = hunk.lines[j - 1] ? hunk.lines[j - 1][0] : null;\n        if (previousOperation === '+') {\n          removeEOFNL = true;\n        } else if (previousOperation === '-') {\n          addEOFNL = true;\n        }\n      }\n    }\n  }\n\n  // Handle EOFNL insertion/removal\n  if (removeEOFNL) {\n    while (!lines[lines.length - 1]) {\n      lines.pop();\n      delimiters.pop();\n    }\n  } else if (addEOFNL) {\n    lines.push('');\n    delimiters.push('\\n');\n  }\n  for (let _k = 0; _k < lines.length - 1; _k++) {\n    lines[_k] = lines[_k] + delimiters[_k];\n  }\n  return lines.join('');\n}\n\n// Wrapper that supports multiple file patches via callbacks.\nexport function applyPatches(uniDiff, options) {\n  if (typeof uniDiff === 'string') {\n    uniDiff = parsePatch(uniDiff);\n  }\n\n  let currentIndex = 0;\n  function processIndex() {\n    let index = uniDiff[currentIndex++];\n    if (!index) {\n      return options.complete();\n    }\n\n    options.loadFile(index, function(err, data) {\n      if (err) {\n        return options.complete(err);\n      }\n\n      let updatedContent = applyPatch(data, index, options);\n      options.patched(index, updatedContent, function(err) {\n        if (err) {\n          return options.complete(err);\n        }\n\n        processIndex();\n      });\n    });\n  }\n  processIndex();\n}\n"]},"metadata":{},"sourceType":"script","externalDependencies":[]}