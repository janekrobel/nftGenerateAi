{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Bytecode = exports.Instruction = exports.CustomError = exports.ContractFunction = exports.Contract = exports.SourceLocation = exports.SourceFile = exports.ContractFunctionVisibility = exports.ContractFunctionType = exports.ContractType = exports.JumpType = void 0;\nconst ethereumjs_util_1 = require(\"@nomicfoundation/ethereumjs-util\");\nconst abi_helpers_1 = require(\"../../util/abi-helpers\");\n/* eslint-disable @nomiclabs/hardhat-internal-rules/only-hardhat-error */\nvar JumpType;\n(function (JumpType) {\n  JumpType[JumpType[\"NOT_JUMP\"] = 0] = \"NOT_JUMP\";\n  JumpType[JumpType[\"INTO_FUNCTION\"] = 1] = \"INTO_FUNCTION\";\n  JumpType[JumpType[\"OUTOF_FUNCTION\"] = 2] = \"OUTOF_FUNCTION\";\n  JumpType[JumpType[\"INTERNAL_JUMP\"] = 3] = \"INTERNAL_JUMP\";\n})(JumpType = exports.JumpType || (exports.JumpType = {}));\nvar ContractType;\n(function (ContractType) {\n  ContractType[ContractType[\"CONTRACT\"] = 0] = \"CONTRACT\";\n  ContractType[ContractType[\"LIBRARY\"] = 1] = \"LIBRARY\";\n})(ContractType = exports.ContractType || (exports.ContractType = {}));\nvar ContractFunctionType;\n(function (ContractFunctionType) {\n  ContractFunctionType[ContractFunctionType[\"CONSTRUCTOR\"] = 0] = \"CONSTRUCTOR\";\n  ContractFunctionType[ContractFunctionType[\"FUNCTION\"] = 1] = \"FUNCTION\";\n  ContractFunctionType[ContractFunctionType[\"FALLBACK\"] = 2] = \"FALLBACK\";\n  ContractFunctionType[ContractFunctionType[\"RECEIVE\"] = 3] = \"RECEIVE\";\n  ContractFunctionType[ContractFunctionType[\"GETTER\"] = 4] = \"GETTER\";\n  ContractFunctionType[ContractFunctionType[\"MODIFIER\"] = 5] = \"MODIFIER\";\n  ContractFunctionType[ContractFunctionType[\"FREE_FUNCTION\"] = 6] = \"FREE_FUNCTION\";\n})(ContractFunctionType = exports.ContractFunctionType || (exports.ContractFunctionType = {}));\nvar ContractFunctionVisibility;\n(function (ContractFunctionVisibility) {\n  ContractFunctionVisibility[ContractFunctionVisibility[\"PRIVATE\"] = 0] = \"PRIVATE\";\n  ContractFunctionVisibility[ContractFunctionVisibility[\"INTERNAL\"] = 1] = \"INTERNAL\";\n  ContractFunctionVisibility[ContractFunctionVisibility[\"PUBLIC\"] = 2] = \"PUBLIC\";\n  ContractFunctionVisibility[ContractFunctionVisibility[\"EXTERNAL\"] = 3] = \"EXTERNAL\";\n})(ContractFunctionVisibility = exports.ContractFunctionVisibility || (exports.ContractFunctionVisibility = {}));\nclass SourceFile {\n  constructor(sourceName, content) {\n    this.sourceName = sourceName;\n    this.content = content;\n    this.contracts = [];\n    this.functions = [];\n  }\n  addContract(contract) {\n    if (contract.location.file !== this) {\n      throw new Error(\"Trying to add a contract from another file\");\n    }\n    this.contracts.push(contract);\n  }\n  addFunction(func) {\n    if (func.location.file !== this) {\n      throw new Error(\"Trying to add a function from another file\");\n    }\n    this.functions.push(func);\n  }\n  getContainingFunction(location) {\n    // TODO: Optimize this with a binary search or an internal tree\n    for (const func of this.functions) {\n      if (func.location.contains(location)) {\n        return func;\n      }\n    }\n    return undefined;\n  }\n}\nexports.SourceFile = SourceFile;\nclass SourceLocation {\n  constructor(file, offset, length) {\n    this.file = file;\n    this.offset = offset;\n    this.length = length;\n  }\n  getStartingLineNumber() {\n    if (this._line === undefined) {\n      this._line = 1;\n      for (const c of this.file.content.slice(0, this.offset)) {\n        if (c === \"\\n\") {\n          this._line += 1;\n        }\n      }\n    }\n    return this._line;\n  }\n  getContainingFunction() {\n    return this.file.getContainingFunction(this);\n  }\n  contains(other) {\n    if (this.file !== other.file) {\n      return false;\n    }\n    if (other.offset < this.offset) {\n      return false;\n    }\n    return other.offset + other.length <= this.offset + this.length;\n  }\n  equals(other) {\n    return this.file === other.file && this.offset === other.offset && this.length === other.length;\n  }\n}\nexports.SourceLocation = SourceLocation;\nclass Contract {\n  constructor(name, type, location) {\n    this.name = name;\n    this.type = type;\n    this.location = location;\n    this.localFunctions = [];\n    this.customErrors = [];\n    this._selectorHexToFunction = new Map();\n  }\n  get constructorFunction() {\n    return this._constructor;\n  }\n  get fallback() {\n    return this._fallback;\n  }\n  get receive() {\n    return this._receive;\n  }\n  addLocalFunction(func) {\n    if (func.contract !== this) {\n      throw new Error(\"Function isn't local\");\n    }\n    if (func.visibility === ContractFunctionVisibility.PUBLIC || func.visibility === ContractFunctionVisibility.EXTERNAL) {\n      if (func.type === ContractFunctionType.FUNCTION || func.type === ContractFunctionType.GETTER) {\n        this._selectorHexToFunction.set((0, ethereumjs_util_1.bufferToHex)(func.selector), func);\n      } else if (func.type === ContractFunctionType.CONSTRUCTOR) {\n        this._constructor = func;\n      } else if (func.type === ContractFunctionType.FALLBACK) {\n        this._fallback = func;\n      } else if (func.type === ContractFunctionType.RECEIVE) {\n        this._receive = func;\n      }\n    }\n    this.localFunctions.push(func);\n  }\n  addCustomError(customError) {\n    this.customErrors.push(customError);\n  }\n  addNextLinearizedBaseContract(baseContract) {\n    if (this._fallback === undefined && baseContract._fallback !== undefined) {\n      this._fallback = baseContract._fallback;\n    }\n    if (this._receive === undefined && baseContract._receive !== undefined) {\n      this._receive = baseContract._receive;\n    }\n    for (const baseContractFunction of baseContract.localFunctions) {\n      if (baseContractFunction.type !== ContractFunctionType.GETTER && baseContractFunction.type !== ContractFunctionType.FUNCTION) {\n        continue;\n      }\n      if (baseContractFunction.visibility !== ContractFunctionVisibility.PUBLIC && baseContractFunction.visibility !== ContractFunctionVisibility.EXTERNAL) {\n        continue;\n      }\n      const selectorHex = (0, ethereumjs_util_1.bufferToHex)(baseContractFunction.selector);\n      if (!this._selectorHexToFunction.has(selectorHex)) {\n        this._selectorHexToFunction.set(selectorHex, baseContractFunction);\n      }\n    }\n  }\n  getFunctionFromSelector(selector) {\n    return this._selectorHexToFunction.get((0, ethereumjs_util_1.bufferToHex)(selector));\n  }\n  /**\n   * We compute selectors manually, which is particularly hard. We do this\n   * because we need to map selectors to AST nodes, and it seems easier to start\n   * from the AST node. This is surprisingly super hard: things like inherited\n   * enums, structs and ABIv2 complicate it.\n   *\n   * As we know that that can fail, we run a heuristic that tries to correct\n   * incorrect selectors. What it does is checking the `evm.methodIdentifiers`\n   * compiler output, and detect missing selectors. Then we take those and\n   * find contract functions with the same name. If there are multiple of those\n   * we can't do anything. If there is a single one, it must have an incorrect\n   * selector, so we update it with the `evm.methodIdentifiers`'s value.\n   */\n  correctSelector(functionName, selector) {\n    const functions = Array.from(this._selectorHexToFunction.values()).filter(cf => cf.name === functionName);\n    if (functions.length !== 1) {\n      return false;\n    }\n    const functionToCorrect = functions[0];\n    if (functionToCorrect.selector !== undefined) {\n      this._selectorHexToFunction.delete((0, ethereumjs_util_1.bufferToHex)(functionToCorrect.selector));\n    }\n    functionToCorrect.selector = selector;\n    this._selectorHexToFunction.set((0, ethereumjs_util_1.bufferToHex)(selector), functionToCorrect);\n    return true;\n  }\n}\nexports.Contract = Contract;\nclass ContractFunction {\n  constructor(name, type, location, contract, visibility, isPayable, selector) {\n    this.name = name;\n    this.type = type;\n    this.location = location;\n    this.contract = contract;\n    this.visibility = visibility;\n    this.isPayable = isPayable;\n    this.selector = selector;\n    if (contract !== undefined && !contract.location.contains(location)) {\n      throw new Error(\"Incompatible contract and function location\");\n    }\n  }\n}\nexports.ContractFunction = ContractFunction;\nclass CustomError {\n  constructor(selector, name, paramTypes) {\n    this.selector = selector;\n    this.name = name;\n    this.paramTypes = paramTypes;\n  }\n  /**\n   * Return a CustomError from the given ABI information: the name\n   * of the error and its inputs. Returns undefined if it can't build\n   * the CustomError.\n   */\n  static fromABI(name, inputs) {\n    const selector = abi_helpers_1.AbiHelpers.computeSelector(name, inputs);\n    if (selector !== undefined) {\n      return new CustomError(selector, name, inputs);\n    }\n  }\n}\nexports.CustomError = CustomError;\nclass Instruction {\n  constructor(pc, opcode, jumpType, pushData, location) {\n    this.pc = pc;\n    this.opcode = opcode;\n    this.jumpType = jumpType;\n    this.pushData = pushData;\n    this.location = location;\n  }\n}\nexports.Instruction = Instruction;\nclass Bytecode {\n  constructor(contract, isDeployment, normalizedCode, instructions, libraryAddressPositions, immutableReferences, compilerVersion) {\n    this.contract = contract;\n    this.isDeployment = isDeployment;\n    this.normalizedCode = normalizedCode;\n    this.instructions = instructions;\n    this.libraryAddressPositions = libraryAddressPositions;\n    this.immutableReferences = immutableReferences;\n    this.compilerVersion = compilerVersion;\n    this._pcToInstruction = new Map();\n    for (const inst of instructions) {\n      this._pcToInstruction.set(inst.pc, inst);\n    }\n  }\n  getInstruction(pc) {\n    const inst = this._pcToInstruction.get(pc);\n    if (inst === undefined) {\n      throw new Error(`There's no instruction at pc ${pc}`);\n    }\n    return inst;\n  }\n  hasInstruction(pc) {\n    return this._pcToInstruction.has(pc);\n  }\n}\nexports.Bytecode = Bytecode;","map":{"version":3,"mappings":"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","names":["JumpType","exports","ContractType","ContractFunctionType","ContractFunctionVisibility","SourceFile","constructor","sourceName","content","addContract","contract","location","file","Error","contracts","push","addFunction","func","functions","getContainingFunction","contains","undefined","SourceLocation","offset","length","getStartingLineNumber","_line","c","slice","other","equals","Contract","name","type","Map","constructorFunction","_constructor","fallback","_fallback","receive","_receive","addLocalFunction","visibility","PUBLIC","EXTERNAL","FUNCTION","GETTER","_selectorHexToFunction","set","selector","CONSTRUCTOR","FALLBACK","RECEIVE","localFunctions","addCustomError","customError","customErrors","addNextLinearizedBaseContract","baseContract","baseContractFunction","selectorHex","has","getFunctionFromSelector","get","correctSelector","functionName","Array","from","values","filter","cf","functionToCorrect","delete","ContractFunction","isPayable","CustomError","paramTypes","fromABI","inputs","abi_helpers_1","computeSelector","Instruction","pc","opcode","jumpType","pushData","Bytecode","isDeployment","normalizedCode","instructions","libraryAddressPositions","immutableReferences","compilerVersion","inst","_pcToInstruction","getInstruction","hasInstruction"],"sources":["/Users/janrobel/Documents/PersonalProjekty/nftGenerateAi/clientAndContract/node_modules/hardhat/src/internal/hardhat-network/stack-traces/model.ts"],"sourcesContent":["import { bufferToHex } from \"@nomicfoundation/ethereumjs-util\";\n\nimport { AbiHelpers } from \"../../util/abi-helpers\";\n\nimport { Opcode } from \"./opcodes\";\n\n/* eslint-disable @nomiclabs/hardhat-internal-rules/only-hardhat-error */\n\nexport enum JumpType {\n  NOT_JUMP,\n  INTO_FUNCTION,\n  OUTOF_FUNCTION,\n  INTERNAL_JUMP,\n}\n\nexport enum ContractType {\n  CONTRACT,\n  LIBRARY,\n}\n\nexport enum ContractFunctionType {\n  CONSTRUCTOR,\n  FUNCTION,\n  FALLBACK,\n  RECEIVE,\n  GETTER,\n  MODIFIER,\n  FREE_FUNCTION,\n}\n\nexport enum ContractFunctionVisibility {\n  PRIVATE,\n  INTERNAL,\n  PUBLIC,\n  EXTERNAL,\n}\n\nexport class SourceFile {\n  public readonly contracts: Contract[] = [];\n  public readonly functions: ContractFunction[] = [];\n\n  constructor(\n    public readonly sourceName: string,\n    public readonly content: string\n  ) {}\n\n  public addContract(contract: Contract) {\n    if (contract.location.file !== this) {\n      throw new Error(\"Trying to add a contract from another file\");\n    }\n\n    this.contracts.push(contract);\n  }\n\n  public addFunction(func: ContractFunction) {\n    if (func.location.file !== this) {\n      throw new Error(\"Trying to add a function from another file\");\n    }\n\n    this.functions.push(func);\n  }\n\n  public getContainingFunction(\n    location: SourceLocation\n  ): ContractFunction | undefined {\n    // TODO: Optimize this with a binary search or an internal tree\n\n    for (const func of this.functions) {\n      if (func.location.contains(location)) {\n        return func;\n      }\n    }\n\n    return undefined;\n  }\n}\n\nexport class SourceLocation {\n  private _line: number | undefined;\n\n  constructor(\n    public readonly file: SourceFile,\n    public readonly offset: number,\n    public readonly length: number\n  ) {}\n\n  public getStartingLineNumber(): number {\n    if (this._line === undefined) {\n      this._line = 1;\n\n      for (const c of this.file.content.slice(0, this.offset)) {\n        if (c === \"\\n\") {\n          this._line += 1;\n        }\n      }\n    }\n\n    return this._line;\n  }\n\n  public getContainingFunction(): ContractFunction | undefined {\n    return this.file.getContainingFunction(this);\n  }\n\n  public contains(other: SourceLocation) {\n    if (this.file !== other.file) {\n      return false;\n    }\n\n    if (other.offset < this.offset) {\n      return false;\n    }\n\n    return other.offset + other.length <= this.offset + this.length;\n  }\n\n  public equals(other: SourceLocation) {\n    return (\n      this.file === other.file &&\n      this.offset === other.offset &&\n      this.length === other.length\n    );\n  }\n}\n\nexport class Contract {\n  public readonly localFunctions: ContractFunction[] = [];\n  public readonly customErrors: CustomError[] = [];\n\n  private _constructor: ContractFunction | undefined;\n  private _fallback: ContractFunction | undefined;\n  private _receive: ContractFunction | undefined;\n  private readonly _selectorHexToFunction: Map<string, ContractFunction> =\n    new Map();\n\n  constructor(\n    public readonly name: string,\n    public readonly type: ContractType,\n    public readonly location: SourceLocation\n  ) {}\n\n  public get constructorFunction(): ContractFunction | undefined {\n    return this._constructor;\n  }\n\n  public get fallback(): ContractFunction | undefined {\n    return this._fallback;\n  }\n\n  public get receive(): ContractFunction | undefined {\n    return this._receive;\n  }\n\n  public addLocalFunction(func: ContractFunction) {\n    if (func.contract !== this) {\n      throw new Error(\"Function isn't local\");\n    }\n\n    if (\n      func.visibility === ContractFunctionVisibility.PUBLIC ||\n      func.visibility === ContractFunctionVisibility.EXTERNAL\n    ) {\n      if (\n        func.type === ContractFunctionType.FUNCTION ||\n        func.type === ContractFunctionType.GETTER\n      ) {\n        this._selectorHexToFunction.set(bufferToHex(func.selector!), func);\n      } else if (func.type === ContractFunctionType.CONSTRUCTOR) {\n        this._constructor = func;\n      } else if (func.type === ContractFunctionType.FALLBACK) {\n        this._fallback = func;\n      } else if (func.type === ContractFunctionType.RECEIVE) {\n        this._receive = func;\n      }\n    }\n\n    this.localFunctions.push(func);\n  }\n\n  public addCustomError(customError: CustomError) {\n    this.customErrors.push(customError);\n  }\n\n  public addNextLinearizedBaseContract(baseContract: Contract) {\n    if (this._fallback === undefined && baseContract._fallback !== undefined) {\n      this._fallback = baseContract._fallback;\n    }\n    if (this._receive === undefined && baseContract._receive !== undefined) {\n      this._receive = baseContract._receive;\n    }\n\n    for (const baseContractFunction of baseContract.localFunctions) {\n      if (\n        baseContractFunction.type !== ContractFunctionType.GETTER &&\n        baseContractFunction.type !== ContractFunctionType.FUNCTION\n      ) {\n        continue;\n      }\n\n      if (\n        baseContractFunction.visibility !== ContractFunctionVisibility.PUBLIC &&\n        baseContractFunction.visibility !== ContractFunctionVisibility.EXTERNAL\n      ) {\n        continue;\n      }\n\n      const selectorHex = bufferToHex(baseContractFunction.selector!);\n      if (!this._selectorHexToFunction.has(selectorHex)) {\n        this._selectorHexToFunction.set(selectorHex, baseContractFunction);\n      }\n    }\n  }\n\n  public getFunctionFromSelector(\n    selector: Buffer\n  ): ContractFunction | undefined {\n    return this._selectorHexToFunction.get(bufferToHex(selector));\n  }\n\n  /**\n   * We compute selectors manually, which is particularly hard. We do this\n   * because we need to map selectors to AST nodes, and it seems easier to start\n   * from the AST node. This is surprisingly super hard: things like inherited\n   * enums, structs and ABIv2 complicate it.\n   *\n   * As we know that that can fail, we run a heuristic that tries to correct\n   * incorrect selectors. What it does is checking the `evm.methodIdentifiers`\n   * compiler output, and detect missing selectors. Then we take those and\n   * find contract functions with the same name. If there are multiple of those\n   * we can't do anything. If there is a single one, it must have an incorrect\n   * selector, so we update it with the `evm.methodIdentifiers`'s value.\n   */\n  public correctSelector(functionName: string, selector: Buffer): boolean {\n    const functions = Array.from(this._selectorHexToFunction.values()).filter(\n      (cf) => cf.name === functionName\n    );\n\n    if (functions.length !== 1) {\n      return false;\n    }\n\n    const functionToCorrect = functions[0];\n\n    if (functionToCorrect.selector !== undefined) {\n      this._selectorHexToFunction.delete(\n        bufferToHex(functionToCorrect.selector)\n      );\n    }\n\n    functionToCorrect.selector = selector;\n    this._selectorHexToFunction.set(bufferToHex(selector), functionToCorrect);\n    return true;\n  }\n}\n\nexport class ContractFunction {\n  constructor(\n    public readonly name: string,\n    public readonly type: ContractFunctionType,\n    public readonly location: SourceLocation,\n    public readonly contract?: Contract,\n    public readonly visibility?: ContractFunctionVisibility,\n    public readonly isPayable?: boolean,\n    public selector?: Buffer\n  ) {\n    if (contract !== undefined && !contract.location.contains(location)) {\n      throw new Error(\"Incompatible contract and function location\");\n    }\n  }\n}\n\nexport class CustomError {\n  /**\n   * Return a CustomError from the given ABI information: the name\n   * of the error and its inputs. Returns undefined if it can't build\n   * the CustomError.\n   */\n  public static fromABI(name: string, inputs: any[]): CustomError | undefined {\n    const selector = AbiHelpers.computeSelector(name, inputs);\n\n    if (selector !== undefined) {\n      return new CustomError(selector, name, inputs);\n    }\n  }\n\n  private constructor(\n    public readonly selector: Buffer,\n    public readonly name: string,\n    public readonly paramTypes: any[]\n  ) {}\n}\n\nexport class Instruction {\n  constructor(\n    public readonly pc: number,\n    public readonly opcode: Opcode,\n    public readonly jumpType: JumpType,\n    public readonly pushData?: Buffer,\n    public readonly location?: SourceLocation\n  ) {}\n}\n\ninterface ImmutableReference {\n  start: number;\n  length: number;\n}\n\nexport class Bytecode {\n  private readonly _pcToInstruction: Map<number, Instruction> = new Map();\n\n  constructor(\n    public readonly contract: Contract,\n    public readonly isDeployment: boolean,\n    public readonly normalizedCode: Buffer,\n    public readonly instructions: Instruction[],\n    public readonly libraryAddressPositions: number[],\n    public readonly immutableReferences: ImmutableReference[],\n    public readonly compilerVersion: string\n  ) {\n    for (const inst of instructions) {\n      this._pcToInstruction.set(inst.pc, inst);\n    }\n  }\n\n  public getInstruction(pc: number): Instruction {\n    const inst = this._pcToInstruction.get(pc);\n\n    if (inst === undefined) {\n      throw new Error(`There's no instruction at pc ${pc}`);\n    }\n\n    return inst;\n  }\n\n  public hasInstruction(pc: number): boolean {\n    return this._pcToInstruction.has(pc);\n  }\n}\n"]},"metadata":{},"sourceType":"script","externalDependencies":[]}