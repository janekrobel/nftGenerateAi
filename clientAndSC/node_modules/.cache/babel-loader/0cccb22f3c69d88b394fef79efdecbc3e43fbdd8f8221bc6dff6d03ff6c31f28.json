{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.createEsmHooks = exports.registerAndCreateEsmHooks = exports.filterHooksByAPIVersion = void 0;\nconst index_1 = require(\"./index\");\nconst url_1 = require(\"url\");\nconst path_1 = require(\"path\");\nconst assert = require(\"assert\");\nconst util_1 = require(\"./util\");\nconst module_1 = require(\"module\");\n// The hooks API changed in node version X so we need to check for backwards compatibility.\nconst newHooksAPI = (0, util_1.versionGteLt)(process.versions.node, '16.12.0');\n/** @internal */\nfunction filterHooksByAPIVersion(hooks) {\n  const {\n    getFormat,\n    load,\n    resolve,\n    transformSource\n  } = hooks;\n  // Explicit return type to avoid TS's non-ideal inferred type\n  const hooksAPI = newHooksAPI ? {\n    resolve,\n    load,\n    getFormat: undefined,\n    transformSource: undefined\n  } : {\n    resolve,\n    getFormat,\n    transformSource,\n    load: undefined\n  };\n  return hooksAPI;\n}\nexports.filterHooksByAPIVersion = filterHooksByAPIVersion;\n/** @internal */\nfunction registerAndCreateEsmHooks(opts) {\n  // Automatically performs registration just like `-r ts-node/register`\n  const tsNodeInstance = (0, index_1.register)(opts);\n  return createEsmHooks(tsNodeInstance);\n}\nexports.registerAndCreateEsmHooks = registerAndCreateEsmHooks;\nfunction createEsmHooks(tsNodeService) {\n  tsNodeService.enableExperimentalEsmLoaderInterop();\n  // Custom implementation that considers additional file extensions and automatically adds file extensions\n  const nodeResolveImplementation = tsNodeService.getNodeEsmResolver();\n  const nodeGetFormatImplementation = tsNodeService.getNodeEsmGetFormat();\n  const extensions = tsNodeService.extensions;\n  const hooksAPI = filterHooksByAPIVersion({\n    resolve,\n    load,\n    getFormat,\n    transformSource\n  });\n  function isFileUrlOrNodeStyleSpecifier(parsed) {\n    // We only understand file:// URLs, but in node, the specifier can be a node-style `./foo` or `foo`\n    const {\n      protocol\n    } = parsed;\n    return protocol === null || protocol === 'file:';\n  }\n  /**\n   * Named \"probably\" as a reminder that this is a guess.\n   * node does not explicitly tell us if we're resolving the entrypoint or not.\n   */\n  function isProbablyEntrypoint(specifier, parentURL) {\n    return parentURL === undefined && specifier.startsWith('file://');\n  }\n  // Side-channel between `resolve()` and `load()` hooks\n  const rememberIsProbablyEntrypoint = new Set();\n  const rememberResolvedViaCommonjsFallback = new Set();\n  async function resolve(specifier, context, defaultResolve) {\n    const defer = async () => {\n      const r = await defaultResolve(specifier, context, defaultResolve);\n      return r;\n    };\n    // See: https://github.com/nodejs/node/discussions/41711\n    // nodejs will likely implement a similar fallback.  Till then, we can do our users a favor and fallback today.\n    async function entrypointFallback(cb) {\n      try {\n        const resolution = await cb();\n        if ((resolution === null || resolution === void 0 ? void 0 : resolution.url) && isProbablyEntrypoint(specifier, context.parentURL)) rememberIsProbablyEntrypoint.add(resolution.url);\n        return resolution;\n      } catch (esmResolverError) {\n        if (!isProbablyEntrypoint(specifier, context.parentURL)) throw esmResolverError;\n        try {\n          let cjsSpecifier = specifier;\n          // Attempt to convert from ESM file:// to CommonJS path\n          try {\n            if (specifier.startsWith('file://')) cjsSpecifier = (0, url_1.fileURLToPath)(specifier);\n          } catch {}\n          const resolution = (0, url_1.pathToFileURL)((0, module_1.createRequire)(process.cwd()).resolve(cjsSpecifier)).toString();\n          rememberIsProbablyEntrypoint.add(resolution);\n          rememberResolvedViaCommonjsFallback.add(resolution);\n          return {\n            url: resolution,\n            format: 'commonjs'\n          };\n        } catch (commonjsResolverError) {\n          throw esmResolverError;\n        }\n      }\n    }\n    return addShortCircuitFlag(async () => {\n      const parsed = (0, url_1.parse)(specifier);\n      const {\n        pathname,\n        protocol,\n        hostname\n      } = parsed;\n      if (!isFileUrlOrNodeStyleSpecifier(parsed)) {\n        return entrypointFallback(defer);\n      }\n      if (protocol !== null && protocol !== 'file:') {\n        return entrypointFallback(defer);\n      }\n      // Malformed file:// URL?  We should always see `null` or `''`\n      if (hostname) {\n        // TODO file://./foo sets `hostname` to `'.'`.  Perhaps we should special-case this.\n        return entrypointFallback(defer);\n      }\n      // pathname is the path to be resolved\n      return entrypointFallback(() => nodeResolveImplementation.defaultResolve(specifier, context, defaultResolve));\n    });\n  }\n  // `load` from new loader hook API (See description at the top of this file)\n  async function load(url, context, defaultLoad) {\n    return addShortCircuitFlag(async () => {\n      var _a;\n      // If we get a format hint from resolve() on the context then use it\n      // otherwise call the old getFormat() hook using node's old built-in defaultGetFormat() that ships with ts-node\n      const format = (_a = context.format) !== null && _a !== void 0 ? _a : (await getFormat(url, context, nodeGetFormatImplementation.defaultGetFormat)).format;\n      let source = undefined;\n      if (format !== 'builtin' && format !== 'commonjs') {\n        // Call the new defaultLoad() to get the source\n        const {\n          source: rawSource\n        } = await defaultLoad(url, {\n          ...context,\n          format\n        }, defaultLoad);\n        if (rawSource === undefined || rawSource === null) {\n          throw new Error(`Failed to load raw source: Format was '${format}' and url was '${url}''.`);\n        }\n        // Emulate node's built-in old defaultTransformSource() so we can re-use the old transformSource() hook\n        const defaultTransformSource = async (source, _context, _defaultTransformSource) => ({\n          source\n        });\n        // Call the old hook\n        const {\n          source: transformedSource\n        } = await transformSource(rawSource, {\n          url,\n          format\n        }, defaultTransformSource);\n        source = transformedSource;\n      }\n      return {\n        format,\n        source\n      };\n    });\n  }\n  async function getFormat(url, context, defaultGetFormat) {\n    const defer = function () {\n      let overrideUrl = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : url;\n      return defaultGetFormat(overrideUrl, context, defaultGetFormat);\n    };\n    // See: https://github.com/nodejs/node/discussions/41711\n    // nodejs will likely implement a similar fallback.  Till then, we can do our users a favor and fallback today.\n    async function entrypointFallback(cb) {\n      try {\n        return await cb();\n      } catch (getFormatError) {\n        if (!rememberIsProbablyEntrypoint.has(url)) throw getFormatError;\n        return {\n          format: 'commonjs'\n        };\n      }\n    }\n    const parsed = (0, url_1.parse)(url);\n    if (!isFileUrlOrNodeStyleSpecifier(parsed)) {\n      return entrypointFallback(defer);\n    }\n    const {\n      pathname\n    } = parsed;\n    assert(pathname !== null, 'ESM getFormat() hook: URL should never have null pathname');\n    const nativePath = (0, url_1.fileURLToPath)(url);\n    let nodeSays;\n    // If file has extension not understood by node, then ask node how it would treat the emitted extension.\n    // E.g. .mts compiles to .mjs, so ask node how to classify an .mjs file.\n    const ext = (0, path_1.extname)(nativePath);\n    const tsNodeIgnored = tsNodeService.ignored(nativePath);\n    const nodeEquivalentExt = extensions.nodeEquivalents.get(ext);\n    if (nodeEquivalentExt && !tsNodeIgnored) {\n      nodeSays = await entrypointFallback(() => defer((0, url_1.format)((0, url_1.pathToFileURL)(nativePath + nodeEquivalentExt))));\n    } else {\n      try {\n        nodeSays = await entrypointFallback(defer);\n      } catch (e) {\n        if (e instanceof Error && tsNodeIgnored && extensions.nodeDoesNotUnderstand.includes(ext)) {\n          e.message += `\\n\\n` + `Hint:\\n` + `ts-node is configured to ignore this file.\\n` + `If you want ts-node to handle this file, consider enabling the \"skipIgnore\" option or adjusting your \"ignore\" patterns.\\n` + `https://typestrong.org/ts-node/docs/scope\\n`;\n        }\n        throw e;\n      }\n    }\n    // For files compiled by ts-node that node believes are either CJS or ESM, check if we should override that classification\n    if (!tsNodeService.ignored(nativePath) && (nodeSays.format === 'commonjs' || nodeSays.format === 'module')) {\n      const {\n        moduleType\n      } = tsNodeService.moduleTypeClassifier.classifyModuleByModuleTypeOverrides((0, util_1.normalizeSlashes)(nativePath));\n      if (moduleType === 'cjs') {\n        return {\n          format: 'commonjs'\n        };\n      } else if (moduleType === 'esm') {\n        return {\n          format: 'module'\n        };\n      }\n    }\n    return nodeSays;\n  }\n  async function transformSource(source, context, defaultTransformSource) {\n    if (source === null || source === undefined) {\n      throw new Error('No source');\n    }\n    const defer = () => defaultTransformSource(source, context, defaultTransformSource);\n    const sourceAsString = typeof source === 'string' ? source : source.toString('utf8');\n    const {\n      url\n    } = context;\n    const parsed = (0, url_1.parse)(url);\n    if (!isFileUrlOrNodeStyleSpecifier(parsed)) {\n      return defer();\n    }\n    const nativePath = (0, url_1.fileURLToPath)(url);\n    if (tsNodeService.ignored(nativePath)) {\n      return defer();\n    }\n    const emittedJs = tsNodeService.compile(sourceAsString, nativePath);\n    return {\n      source: emittedJs\n    };\n  }\n  return hooksAPI;\n}\nexports.createEsmHooks = createEsmHooks;\nasync function addShortCircuitFlag(fn) {\n  const ret = await fn();\n  // Not sure if this is necessary; being lazy.  Can revisit in the future.\n  if (ret == null) return ret;\n  return {\n    ...ret,\n    shortCircuit: true\n  };\n}","map":{"version":3,"mappings":"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","names":["newHooksAPI","process","versions","node","filterHooksByAPIVersion","hooks","getFormat","load","resolve","transformSource","hooksAPI","undefined","exports","registerAndCreateEsmHooks","opts","tsNodeInstance","createEsmHooks","tsNodeService","enableExperimentalEsmLoaderInterop","nodeResolveImplementation","getNodeEsmResolver","nodeGetFormatImplementation","getNodeEsmGetFormat","extensions","isFileUrlOrNodeStyleSpecifier","parsed","protocol","isProbablyEntrypoint","specifier","parentURL","startsWith","rememberIsProbablyEntrypoint","Set","rememberResolvedViaCommonjsFallback","context","defaultResolve","defer","r","entrypointFallback","cb","resolution","url","add","esmResolverError","cjsSpecifier","cwd","toString","format","commonjsResolverError","addShortCircuitFlag","pathname","hostname","defaultLoad","defaultGetFormat","source","rawSource","Error","defaultTransformSource","_context","_defaultTransformSource","transformedSource","overrideUrl","getFormatError","has","assert","nativePath","nodeSays","ext","tsNodeIgnored","ignored","nodeEquivalentExt","nodeEquivalents","get","e","nodeDoesNotUnderstand","includes","message","moduleType","moduleTypeClassifier","classifyModuleByModuleTypeOverrides","sourceAsString","emittedJs","compile","fn","ret","shortCircuit"],"sources":["/Users/janrobel/Documents/PersonalProjekty/nftGenerateAi/clientAndContract/node_modules/ts-node/src/esm.ts"],"sourcesContent":["import { register, RegisterOptions, Service } from './index';\nimport {\n  parse as parseUrl,\n  format as formatUrl,\n  UrlWithStringQuery,\n  fileURLToPath,\n  pathToFileURL,\n} from 'url';\nimport { extname } from 'path';\nimport * as assert from 'assert';\nimport { normalizeSlashes, versionGteLt } from './util';\nimport { createRequire } from 'module';\n\n// Note: On Windows, URLs look like this: file:///D:/dev/@TypeStrong/ts-node-examples/foo.ts\n\n// NOTE ABOUT MULTIPLE EXPERIMENTAL LOADER APIS\n//\n// At the time of writing, this file implements 2x different loader APIs.\n// Node made a breaking change to the loader API in https://github.com/nodejs/node/pull/37468\n//\n// We check the node version number and export either the *old* or the *new* API.\n//\n// Today, we are implementing the *new* API on top of our implementation of the *old* API,\n// which relies on copy-pasted code from the *old* hooks implementation in node.\n//\n// In the future, we will likely invert this: we will copy-paste the *new* API implementation\n// from node, build our implementation of the *new* API on top of it, and implement the *old*\n// hooks API as a shim to the *new* API.\n\nexport interface NodeLoaderHooksAPI1 {\n  resolve: NodeLoaderHooksAPI1.ResolveHook;\n  getFormat: NodeLoaderHooksAPI1.GetFormatHook;\n  transformSource: NodeLoaderHooksAPI1.TransformSourceHook;\n}\nexport namespace NodeLoaderHooksAPI1 {\n  export type ResolveHook = NodeLoaderHooksAPI2.ResolveHook;\n  export type GetFormatHook = (\n    url: string,\n    context: {},\n    defaultGetFormat: GetFormatHook\n  ) => Promise<{ format: NodeLoaderHooksFormat }>;\n  export type TransformSourceHook = (\n    source: string | Buffer,\n    context: { url: string; format: NodeLoaderHooksFormat },\n    defaultTransformSource: NodeLoaderHooksAPI1.TransformSourceHook\n  ) => Promise<{ source: string | Buffer }>;\n}\n\nexport interface NodeLoaderHooksAPI2 {\n  resolve: NodeLoaderHooksAPI2.ResolveHook;\n  load: NodeLoaderHooksAPI2.LoadHook;\n}\nexport namespace NodeLoaderHooksAPI2 {\n  export type ResolveHook = (\n    specifier: string,\n    context: {\n      conditions?: NodeImportConditions;\n      importAssertions?: NodeImportAssertions;\n      parentURL: string;\n    },\n    defaultResolve: ResolveHook\n  ) => Promise<{\n    url: string;\n    format?: NodeLoaderHooksFormat;\n    shortCircuit?: boolean;\n  }>;\n  export type LoadHook = (\n    url: string,\n    context: {\n      format: NodeLoaderHooksFormat | null | undefined;\n      importAssertions?: NodeImportAssertions;\n    },\n    defaultLoad: NodeLoaderHooksAPI2['load']\n  ) => Promise<{\n    format: NodeLoaderHooksFormat;\n    source: string | Buffer | undefined;\n    shortCircuit?: boolean;\n  }>;\n  export type NodeImportConditions = unknown;\n  export interface NodeImportAssertions {\n    type?: 'json';\n  }\n}\n\nexport type NodeLoaderHooksFormat =\n  | 'builtin'\n  | 'commonjs'\n  | 'dynamic'\n  | 'json'\n  | 'module'\n  | 'wasm';\n\nexport type NodeImportConditions = unknown;\nexport interface NodeImportAssertions {\n  type?: 'json';\n}\n\n// The hooks API changed in node version X so we need to check for backwards compatibility.\nconst newHooksAPI = versionGteLt(process.versions.node, '16.12.0');\n\n/** @internal */\nexport function filterHooksByAPIVersion(\n  hooks: NodeLoaderHooksAPI1 & NodeLoaderHooksAPI2\n): NodeLoaderHooksAPI1 | NodeLoaderHooksAPI2 {\n  const { getFormat, load, resolve, transformSource } = hooks;\n  // Explicit return type to avoid TS's non-ideal inferred type\n  const hooksAPI: NodeLoaderHooksAPI1 | NodeLoaderHooksAPI2 = newHooksAPI\n    ? { resolve, load, getFormat: undefined, transformSource: undefined }\n    : { resolve, getFormat, transformSource, load: undefined };\n  return hooksAPI;\n}\n\n/** @internal */\nexport function registerAndCreateEsmHooks(opts?: RegisterOptions) {\n  // Automatically performs registration just like `-r ts-node/register`\n  const tsNodeInstance = register(opts);\n\n  return createEsmHooks(tsNodeInstance);\n}\n\nexport function createEsmHooks(tsNodeService: Service) {\n  tsNodeService.enableExperimentalEsmLoaderInterop();\n\n  // Custom implementation that considers additional file extensions and automatically adds file extensions\n  const nodeResolveImplementation = tsNodeService.getNodeEsmResolver();\n  const nodeGetFormatImplementation = tsNodeService.getNodeEsmGetFormat();\n  const extensions = tsNodeService.extensions;\n\n  const hooksAPI = filterHooksByAPIVersion({\n    resolve,\n    load,\n    getFormat,\n    transformSource,\n  });\n\n  function isFileUrlOrNodeStyleSpecifier(parsed: UrlWithStringQuery) {\n    // We only understand file:// URLs, but in node, the specifier can be a node-style `./foo` or `foo`\n    const { protocol } = parsed;\n    return protocol === null || protocol === 'file:';\n  }\n\n  /**\n   * Named \"probably\" as a reminder that this is a guess.\n   * node does not explicitly tell us if we're resolving the entrypoint or not.\n   */\n  function isProbablyEntrypoint(specifier: string, parentURL: string) {\n    return parentURL === undefined && specifier.startsWith('file://');\n  }\n  // Side-channel between `resolve()` and `load()` hooks\n  const rememberIsProbablyEntrypoint = new Set();\n  const rememberResolvedViaCommonjsFallback = new Set();\n\n  async function resolve(\n    specifier: string,\n    context: { parentURL: string },\n    defaultResolve: typeof resolve\n  ): Promise<{ url: string; format?: NodeLoaderHooksFormat }> {\n    const defer = async () => {\n      const r = await defaultResolve(specifier, context, defaultResolve);\n      return r;\n    };\n    // See: https://github.com/nodejs/node/discussions/41711\n    // nodejs will likely implement a similar fallback.  Till then, we can do our users a favor and fallback today.\n    async function entrypointFallback(\n      cb: () => ReturnType<typeof resolve> | Awaited<ReturnType<typeof resolve>>\n    ): ReturnType<typeof resolve> {\n      try {\n        const resolution = await cb();\n        if (\n          resolution?.url &&\n          isProbablyEntrypoint(specifier, context.parentURL)\n        )\n          rememberIsProbablyEntrypoint.add(resolution.url);\n        return resolution;\n      } catch (esmResolverError) {\n        if (!isProbablyEntrypoint(specifier, context.parentURL))\n          throw esmResolverError;\n        try {\n          let cjsSpecifier = specifier;\n          // Attempt to convert from ESM file:// to CommonJS path\n          try {\n            if (specifier.startsWith('file://'))\n              cjsSpecifier = fileURLToPath(specifier);\n          } catch {}\n          const resolution = pathToFileURL(\n            createRequire(process.cwd()).resolve(cjsSpecifier)\n          ).toString();\n          rememberIsProbablyEntrypoint.add(resolution);\n          rememberResolvedViaCommonjsFallback.add(resolution);\n          return { url: resolution, format: 'commonjs' };\n        } catch (commonjsResolverError) {\n          throw esmResolverError;\n        }\n      }\n    }\n\n    return addShortCircuitFlag(async () => {\n      const parsed = parseUrl(specifier);\n      const { pathname, protocol, hostname } = parsed;\n\n      if (!isFileUrlOrNodeStyleSpecifier(parsed)) {\n        return entrypointFallback(defer);\n      }\n\n      if (protocol !== null && protocol !== 'file:') {\n        return entrypointFallback(defer);\n      }\n\n      // Malformed file:// URL?  We should always see `null` or `''`\n      if (hostname) {\n        // TODO file://./foo sets `hostname` to `'.'`.  Perhaps we should special-case this.\n        return entrypointFallback(defer);\n      }\n\n      // pathname is the path to be resolved\n\n      return entrypointFallback(() =>\n        nodeResolveImplementation.defaultResolve(\n          specifier,\n          context,\n          defaultResolve\n        )\n      );\n    });\n  }\n\n  // `load` from new loader hook API (See description at the top of this file)\n  async function load(\n    url: string,\n    context: {\n      format: NodeLoaderHooksFormat | null | undefined;\n      importAssertions?: NodeLoaderHooksAPI2.NodeImportAssertions;\n    },\n    defaultLoad: typeof load\n  ): Promise<{\n    format: NodeLoaderHooksFormat;\n    source: string | Buffer | undefined;\n  }> {\n    return addShortCircuitFlag(async () => {\n      // If we get a format hint from resolve() on the context then use it\n      // otherwise call the old getFormat() hook using node's old built-in defaultGetFormat() that ships with ts-node\n      const format =\n        context.format ??\n        (\n          await getFormat(\n            url,\n            context,\n            nodeGetFormatImplementation.defaultGetFormat\n          )\n        ).format;\n\n      let source = undefined;\n      if (format !== 'builtin' && format !== 'commonjs') {\n        // Call the new defaultLoad() to get the source\n        const { source: rawSource } = await defaultLoad(\n          url,\n          {\n            ...context,\n            format,\n          },\n          defaultLoad\n        );\n\n        if (rawSource === undefined || rawSource === null) {\n          throw new Error(\n            `Failed to load raw source: Format was '${format}' and url was '${url}''.`\n          );\n        }\n\n        // Emulate node's built-in old defaultTransformSource() so we can re-use the old transformSource() hook\n        const defaultTransformSource: typeof transformSource = async (\n          source,\n          _context,\n          _defaultTransformSource\n        ) => ({ source });\n\n        // Call the old hook\n        const { source: transformedSource } = await transformSource(\n          rawSource,\n          { url, format },\n          defaultTransformSource\n        );\n        source = transformedSource;\n      }\n\n      return { format, source };\n    });\n  }\n\n  async function getFormat(\n    url: string,\n    context: {},\n    defaultGetFormat: typeof getFormat\n  ): Promise<{ format: NodeLoaderHooksFormat }> {\n    const defer = (overrideUrl: string = url) =>\n      defaultGetFormat(overrideUrl, context, defaultGetFormat);\n\n    // See: https://github.com/nodejs/node/discussions/41711\n    // nodejs will likely implement a similar fallback.  Till then, we can do our users a favor and fallback today.\n    async function entrypointFallback(\n      cb: () => ReturnType<typeof getFormat>\n    ): ReturnType<typeof getFormat> {\n      try {\n        return await cb();\n      } catch (getFormatError) {\n        if (!rememberIsProbablyEntrypoint.has(url)) throw getFormatError;\n        return { format: 'commonjs' };\n      }\n    }\n\n    const parsed = parseUrl(url);\n\n    if (!isFileUrlOrNodeStyleSpecifier(parsed)) {\n      return entrypointFallback(defer);\n    }\n\n    const { pathname } = parsed;\n    assert(\n      pathname !== null,\n      'ESM getFormat() hook: URL should never have null pathname'\n    );\n\n    const nativePath = fileURLToPath(url);\n\n    let nodeSays: { format: NodeLoaderHooksFormat };\n\n    // If file has extension not understood by node, then ask node how it would treat the emitted extension.\n    // E.g. .mts compiles to .mjs, so ask node how to classify an .mjs file.\n    const ext = extname(nativePath);\n    const tsNodeIgnored = tsNodeService.ignored(nativePath);\n    const nodeEquivalentExt = extensions.nodeEquivalents.get(ext);\n    if (nodeEquivalentExt && !tsNodeIgnored) {\n      nodeSays = await entrypointFallback(() =>\n        defer(formatUrl(pathToFileURL(nativePath + nodeEquivalentExt)))\n      );\n    } else {\n      try {\n        nodeSays = await entrypointFallback(defer);\n      } catch (e) {\n        if (\n          e instanceof Error &&\n          tsNodeIgnored &&\n          extensions.nodeDoesNotUnderstand.includes(ext)\n        ) {\n          e.message +=\n            `\\n\\n` +\n            `Hint:\\n` +\n            `ts-node is configured to ignore this file.\\n` +\n            `If you want ts-node to handle this file, consider enabling the \"skipIgnore\" option or adjusting your \"ignore\" patterns.\\n` +\n            `https://typestrong.org/ts-node/docs/scope\\n`;\n        }\n        throw e;\n      }\n    }\n    // For files compiled by ts-node that node believes are either CJS or ESM, check if we should override that classification\n    if (\n      !tsNodeService.ignored(nativePath) &&\n      (nodeSays.format === 'commonjs' || nodeSays.format === 'module')\n    ) {\n      const { moduleType } =\n        tsNodeService.moduleTypeClassifier.classifyModuleByModuleTypeOverrides(\n          normalizeSlashes(nativePath)\n        );\n      if (moduleType === 'cjs') {\n        return { format: 'commonjs' };\n      } else if (moduleType === 'esm') {\n        return { format: 'module' };\n      }\n    }\n    return nodeSays;\n  }\n\n  async function transformSource(\n    source: string | Buffer,\n    context: { url: string; format: NodeLoaderHooksFormat },\n    defaultTransformSource: typeof transformSource\n  ): Promise<{ source: string | Buffer }> {\n    if (source === null || source === undefined) {\n      throw new Error('No source');\n    }\n\n    const defer = () =>\n      defaultTransformSource(source, context, defaultTransformSource);\n\n    const sourceAsString =\n      typeof source === 'string' ? source : source.toString('utf8');\n\n    const { url } = context;\n    const parsed = parseUrl(url);\n\n    if (!isFileUrlOrNodeStyleSpecifier(parsed)) {\n      return defer();\n    }\n    const nativePath = fileURLToPath(url);\n\n    if (tsNodeService.ignored(nativePath)) {\n      return defer();\n    }\n\n    const emittedJs = tsNodeService.compile(sourceAsString, nativePath);\n\n    return { source: emittedJs };\n  }\n\n  return hooksAPI;\n}\n\nasync function addShortCircuitFlag<T>(fn: () => Promise<T>) {\n  const ret = await fn();\n  // Not sure if this is necessary; being lazy.  Can revisit in the future.\n  if (ret == null) return ret;\n  return {\n    ...ret,\n    shortCircuit: true,\n  };\n}\n"]},"metadata":{},"sourceType":"script","externalDependencies":[]}