{"ast":null,"code":"/* eslint no-unused-vars: [\"error\", { \"varsIgnorePattern\": \"^Readable$\" }] */\n\n'use strict';\n\nconst EventEmitter = require('events');\nconst https = require('https');\nconst http = require('http');\nconst net = require('net');\nconst tls = require('tls');\nconst {\n  randomBytes,\n  createHash\n} = require('crypto');\nconst {\n  Readable\n} = require('stream');\nconst {\n  URL\n} = require('url');\nconst PerMessageDeflate = require('./permessage-deflate');\nconst Receiver = require('./receiver');\nconst Sender = require('./sender');\nconst {\n  BINARY_TYPES,\n  EMPTY_BUFFER,\n  GUID,\n  kForOnEventAttribute,\n  kListener,\n  kStatusCode,\n  kWebSocket,\n  NOOP\n} = require('./constants');\nconst {\n  EventTarget: {\n    addEventListener,\n    removeEventListener\n  }\n} = require('./event-target');\nconst {\n  format,\n  parse\n} = require('./extension');\nconst {\n  toBuffer\n} = require('./buffer-util');\nconst readyStates = ['CONNECTING', 'OPEN', 'CLOSING', 'CLOSED'];\nconst subprotocolRegex = /^[!#$%&'*+\\-.0-9A-Z^_`|a-z~]+$/;\nconst protocolVersions = [8, 13];\nconst closeTimeout = 30 * 1000;\n\n/**\n * Class representing a WebSocket.\n *\n * @extends EventEmitter\n */\nclass WebSocket extends EventEmitter {\n  /**\n   * Create a new `WebSocket`.\n   *\n   * @param {(String|URL)} address The URL to which to connect\n   * @param {(String|String[])} [protocols] The subprotocols\n   * @param {Object} [options] Connection options\n   */\n  constructor(address, protocols, options) {\n    super();\n    this._binaryType = BINARY_TYPES[0];\n    this._closeCode = 1006;\n    this._closeFrameReceived = false;\n    this._closeFrameSent = false;\n    this._closeMessage = EMPTY_BUFFER;\n    this._closeTimer = null;\n    this._extensions = {};\n    this._paused = false;\n    this._protocol = '';\n    this._readyState = WebSocket.CONNECTING;\n    this._receiver = null;\n    this._sender = null;\n    this._socket = null;\n    if (address !== null) {\n      this._bufferedAmount = 0;\n      this._isServer = false;\n      this._redirects = 0;\n      if (protocols === undefined) {\n        protocols = [];\n      } else if (!Array.isArray(protocols)) {\n        if (typeof protocols === 'object' && protocols !== null) {\n          options = protocols;\n          protocols = [];\n        } else {\n          protocols = [protocols];\n        }\n      }\n      initAsClient(this, address, protocols, options);\n    } else {\n      this._isServer = true;\n    }\n  }\n\n  /**\n   * This deviates from the WHATWG interface since ws doesn't support the\n   * required default \"blob\" type (instead we define a custom \"nodebuffer\"\n   * type).\n   *\n   * @type {String}\n   */\n  get binaryType() {\n    return this._binaryType;\n  }\n  set binaryType(type) {\n    if (!BINARY_TYPES.includes(type)) return;\n    this._binaryType = type;\n\n    //\n    // Allow to change `binaryType` on the fly.\n    //\n    if (this._receiver) this._receiver._binaryType = type;\n  }\n\n  /**\n   * @type {Number}\n   */\n  get bufferedAmount() {\n    if (!this._socket) return this._bufferedAmount;\n    return this._socket._writableState.length + this._sender._bufferedBytes;\n  }\n\n  /**\n   * @type {String}\n   */\n  get extensions() {\n    return Object.keys(this._extensions).join();\n  }\n\n  /**\n   * @type {Boolean}\n   */\n  get isPaused() {\n    return this._paused;\n  }\n\n  /**\n   * @type {Function}\n   */\n  /* istanbul ignore next */\n  get onclose() {\n    return null;\n  }\n\n  /**\n   * @type {Function}\n   */\n  /* istanbul ignore next */\n  get onerror() {\n    return null;\n  }\n\n  /**\n   * @type {Function}\n   */\n  /* istanbul ignore next */\n  get onopen() {\n    return null;\n  }\n\n  /**\n   * @type {Function}\n   */\n  /* istanbul ignore next */\n  get onmessage() {\n    return null;\n  }\n\n  /**\n   * @type {String}\n   */\n  get protocol() {\n    return this._protocol;\n  }\n\n  /**\n   * @type {Number}\n   */\n  get readyState() {\n    return this._readyState;\n  }\n\n  /**\n   * @type {String}\n   */\n  get url() {\n    return this._url;\n  }\n\n  /**\n   * Set up the socket and the internal resources.\n   *\n   * @param {(net.Socket|tls.Socket)} socket The network socket between the\n   *     server and client\n   * @param {Buffer} head The first packet of the upgraded stream\n   * @param {Object} options Options object\n   * @param {Function} [options.generateMask] The function used to generate the\n   *     masking key\n   * @param {Number} [options.maxPayload=0] The maximum allowed message size\n   * @param {Boolean} [options.skipUTF8Validation=false] Specifies whether or\n   *     not to skip UTF-8 validation for text and close messages\n   * @private\n   */\n  setSocket(socket, head, options) {\n    const receiver = new Receiver({\n      binaryType: this.binaryType,\n      extensions: this._extensions,\n      isServer: this._isServer,\n      maxPayload: options.maxPayload,\n      skipUTF8Validation: options.skipUTF8Validation\n    });\n    this._sender = new Sender(socket, this._extensions, options.generateMask);\n    this._receiver = receiver;\n    this._socket = socket;\n    receiver[kWebSocket] = this;\n    socket[kWebSocket] = this;\n    receiver.on('conclude', receiverOnConclude);\n    receiver.on('drain', receiverOnDrain);\n    receiver.on('error', receiverOnError);\n    receiver.on('message', receiverOnMessage);\n    receiver.on('ping', receiverOnPing);\n    receiver.on('pong', receiverOnPong);\n    socket.setTimeout(0);\n    socket.setNoDelay();\n    if (head.length > 0) socket.unshift(head);\n    socket.on('close', socketOnClose);\n    socket.on('data', socketOnData);\n    socket.on('end', socketOnEnd);\n    socket.on('error', socketOnError);\n    this._readyState = WebSocket.OPEN;\n    this.emit('open');\n  }\n\n  /**\n   * Emit the `'close'` event.\n   *\n   * @private\n   */\n  emitClose() {\n    if (!this._socket) {\n      this._readyState = WebSocket.CLOSED;\n      this.emit('close', this._closeCode, this._closeMessage);\n      return;\n    }\n    if (this._extensions[PerMessageDeflate.extensionName]) {\n      this._extensions[PerMessageDeflate.extensionName].cleanup();\n    }\n    this._receiver.removeAllListeners();\n    this._readyState = WebSocket.CLOSED;\n    this.emit('close', this._closeCode, this._closeMessage);\n  }\n\n  /**\n   * Start a closing handshake.\n   *\n   *          +----------+   +-----------+   +----------+\n   *     - - -|ws.close()|-->|close frame|-->|ws.close()|- - -\n   *    |     +----------+   +-----------+   +----------+     |\n   *          +----------+   +-----------+         |\n   * CLOSING  |ws.close()|<--|close frame|<--+-----+       CLOSING\n   *          +----------+   +-----------+   |\n   *    |           |                        |   +---+        |\n   *                +------------------------+-->|fin| - - - -\n   *    |         +---+                      |   +---+\n   *     - - - - -|fin|<---------------------+\n   *              +---+\n   *\n   * @param {Number} [code] Status code explaining why the connection is closing\n   * @param {(String|Buffer)} [data] The reason why the connection is\n   *     closing\n   * @public\n   */\n  close(code, data) {\n    if (this.readyState === WebSocket.CLOSED) return;\n    if (this.readyState === WebSocket.CONNECTING) {\n      const msg = 'WebSocket was closed before the connection was established';\n      return abortHandshake(this, this._req, msg);\n    }\n    if (this.readyState === WebSocket.CLOSING) {\n      if (this._closeFrameSent && (this._closeFrameReceived || this._receiver._writableState.errorEmitted)) {\n        this._socket.end();\n      }\n      return;\n    }\n    this._readyState = WebSocket.CLOSING;\n    this._sender.close(code, data, !this._isServer, err => {\n      //\n      // This error is handled by the `'error'` listener on the socket. We only\n      // want to know if the close frame has been sent here.\n      //\n      if (err) return;\n      this._closeFrameSent = true;\n      if (this._closeFrameReceived || this._receiver._writableState.errorEmitted) {\n        this._socket.end();\n      }\n    });\n\n    //\n    // Specify a timeout for the closing handshake to complete.\n    //\n    this._closeTimer = setTimeout(this._socket.destroy.bind(this._socket), closeTimeout);\n  }\n\n  /**\n   * Pause the socket.\n   *\n   * @public\n   */\n  pause() {\n    if (this.readyState === WebSocket.CONNECTING || this.readyState === WebSocket.CLOSED) {\n      return;\n    }\n    this._paused = true;\n    this._socket.pause();\n  }\n\n  /**\n   * Send a ping.\n   *\n   * @param {*} [data] The data to send\n   * @param {Boolean} [mask] Indicates whether or not to mask `data`\n   * @param {Function} [cb] Callback which is executed when the ping is sent\n   * @public\n   */\n  ping(data, mask, cb) {\n    if (this.readyState === WebSocket.CONNECTING) {\n      throw new Error('WebSocket is not open: readyState 0 (CONNECTING)');\n    }\n    if (typeof data === 'function') {\n      cb = data;\n      data = mask = undefined;\n    } else if (typeof mask === 'function') {\n      cb = mask;\n      mask = undefined;\n    }\n    if (typeof data === 'number') data = data.toString();\n    if (this.readyState !== WebSocket.OPEN) {\n      sendAfterClose(this, data, cb);\n      return;\n    }\n    if (mask === undefined) mask = !this._isServer;\n    this._sender.ping(data || EMPTY_BUFFER, mask, cb);\n  }\n\n  /**\n   * Send a pong.\n   *\n   * @param {*} [data] The data to send\n   * @param {Boolean} [mask] Indicates whether or not to mask `data`\n   * @param {Function} [cb] Callback which is executed when the pong is sent\n   * @public\n   */\n  pong(data, mask, cb) {\n    if (this.readyState === WebSocket.CONNECTING) {\n      throw new Error('WebSocket is not open: readyState 0 (CONNECTING)');\n    }\n    if (typeof data === 'function') {\n      cb = data;\n      data = mask = undefined;\n    } else if (typeof mask === 'function') {\n      cb = mask;\n      mask = undefined;\n    }\n    if (typeof data === 'number') data = data.toString();\n    if (this.readyState !== WebSocket.OPEN) {\n      sendAfterClose(this, data, cb);\n      return;\n    }\n    if (mask === undefined) mask = !this._isServer;\n    this._sender.pong(data || EMPTY_BUFFER, mask, cb);\n  }\n\n  /**\n   * Resume the socket.\n   *\n   * @public\n   */\n  resume() {\n    if (this.readyState === WebSocket.CONNECTING || this.readyState === WebSocket.CLOSED) {\n      return;\n    }\n    this._paused = false;\n    if (!this._receiver._writableState.needDrain) this._socket.resume();\n  }\n\n  /**\n   * Send a data message.\n   *\n   * @param {*} data The message to send\n   * @param {Object} [options] Options object\n   * @param {Boolean} [options.binary] Specifies whether `data` is binary or\n   *     text\n   * @param {Boolean} [options.compress] Specifies whether or not to compress\n   *     `data`\n   * @param {Boolean} [options.fin=true] Specifies whether the fragment is the\n   *     last one\n   * @param {Boolean} [options.mask] Specifies whether or not to mask `data`\n   * @param {Function} [cb] Callback which is executed when data is written out\n   * @public\n   */\n  send(data, options, cb) {\n    if (this.readyState === WebSocket.CONNECTING) {\n      throw new Error('WebSocket is not open: readyState 0 (CONNECTING)');\n    }\n    if (typeof options === 'function') {\n      cb = options;\n      options = {};\n    }\n    if (typeof data === 'number') data = data.toString();\n    if (this.readyState !== WebSocket.OPEN) {\n      sendAfterClose(this, data, cb);\n      return;\n    }\n    const opts = {\n      binary: typeof data !== 'string',\n      mask: !this._isServer,\n      compress: true,\n      fin: true,\n      ...options\n    };\n    if (!this._extensions[PerMessageDeflate.extensionName]) {\n      opts.compress = false;\n    }\n    this._sender.send(data || EMPTY_BUFFER, opts, cb);\n  }\n\n  /**\n   * Forcibly close the connection.\n   *\n   * @public\n   */\n  terminate() {\n    if (this.readyState === WebSocket.CLOSED) return;\n    if (this.readyState === WebSocket.CONNECTING) {\n      const msg = 'WebSocket was closed before the connection was established';\n      return abortHandshake(this, this._req, msg);\n    }\n    if (this._socket) {\n      this._readyState = WebSocket.CLOSING;\n      this._socket.destroy();\n    }\n  }\n}\n\n/**\n * @constant {Number} CONNECTING\n * @memberof WebSocket\n */\nObject.defineProperty(WebSocket, 'CONNECTING', {\n  enumerable: true,\n  value: readyStates.indexOf('CONNECTING')\n});\n\n/**\n * @constant {Number} CONNECTING\n * @memberof WebSocket.prototype\n */\nObject.defineProperty(WebSocket.prototype, 'CONNECTING', {\n  enumerable: true,\n  value: readyStates.indexOf('CONNECTING')\n});\n\n/**\n * @constant {Number} OPEN\n * @memberof WebSocket\n */\nObject.defineProperty(WebSocket, 'OPEN', {\n  enumerable: true,\n  value: readyStates.indexOf('OPEN')\n});\n\n/**\n * @constant {Number} OPEN\n * @memberof WebSocket.prototype\n */\nObject.defineProperty(WebSocket.prototype, 'OPEN', {\n  enumerable: true,\n  value: readyStates.indexOf('OPEN')\n});\n\n/**\n * @constant {Number} CLOSING\n * @memberof WebSocket\n */\nObject.defineProperty(WebSocket, 'CLOSING', {\n  enumerable: true,\n  value: readyStates.indexOf('CLOSING')\n});\n\n/**\n * @constant {Number} CLOSING\n * @memberof WebSocket.prototype\n */\nObject.defineProperty(WebSocket.prototype, 'CLOSING', {\n  enumerable: true,\n  value: readyStates.indexOf('CLOSING')\n});\n\n/**\n * @constant {Number} CLOSED\n * @memberof WebSocket\n */\nObject.defineProperty(WebSocket, 'CLOSED', {\n  enumerable: true,\n  value: readyStates.indexOf('CLOSED')\n});\n\n/**\n * @constant {Number} CLOSED\n * @memberof WebSocket.prototype\n */\nObject.defineProperty(WebSocket.prototype, 'CLOSED', {\n  enumerable: true,\n  value: readyStates.indexOf('CLOSED')\n});\n['binaryType', 'bufferedAmount', 'extensions', 'isPaused', 'protocol', 'readyState', 'url'].forEach(property => {\n  Object.defineProperty(WebSocket.prototype, property, {\n    enumerable: true\n  });\n});\n\n//\n// Add the `onopen`, `onerror`, `onclose`, and `onmessage` attributes.\n// See https://html.spec.whatwg.org/multipage/comms.html#the-websocket-interface\n//\n['open', 'error', 'close', 'message'].forEach(method => {\n  Object.defineProperty(WebSocket.prototype, `on${method}`, {\n    enumerable: true,\n    get() {\n      for (const listener of this.listeners(method)) {\n        if (listener[kForOnEventAttribute]) return listener[kListener];\n      }\n      return null;\n    },\n    set(handler) {\n      for (const listener of this.listeners(method)) {\n        if (listener[kForOnEventAttribute]) {\n          this.removeListener(method, listener);\n          break;\n        }\n      }\n      if (typeof handler !== 'function') return;\n      this.addEventListener(method, handler, {\n        [kForOnEventAttribute]: true\n      });\n    }\n  });\n});\nWebSocket.prototype.addEventListener = addEventListener;\nWebSocket.prototype.removeEventListener = removeEventListener;\nmodule.exports = WebSocket;\n\n/**\n * Initialize a WebSocket client.\n *\n * @param {WebSocket} websocket The client to initialize\n * @param {(String|URL)} address The URL to which to connect\n * @param {Array} protocols The subprotocols\n * @param {Object} [options] Connection options\n * @param {Boolean} [options.followRedirects=false] Whether or not to follow\n *     redirects\n * @param {Function} [options.generateMask] The function used to generate the\n *     masking key\n * @param {Number} [options.handshakeTimeout] Timeout in milliseconds for the\n *     handshake request\n * @param {Number} [options.maxPayload=104857600] The maximum allowed message\n *     size\n * @param {Number} [options.maxRedirects=10] The maximum number of redirects\n *     allowed\n * @param {String} [options.origin] Value of the `Origin` or\n *     `Sec-WebSocket-Origin` header\n * @param {(Boolean|Object)} [options.perMessageDeflate=true] Enable/disable\n *     permessage-deflate\n * @param {Number} [options.protocolVersion=13] Value of the\n *     `Sec-WebSocket-Version` header\n * @param {Boolean} [options.skipUTF8Validation=false] Specifies whether or\n *     not to skip UTF-8 validation for text and close messages\n * @private\n */\nfunction initAsClient(websocket, address, protocols, options) {\n  const opts = {\n    protocolVersion: protocolVersions[1],\n    maxPayload: 100 * 1024 * 1024,\n    skipUTF8Validation: false,\n    perMessageDeflate: true,\n    followRedirects: false,\n    maxRedirects: 10,\n    ...options,\n    createConnection: undefined,\n    socketPath: undefined,\n    hostname: undefined,\n    protocol: undefined,\n    timeout: undefined,\n    method: undefined,\n    host: undefined,\n    path: undefined,\n    port: undefined\n  };\n  if (!protocolVersions.includes(opts.protocolVersion)) {\n    throw new RangeError(`Unsupported protocol version: ${opts.protocolVersion} ` + `(supported versions: ${protocolVersions.join(', ')})`);\n  }\n  let parsedUrl;\n  if (address instanceof URL) {\n    parsedUrl = address;\n    websocket._url = address.href;\n  } else {\n    try {\n      parsedUrl = new URL(address);\n    } catch (e) {\n      throw new SyntaxError(`Invalid URL: ${address}`);\n    }\n    websocket._url = address;\n  }\n  const isSecure = parsedUrl.protocol === 'wss:';\n  const isUnixSocket = parsedUrl.protocol === 'ws+unix:';\n  let invalidURLMessage;\n  if (parsedUrl.protocol !== 'ws:' && !isSecure && !isUnixSocket) {\n    invalidURLMessage = 'The URL\\'s protocol must be one of \"ws:\", \"wss:\", or \"ws+unix:\"';\n  } else if (isUnixSocket && !parsedUrl.pathname) {\n    invalidURLMessage = \"The URL's pathname is empty\";\n  } else if (parsedUrl.hash) {\n    invalidURLMessage = 'The URL contains a fragment identifier';\n  }\n  if (invalidURLMessage) {\n    const err = new SyntaxError(invalidURLMessage);\n    if (websocket._redirects === 0) {\n      throw err;\n    } else {\n      emitErrorAndClose(websocket, err);\n      return;\n    }\n  }\n  const defaultPort = isSecure ? 443 : 80;\n  const key = randomBytes(16).toString('base64');\n  const get = isSecure ? https.get : http.get;\n  const protocolSet = new Set();\n  let perMessageDeflate;\n  opts.createConnection = isSecure ? tlsConnect : netConnect;\n  opts.defaultPort = opts.defaultPort || defaultPort;\n  opts.port = parsedUrl.port || defaultPort;\n  opts.host = parsedUrl.hostname.startsWith('[') ? parsedUrl.hostname.slice(1, -1) : parsedUrl.hostname;\n  opts.headers = {\n    'Sec-WebSocket-Version': opts.protocolVersion,\n    'Sec-WebSocket-Key': key,\n    Connection: 'Upgrade',\n    Upgrade: 'websocket',\n    ...opts.headers\n  };\n  opts.path = parsedUrl.pathname + parsedUrl.search;\n  opts.timeout = opts.handshakeTimeout;\n  if (opts.perMessageDeflate) {\n    perMessageDeflate = new PerMessageDeflate(opts.perMessageDeflate !== true ? opts.perMessageDeflate : {}, false, opts.maxPayload);\n    opts.headers['Sec-WebSocket-Extensions'] = format({\n      [PerMessageDeflate.extensionName]: perMessageDeflate.offer()\n    });\n  }\n  if (protocols.length) {\n    for (const protocol of protocols) {\n      if (typeof protocol !== 'string' || !subprotocolRegex.test(protocol) || protocolSet.has(protocol)) {\n        throw new SyntaxError('An invalid or duplicated subprotocol was specified');\n      }\n      protocolSet.add(protocol);\n    }\n    opts.headers['Sec-WebSocket-Protocol'] = protocols.join(',');\n  }\n  if (opts.origin) {\n    if (opts.protocolVersion < 13) {\n      opts.headers['Sec-WebSocket-Origin'] = opts.origin;\n    } else {\n      opts.headers.Origin = opts.origin;\n    }\n  }\n  if (parsedUrl.username || parsedUrl.password) {\n    opts.auth = `${parsedUrl.username}:${parsedUrl.password}`;\n  }\n  if (isUnixSocket) {\n    const parts = opts.path.split(':');\n    opts.socketPath = parts[0];\n    opts.path = parts[1];\n  }\n  if (opts.followRedirects) {\n    if (websocket._redirects === 0) {\n      websocket._originalHost = parsedUrl.host;\n      const headers = options && options.headers;\n\n      //\n      // Shallow copy the user provided options so that headers can be changed\n      // without mutating the original object.\n      //\n      options = {\n        ...options,\n        headers: {}\n      };\n      if (headers) {\n        for (const [key, value] of Object.entries(headers)) {\n          options.headers[key.toLowerCase()] = value;\n        }\n      }\n    } else if (parsedUrl.host !== websocket._originalHost) {\n      //\n      // Match curl 7.77.0 behavior and drop the following headers. These\n      // headers are also dropped when following a redirect to a subdomain.\n      //\n      delete opts.headers.authorization;\n      delete opts.headers.cookie;\n      delete opts.headers.host;\n      opts.auth = undefined;\n    }\n\n    //\n    // Match curl 7.77.0 behavior and make the first `Authorization` header win.\n    // If the `Authorization` header is set, then there is nothing to do as it\n    // will take precedence.\n    //\n    if (opts.auth && !options.headers.authorization) {\n      options.headers.authorization = 'Basic ' + Buffer.from(opts.auth).toString('base64');\n    }\n  }\n  let req = websocket._req = get(opts);\n  if (opts.timeout) {\n    req.on('timeout', () => {\n      abortHandshake(websocket, req, 'Opening handshake has timed out');\n    });\n  }\n  req.on('error', err => {\n    if (req === null || req.aborted) return;\n    req = websocket._req = null;\n    emitErrorAndClose(websocket, err);\n  });\n  req.on('response', res => {\n    const location = res.headers.location;\n    const statusCode = res.statusCode;\n    if (location && opts.followRedirects && statusCode >= 300 && statusCode < 400) {\n      if (++websocket._redirects > opts.maxRedirects) {\n        abortHandshake(websocket, req, 'Maximum redirects exceeded');\n        return;\n      }\n      req.abort();\n      let addr;\n      try {\n        addr = new URL(location, address);\n      } catch (e) {\n        const err = new SyntaxError(`Invalid URL: ${location}`);\n        emitErrorAndClose(websocket, err);\n        return;\n      }\n      initAsClient(websocket, addr, protocols, options);\n    } else if (!websocket.emit('unexpected-response', req, res)) {\n      abortHandshake(websocket, req, `Unexpected server response: ${res.statusCode}`);\n    }\n  });\n  req.on('upgrade', (res, socket, head) => {\n    websocket.emit('upgrade', res);\n\n    //\n    // The user may have closed the connection from a listener of the `upgrade`\n    // event.\n    //\n    if (websocket.readyState !== WebSocket.CONNECTING) return;\n    req = websocket._req = null;\n    const digest = createHash('sha1').update(key + GUID).digest('base64');\n    if (res.headers['sec-websocket-accept'] !== digest) {\n      abortHandshake(websocket, socket, 'Invalid Sec-WebSocket-Accept header');\n      return;\n    }\n    const serverProt = res.headers['sec-websocket-protocol'];\n    let protError;\n    if (serverProt !== undefined) {\n      if (!protocolSet.size) {\n        protError = 'Server sent a subprotocol but none was requested';\n      } else if (!protocolSet.has(serverProt)) {\n        protError = 'Server sent an invalid subprotocol';\n      }\n    } else if (protocolSet.size) {\n      protError = 'Server sent no subprotocol';\n    }\n    if (protError) {\n      abortHandshake(websocket, socket, protError);\n      return;\n    }\n    if (serverProt) websocket._protocol = serverProt;\n    const secWebSocketExtensions = res.headers['sec-websocket-extensions'];\n    if (secWebSocketExtensions !== undefined) {\n      if (!perMessageDeflate) {\n        const message = 'Server sent a Sec-WebSocket-Extensions header but no extension ' + 'was requested';\n        abortHandshake(websocket, socket, message);\n        return;\n      }\n      let extensions;\n      try {\n        extensions = parse(secWebSocketExtensions);\n      } catch (err) {\n        const message = 'Invalid Sec-WebSocket-Extensions header';\n        abortHandshake(websocket, socket, message);\n        return;\n      }\n      const extensionNames = Object.keys(extensions);\n      if (extensionNames.length !== 1 || extensionNames[0] !== PerMessageDeflate.extensionName) {\n        const message = 'Server indicated an extension that was not requested';\n        abortHandshake(websocket, socket, message);\n        return;\n      }\n      try {\n        perMessageDeflate.accept(extensions[PerMessageDeflate.extensionName]);\n      } catch (err) {\n        const message = 'Invalid Sec-WebSocket-Extensions header';\n        abortHandshake(websocket, socket, message);\n        return;\n      }\n      websocket._extensions[PerMessageDeflate.extensionName] = perMessageDeflate;\n    }\n    websocket.setSocket(socket, head, {\n      generateMask: opts.generateMask,\n      maxPayload: opts.maxPayload,\n      skipUTF8Validation: opts.skipUTF8Validation\n    });\n  });\n}\n\n/**\n * Emit the `'error'` and `'close'` event.\n *\n * @param {WebSocket} websocket The WebSocket instance\n * @param {Error} The error to emit\n * @private\n */\nfunction emitErrorAndClose(websocket, err) {\n  websocket._readyState = WebSocket.CLOSING;\n  websocket.emit('error', err);\n  websocket.emitClose();\n}\n\n/**\n * Create a `net.Socket` and initiate a connection.\n *\n * @param {Object} options Connection options\n * @return {net.Socket} The newly created socket used to start the connection\n * @private\n */\nfunction netConnect(options) {\n  options.path = options.socketPath;\n  return net.connect(options);\n}\n\n/**\n * Create a `tls.TLSSocket` and initiate a connection.\n *\n * @param {Object} options Connection options\n * @return {tls.TLSSocket} The newly created socket used to start the connection\n * @private\n */\nfunction tlsConnect(options) {\n  options.path = undefined;\n  if (!options.servername && options.servername !== '') {\n    options.servername = net.isIP(options.host) ? '' : options.host;\n  }\n  return tls.connect(options);\n}\n\n/**\n * Abort the handshake and emit an error.\n *\n * @param {WebSocket} websocket The WebSocket instance\n * @param {(http.ClientRequest|net.Socket|tls.Socket)} stream The request to\n *     abort or the socket to destroy\n * @param {String} message The error message\n * @private\n */\nfunction abortHandshake(websocket, stream, message) {\n  websocket._readyState = WebSocket.CLOSING;\n  const err = new Error(message);\n  Error.captureStackTrace(err, abortHandshake);\n  if (stream.setHeader) {\n    stream.abort();\n    if (stream.socket && !stream.socket.destroyed) {\n      //\n      // On Node.js >= 14.3.0 `request.abort()` does not destroy the socket if\n      // called after the request completed. See\n      // https://github.com/websockets/ws/issues/1869.\n      //\n      stream.socket.destroy();\n    }\n    stream.once('abort', websocket.emitClose.bind(websocket));\n    websocket.emit('error', err);\n  } else {\n    stream.destroy(err);\n    stream.once('error', websocket.emit.bind(websocket, 'error'));\n    stream.once('close', websocket.emitClose.bind(websocket));\n  }\n}\n\n/**\n * Handle cases where the `ping()`, `pong()`, or `send()` methods are called\n * when the `readyState` attribute is `CLOSING` or `CLOSED`.\n *\n * @param {WebSocket} websocket The WebSocket instance\n * @param {*} [data] The data to send\n * @param {Function} [cb] Callback\n * @private\n */\nfunction sendAfterClose(websocket, data, cb) {\n  if (data) {\n    const length = toBuffer(data).length;\n\n    //\n    // The `_bufferedAmount` property is used only when the peer is a client and\n    // the opening handshake fails. Under these circumstances, in fact, the\n    // `setSocket()` method is not called, so the `_socket` and `_sender`\n    // properties are set to `null`.\n    //\n    if (websocket._socket) websocket._sender._bufferedBytes += length;else websocket._bufferedAmount += length;\n  }\n  if (cb) {\n    const err = new Error(`WebSocket is not open: readyState ${websocket.readyState} ` + `(${readyStates[websocket.readyState]})`);\n    cb(err);\n  }\n}\n\n/**\n * The listener of the `Receiver` `'conclude'` event.\n *\n * @param {Number} code The status code\n * @param {Buffer} reason The reason for closing\n * @private\n */\nfunction receiverOnConclude(code, reason) {\n  const websocket = this[kWebSocket];\n  websocket._closeFrameReceived = true;\n  websocket._closeMessage = reason;\n  websocket._closeCode = code;\n  if (websocket._socket[kWebSocket] === undefined) return;\n  websocket._socket.removeListener('data', socketOnData);\n  process.nextTick(resume, websocket._socket);\n  if (code === 1005) websocket.close();else websocket.close(code, reason);\n}\n\n/**\n * The listener of the `Receiver` `'drain'` event.\n *\n * @private\n */\nfunction receiverOnDrain() {\n  const websocket = this[kWebSocket];\n  if (!websocket.isPaused) websocket._socket.resume();\n}\n\n/**\n * The listener of the `Receiver` `'error'` event.\n *\n * @param {(RangeError|Error)} err The emitted error\n * @private\n */\nfunction receiverOnError(err) {\n  const websocket = this[kWebSocket];\n  if (websocket._socket[kWebSocket] !== undefined) {\n    websocket._socket.removeListener('data', socketOnData);\n\n    //\n    // On Node.js < 14.0.0 the `'error'` event is emitted synchronously. See\n    // https://github.com/websockets/ws/issues/1940.\n    //\n    process.nextTick(resume, websocket._socket);\n    websocket.close(err[kStatusCode]);\n  }\n  websocket.emit('error', err);\n}\n\n/**\n * The listener of the `Receiver` `'finish'` event.\n *\n * @private\n */\nfunction receiverOnFinish() {\n  this[kWebSocket].emitClose();\n}\n\n/**\n * The listener of the `Receiver` `'message'` event.\n *\n * @param {Buffer|ArrayBuffer|Buffer[])} data The message\n * @param {Boolean} isBinary Specifies whether the message is binary or not\n * @private\n */\nfunction receiverOnMessage(data, isBinary) {\n  this[kWebSocket].emit('message', data, isBinary);\n}\n\n/**\n * The listener of the `Receiver` `'ping'` event.\n *\n * @param {Buffer} data The data included in the ping frame\n * @private\n */\nfunction receiverOnPing(data) {\n  const websocket = this[kWebSocket];\n  websocket.pong(data, !websocket._isServer, NOOP);\n  websocket.emit('ping', data);\n}\n\n/**\n * The listener of the `Receiver` `'pong'` event.\n *\n * @param {Buffer} data The data included in the pong frame\n * @private\n */\nfunction receiverOnPong(data) {\n  this[kWebSocket].emit('pong', data);\n}\n\n/**\n * Resume a readable stream\n *\n * @param {Readable} stream The readable stream\n * @private\n */\nfunction resume(stream) {\n  stream.resume();\n}\n\n/**\n * The listener of the `net.Socket` `'close'` event.\n *\n * @private\n */\nfunction socketOnClose() {\n  const websocket = this[kWebSocket];\n  this.removeListener('close', socketOnClose);\n  this.removeListener('data', socketOnData);\n  this.removeListener('end', socketOnEnd);\n  websocket._readyState = WebSocket.CLOSING;\n  let chunk;\n\n  //\n  // The close frame might not have been received or the `'end'` event emitted,\n  // for example, if the socket was destroyed due to an error. Ensure that the\n  // `receiver` stream is closed after writing any remaining buffered data to\n  // it. If the readable side of the socket is in flowing mode then there is no\n  // buffered data as everything has been already written and `readable.read()`\n  // will return `null`. If instead, the socket is paused, any possible buffered\n  // data will be read as a single chunk.\n  //\n  if (!this._readableState.endEmitted && !websocket._closeFrameReceived && !websocket._receiver._writableState.errorEmitted && (chunk = websocket._socket.read()) !== null) {\n    websocket._receiver.write(chunk);\n  }\n  websocket._receiver.end();\n  this[kWebSocket] = undefined;\n  clearTimeout(websocket._closeTimer);\n  if (websocket._receiver._writableState.finished || websocket._receiver._writableState.errorEmitted) {\n    websocket.emitClose();\n  } else {\n    websocket._receiver.on('error', receiverOnFinish);\n    websocket._receiver.on('finish', receiverOnFinish);\n  }\n}\n\n/**\n * The listener of the `net.Socket` `'data'` event.\n *\n * @param {Buffer} chunk A chunk of data\n * @private\n */\nfunction socketOnData(chunk) {\n  if (!this[kWebSocket]._receiver.write(chunk)) {\n    this.pause();\n  }\n}\n\n/**\n * The listener of the `net.Socket` `'end'` event.\n *\n * @private\n */\nfunction socketOnEnd() {\n  const websocket = this[kWebSocket];\n  websocket._readyState = WebSocket.CLOSING;\n  websocket._receiver.end();\n  this.end();\n}\n\n/**\n * The listener of the `net.Socket` `'error'` event.\n *\n * @private\n */\nfunction socketOnError() {\n  const websocket = this[kWebSocket];\n  this.removeListener('error', socketOnError);\n  this.on('error', NOOP);\n  if (websocket) {\n    websocket._readyState = WebSocket.CLOSING;\n    this.destroy();\n  }\n}","map":{"version":3,"names":["EventEmitter","require","https","http","net","tls","randomBytes","createHash","Readable","URL","PerMessageDeflate","Receiver","Sender","BINARY_TYPES","EMPTY_BUFFER","GUID","kForOnEventAttribute","kListener","kStatusCode","kWebSocket","NOOP","EventTarget","addEventListener","removeEventListener","format","parse","toBuffer","readyStates","subprotocolRegex","protocolVersions","closeTimeout","WebSocket","constructor","address","protocols","options","_binaryType","_closeCode","_closeFrameReceived","_closeFrameSent","_closeMessage","_closeTimer","_extensions","_paused","_protocol","_readyState","CONNECTING","_receiver","_sender","_socket","_bufferedAmount","_isServer","_redirects","undefined","Array","isArray","initAsClient","binaryType","type","includes","bufferedAmount","_writableState","length","_bufferedBytes","extensions","Object","keys","join","isPaused","onclose","onerror","onopen","onmessage","protocol","readyState","url","_url","setSocket","socket","head","receiver","isServer","maxPayload","skipUTF8Validation","generateMask","on","receiverOnConclude","receiverOnDrain","receiverOnError","receiverOnMessage","receiverOnPing","receiverOnPong","setTimeout","setNoDelay","unshift","socketOnClose","socketOnData","socketOnEnd","socketOnError","OPEN","emit","emitClose","CLOSED","extensionName","cleanup","removeAllListeners","close","code","data","msg","abortHandshake","_req","CLOSING","errorEmitted","end","err","destroy","bind","pause","ping","mask","cb","Error","toString","sendAfterClose","pong","resume","needDrain","send","opts","binary","compress","fin","terminate","defineProperty","enumerable","value","indexOf","prototype","forEach","property","method","get","listener","listeners","set","handler","removeListener","module","exports","websocket","protocolVersion","perMessageDeflate","followRedirects","maxRedirects","createConnection","socketPath","hostname","timeout","host","path","port","RangeError","parsedUrl","href","e","SyntaxError","isSecure","isUnixSocket","invalidURLMessage","pathname","hash","emitErrorAndClose","defaultPort","key","protocolSet","Set","tlsConnect","netConnect","startsWith","slice","headers","Connection","Upgrade","search","handshakeTimeout","offer","test","has","add","origin","Origin","username","password","auth","parts","split","_originalHost","entries","toLowerCase","authorization","cookie","Buffer","from","req","aborted","res","location","statusCode","abort","addr","digest","update","serverProt","protError","size","secWebSocketExtensions","message","extensionNames","accept","connect","servername","isIP","stream","captureStackTrace","setHeader","destroyed","once","reason","process","nextTick","receiverOnFinish","isBinary","chunk","_readableState","endEmitted","read","write","clearTimeout","finished"],"sources":["/Users/janrobel/Documents/PersonalProjekty/nftGenerateAi/clientAndContract/node_modules/ethers/node_modules/ws/lib/websocket.js"],"sourcesContent":["/* eslint no-unused-vars: [\"error\", { \"varsIgnorePattern\": \"^Readable$\" }] */\n\n'use strict';\n\nconst EventEmitter = require('events');\nconst https = require('https');\nconst http = require('http');\nconst net = require('net');\nconst tls = require('tls');\nconst { randomBytes, createHash } = require('crypto');\nconst { Readable } = require('stream');\nconst { URL } = require('url');\n\nconst PerMessageDeflate = require('./permessage-deflate');\nconst Receiver = require('./receiver');\nconst Sender = require('./sender');\nconst {\n  BINARY_TYPES,\n  EMPTY_BUFFER,\n  GUID,\n  kForOnEventAttribute,\n  kListener,\n  kStatusCode,\n  kWebSocket,\n  NOOP\n} = require('./constants');\nconst {\n  EventTarget: { addEventListener, removeEventListener }\n} = require('./event-target');\nconst { format, parse } = require('./extension');\nconst { toBuffer } = require('./buffer-util');\n\nconst readyStates = ['CONNECTING', 'OPEN', 'CLOSING', 'CLOSED'];\nconst subprotocolRegex = /^[!#$%&'*+\\-.0-9A-Z^_`|a-z~]+$/;\nconst protocolVersions = [8, 13];\nconst closeTimeout = 30 * 1000;\n\n/**\n * Class representing a WebSocket.\n *\n * @extends EventEmitter\n */\nclass WebSocket extends EventEmitter {\n  /**\n   * Create a new `WebSocket`.\n   *\n   * @param {(String|URL)} address The URL to which to connect\n   * @param {(String|String[])} [protocols] The subprotocols\n   * @param {Object} [options] Connection options\n   */\n  constructor(address, protocols, options) {\n    super();\n\n    this._binaryType = BINARY_TYPES[0];\n    this._closeCode = 1006;\n    this._closeFrameReceived = false;\n    this._closeFrameSent = false;\n    this._closeMessage = EMPTY_BUFFER;\n    this._closeTimer = null;\n    this._extensions = {};\n    this._paused = false;\n    this._protocol = '';\n    this._readyState = WebSocket.CONNECTING;\n    this._receiver = null;\n    this._sender = null;\n    this._socket = null;\n\n    if (address !== null) {\n      this._bufferedAmount = 0;\n      this._isServer = false;\n      this._redirects = 0;\n\n      if (protocols === undefined) {\n        protocols = [];\n      } else if (!Array.isArray(protocols)) {\n        if (typeof protocols === 'object' && protocols !== null) {\n          options = protocols;\n          protocols = [];\n        } else {\n          protocols = [protocols];\n        }\n      }\n\n      initAsClient(this, address, protocols, options);\n    } else {\n      this._isServer = true;\n    }\n  }\n\n  /**\n   * This deviates from the WHATWG interface since ws doesn't support the\n   * required default \"blob\" type (instead we define a custom \"nodebuffer\"\n   * type).\n   *\n   * @type {String}\n   */\n  get binaryType() {\n    return this._binaryType;\n  }\n\n  set binaryType(type) {\n    if (!BINARY_TYPES.includes(type)) return;\n\n    this._binaryType = type;\n\n    //\n    // Allow to change `binaryType` on the fly.\n    //\n    if (this._receiver) this._receiver._binaryType = type;\n  }\n\n  /**\n   * @type {Number}\n   */\n  get bufferedAmount() {\n    if (!this._socket) return this._bufferedAmount;\n\n    return this._socket._writableState.length + this._sender._bufferedBytes;\n  }\n\n  /**\n   * @type {String}\n   */\n  get extensions() {\n    return Object.keys(this._extensions).join();\n  }\n\n  /**\n   * @type {Boolean}\n   */\n  get isPaused() {\n    return this._paused;\n  }\n\n  /**\n   * @type {Function}\n   */\n  /* istanbul ignore next */\n  get onclose() {\n    return null;\n  }\n\n  /**\n   * @type {Function}\n   */\n  /* istanbul ignore next */\n  get onerror() {\n    return null;\n  }\n\n  /**\n   * @type {Function}\n   */\n  /* istanbul ignore next */\n  get onopen() {\n    return null;\n  }\n\n  /**\n   * @type {Function}\n   */\n  /* istanbul ignore next */\n  get onmessage() {\n    return null;\n  }\n\n  /**\n   * @type {String}\n   */\n  get protocol() {\n    return this._protocol;\n  }\n\n  /**\n   * @type {Number}\n   */\n  get readyState() {\n    return this._readyState;\n  }\n\n  /**\n   * @type {String}\n   */\n  get url() {\n    return this._url;\n  }\n\n  /**\n   * Set up the socket and the internal resources.\n   *\n   * @param {(net.Socket|tls.Socket)} socket The network socket between the\n   *     server and client\n   * @param {Buffer} head The first packet of the upgraded stream\n   * @param {Object} options Options object\n   * @param {Function} [options.generateMask] The function used to generate the\n   *     masking key\n   * @param {Number} [options.maxPayload=0] The maximum allowed message size\n   * @param {Boolean} [options.skipUTF8Validation=false] Specifies whether or\n   *     not to skip UTF-8 validation for text and close messages\n   * @private\n   */\n  setSocket(socket, head, options) {\n    const receiver = new Receiver({\n      binaryType: this.binaryType,\n      extensions: this._extensions,\n      isServer: this._isServer,\n      maxPayload: options.maxPayload,\n      skipUTF8Validation: options.skipUTF8Validation\n    });\n\n    this._sender = new Sender(socket, this._extensions, options.generateMask);\n    this._receiver = receiver;\n    this._socket = socket;\n\n    receiver[kWebSocket] = this;\n    socket[kWebSocket] = this;\n\n    receiver.on('conclude', receiverOnConclude);\n    receiver.on('drain', receiverOnDrain);\n    receiver.on('error', receiverOnError);\n    receiver.on('message', receiverOnMessage);\n    receiver.on('ping', receiverOnPing);\n    receiver.on('pong', receiverOnPong);\n\n    socket.setTimeout(0);\n    socket.setNoDelay();\n\n    if (head.length > 0) socket.unshift(head);\n\n    socket.on('close', socketOnClose);\n    socket.on('data', socketOnData);\n    socket.on('end', socketOnEnd);\n    socket.on('error', socketOnError);\n\n    this._readyState = WebSocket.OPEN;\n    this.emit('open');\n  }\n\n  /**\n   * Emit the `'close'` event.\n   *\n   * @private\n   */\n  emitClose() {\n    if (!this._socket) {\n      this._readyState = WebSocket.CLOSED;\n      this.emit('close', this._closeCode, this._closeMessage);\n      return;\n    }\n\n    if (this._extensions[PerMessageDeflate.extensionName]) {\n      this._extensions[PerMessageDeflate.extensionName].cleanup();\n    }\n\n    this._receiver.removeAllListeners();\n    this._readyState = WebSocket.CLOSED;\n    this.emit('close', this._closeCode, this._closeMessage);\n  }\n\n  /**\n   * Start a closing handshake.\n   *\n   *          +----------+   +-----------+   +----------+\n   *     - - -|ws.close()|-->|close frame|-->|ws.close()|- - -\n   *    |     +----------+   +-----------+   +----------+     |\n   *          +----------+   +-----------+         |\n   * CLOSING  |ws.close()|<--|close frame|<--+-----+       CLOSING\n   *          +----------+   +-----------+   |\n   *    |           |                        |   +---+        |\n   *                +------------------------+-->|fin| - - - -\n   *    |         +---+                      |   +---+\n   *     - - - - -|fin|<---------------------+\n   *              +---+\n   *\n   * @param {Number} [code] Status code explaining why the connection is closing\n   * @param {(String|Buffer)} [data] The reason why the connection is\n   *     closing\n   * @public\n   */\n  close(code, data) {\n    if (this.readyState === WebSocket.CLOSED) return;\n    if (this.readyState === WebSocket.CONNECTING) {\n      const msg = 'WebSocket was closed before the connection was established';\n      return abortHandshake(this, this._req, msg);\n    }\n\n    if (this.readyState === WebSocket.CLOSING) {\n      if (\n        this._closeFrameSent &&\n        (this._closeFrameReceived || this._receiver._writableState.errorEmitted)\n      ) {\n        this._socket.end();\n      }\n\n      return;\n    }\n\n    this._readyState = WebSocket.CLOSING;\n    this._sender.close(code, data, !this._isServer, (err) => {\n      //\n      // This error is handled by the `'error'` listener on the socket. We only\n      // want to know if the close frame has been sent here.\n      //\n      if (err) return;\n\n      this._closeFrameSent = true;\n\n      if (\n        this._closeFrameReceived ||\n        this._receiver._writableState.errorEmitted\n      ) {\n        this._socket.end();\n      }\n    });\n\n    //\n    // Specify a timeout for the closing handshake to complete.\n    //\n    this._closeTimer = setTimeout(\n      this._socket.destroy.bind(this._socket),\n      closeTimeout\n    );\n  }\n\n  /**\n   * Pause the socket.\n   *\n   * @public\n   */\n  pause() {\n    if (\n      this.readyState === WebSocket.CONNECTING ||\n      this.readyState === WebSocket.CLOSED\n    ) {\n      return;\n    }\n\n    this._paused = true;\n    this._socket.pause();\n  }\n\n  /**\n   * Send a ping.\n   *\n   * @param {*} [data] The data to send\n   * @param {Boolean} [mask] Indicates whether or not to mask `data`\n   * @param {Function} [cb] Callback which is executed when the ping is sent\n   * @public\n   */\n  ping(data, mask, cb) {\n    if (this.readyState === WebSocket.CONNECTING) {\n      throw new Error('WebSocket is not open: readyState 0 (CONNECTING)');\n    }\n\n    if (typeof data === 'function') {\n      cb = data;\n      data = mask = undefined;\n    } else if (typeof mask === 'function') {\n      cb = mask;\n      mask = undefined;\n    }\n\n    if (typeof data === 'number') data = data.toString();\n\n    if (this.readyState !== WebSocket.OPEN) {\n      sendAfterClose(this, data, cb);\n      return;\n    }\n\n    if (mask === undefined) mask = !this._isServer;\n    this._sender.ping(data || EMPTY_BUFFER, mask, cb);\n  }\n\n  /**\n   * Send a pong.\n   *\n   * @param {*} [data] The data to send\n   * @param {Boolean} [mask] Indicates whether or not to mask `data`\n   * @param {Function} [cb] Callback which is executed when the pong is sent\n   * @public\n   */\n  pong(data, mask, cb) {\n    if (this.readyState === WebSocket.CONNECTING) {\n      throw new Error('WebSocket is not open: readyState 0 (CONNECTING)');\n    }\n\n    if (typeof data === 'function') {\n      cb = data;\n      data = mask = undefined;\n    } else if (typeof mask === 'function') {\n      cb = mask;\n      mask = undefined;\n    }\n\n    if (typeof data === 'number') data = data.toString();\n\n    if (this.readyState !== WebSocket.OPEN) {\n      sendAfterClose(this, data, cb);\n      return;\n    }\n\n    if (mask === undefined) mask = !this._isServer;\n    this._sender.pong(data || EMPTY_BUFFER, mask, cb);\n  }\n\n  /**\n   * Resume the socket.\n   *\n   * @public\n   */\n  resume() {\n    if (\n      this.readyState === WebSocket.CONNECTING ||\n      this.readyState === WebSocket.CLOSED\n    ) {\n      return;\n    }\n\n    this._paused = false;\n    if (!this._receiver._writableState.needDrain) this._socket.resume();\n  }\n\n  /**\n   * Send a data message.\n   *\n   * @param {*} data The message to send\n   * @param {Object} [options] Options object\n   * @param {Boolean} [options.binary] Specifies whether `data` is binary or\n   *     text\n   * @param {Boolean} [options.compress] Specifies whether or not to compress\n   *     `data`\n   * @param {Boolean} [options.fin=true] Specifies whether the fragment is the\n   *     last one\n   * @param {Boolean} [options.mask] Specifies whether or not to mask `data`\n   * @param {Function} [cb] Callback which is executed when data is written out\n   * @public\n   */\n  send(data, options, cb) {\n    if (this.readyState === WebSocket.CONNECTING) {\n      throw new Error('WebSocket is not open: readyState 0 (CONNECTING)');\n    }\n\n    if (typeof options === 'function') {\n      cb = options;\n      options = {};\n    }\n\n    if (typeof data === 'number') data = data.toString();\n\n    if (this.readyState !== WebSocket.OPEN) {\n      sendAfterClose(this, data, cb);\n      return;\n    }\n\n    const opts = {\n      binary: typeof data !== 'string',\n      mask: !this._isServer,\n      compress: true,\n      fin: true,\n      ...options\n    };\n\n    if (!this._extensions[PerMessageDeflate.extensionName]) {\n      opts.compress = false;\n    }\n\n    this._sender.send(data || EMPTY_BUFFER, opts, cb);\n  }\n\n  /**\n   * Forcibly close the connection.\n   *\n   * @public\n   */\n  terminate() {\n    if (this.readyState === WebSocket.CLOSED) return;\n    if (this.readyState === WebSocket.CONNECTING) {\n      const msg = 'WebSocket was closed before the connection was established';\n      return abortHandshake(this, this._req, msg);\n    }\n\n    if (this._socket) {\n      this._readyState = WebSocket.CLOSING;\n      this._socket.destroy();\n    }\n  }\n}\n\n/**\n * @constant {Number} CONNECTING\n * @memberof WebSocket\n */\nObject.defineProperty(WebSocket, 'CONNECTING', {\n  enumerable: true,\n  value: readyStates.indexOf('CONNECTING')\n});\n\n/**\n * @constant {Number} CONNECTING\n * @memberof WebSocket.prototype\n */\nObject.defineProperty(WebSocket.prototype, 'CONNECTING', {\n  enumerable: true,\n  value: readyStates.indexOf('CONNECTING')\n});\n\n/**\n * @constant {Number} OPEN\n * @memberof WebSocket\n */\nObject.defineProperty(WebSocket, 'OPEN', {\n  enumerable: true,\n  value: readyStates.indexOf('OPEN')\n});\n\n/**\n * @constant {Number} OPEN\n * @memberof WebSocket.prototype\n */\nObject.defineProperty(WebSocket.prototype, 'OPEN', {\n  enumerable: true,\n  value: readyStates.indexOf('OPEN')\n});\n\n/**\n * @constant {Number} CLOSING\n * @memberof WebSocket\n */\nObject.defineProperty(WebSocket, 'CLOSING', {\n  enumerable: true,\n  value: readyStates.indexOf('CLOSING')\n});\n\n/**\n * @constant {Number} CLOSING\n * @memberof WebSocket.prototype\n */\nObject.defineProperty(WebSocket.prototype, 'CLOSING', {\n  enumerable: true,\n  value: readyStates.indexOf('CLOSING')\n});\n\n/**\n * @constant {Number} CLOSED\n * @memberof WebSocket\n */\nObject.defineProperty(WebSocket, 'CLOSED', {\n  enumerable: true,\n  value: readyStates.indexOf('CLOSED')\n});\n\n/**\n * @constant {Number} CLOSED\n * @memberof WebSocket.prototype\n */\nObject.defineProperty(WebSocket.prototype, 'CLOSED', {\n  enumerable: true,\n  value: readyStates.indexOf('CLOSED')\n});\n\n[\n  'binaryType',\n  'bufferedAmount',\n  'extensions',\n  'isPaused',\n  'protocol',\n  'readyState',\n  'url'\n].forEach((property) => {\n  Object.defineProperty(WebSocket.prototype, property, { enumerable: true });\n});\n\n//\n// Add the `onopen`, `onerror`, `onclose`, and `onmessage` attributes.\n// See https://html.spec.whatwg.org/multipage/comms.html#the-websocket-interface\n//\n['open', 'error', 'close', 'message'].forEach((method) => {\n  Object.defineProperty(WebSocket.prototype, `on${method}`, {\n    enumerable: true,\n    get() {\n      for (const listener of this.listeners(method)) {\n        if (listener[kForOnEventAttribute]) return listener[kListener];\n      }\n\n      return null;\n    },\n    set(handler) {\n      for (const listener of this.listeners(method)) {\n        if (listener[kForOnEventAttribute]) {\n          this.removeListener(method, listener);\n          break;\n        }\n      }\n\n      if (typeof handler !== 'function') return;\n\n      this.addEventListener(method, handler, {\n        [kForOnEventAttribute]: true\n      });\n    }\n  });\n});\n\nWebSocket.prototype.addEventListener = addEventListener;\nWebSocket.prototype.removeEventListener = removeEventListener;\n\nmodule.exports = WebSocket;\n\n/**\n * Initialize a WebSocket client.\n *\n * @param {WebSocket} websocket The client to initialize\n * @param {(String|URL)} address The URL to which to connect\n * @param {Array} protocols The subprotocols\n * @param {Object} [options] Connection options\n * @param {Boolean} [options.followRedirects=false] Whether or not to follow\n *     redirects\n * @param {Function} [options.generateMask] The function used to generate the\n *     masking key\n * @param {Number} [options.handshakeTimeout] Timeout in milliseconds for the\n *     handshake request\n * @param {Number} [options.maxPayload=104857600] The maximum allowed message\n *     size\n * @param {Number} [options.maxRedirects=10] The maximum number of redirects\n *     allowed\n * @param {String} [options.origin] Value of the `Origin` or\n *     `Sec-WebSocket-Origin` header\n * @param {(Boolean|Object)} [options.perMessageDeflate=true] Enable/disable\n *     permessage-deflate\n * @param {Number} [options.protocolVersion=13] Value of the\n *     `Sec-WebSocket-Version` header\n * @param {Boolean} [options.skipUTF8Validation=false] Specifies whether or\n *     not to skip UTF-8 validation for text and close messages\n * @private\n */\nfunction initAsClient(websocket, address, protocols, options) {\n  const opts = {\n    protocolVersion: protocolVersions[1],\n    maxPayload: 100 * 1024 * 1024,\n    skipUTF8Validation: false,\n    perMessageDeflate: true,\n    followRedirects: false,\n    maxRedirects: 10,\n    ...options,\n    createConnection: undefined,\n    socketPath: undefined,\n    hostname: undefined,\n    protocol: undefined,\n    timeout: undefined,\n    method: undefined,\n    host: undefined,\n    path: undefined,\n    port: undefined\n  };\n\n  if (!protocolVersions.includes(opts.protocolVersion)) {\n    throw new RangeError(\n      `Unsupported protocol version: ${opts.protocolVersion} ` +\n        `(supported versions: ${protocolVersions.join(', ')})`\n    );\n  }\n\n  let parsedUrl;\n\n  if (address instanceof URL) {\n    parsedUrl = address;\n    websocket._url = address.href;\n  } else {\n    try {\n      parsedUrl = new URL(address);\n    } catch (e) {\n      throw new SyntaxError(`Invalid URL: ${address}`);\n    }\n\n    websocket._url = address;\n  }\n\n  const isSecure = parsedUrl.protocol === 'wss:';\n  const isUnixSocket = parsedUrl.protocol === 'ws+unix:';\n  let invalidURLMessage;\n\n  if (parsedUrl.protocol !== 'ws:' && !isSecure && !isUnixSocket) {\n    invalidURLMessage =\n      'The URL\\'s protocol must be one of \"ws:\", \"wss:\", or \"ws+unix:\"';\n  } else if (isUnixSocket && !parsedUrl.pathname) {\n    invalidURLMessage = \"The URL's pathname is empty\";\n  } else if (parsedUrl.hash) {\n    invalidURLMessage = 'The URL contains a fragment identifier';\n  }\n\n  if (invalidURLMessage) {\n    const err = new SyntaxError(invalidURLMessage);\n\n    if (websocket._redirects === 0) {\n      throw err;\n    } else {\n      emitErrorAndClose(websocket, err);\n      return;\n    }\n  }\n\n  const defaultPort = isSecure ? 443 : 80;\n  const key = randomBytes(16).toString('base64');\n  const get = isSecure ? https.get : http.get;\n  const protocolSet = new Set();\n  let perMessageDeflate;\n\n  opts.createConnection = isSecure ? tlsConnect : netConnect;\n  opts.defaultPort = opts.defaultPort || defaultPort;\n  opts.port = parsedUrl.port || defaultPort;\n  opts.host = parsedUrl.hostname.startsWith('[')\n    ? parsedUrl.hostname.slice(1, -1)\n    : parsedUrl.hostname;\n  opts.headers = {\n    'Sec-WebSocket-Version': opts.protocolVersion,\n    'Sec-WebSocket-Key': key,\n    Connection: 'Upgrade',\n    Upgrade: 'websocket',\n    ...opts.headers\n  };\n  opts.path = parsedUrl.pathname + parsedUrl.search;\n  opts.timeout = opts.handshakeTimeout;\n\n  if (opts.perMessageDeflate) {\n    perMessageDeflate = new PerMessageDeflate(\n      opts.perMessageDeflate !== true ? opts.perMessageDeflate : {},\n      false,\n      opts.maxPayload\n    );\n    opts.headers['Sec-WebSocket-Extensions'] = format({\n      [PerMessageDeflate.extensionName]: perMessageDeflate.offer()\n    });\n  }\n  if (protocols.length) {\n    for (const protocol of protocols) {\n      if (\n        typeof protocol !== 'string' ||\n        !subprotocolRegex.test(protocol) ||\n        protocolSet.has(protocol)\n      ) {\n        throw new SyntaxError(\n          'An invalid or duplicated subprotocol was specified'\n        );\n      }\n\n      protocolSet.add(protocol);\n    }\n\n    opts.headers['Sec-WebSocket-Protocol'] = protocols.join(',');\n  }\n  if (opts.origin) {\n    if (opts.protocolVersion < 13) {\n      opts.headers['Sec-WebSocket-Origin'] = opts.origin;\n    } else {\n      opts.headers.Origin = opts.origin;\n    }\n  }\n  if (parsedUrl.username || parsedUrl.password) {\n    opts.auth = `${parsedUrl.username}:${parsedUrl.password}`;\n  }\n\n  if (isUnixSocket) {\n    const parts = opts.path.split(':');\n\n    opts.socketPath = parts[0];\n    opts.path = parts[1];\n  }\n\n  if (opts.followRedirects) {\n    if (websocket._redirects === 0) {\n      websocket._originalHost = parsedUrl.host;\n\n      const headers = options && options.headers;\n\n      //\n      // Shallow copy the user provided options so that headers can be changed\n      // without mutating the original object.\n      //\n      options = { ...options, headers: {} };\n\n      if (headers) {\n        for (const [key, value] of Object.entries(headers)) {\n          options.headers[key.toLowerCase()] = value;\n        }\n      }\n    } else if (parsedUrl.host !== websocket._originalHost) {\n      //\n      // Match curl 7.77.0 behavior and drop the following headers. These\n      // headers are also dropped when following a redirect to a subdomain.\n      //\n      delete opts.headers.authorization;\n      delete opts.headers.cookie;\n      delete opts.headers.host;\n      opts.auth = undefined;\n    }\n\n    //\n    // Match curl 7.77.0 behavior and make the first `Authorization` header win.\n    // If the `Authorization` header is set, then there is nothing to do as it\n    // will take precedence.\n    //\n    if (opts.auth && !options.headers.authorization) {\n      options.headers.authorization =\n        'Basic ' + Buffer.from(opts.auth).toString('base64');\n    }\n  }\n\n  let req = (websocket._req = get(opts));\n\n  if (opts.timeout) {\n    req.on('timeout', () => {\n      abortHandshake(websocket, req, 'Opening handshake has timed out');\n    });\n  }\n\n  req.on('error', (err) => {\n    if (req === null || req.aborted) return;\n\n    req = websocket._req = null;\n    emitErrorAndClose(websocket, err);\n  });\n\n  req.on('response', (res) => {\n    const location = res.headers.location;\n    const statusCode = res.statusCode;\n\n    if (\n      location &&\n      opts.followRedirects &&\n      statusCode >= 300 &&\n      statusCode < 400\n    ) {\n      if (++websocket._redirects > opts.maxRedirects) {\n        abortHandshake(websocket, req, 'Maximum redirects exceeded');\n        return;\n      }\n\n      req.abort();\n\n      let addr;\n\n      try {\n        addr = new URL(location, address);\n      } catch (e) {\n        const err = new SyntaxError(`Invalid URL: ${location}`);\n        emitErrorAndClose(websocket, err);\n        return;\n      }\n\n      initAsClient(websocket, addr, protocols, options);\n    } else if (!websocket.emit('unexpected-response', req, res)) {\n      abortHandshake(\n        websocket,\n        req,\n        `Unexpected server response: ${res.statusCode}`\n      );\n    }\n  });\n\n  req.on('upgrade', (res, socket, head) => {\n    websocket.emit('upgrade', res);\n\n    //\n    // The user may have closed the connection from a listener of the `upgrade`\n    // event.\n    //\n    if (websocket.readyState !== WebSocket.CONNECTING) return;\n\n    req = websocket._req = null;\n\n    const digest = createHash('sha1')\n      .update(key + GUID)\n      .digest('base64');\n\n    if (res.headers['sec-websocket-accept'] !== digest) {\n      abortHandshake(websocket, socket, 'Invalid Sec-WebSocket-Accept header');\n      return;\n    }\n\n    const serverProt = res.headers['sec-websocket-protocol'];\n    let protError;\n\n    if (serverProt !== undefined) {\n      if (!protocolSet.size) {\n        protError = 'Server sent a subprotocol but none was requested';\n      } else if (!protocolSet.has(serverProt)) {\n        protError = 'Server sent an invalid subprotocol';\n      }\n    } else if (protocolSet.size) {\n      protError = 'Server sent no subprotocol';\n    }\n\n    if (protError) {\n      abortHandshake(websocket, socket, protError);\n      return;\n    }\n\n    if (serverProt) websocket._protocol = serverProt;\n\n    const secWebSocketExtensions = res.headers['sec-websocket-extensions'];\n\n    if (secWebSocketExtensions !== undefined) {\n      if (!perMessageDeflate) {\n        const message =\n          'Server sent a Sec-WebSocket-Extensions header but no extension ' +\n          'was requested';\n        abortHandshake(websocket, socket, message);\n        return;\n      }\n\n      let extensions;\n\n      try {\n        extensions = parse(secWebSocketExtensions);\n      } catch (err) {\n        const message = 'Invalid Sec-WebSocket-Extensions header';\n        abortHandshake(websocket, socket, message);\n        return;\n      }\n\n      const extensionNames = Object.keys(extensions);\n\n      if (\n        extensionNames.length !== 1 ||\n        extensionNames[0] !== PerMessageDeflate.extensionName\n      ) {\n        const message = 'Server indicated an extension that was not requested';\n        abortHandshake(websocket, socket, message);\n        return;\n      }\n\n      try {\n        perMessageDeflate.accept(extensions[PerMessageDeflate.extensionName]);\n      } catch (err) {\n        const message = 'Invalid Sec-WebSocket-Extensions header';\n        abortHandshake(websocket, socket, message);\n        return;\n      }\n\n      websocket._extensions[PerMessageDeflate.extensionName] =\n        perMessageDeflate;\n    }\n\n    websocket.setSocket(socket, head, {\n      generateMask: opts.generateMask,\n      maxPayload: opts.maxPayload,\n      skipUTF8Validation: opts.skipUTF8Validation\n    });\n  });\n}\n\n/**\n * Emit the `'error'` and `'close'` event.\n *\n * @param {WebSocket} websocket The WebSocket instance\n * @param {Error} The error to emit\n * @private\n */\nfunction emitErrorAndClose(websocket, err) {\n  websocket._readyState = WebSocket.CLOSING;\n  websocket.emit('error', err);\n  websocket.emitClose();\n}\n\n/**\n * Create a `net.Socket` and initiate a connection.\n *\n * @param {Object} options Connection options\n * @return {net.Socket} The newly created socket used to start the connection\n * @private\n */\nfunction netConnect(options) {\n  options.path = options.socketPath;\n  return net.connect(options);\n}\n\n/**\n * Create a `tls.TLSSocket` and initiate a connection.\n *\n * @param {Object} options Connection options\n * @return {tls.TLSSocket} The newly created socket used to start the connection\n * @private\n */\nfunction tlsConnect(options) {\n  options.path = undefined;\n\n  if (!options.servername && options.servername !== '') {\n    options.servername = net.isIP(options.host) ? '' : options.host;\n  }\n\n  return tls.connect(options);\n}\n\n/**\n * Abort the handshake and emit an error.\n *\n * @param {WebSocket} websocket The WebSocket instance\n * @param {(http.ClientRequest|net.Socket|tls.Socket)} stream The request to\n *     abort or the socket to destroy\n * @param {String} message The error message\n * @private\n */\nfunction abortHandshake(websocket, stream, message) {\n  websocket._readyState = WebSocket.CLOSING;\n\n  const err = new Error(message);\n  Error.captureStackTrace(err, abortHandshake);\n\n  if (stream.setHeader) {\n    stream.abort();\n\n    if (stream.socket && !stream.socket.destroyed) {\n      //\n      // On Node.js >= 14.3.0 `request.abort()` does not destroy the socket if\n      // called after the request completed. See\n      // https://github.com/websockets/ws/issues/1869.\n      //\n      stream.socket.destroy();\n    }\n\n    stream.once('abort', websocket.emitClose.bind(websocket));\n    websocket.emit('error', err);\n  } else {\n    stream.destroy(err);\n    stream.once('error', websocket.emit.bind(websocket, 'error'));\n    stream.once('close', websocket.emitClose.bind(websocket));\n  }\n}\n\n/**\n * Handle cases where the `ping()`, `pong()`, or `send()` methods are called\n * when the `readyState` attribute is `CLOSING` or `CLOSED`.\n *\n * @param {WebSocket} websocket The WebSocket instance\n * @param {*} [data] The data to send\n * @param {Function} [cb] Callback\n * @private\n */\nfunction sendAfterClose(websocket, data, cb) {\n  if (data) {\n    const length = toBuffer(data).length;\n\n    //\n    // The `_bufferedAmount` property is used only when the peer is a client and\n    // the opening handshake fails. Under these circumstances, in fact, the\n    // `setSocket()` method is not called, so the `_socket` and `_sender`\n    // properties are set to `null`.\n    //\n    if (websocket._socket) websocket._sender._bufferedBytes += length;\n    else websocket._bufferedAmount += length;\n  }\n\n  if (cb) {\n    const err = new Error(\n      `WebSocket is not open: readyState ${websocket.readyState} ` +\n        `(${readyStates[websocket.readyState]})`\n    );\n    cb(err);\n  }\n}\n\n/**\n * The listener of the `Receiver` `'conclude'` event.\n *\n * @param {Number} code The status code\n * @param {Buffer} reason The reason for closing\n * @private\n */\nfunction receiverOnConclude(code, reason) {\n  const websocket = this[kWebSocket];\n\n  websocket._closeFrameReceived = true;\n  websocket._closeMessage = reason;\n  websocket._closeCode = code;\n\n  if (websocket._socket[kWebSocket] === undefined) return;\n\n  websocket._socket.removeListener('data', socketOnData);\n  process.nextTick(resume, websocket._socket);\n\n  if (code === 1005) websocket.close();\n  else websocket.close(code, reason);\n}\n\n/**\n * The listener of the `Receiver` `'drain'` event.\n *\n * @private\n */\nfunction receiverOnDrain() {\n  const websocket = this[kWebSocket];\n\n  if (!websocket.isPaused) websocket._socket.resume();\n}\n\n/**\n * The listener of the `Receiver` `'error'` event.\n *\n * @param {(RangeError|Error)} err The emitted error\n * @private\n */\nfunction receiverOnError(err) {\n  const websocket = this[kWebSocket];\n\n  if (websocket._socket[kWebSocket] !== undefined) {\n    websocket._socket.removeListener('data', socketOnData);\n\n    //\n    // On Node.js < 14.0.0 the `'error'` event is emitted synchronously. See\n    // https://github.com/websockets/ws/issues/1940.\n    //\n    process.nextTick(resume, websocket._socket);\n\n    websocket.close(err[kStatusCode]);\n  }\n\n  websocket.emit('error', err);\n}\n\n/**\n * The listener of the `Receiver` `'finish'` event.\n *\n * @private\n */\nfunction receiverOnFinish() {\n  this[kWebSocket].emitClose();\n}\n\n/**\n * The listener of the `Receiver` `'message'` event.\n *\n * @param {Buffer|ArrayBuffer|Buffer[])} data The message\n * @param {Boolean} isBinary Specifies whether the message is binary or not\n * @private\n */\nfunction receiverOnMessage(data, isBinary) {\n  this[kWebSocket].emit('message', data, isBinary);\n}\n\n/**\n * The listener of the `Receiver` `'ping'` event.\n *\n * @param {Buffer} data The data included in the ping frame\n * @private\n */\nfunction receiverOnPing(data) {\n  const websocket = this[kWebSocket];\n\n  websocket.pong(data, !websocket._isServer, NOOP);\n  websocket.emit('ping', data);\n}\n\n/**\n * The listener of the `Receiver` `'pong'` event.\n *\n * @param {Buffer} data The data included in the pong frame\n * @private\n */\nfunction receiverOnPong(data) {\n  this[kWebSocket].emit('pong', data);\n}\n\n/**\n * Resume a readable stream\n *\n * @param {Readable} stream The readable stream\n * @private\n */\nfunction resume(stream) {\n  stream.resume();\n}\n\n/**\n * The listener of the `net.Socket` `'close'` event.\n *\n * @private\n */\nfunction socketOnClose() {\n  const websocket = this[kWebSocket];\n\n  this.removeListener('close', socketOnClose);\n  this.removeListener('data', socketOnData);\n  this.removeListener('end', socketOnEnd);\n\n  websocket._readyState = WebSocket.CLOSING;\n\n  let chunk;\n\n  //\n  // The close frame might not have been received or the `'end'` event emitted,\n  // for example, if the socket was destroyed due to an error. Ensure that the\n  // `receiver` stream is closed after writing any remaining buffered data to\n  // it. If the readable side of the socket is in flowing mode then there is no\n  // buffered data as everything has been already written and `readable.read()`\n  // will return `null`. If instead, the socket is paused, any possible buffered\n  // data will be read as a single chunk.\n  //\n  if (\n    !this._readableState.endEmitted &&\n    !websocket._closeFrameReceived &&\n    !websocket._receiver._writableState.errorEmitted &&\n    (chunk = websocket._socket.read()) !== null\n  ) {\n    websocket._receiver.write(chunk);\n  }\n\n  websocket._receiver.end();\n\n  this[kWebSocket] = undefined;\n\n  clearTimeout(websocket._closeTimer);\n\n  if (\n    websocket._receiver._writableState.finished ||\n    websocket._receiver._writableState.errorEmitted\n  ) {\n    websocket.emitClose();\n  } else {\n    websocket._receiver.on('error', receiverOnFinish);\n    websocket._receiver.on('finish', receiverOnFinish);\n  }\n}\n\n/**\n * The listener of the `net.Socket` `'data'` event.\n *\n * @param {Buffer} chunk A chunk of data\n * @private\n */\nfunction socketOnData(chunk) {\n  if (!this[kWebSocket]._receiver.write(chunk)) {\n    this.pause();\n  }\n}\n\n/**\n * The listener of the `net.Socket` `'end'` event.\n *\n * @private\n */\nfunction socketOnEnd() {\n  const websocket = this[kWebSocket];\n\n  websocket._readyState = WebSocket.CLOSING;\n  websocket._receiver.end();\n  this.end();\n}\n\n/**\n * The listener of the `net.Socket` `'error'` event.\n *\n * @private\n */\nfunction socketOnError() {\n  const websocket = this[kWebSocket];\n\n  this.removeListener('error', socketOnError);\n  this.on('error', NOOP);\n\n  if (websocket) {\n    websocket._readyState = WebSocket.CLOSING;\n    this.destroy();\n  }\n}\n"],"mappings":"AAAA;;AAEA,YAAY;;AAEZ,MAAMA,YAAY,GAAGC,OAAO,CAAC,QAAQ,CAAC;AACtC,MAAMC,KAAK,GAAGD,OAAO,CAAC,OAAO,CAAC;AAC9B,MAAME,IAAI,GAAGF,OAAO,CAAC,MAAM,CAAC;AAC5B,MAAMG,GAAG,GAAGH,OAAO,CAAC,KAAK,CAAC;AAC1B,MAAMI,GAAG,GAAGJ,OAAO,CAAC,KAAK,CAAC;AAC1B,MAAM;EAAEK,WAAW;EAAEC;AAAW,CAAC,GAAGN,OAAO,CAAC,QAAQ,CAAC;AACrD,MAAM;EAAEO;AAAS,CAAC,GAAGP,OAAO,CAAC,QAAQ,CAAC;AACtC,MAAM;EAAEQ;AAAI,CAAC,GAAGR,OAAO,CAAC,KAAK,CAAC;AAE9B,MAAMS,iBAAiB,GAAGT,OAAO,CAAC,sBAAsB,CAAC;AACzD,MAAMU,QAAQ,GAAGV,OAAO,CAAC,YAAY,CAAC;AACtC,MAAMW,MAAM,GAAGX,OAAO,CAAC,UAAU,CAAC;AAClC,MAAM;EACJY,YAAY;EACZC,YAAY;EACZC,IAAI;EACJC,oBAAoB;EACpBC,SAAS;EACTC,WAAW;EACXC,UAAU;EACVC;AACF,CAAC,GAAGnB,OAAO,CAAC,aAAa,CAAC;AAC1B,MAAM;EACJoB,WAAW,EAAE;IAAEC,gBAAgB;IAAEC;EAAoB;AACvD,CAAC,GAAGtB,OAAO,CAAC,gBAAgB,CAAC;AAC7B,MAAM;EAAEuB,MAAM;EAAEC;AAAM,CAAC,GAAGxB,OAAO,CAAC,aAAa,CAAC;AAChD,MAAM;EAAEyB;AAAS,CAAC,GAAGzB,OAAO,CAAC,eAAe,CAAC;AAE7C,MAAM0B,WAAW,GAAG,CAAC,YAAY,EAAE,MAAM,EAAE,SAAS,EAAE,QAAQ,CAAC;AAC/D,MAAMC,gBAAgB,GAAG,gCAAgC;AACzD,MAAMC,gBAAgB,GAAG,CAAC,CAAC,EAAE,EAAE,CAAC;AAChC,MAAMC,YAAY,GAAG,EAAE,GAAG,IAAI;;AAE9B;AACA;AACA;AACA;AACA;AACA,MAAMC,SAAS,SAAS/B,YAAY,CAAC;EACnC;AACF;AACA;AACA;AACA;AACA;AACA;EACEgC,WAAW,CAACC,OAAO,EAAEC,SAAS,EAAEC,OAAO,EAAE;IACvC,KAAK,EAAE;IAEP,IAAI,CAACC,WAAW,GAAGvB,YAAY,CAAC,CAAC,CAAC;IAClC,IAAI,CAACwB,UAAU,GAAG,IAAI;IACtB,IAAI,CAACC,mBAAmB,GAAG,KAAK;IAChC,IAAI,CAACC,eAAe,GAAG,KAAK;IAC5B,IAAI,CAACC,aAAa,GAAG1B,YAAY;IACjC,IAAI,CAAC2B,WAAW,GAAG,IAAI;IACvB,IAAI,CAACC,WAAW,GAAG,CAAC,CAAC;IACrB,IAAI,CAACC,OAAO,GAAG,KAAK;IACpB,IAAI,CAACC,SAAS,GAAG,EAAE;IACnB,IAAI,CAACC,WAAW,GAAGd,SAAS,CAACe,UAAU;IACvC,IAAI,CAACC,SAAS,GAAG,IAAI;IACrB,IAAI,CAACC,OAAO,GAAG,IAAI;IACnB,IAAI,CAACC,OAAO,GAAG,IAAI;IAEnB,IAAIhB,OAAO,KAAK,IAAI,EAAE;MACpB,IAAI,CAACiB,eAAe,GAAG,CAAC;MACxB,IAAI,CAACC,SAAS,GAAG,KAAK;MACtB,IAAI,CAACC,UAAU,GAAG,CAAC;MAEnB,IAAIlB,SAAS,KAAKmB,SAAS,EAAE;QAC3BnB,SAAS,GAAG,EAAE;MAChB,CAAC,MAAM,IAAI,CAACoB,KAAK,CAACC,OAAO,CAACrB,SAAS,CAAC,EAAE;QACpC,IAAI,OAAOA,SAAS,KAAK,QAAQ,IAAIA,SAAS,KAAK,IAAI,EAAE;UACvDC,OAAO,GAAGD,SAAS;UACnBA,SAAS,GAAG,EAAE;QAChB,CAAC,MAAM;UACLA,SAAS,GAAG,CAACA,SAAS,CAAC;QACzB;MACF;MAEAsB,YAAY,CAAC,IAAI,EAAEvB,OAAO,EAAEC,SAAS,EAAEC,OAAO,CAAC;IACjD,CAAC,MAAM;MACL,IAAI,CAACgB,SAAS,GAAG,IAAI;IACvB;EACF;;EAEA;AACF;AACA;AACA;AACA;AACA;AACA;EACE,IAAIM,UAAU,GAAG;IACf,OAAO,IAAI,CAACrB,WAAW;EACzB;EAEA,IAAIqB,UAAU,CAACC,IAAI,EAAE;IACnB,IAAI,CAAC7C,YAAY,CAAC8C,QAAQ,CAACD,IAAI,CAAC,EAAE;IAElC,IAAI,CAACtB,WAAW,GAAGsB,IAAI;;IAEvB;IACA;IACA;IACA,IAAI,IAAI,CAACX,SAAS,EAAE,IAAI,CAACA,SAAS,CAACX,WAAW,GAAGsB,IAAI;EACvD;;EAEA;AACF;AACA;EACE,IAAIE,cAAc,GAAG;IACnB,IAAI,CAAC,IAAI,CAACX,OAAO,EAAE,OAAO,IAAI,CAACC,eAAe;IAE9C,OAAO,IAAI,CAACD,OAAO,CAACY,cAAc,CAACC,MAAM,GAAG,IAAI,CAACd,OAAO,CAACe,cAAc;EACzE;;EAEA;AACF;AACA;EACE,IAAIC,UAAU,GAAG;IACf,OAAOC,MAAM,CAACC,IAAI,CAAC,IAAI,CAACxB,WAAW,CAAC,CAACyB,IAAI,EAAE;EAC7C;;EAEA;AACF;AACA;EACE,IAAIC,QAAQ,GAAG;IACb,OAAO,IAAI,CAACzB,OAAO;EACrB;;EAEA;AACF;AACA;EACE;EACA,IAAI0B,OAAO,GAAG;IACZ,OAAO,IAAI;EACb;;EAEA;AACF;AACA;EACE;EACA,IAAIC,OAAO,GAAG;IACZ,OAAO,IAAI;EACb;;EAEA;AACF;AACA;EACE;EACA,IAAIC,MAAM,GAAG;IACX,OAAO,IAAI;EACb;;EAEA;AACF;AACA;EACE;EACA,IAAIC,SAAS,GAAG;IACd,OAAO,IAAI;EACb;;EAEA;AACF;AACA;EACE,IAAIC,QAAQ,GAAG;IACb,OAAO,IAAI,CAAC7B,SAAS;EACvB;;EAEA;AACF;AACA;EACE,IAAI8B,UAAU,GAAG;IACf,OAAO,IAAI,CAAC7B,WAAW;EACzB;;EAEA;AACF;AACA;EACE,IAAI8B,GAAG,GAAG;IACR,OAAO,IAAI,CAACC,IAAI;EAClB;;EAEA;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACEC,SAAS,CAACC,MAAM,EAAEC,IAAI,EAAE5C,OAAO,EAAE;IAC/B,MAAM6C,QAAQ,GAAG,IAAIrE,QAAQ,CAAC;MAC5B8C,UAAU,EAAE,IAAI,CAACA,UAAU;MAC3BO,UAAU,EAAE,IAAI,CAACtB,WAAW;MAC5BuC,QAAQ,EAAE,IAAI,CAAC9B,SAAS;MACxB+B,UAAU,EAAE/C,OAAO,CAAC+C,UAAU;MAC9BC,kBAAkB,EAAEhD,OAAO,CAACgD;IAC9B,CAAC,CAAC;IAEF,IAAI,CAACnC,OAAO,GAAG,IAAIpC,MAAM,CAACkE,MAAM,EAAE,IAAI,CAACpC,WAAW,EAAEP,OAAO,CAACiD,YAAY,CAAC;IACzE,IAAI,CAACrC,SAAS,GAAGiC,QAAQ;IACzB,IAAI,CAAC/B,OAAO,GAAG6B,MAAM;IAErBE,QAAQ,CAAC7D,UAAU,CAAC,GAAG,IAAI;IAC3B2D,MAAM,CAAC3D,UAAU,CAAC,GAAG,IAAI;IAEzB6D,QAAQ,CAACK,EAAE,CAAC,UAAU,EAAEC,kBAAkB,CAAC;IAC3CN,QAAQ,CAACK,EAAE,CAAC,OAAO,EAAEE,eAAe,CAAC;IACrCP,QAAQ,CAACK,EAAE,CAAC,OAAO,EAAEG,eAAe,CAAC;IACrCR,QAAQ,CAACK,EAAE,CAAC,SAAS,EAAEI,iBAAiB,CAAC;IACzCT,QAAQ,CAACK,EAAE,CAAC,MAAM,EAAEK,cAAc,CAAC;IACnCV,QAAQ,CAACK,EAAE,CAAC,MAAM,EAAEM,cAAc,CAAC;IAEnCb,MAAM,CAACc,UAAU,CAAC,CAAC,CAAC;IACpBd,MAAM,CAACe,UAAU,EAAE;IAEnB,IAAId,IAAI,CAACjB,MAAM,GAAG,CAAC,EAAEgB,MAAM,CAACgB,OAAO,CAACf,IAAI,CAAC;IAEzCD,MAAM,CAACO,EAAE,CAAC,OAAO,EAAEU,aAAa,CAAC;IACjCjB,MAAM,CAACO,EAAE,CAAC,MAAM,EAAEW,YAAY,CAAC;IAC/BlB,MAAM,CAACO,EAAE,CAAC,KAAK,EAAEY,WAAW,CAAC;IAC7BnB,MAAM,CAACO,EAAE,CAAC,OAAO,EAAEa,aAAa,CAAC;IAEjC,IAAI,CAACrD,WAAW,GAAGd,SAAS,CAACoE,IAAI;IACjC,IAAI,CAACC,IAAI,CAAC,MAAM,CAAC;EACnB;;EAEA;AACF;AACA;AACA;AACA;EACEC,SAAS,GAAG;IACV,IAAI,CAAC,IAAI,CAACpD,OAAO,EAAE;MACjB,IAAI,CAACJ,WAAW,GAAGd,SAAS,CAACuE,MAAM;MACnC,IAAI,CAACF,IAAI,CAAC,OAAO,EAAE,IAAI,CAAC/D,UAAU,EAAE,IAAI,CAACG,aAAa,CAAC;MACvD;IACF;IAEA,IAAI,IAAI,CAACE,WAAW,CAAChC,iBAAiB,CAAC6F,aAAa,CAAC,EAAE;MACrD,IAAI,CAAC7D,WAAW,CAAChC,iBAAiB,CAAC6F,aAAa,CAAC,CAACC,OAAO,EAAE;IAC7D;IAEA,IAAI,CAACzD,SAAS,CAAC0D,kBAAkB,EAAE;IACnC,IAAI,CAAC5D,WAAW,GAAGd,SAAS,CAACuE,MAAM;IACnC,IAAI,CAACF,IAAI,CAAC,OAAO,EAAE,IAAI,CAAC/D,UAAU,EAAE,IAAI,CAACG,aAAa,CAAC;EACzD;;EAEA;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACEkE,KAAK,CAACC,IAAI,EAAEC,IAAI,EAAE;IAChB,IAAI,IAAI,CAAClC,UAAU,KAAK3C,SAAS,CAACuE,MAAM,EAAE;IAC1C,IAAI,IAAI,CAAC5B,UAAU,KAAK3C,SAAS,CAACe,UAAU,EAAE;MAC5C,MAAM+D,GAAG,GAAG,4DAA4D;MACxE,OAAOC,cAAc,CAAC,IAAI,EAAE,IAAI,CAACC,IAAI,EAAEF,GAAG,CAAC;IAC7C;IAEA,IAAI,IAAI,CAACnC,UAAU,KAAK3C,SAAS,CAACiF,OAAO,EAAE;MACzC,IACE,IAAI,CAACzE,eAAe,KACnB,IAAI,CAACD,mBAAmB,IAAI,IAAI,CAACS,SAAS,CAACc,cAAc,CAACoD,YAAY,CAAC,EACxE;QACA,IAAI,CAAChE,OAAO,CAACiE,GAAG,EAAE;MACpB;MAEA;IACF;IAEA,IAAI,CAACrE,WAAW,GAAGd,SAAS,CAACiF,OAAO;IACpC,IAAI,CAAChE,OAAO,CAAC0D,KAAK,CAACC,IAAI,EAAEC,IAAI,EAAE,CAAC,IAAI,CAACzD,SAAS,EAAGgE,GAAG,IAAK;MACvD;MACA;MACA;MACA;MACA,IAAIA,GAAG,EAAE;MAET,IAAI,CAAC5E,eAAe,GAAG,IAAI;MAE3B,IACE,IAAI,CAACD,mBAAmB,IACxB,IAAI,CAACS,SAAS,CAACc,cAAc,CAACoD,YAAY,EAC1C;QACA,IAAI,CAAChE,OAAO,CAACiE,GAAG,EAAE;MACpB;IACF,CAAC,CAAC;;IAEF;IACA;IACA;IACA,IAAI,CAACzE,WAAW,GAAGmD,UAAU,CAC3B,IAAI,CAAC3C,OAAO,CAACmE,OAAO,CAACC,IAAI,CAAC,IAAI,CAACpE,OAAO,CAAC,EACvCnB,YAAY,CACb;EACH;;EAEA;AACF;AACA;AACA;AACA;EACEwF,KAAK,GAAG;IACN,IACE,IAAI,CAAC5C,UAAU,KAAK3C,SAAS,CAACe,UAAU,IACxC,IAAI,CAAC4B,UAAU,KAAK3C,SAAS,CAACuE,MAAM,EACpC;MACA;IACF;IAEA,IAAI,CAAC3D,OAAO,GAAG,IAAI;IACnB,IAAI,CAACM,OAAO,CAACqE,KAAK,EAAE;EACtB;;EAEA;AACF;AACA;AACA;AACA;AACA;AACA;AACA;EACEC,IAAI,CAACX,IAAI,EAAEY,IAAI,EAAEC,EAAE,EAAE;IACnB,IAAI,IAAI,CAAC/C,UAAU,KAAK3C,SAAS,CAACe,UAAU,EAAE;MAC5C,MAAM,IAAI4E,KAAK,CAAC,kDAAkD,CAAC;IACrE;IAEA,IAAI,OAAOd,IAAI,KAAK,UAAU,EAAE;MAC9Ba,EAAE,GAAGb,IAAI;MACTA,IAAI,GAAGY,IAAI,GAAGnE,SAAS;IACzB,CAAC,MAAM,IAAI,OAAOmE,IAAI,KAAK,UAAU,EAAE;MACrCC,EAAE,GAAGD,IAAI;MACTA,IAAI,GAAGnE,SAAS;IAClB;IAEA,IAAI,OAAOuD,IAAI,KAAK,QAAQ,EAAEA,IAAI,GAAGA,IAAI,CAACe,QAAQ,EAAE;IAEpD,IAAI,IAAI,CAACjD,UAAU,KAAK3C,SAAS,CAACoE,IAAI,EAAE;MACtCyB,cAAc,CAAC,IAAI,EAAEhB,IAAI,EAAEa,EAAE,CAAC;MAC9B;IACF;IAEA,IAAID,IAAI,KAAKnE,SAAS,EAAEmE,IAAI,GAAG,CAAC,IAAI,CAACrE,SAAS;IAC9C,IAAI,CAACH,OAAO,CAACuE,IAAI,CAACX,IAAI,IAAI9F,YAAY,EAAE0G,IAAI,EAAEC,EAAE,CAAC;EACnD;;EAEA;AACF;AACA;AACA;AACA;AACA;AACA;AACA;EACEI,IAAI,CAACjB,IAAI,EAAEY,IAAI,EAAEC,EAAE,EAAE;IACnB,IAAI,IAAI,CAAC/C,UAAU,KAAK3C,SAAS,CAACe,UAAU,EAAE;MAC5C,MAAM,IAAI4E,KAAK,CAAC,kDAAkD,CAAC;IACrE;IAEA,IAAI,OAAOd,IAAI,KAAK,UAAU,EAAE;MAC9Ba,EAAE,GAAGb,IAAI;MACTA,IAAI,GAAGY,IAAI,GAAGnE,SAAS;IACzB,CAAC,MAAM,IAAI,OAAOmE,IAAI,KAAK,UAAU,EAAE;MACrCC,EAAE,GAAGD,IAAI;MACTA,IAAI,GAAGnE,SAAS;IAClB;IAEA,IAAI,OAAOuD,IAAI,KAAK,QAAQ,EAAEA,IAAI,GAAGA,IAAI,CAACe,QAAQ,EAAE;IAEpD,IAAI,IAAI,CAACjD,UAAU,KAAK3C,SAAS,CAACoE,IAAI,EAAE;MACtCyB,cAAc,CAAC,IAAI,EAAEhB,IAAI,EAAEa,EAAE,CAAC;MAC9B;IACF;IAEA,IAAID,IAAI,KAAKnE,SAAS,EAAEmE,IAAI,GAAG,CAAC,IAAI,CAACrE,SAAS;IAC9C,IAAI,CAACH,OAAO,CAAC6E,IAAI,CAACjB,IAAI,IAAI9F,YAAY,EAAE0G,IAAI,EAAEC,EAAE,CAAC;EACnD;;EAEA;AACF;AACA;AACA;AACA;EACEK,MAAM,GAAG;IACP,IACE,IAAI,CAACpD,UAAU,KAAK3C,SAAS,CAACe,UAAU,IACxC,IAAI,CAAC4B,UAAU,KAAK3C,SAAS,CAACuE,MAAM,EACpC;MACA;IACF;IAEA,IAAI,CAAC3D,OAAO,GAAG,KAAK;IACpB,IAAI,CAAC,IAAI,CAACI,SAAS,CAACc,cAAc,CAACkE,SAAS,EAAE,IAAI,CAAC9E,OAAO,CAAC6E,MAAM,EAAE;EACrE;;EAEA;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACEE,IAAI,CAACpB,IAAI,EAAEzE,OAAO,EAAEsF,EAAE,EAAE;IACtB,IAAI,IAAI,CAAC/C,UAAU,KAAK3C,SAAS,CAACe,UAAU,EAAE;MAC5C,MAAM,IAAI4E,KAAK,CAAC,kDAAkD,CAAC;IACrE;IAEA,IAAI,OAAOvF,OAAO,KAAK,UAAU,EAAE;MACjCsF,EAAE,GAAGtF,OAAO;MACZA,OAAO,GAAG,CAAC,CAAC;IACd;IAEA,IAAI,OAAOyE,IAAI,KAAK,QAAQ,EAAEA,IAAI,GAAGA,IAAI,CAACe,QAAQ,EAAE;IAEpD,IAAI,IAAI,CAACjD,UAAU,KAAK3C,SAAS,CAACoE,IAAI,EAAE;MACtCyB,cAAc,CAAC,IAAI,EAAEhB,IAAI,EAAEa,EAAE,CAAC;MAC9B;IACF;IAEA,MAAMQ,IAAI,GAAG;MACXC,MAAM,EAAE,OAAOtB,IAAI,KAAK,QAAQ;MAChCY,IAAI,EAAE,CAAC,IAAI,CAACrE,SAAS;MACrBgF,QAAQ,EAAE,IAAI;MACdC,GAAG,EAAE,IAAI;MACT,GAAGjG;IACL,CAAC;IAED,IAAI,CAAC,IAAI,CAACO,WAAW,CAAChC,iBAAiB,CAAC6F,aAAa,CAAC,EAAE;MACtD0B,IAAI,CAACE,QAAQ,GAAG,KAAK;IACvB;IAEA,IAAI,CAACnF,OAAO,CAACgF,IAAI,CAACpB,IAAI,IAAI9F,YAAY,EAAEmH,IAAI,EAAER,EAAE,CAAC;EACnD;;EAEA;AACF;AACA;AACA;AACA;EACEY,SAAS,GAAG;IACV,IAAI,IAAI,CAAC3D,UAAU,KAAK3C,SAAS,CAACuE,MAAM,EAAE;IAC1C,IAAI,IAAI,CAAC5B,UAAU,KAAK3C,SAAS,CAACe,UAAU,EAAE;MAC5C,MAAM+D,GAAG,GAAG,4DAA4D;MACxE,OAAOC,cAAc,CAAC,IAAI,EAAE,IAAI,CAACC,IAAI,EAAEF,GAAG,CAAC;IAC7C;IAEA,IAAI,IAAI,CAAC5D,OAAO,EAAE;MAChB,IAAI,CAACJ,WAAW,GAAGd,SAAS,CAACiF,OAAO;MACpC,IAAI,CAAC/D,OAAO,CAACmE,OAAO,EAAE;IACxB;EACF;AACF;;AAEA;AACA;AACA;AACA;AACAnD,MAAM,CAACqE,cAAc,CAACvG,SAAS,EAAE,YAAY,EAAE;EAC7CwG,UAAU,EAAE,IAAI;EAChBC,KAAK,EAAE7G,WAAW,CAAC8G,OAAO,CAAC,YAAY;AACzC,CAAC,CAAC;;AAEF;AACA;AACA;AACA;AACAxE,MAAM,CAACqE,cAAc,CAACvG,SAAS,CAAC2G,SAAS,EAAE,YAAY,EAAE;EACvDH,UAAU,EAAE,IAAI;EAChBC,KAAK,EAAE7G,WAAW,CAAC8G,OAAO,CAAC,YAAY;AACzC,CAAC,CAAC;;AAEF;AACA;AACA;AACA;AACAxE,MAAM,CAACqE,cAAc,CAACvG,SAAS,EAAE,MAAM,EAAE;EACvCwG,UAAU,EAAE,IAAI;EAChBC,KAAK,EAAE7G,WAAW,CAAC8G,OAAO,CAAC,MAAM;AACnC,CAAC,CAAC;;AAEF;AACA;AACA;AACA;AACAxE,MAAM,CAACqE,cAAc,CAACvG,SAAS,CAAC2G,SAAS,EAAE,MAAM,EAAE;EACjDH,UAAU,EAAE,IAAI;EAChBC,KAAK,EAAE7G,WAAW,CAAC8G,OAAO,CAAC,MAAM;AACnC,CAAC,CAAC;;AAEF;AACA;AACA;AACA;AACAxE,MAAM,CAACqE,cAAc,CAACvG,SAAS,EAAE,SAAS,EAAE;EAC1CwG,UAAU,EAAE,IAAI;EAChBC,KAAK,EAAE7G,WAAW,CAAC8G,OAAO,CAAC,SAAS;AACtC,CAAC,CAAC;;AAEF;AACA;AACA;AACA;AACAxE,MAAM,CAACqE,cAAc,CAACvG,SAAS,CAAC2G,SAAS,EAAE,SAAS,EAAE;EACpDH,UAAU,EAAE,IAAI;EAChBC,KAAK,EAAE7G,WAAW,CAAC8G,OAAO,CAAC,SAAS;AACtC,CAAC,CAAC;;AAEF;AACA;AACA;AACA;AACAxE,MAAM,CAACqE,cAAc,CAACvG,SAAS,EAAE,QAAQ,EAAE;EACzCwG,UAAU,EAAE,IAAI;EAChBC,KAAK,EAAE7G,WAAW,CAAC8G,OAAO,CAAC,QAAQ;AACrC,CAAC,CAAC;;AAEF;AACA;AACA;AACA;AACAxE,MAAM,CAACqE,cAAc,CAACvG,SAAS,CAAC2G,SAAS,EAAE,QAAQ,EAAE;EACnDH,UAAU,EAAE,IAAI;EAChBC,KAAK,EAAE7G,WAAW,CAAC8G,OAAO,CAAC,QAAQ;AACrC,CAAC,CAAC;AAEF,CACE,YAAY,EACZ,gBAAgB,EAChB,YAAY,EACZ,UAAU,EACV,UAAU,EACV,YAAY,EACZ,KAAK,CACN,CAACE,OAAO,CAAEC,QAAQ,IAAK;EACtB3E,MAAM,CAACqE,cAAc,CAACvG,SAAS,CAAC2G,SAAS,EAAEE,QAAQ,EAAE;IAAEL,UAAU,EAAE;EAAK,CAAC,CAAC;AAC5E,CAAC,CAAC;;AAEF;AACA;AACA;AACA;AACA,CAAC,MAAM,EAAE,OAAO,EAAE,OAAO,EAAE,SAAS,CAAC,CAACI,OAAO,CAAEE,MAAM,IAAK;EACxD5E,MAAM,CAACqE,cAAc,CAACvG,SAAS,CAAC2G,SAAS,EAAG,KAAIG,MAAO,EAAC,EAAE;IACxDN,UAAU,EAAE,IAAI;IAChBO,GAAG,GAAG;MACJ,KAAK,MAAMC,QAAQ,IAAI,IAAI,CAACC,SAAS,CAACH,MAAM,CAAC,EAAE;QAC7C,IAAIE,QAAQ,CAAC/H,oBAAoB,CAAC,EAAE,OAAO+H,QAAQ,CAAC9H,SAAS,CAAC;MAChE;MAEA,OAAO,IAAI;IACb,CAAC;IACDgI,GAAG,CAACC,OAAO,EAAE;MACX,KAAK,MAAMH,QAAQ,IAAI,IAAI,CAACC,SAAS,CAACH,MAAM,CAAC,EAAE;QAC7C,IAAIE,QAAQ,CAAC/H,oBAAoB,CAAC,EAAE;UAClC,IAAI,CAACmI,cAAc,CAACN,MAAM,EAAEE,QAAQ,CAAC;UACrC;QACF;MACF;MAEA,IAAI,OAAOG,OAAO,KAAK,UAAU,EAAE;MAEnC,IAAI,CAAC5H,gBAAgB,CAACuH,MAAM,EAAEK,OAAO,EAAE;QACrC,CAAClI,oBAAoB,GAAG;MAC1B,CAAC,CAAC;IACJ;EACF,CAAC,CAAC;AACJ,CAAC,CAAC;AAEFe,SAAS,CAAC2G,SAAS,CAACpH,gBAAgB,GAAGA,gBAAgB;AACvDS,SAAS,CAAC2G,SAAS,CAACnH,mBAAmB,GAAGA,mBAAmB;AAE7D6H,MAAM,CAACC,OAAO,GAAGtH,SAAS;;AAE1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASyB,YAAY,CAAC8F,SAAS,EAAErH,OAAO,EAAEC,SAAS,EAAEC,OAAO,EAAE;EAC5D,MAAM8F,IAAI,GAAG;IACXsB,eAAe,EAAE1H,gBAAgB,CAAC,CAAC,CAAC;IACpCqD,UAAU,EAAE,GAAG,GAAG,IAAI,GAAG,IAAI;IAC7BC,kBAAkB,EAAE,KAAK;IACzBqE,iBAAiB,EAAE,IAAI;IACvBC,eAAe,EAAE,KAAK;IACtBC,YAAY,EAAE,EAAE;IAChB,GAAGvH,OAAO;IACVwH,gBAAgB,EAAEtG,SAAS;IAC3BuG,UAAU,EAAEvG,SAAS;IACrBwG,QAAQ,EAAExG,SAAS;IACnBoB,QAAQ,EAAEpB,SAAS;IACnByG,OAAO,EAAEzG,SAAS;IAClBwF,MAAM,EAAExF,SAAS;IACjB0G,IAAI,EAAE1G,SAAS;IACf2G,IAAI,EAAE3G,SAAS;IACf4G,IAAI,EAAE5G;EACR,CAAC;EAED,IAAI,CAACxB,gBAAgB,CAAC8B,QAAQ,CAACsE,IAAI,CAACsB,eAAe,CAAC,EAAE;IACpD,MAAM,IAAIW,UAAU,CACjB,iCAAgCjC,IAAI,CAACsB,eAAgB,GAAE,GACrD,wBAAuB1H,gBAAgB,CAACsC,IAAI,CAAC,IAAI,CAAE,GAAE,CACzD;EACH;EAEA,IAAIgG,SAAS;EAEb,IAAIlI,OAAO,YAAYxB,GAAG,EAAE;IAC1B0J,SAAS,GAAGlI,OAAO;IACnBqH,SAAS,CAAC1E,IAAI,GAAG3C,OAAO,CAACmI,IAAI;EAC/B,CAAC,MAAM;IACL,IAAI;MACFD,SAAS,GAAG,IAAI1J,GAAG,CAACwB,OAAO,CAAC;IAC9B,CAAC,CAAC,OAAOoI,CAAC,EAAE;MACV,MAAM,IAAIC,WAAW,CAAE,gBAAerI,OAAQ,EAAC,CAAC;IAClD;IAEAqH,SAAS,CAAC1E,IAAI,GAAG3C,OAAO;EAC1B;EAEA,MAAMsI,QAAQ,GAAGJ,SAAS,CAAC1F,QAAQ,KAAK,MAAM;EAC9C,MAAM+F,YAAY,GAAGL,SAAS,CAAC1F,QAAQ,KAAK,UAAU;EACtD,IAAIgG,iBAAiB;EAErB,IAAIN,SAAS,CAAC1F,QAAQ,KAAK,KAAK,IAAI,CAAC8F,QAAQ,IAAI,CAACC,YAAY,EAAE;IAC9DC,iBAAiB,GACf,iEAAiE;EACrE,CAAC,MAAM,IAAID,YAAY,IAAI,CAACL,SAAS,CAACO,QAAQ,EAAE;IAC9CD,iBAAiB,GAAG,6BAA6B;EACnD,CAAC,MAAM,IAAIN,SAAS,CAACQ,IAAI,EAAE;IACzBF,iBAAiB,GAAG,wCAAwC;EAC9D;EAEA,IAAIA,iBAAiB,EAAE;IACrB,MAAMtD,GAAG,GAAG,IAAImD,WAAW,CAACG,iBAAiB,CAAC;IAE9C,IAAInB,SAAS,CAAClG,UAAU,KAAK,CAAC,EAAE;MAC9B,MAAM+D,GAAG;IACX,CAAC,MAAM;MACLyD,iBAAiB,CAACtB,SAAS,EAAEnC,GAAG,CAAC;MACjC;IACF;EACF;EAEA,MAAM0D,WAAW,GAAGN,QAAQ,GAAG,GAAG,GAAG,EAAE;EACvC,MAAMO,GAAG,GAAGxK,WAAW,CAAC,EAAE,CAAC,CAACqH,QAAQ,CAAC,QAAQ,CAAC;EAC9C,MAAMmB,GAAG,GAAGyB,QAAQ,GAAGrK,KAAK,CAAC4I,GAAG,GAAG3I,IAAI,CAAC2I,GAAG;EAC3C,MAAMiC,WAAW,GAAG,IAAIC,GAAG,EAAE;EAC7B,IAAIxB,iBAAiB;EAErBvB,IAAI,CAAC0B,gBAAgB,GAAGY,QAAQ,GAAGU,UAAU,GAAGC,UAAU;EAC1DjD,IAAI,CAAC4C,WAAW,GAAG5C,IAAI,CAAC4C,WAAW,IAAIA,WAAW;EAClD5C,IAAI,CAACgC,IAAI,GAAGE,SAAS,CAACF,IAAI,IAAIY,WAAW;EACzC5C,IAAI,CAAC8B,IAAI,GAAGI,SAAS,CAACN,QAAQ,CAACsB,UAAU,CAAC,GAAG,CAAC,GAC1ChB,SAAS,CAACN,QAAQ,CAACuB,KAAK,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC,GAC/BjB,SAAS,CAACN,QAAQ;EACtB5B,IAAI,CAACoD,OAAO,GAAG;IACb,uBAAuB,EAAEpD,IAAI,CAACsB,eAAe;IAC7C,mBAAmB,EAAEuB,GAAG;IACxBQ,UAAU,EAAE,SAAS;IACrBC,OAAO,EAAE,WAAW;IACpB,GAAGtD,IAAI,CAACoD;EACV,CAAC;EACDpD,IAAI,CAAC+B,IAAI,GAAGG,SAAS,CAACO,QAAQ,GAAGP,SAAS,CAACqB,MAAM;EACjDvD,IAAI,CAAC6B,OAAO,GAAG7B,IAAI,CAACwD,gBAAgB;EAEpC,IAAIxD,IAAI,CAACuB,iBAAiB,EAAE;IAC1BA,iBAAiB,GAAG,IAAI9I,iBAAiB,CACvCuH,IAAI,CAACuB,iBAAiB,KAAK,IAAI,GAAGvB,IAAI,CAACuB,iBAAiB,GAAG,CAAC,CAAC,EAC7D,KAAK,EACLvB,IAAI,CAAC/C,UAAU,CAChB;IACD+C,IAAI,CAACoD,OAAO,CAAC,0BAA0B,CAAC,GAAG7J,MAAM,CAAC;MAChD,CAACd,iBAAiB,CAAC6F,aAAa,GAAGiD,iBAAiB,CAACkC,KAAK;IAC5D,CAAC,CAAC;EACJ;EACA,IAAIxJ,SAAS,CAAC4B,MAAM,EAAE;IACpB,KAAK,MAAMW,QAAQ,IAAIvC,SAAS,EAAE;MAChC,IACE,OAAOuC,QAAQ,KAAK,QAAQ,IAC5B,CAAC7C,gBAAgB,CAAC+J,IAAI,CAAClH,QAAQ,CAAC,IAChCsG,WAAW,CAACa,GAAG,CAACnH,QAAQ,CAAC,EACzB;QACA,MAAM,IAAI6F,WAAW,CACnB,oDAAoD,CACrD;MACH;MAEAS,WAAW,CAACc,GAAG,CAACpH,QAAQ,CAAC;IAC3B;IAEAwD,IAAI,CAACoD,OAAO,CAAC,wBAAwB,CAAC,GAAGnJ,SAAS,CAACiC,IAAI,CAAC,GAAG,CAAC;EAC9D;EACA,IAAI8D,IAAI,CAAC6D,MAAM,EAAE;IACf,IAAI7D,IAAI,CAACsB,eAAe,GAAG,EAAE,EAAE;MAC7BtB,IAAI,CAACoD,OAAO,CAAC,sBAAsB,CAAC,GAAGpD,IAAI,CAAC6D,MAAM;IACpD,CAAC,MAAM;MACL7D,IAAI,CAACoD,OAAO,CAACU,MAAM,GAAG9D,IAAI,CAAC6D,MAAM;IACnC;EACF;EACA,IAAI3B,SAAS,CAAC6B,QAAQ,IAAI7B,SAAS,CAAC8B,QAAQ,EAAE;IAC5ChE,IAAI,CAACiE,IAAI,GAAI,GAAE/B,SAAS,CAAC6B,QAAS,IAAG7B,SAAS,CAAC8B,QAAS,EAAC;EAC3D;EAEA,IAAIzB,YAAY,EAAE;IAChB,MAAM2B,KAAK,GAAGlE,IAAI,CAAC+B,IAAI,CAACoC,KAAK,CAAC,GAAG,CAAC;IAElCnE,IAAI,CAAC2B,UAAU,GAAGuC,KAAK,CAAC,CAAC,CAAC;IAC1BlE,IAAI,CAAC+B,IAAI,GAAGmC,KAAK,CAAC,CAAC,CAAC;EACtB;EAEA,IAAIlE,IAAI,CAACwB,eAAe,EAAE;IACxB,IAAIH,SAAS,CAAClG,UAAU,KAAK,CAAC,EAAE;MAC9BkG,SAAS,CAAC+C,aAAa,GAAGlC,SAAS,CAACJ,IAAI;MAExC,MAAMsB,OAAO,GAAGlJ,OAAO,IAAIA,OAAO,CAACkJ,OAAO;;MAE1C;MACA;MACA;MACA;MACAlJ,OAAO,GAAG;QAAE,GAAGA,OAAO;QAAEkJ,OAAO,EAAE,CAAC;MAAE,CAAC;MAErC,IAAIA,OAAO,EAAE;QACX,KAAK,MAAM,CAACP,GAAG,EAAEtC,KAAK,CAAC,IAAIvE,MAAM,CAACqI,OAAO,CAACjB,OAAO,CAAC,EAAE;UAClDlJ,OAAO,CAACkJ,OAAO,CAACP,GAAG,CAACyB,WAAW,EAAE,CAAC,GAAG/D,KAAK;QAC5C;MACF;IACF,CAAC,MAAM,IAAI2B,SAAS,CAACJ,IAAI,KAAKT,SAAS,CAAC+C,aAAa,EAAE;MACrD;MACA;MACA;MACA;MACA,OAAOpE,IAAI,CAACoD,OAAO,CAACmB,aAAa;MACjC,OAAOvE,IAAI,CAACoD,OAAO,CAACoB,MAAM;MAC1B,OAAOxE,IAAI,CAACoD,OAAO,CAACtB,IAAI;MACxB9B,IAAI,CAACiE,IAAI,GAAG7I,SAAS;IACvB;;IAEA;IACA;IACA;IACA;IACA;IACA,IAAI4E,IAAI,CAACiE,IAAI,IAAI,CAAC/J,OAAO,CAACkJ,OAAO,CAACmB,aAAa,EAAE;MAC/CrK,OAAO,CAACkJ,OAAO,CAACmB,aAAa,GAC3B,QAAQ,GAAGE,MAAM,CAACC,IAAI,CAAC1E,IAAI,CAACiE,IAAI,CAAC,CAACvE,QAAQ,CAAC,QAAQ,CAAC;IACxD;EACF;EAEA,IAAIiF,GAAG,GAAItD,SAAS,CAACvC,IAAI,GAAG+B,GAAG,CAACb,IAAI,CAAE;EAEtC,IAAIA,IAAI,CAAC6B,OAAO,EAAE;IAChB8C,GAAG,CAACvH,EAAE,CAAC,SAAS,EAAE,MAAM;MACtByB,cAAc,CAACwC,SAAS,EAAEsD,GAAG,EAAE,iCAAiC,CAAC;IACnE,CAAC,CAAC;EACJ;EAEAA,GAAG,CAACvH,EAAE,CAAC,OAAO,EAAG8B,GAAG,IAAK;IACvB,IAAIyF,GAAG,KAAK,IAAI,IAAIA,GAAG,CAACC,OAAO,EAAE;IAEjCD,GAAG,GAAGtD,SAAS,CAACvC,IAAI,GAAG,IAAI;IAC3B6D,iBAAiB,CAACtB,SAAS,EAAEnC,GAAG,CAAC;EACnC,CAAC,CAAC;EAEFyF,GAAG,CAACvH,EAAE,CAAC,UAAU,EAAGyH,GAAG,IAAK;IAC1B,MAAMC,QAAQ,GAAGD,GAAG,CAACzB,OAAO,CAAC0B,QAAQ;IACrC,MAAMC,UAAU,GAAGF,GAAG,CAACE,UAAU;IAEjC,IACED,QAAQ,IACR9E,IAAI,CAACwB,eAAe,IACpBuD,UAAU,IAAI,GAAG,IACjBA,UAAU,GAAG,GAAG,EAChB;MACA,IAAI,EAAE1D,SAAS,CAAClG,UAAU,GAAG6E,IAAI,CAACyB,YAAY,EAAE;QAC9C5C,cAAc,CAACwC,SAAS,EAAEsD,GAAG,EAAE,4BAA4B,CAAC;QAC5D;MACF;MAEAA,GAAG,CAACK,KAAK,EAAE;MAEX,IAAIC,IAAI;MAER,IAAI;QACFA,IAAI,GAAG,IAAIzM,GAAG,CAACsM,QAAQ,EAAE9K,OAAO,CAAC;MACnC,CAAC,CAAC,OAAOoI,CAAC,EAAE;QACV,MAAMlD,GAAG,GAAG,IAAImD,WAAW,CAAE,gBAAeyC,QAAS,EAAC,CAAC;QACvDnC,iBAAiB,CAACtB,SAAS,EAAEnC,GAAG,CAAC;QACjC;MACF;MAEA3D,YAAY,CAAC8F,SAAS,EAAE4D,IAAI,EAAEhL,SAAS,EAAEC,OAAO,CAAC;IACnD,CAAC,MAAM,IAAI,CAACmH,SAAS,CAAClD,IAAI,CAAC,qBAAqB,EAAEwG,GAAG,EAAEE,GAAG,CAAC,EAAE;MAC3DhG,cAAc,CACZwC,SAAS,EACTsD,GAAG,EACF,+BAA8BE,GAAG,CAACE,UAAW,EAAC,CAChD;IACH;EACF,CAAC,CAAC;EAEFJ,GAAG,CAACvH,EAAE,CAAC,SAAS,EAAE,CAACyH,GAAG,EAAEhI,MAAM,EAAEC,IAAI,KAAK;IACvCuE,SAAS,CAAClD,IAAI,CAAC,SAAS,EAAE0G,GAAG,CAAC;;IAE9B;IACA;IACA;IACA;IACA,IAAIxD,SAAS,CAAC5E,UAAU,KAAK3C,SAAS,CAACe,UAAU,EAAE;IAEnD8J,GAAG,GAAGtD,SAAS,CAACvC,IAAI,GAAG,IAAI;IAE3B,MAAMoG,MAAM,GAAG5M,UAAU,CAAC,MAAM,CAAC,CAC9B6M,MAAM,CAACtC,GAAG,GAAG/J,IAAI,CAAC,CAClBoM,MAAM,CAAC,QAAQ,CAAC;IAEnB,IAAIL,GAAG,CAACzB,OAAO,CAAC,sBAAsB,CAAC,KAAK8B,MAAM,EAAE;MAClDrG,cAAc,CAACwC,SAAS,EAAExE,MAAM,EAAE,qCAAqC,CAAC;MACxE;IACF;IAEA,MAAMuI,UAAU,GAAGP,GAAG,CAACzB,OAAO,CAAC,wBAAwB,CAAC;IACxD,IAAIiC,SAAS;IAEb,IAAID,UAAU,KAAKhK,SAAS,EAAE;MAC5B,IAAI,CAAC0H,WAAW,CAACwC,IAAI,EAAE;QACrBD,SAAS,GAAG,kDAAkD;MAChE,CAAC,MAAM,IAAI,CAACvC,WAAW,CAACa,GAAG,CAACyB,UAAU,CAAC,EAAE;QACvCC,SAAS,GAAG,oCAAoC;MAClD;IACF,CAAC,MAAM,IAAIvC,WAAW,CAACwC,IAAI,EAAE;MAC3BD,SAAS,GAAG,4BAA4B;IAC1C;IAEA,IAAIA,SAAS,EAAE;MACbxG,cAAc,CAACwC,SAAS,EAAExE,MAAM,EAAEwI,SAAS,CAAC;MAC5C;IACF;IAEA,IAAID,UAAU,EAAE/D,SAAS,CAAC1G,SAAS,GAAGyK,UAAU;IAEhD,MAAMG,sBAAsB,GAAGV,GAAG,CAACzB,OAAO,CAAC,0BAA0B,CAAC;IAEtE,IAAImC,sBAAsB,KAAKnK,SAAS,EAAE;MACxC,IAAI,CAACmG,iBAAiB,EAAE;QACtB,MAAMiE,OAAO,GACX,iEAAiE,GACjE,eAAe;QACjB3G,cAAc,CAACwC,SAAS,EAAExE,MAAM,EAAE2I,OAAO,CAAC;QAC1C;MACF;MAEA,IAAIzJ,UAAU;MAEd,IAAI;QACFA,UAAU,GAAGvC,KAAK,CAAC+L,sBAAsB,CAAC;MAC5C,CAAC,CAAC,OAAOrG,GAAG,EAAE;QACZ,MAAMsG,OAAO,GAAG,yCAAyC;QACzD3G,cAAc,CAACwC,SAAS,EAAExE,MAAM,EAAE2I,OAAO,CAAC;QAC1C;MACF;MAEA,MAAMC,cAAc,GAAGzJ,MAAM,CAACC,IAAI,CAACF,UAAU,CAAC;MAE9C,IACE0J,cAAc,CAAC5J,MAAM,KAAK,CAAC,IAC3B4J,cAAc,CAAC,CAAC,CAAC,KAAKhN,iBAAiB,CAAC6F,aAAa,EACrD;QACA,MAAMkH,OAAO,GAAG,sDAAsD;QACtE3G,cAAc,CAACwC,SAAS,EAAExE,MAAM,EAAE2I,OAAO,CAAC;QAC1C;MACF;MAEA,IAAI;QACFjE,iBAAiB,CAACmE,MAAM,CAAC3J,UAAU,CAACtD,iBAAiB,CAAC6F,aAAa,CAAC,CAAC;MACvE,CAAC,CAAC,OAAOY,GAAG,EAAE;QACZ,MAAMsG,OAAO,GAAG,yCAAyC;QACzD3G,cAAc,CAACwC,SAAS,EAAExE,MAAM,EAAE2I,OAAO,CAAC;QAC1C;MACF;MAEAnE,SAAS,CAAC5G,WAAW,CAAChC,iBAAiB,CAAC6F,aAAa,CAAC,GACpDiD,iBAAiB;IACrB;IAEAF,SAAS,CAACzE,SAAS,CAACC,MAAM,EAAEC,IAAI,EAAE;MAChCK,YAAY,EAAE6C,IAAI,CAAC7C,YAAY;MAC/BF,UAAU,EAAE+C,IAAI,CAAC/C,UAAU;MAC3BC,kBAAkB,EAAE8C,IAAI,CAAC9C;IAC3B,CAAC,CAAC;EACJ,CAAC,CAAC;AACJ;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASyF,iBAAiB,CAACtB,SAAS,EAAEnC,GAAG,EAAE;EACzCmC,SAAS,CAACzG,WAAW,GAAGd,SAAS,CAACiF,OAAO;EACzCsC,SAAS,CAAClD,IAAI,CAAC,OAAO,EAAEe,GAAG,CAAC;EAC5BmC,SAAS,CAACjD,SAAS,EAAE;AACvB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS6E,UAAU,CAAC/I,OAAO,EAAE;EAC3BA,OAAO,CAAC6H,IAAI,GAAG7H,OAAO,CAACyH,UAAU;EACjC,OAAOxJ,GAAG,CAACwN,OAAO,CAACzL,OAAO,CAAC;AAC7B;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS8I,UAAU,CAAC9I,OAAO,EAAE;EAC3BA,OAAO,CAAC6H,IAAI,GAAG3G,SAAS;EAExB,IAAI,CAAClB,OAAO,CAAC0L,UAAU,IAAI1L,OAAO,CAAC0L,UAAU,KAAK,EAAE,EAAE;IACpD1L,OAAO,CAAC0L,UAAU,GAAGzN,GAAG,CAAC0N,IAAI,CAAC3L,OAAO,CAAC4H,IAAI,CAAC,GAAG,EAAE,GAAG5H,OAAO,CAAC4H,IAAI;EACjE;EAEA,OAAO1J,GAAG,CAACuN,OAAO,CAACzL,OAAO,CAAC;AAC7B;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS2E,cAAc,CAACwC,SAAS,EAAEyE,MAAM,EAAEN,OAAO,EAAE;EAClDnE,SAAS,CAACzG,WAAW,GAAGd,SAAS,CAACiF,OAAO;EAEzC,MAAMG,GAAG,GAAG,IAAIO,KAAK,CAAC+F,OAAO,CAAC;EAC9B/F,KAAK,CAACsG,iBAAiB,CAAC7G,GAAG,EAAEL,cAAc,CAAC;EAE5C,IAAIiH,MAAM,CAACE,SAAS,EAAE;IACpBF,MAAM,CAACd,KAAK,EAAE;IAEd,IAAIc,MAAM,CAACjJ,MAAM,IAAI,CAACiJ,MAAM,CAACjJ,MAAM,CAACoJ,SAAS,EAAE;MAC7C;MACA;MACA;MACA;MACA;MACAH,MAAM,CAACjJ,MAAM,CAACsC,OAAO,EAAE;IACzB;IAEA2G,MAAM,CAACI,IAAI,CAAC,OAAO,EAAE7E,SAAS,CAACjD,SAAS,CAACgB,IAAI,CAACiC,SAAS,CAAC,CAAC;IACzDA,SAAS,CAAClD,IAAI,CAAC,OAAO,EAAEe,GAAG,CAAC;EAC9B,CAAC,MAAM;IACL4G,MAAM,CAAC3G,OAAO,CAACD,GAAG,CAAC;IACnB4G,MAAM,CAACI,IAAI,CAAC,OAAO,EAAE7E,SAAS,CAAClD,IAAI,CAACiB,IAAI,CAACiC,SAAS,EAAE,OAAO,CAAC,CAAC;IAC7DyE,MAAM,CAACI,IAAI,CAAC,OAAO,EAAE7E,SAAS,CAACjD,SAAS,CAACgB,IAAI,CAACiC,SAAS,CAAC,CAAC;EAC3D;AACF;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS1B,cAAc,CAAC0B,SAAS,EAAE1C,IAAI,EAAEa,EAAE,EAAE;EAC3C,IAAIb,IAAI,EAAE;IACR,MAAM9C,MAAM,GAAGpC,QAAQ,CAACkF,IAAI,CAAC,CAAC9C,MAAM;;IAEpC;IACA;IACA;IACA;IACA;IACA;IACA,IAAIwF,SAAS,CAACrG,OAAO,EAAEqG,SAAS,CAACtG,OAAO,CAACe,cAAc,IAAID,MAAM,CAAC,KAC7DwF,SAAS,CAACpG,eAAe,IAAIY,MAAM;EAC1C;EAEA,IAAI2D,EAAE,EAAE;IACN,MAAMN,GAAG,GAAG,IAAIO,KAAK,CAClB,qCAAoC4B,SAAS,CAAC5E,UAAW,GAAE,GACzD,IAAG/C,WAAW,CAAC2H,SAAS,CAAC5E,UAAU,CAAE,GAAE,CAC3C;IACD+C,EAAE,CAACN,GAAG,CAAC;EACT;AACF;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS7B,kBAAkB,CAACqB,IAAI,EAAEyH,MAAM,EAAE;EACxC,MAAM9E,SAAS,GAAG,IAAI,CAACnI,UAAU,CAAC;EAElCmI,SAAS,CAAChH,mBAAmB,GAAG,IAAI;EACpCgH,SAAS,CAAC9G,aAAa,GAAG4L,MAAM;EAChC9E,SAAS,CAACjH,UAAU,GAAGsE,IAAI;EAE3B,IAAI2C,SAAS,CAACrG,OAAO,CAAC9B,UAAU,CAAC,KAAKkC,SAAS,EAAE;EAEjDiG,SAAS,CAACrG,OAAO,CAACkG,cAAc,CAAC,MAAM,EAAEnD,YAAY,CAAC;EACtDqI,OAAO,CAACC,QAAQ,CAACxG,MAAM,EAAEwB,SAAS,CAACrG,OAAO,CAAC;EAE3C,IAAI0D,IAAI,KAAK,IAAI,EAAE2C,SAAS,CAAC5C,KAAK,EAAE,CAAC,KAChC4C,SAAS,CAAC5C,KAAK,CAACC,IAAI,EAAEyH,MAAM,CAAC;AACpC;;AAEA;AACA;AACA;AACA;AACA;AACA,SAAS7I,eAAe,GAAG;EACzB,MAAM+D,SAAS,GAAG,IAAI,CAACnI,UAAU,CAAC;EAElC,IAAI,CAACmI,SAAS,CAAClF,QAAQ,EAAEkF,SAAS,CAACrG,OAAO,CAAC6E,MAAM,EAAE;AACrD;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,SAAStC,eAAe,CAAC2B,GAAG,EAAE;EAC5B,MAAMmC,SAAS,GAAG,IAAI,CAACnI,UAAU,CAAC;EAElC,IAAImI,SAAS,CAACrG,OAAO,CAAC9B,UAAU,CAAC,KAAKkC,SAAS,EAAE;IAC/CiG,SAAS,CAACrG,OAAO,CAACkG,cAAc,CAAC,MAAM,EAAEnD,YAAY,CAAC;;IAEtD;IACA;IACA;IACA;IACAqI,OAAO,CAACC,QAAQ,CAACxG,MAAM,EAAEwB,SAAS,CAACrG,OAAO,CAAC;IAE3CqG,SAAS,CAAC5C,KAAK,CAACS,GAAG,CAACjG,WAAW,CAAC,CAAC;EACnC;EAEAoI,SAAS,CAAClD,IAAI,CAAC,OAAO,EAAEe,GAAG,CAAC;AAC9B;;AAEA;AACA;AACA;AACA;AACA;AACA,SAASoH,gBAAgB,GAAG;EAC1B,IAAI,CAACpN,UAAU,CAAC,CAACkF,SAAS,EAAE;AAC9B;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASZ,iBAAiB,CAACmB,IAAI,EAAE4H,QAAQ,EAAE;EACzC,IAAI,CAACrN,UAAU,CAAC,CAACiF,IAAI,CAAC,SAAS,EAAEQ,IAAI,EAAE4H,QAAQ,CAAC;AAClD;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS9I,cAAc,CAACkB,IAAI,EAAE;EAC5B,MAAM0C,SAAS,GAAG,IAAI,CAACnI,UAAU,CAAC;EAElCmI,SAAS,CAACzB,IAAI,CAACjB,IAAI,EAAE,CAAC0C,SAAS,CAACnG,SAAS,EAAE/B,IAAI,CAAC;EAChDkI,SAAS,CAAClD,IAAI,CAAC,MAAM,EAAEQ,IAAI,CAAC;AAC9B;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,SAASjB,cAAc,CAACiB,IAAI,EAAE;EAC5B,IAAI,CAACzF,UAAU,CAAC,CAACiF,IAAI,CAAC,MAAM,EAAEQ,IAAI,CAAC;AACrC;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,SAASkB,MAAM,CAACiG,MAAM,EAAE;EACtBA,MAAM,CAACjG,MAAM,EAAE;AACjB;;AAEA;AACA;AACA;AACA;AACA;AACA,SAAS/B,aAAa,GAAG;EACvB,MAAMuD,SAAS,GAAG,IAAI,CAACnI,UAAU,CAAC;EAElC,IAAI,CAACgI,cAAc,CAAC,OAAO,EAAEpD,aAAa,CAAC;EAC3C,IAAI,CAACoD,cAAc,CAAC,MAAM,EAAEnD,YAAY,CAAC;EACzC,IAAI,CAACmD,cAAc,CAAC,KAAK,EAAElD,WAAW,CAAC;EAEvCqD,SAAS,CAACzG,WAAW,GAAGd,SAAS,CAACiF,OAAO;EAEzC,IAAIyH,KAAK;;EAET;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA,IACE,CAAC,IAAI,CAACC,cAAc,CAACC,UAAU,IAC/B,CAACrF,SAAS,CAAChH,mBAAmB,IAC9B,CAACgH,SAAS,CAACvG,SAAS,CAACc,cAAc,CAACoD,YAAY,IAChD,CAACwH,KAAK,GAAGnF,SAAS,CAACrG,OAAO,CAAC2L,IAAI,EAAE,MAAM,IAAI,EAC3C;IACAtF,SAAS,CAACvG,SAAS,CAAC8L,KAAK,CAACJ,KAAK,CAAC;EAClC;EAEAnF,SAAS,CAACvG,SAAS,CAACmE,GAAG,EAAE;EAEzB,IAAI,CAAC/F,UAAU,CAAC,GAAGkC,SAAS;EAE5ByL,YAAY,CAACxF,SAAS,CAAC7G,WAAW,CAAC;EAEnC,IACE6G,SAAS,CAACvG,SAAS,CAACc,cAAc,CAACkL,QAAQ,IAC3CzF,SAAS,CAACvG,SAAS,CAACc,cAAc,CAACoD,YAAY,EAC/C;IACAqC,SAAS,CAACjD,SAAS,EAAE;EACvB,CAAC,MAAM;IACLiD,SAAS,CAACvG,SAAS,CAACsC,EAAE,CAAC,OAAO,EAAEkJ,gBAAgB,CAAC;IACjDjF,SAAS,CAACvG,SAAS,CAACsC,EAAE,CAAC,QAAQ,EAAEkJ,gBAAgB,CAAC;EACpD;AACF;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,SAASvI,YAAY,CAACyI,KAAK,EAAE;EAC3B,IAAI,CAAC,IAAI,CAACtN,UAAU,CAAC,CAAC4B,SAAS,CAAC8L,KAAK,CAACJ,KAAK,CAAC,EAAE;IAC5C,IAAI,CAACnH,KAAK,EAAE;EACd;AACF;;AAEA;AACA;AACA;AACA;AACA;AACA,SAASrB,WAAW,GAAG;EACrB,MAAMqD,SAAS,GAAG,IAAI,CAACnI,UAAU,CAAC;EAElCmI,SAAS,CAACzG,WAAW,GAAGd,SAAS,CAACiF,OAAO;EACzCsC,SAAS,CAACvG,SAAS,CAACmE,GAAG,EAAE;EACzB,IAAI,CAACA,GAAG,EAAE;AACZ;;AAEA;AACA;AACA;AACA;AACA;AACA,SAAShB,aAAa,GAAG;EACvB,MAAMoD,SAAS,GAAG,IAAI,CAACnI,UAAU,CAAC;EAElC,IAAI,CAACgI,cAAc,CAAC,OAAO,EAAEjD,aAAa,CAAC;EAC3C,IAAI,CAACb,EAAE,CAAC,OAAO,EAAEjE,IAAI,CAAC;EAEtB,IAAIkI,SAAS,EAAE;IACbA,SAAS,CAACzG,WAAW,GAAGd,SAAS,CAACiF,OAAO;IACzC,IAAI,CAACI,OAAO,EAAE;EAChB;AACF"},"metadata":{},"sourceType":"script","externalDependencies":[]}