{"ast":null,"code":"// Copied from https://raw.githubusercontent.com/nodejs/node/v15.3.0/lib/internal/modules/esm/resolve.js\n\n'use strict';\n\nconst {\n  versionGteLt\n} = require('../dist/util');\n\n// Test for node >14.13.1 || (>=12.20.0 && <13)\nconst builtinModuleProtocol = versionGteLt(process.versions.node, '14.13.1') || versionGteLt(process.versions.node, '12.20.0', '13.0.0') ? 'node:' : 'nodejs:';\nconst {\n  ArrayIsArray,\n  ArrayPrototypeJoin,\n  ArrayPrototypeShift,\n  JSONParse,\n  JSONStringify,\n  ObjectFreeze,\n  ObjectGetOwnPropertyNames,\n  ObjectPrototypeHasOwnProperty,\n  RegExpPrototypeTest,\n  SafeMap,\n  SafeSet,\n  StringPrototypeEndsWith,\n  StringPrototypeIndexOf,\n  StringPrototypeLastIndexOf,\n  StringPrototypeReplace,\n  StringPrototypeSlice,\n  StringPrototypeSplit,\n  StringPrototypeStartsWith,\n  StringPrototypeSubstr\n} = require('./node-primordials');\n\n// const internalFS = require('internal/fs/utils');\nconst Module = require('module');\nconst {\n  NativeModule\n} = require('./node-nativemodule');\nconst {\n  realpathSync,\n  statSync,\n  Stats\n} = require('fs');\n// const { getOptionValue } = require('internal/options');\nconst {\n  getOptionValue\n} = require('./node-options');\n// // Do not eagerly grab .manifest, it may be in TDZ\n// const policy = getOptionValue('--experimental-policy') ?\n//   require('internal/process/policy') :\n//   null;\n// disabled for now.  I am not sure if/how we should support this\nconst policy = null;\nconst {\n  sep,\n  relative\n} = require('path');\nconst preserveSymlinks = getOptionValue('--preserve-symlinks');\nconst preserveSymlinksMain = getOptionValue('--preserve-symlinks-main');\nconst typeFlag = getOptionValue('--input-type');\n// const { URL, pathToFileURL, fileURLToPath } = require('internal/url');\nconst {\n  URL,\n  pathToFileURL,\n  fileURLToPath\n} = require('url');\nconst {\n  ERR_INPUT_TYPE_NOT_ALLOWED,\n  ERR_INVALID_ARG_VALUE,\n  ERR_INVALID_MODULE_SPECIFIER,\n  ERR_INVALID_PACKAGE_CONFIG,\n  ERR_INVALID_PACKAGE_TARGET,\n  ERR_MANIFEST_DEPENDENCY_MISSING,\n  ERR_MODULE_NOT_FOUND,\n  ERR_PACKAGE_IMPORT_NOT_DEFINED,\n  ERR_PACKAGE_PATH_NOT_EXPORTED,\n  ERR_UNSUPPORTED_DIR_IMPORT,\n  ERR_UNSUPPORTED_ESM_URL_SCHEME\n  // } = require('internal/errors').codes;\n} = require('./node-internal-errors').codes;\n\n// const { Module: CJSModule } = require('internal/modules/cjs/loader');\nconst CJSModule = Module;\n\n// const packageJsonReader = require('internal/modules/package_json_reader');\nconst packageJsonReader = require('./node-internal-modules-package_json_reader');\nconst userConditions = getOptionValue('--conditions');\nconst DEFAULT_CONDITIONS = ObjectFreeze(['node', 'import', ...userConditions]);\nconst DEFAULT_CONDITIONS_SET = new SafeSet(DEFAULT_CONDITIONS);\nconst pendingDeprecation = getOptionValue('--pending-deprecation');\n\n/**\n * @param {{\n *  extensions: import('../src/file-extensions').Extensions,\n *  preferTsExts: boolean | undefined;\n *  tsNodeExperimentalSpecifierResolution: import('../src/index').ExperimentalSpecifierResolution | undefined;\n * }} opts\n */\nfunction createResolve(opts) {\n  // TODO receive cached fs implementations here\n  const {\n    preferTsExts,\n    tsNodeExperimentalSpecifierResolution,\n    extensions\n  } = opts;\n  const esrnExtensions = extensions.experimentalSpecifierResolutionAddsIfOmitted;\n  const {\n    legacyMainResolveAddsIfOmitted,\n    replacementsForCjs,\n    replacementsForJs,\n    replacementsForMjs,\n    replacementsForJsx\n  } = extensions;\n  // const experimentalSpecifierResolution = tsNodeExperimentalSpecifierResolution ?? getOptionValue('--experimental-specifier-resolution');\n  const experimentalSpecifierResolution = tsNodeExperimentalSpecifierResolution != null ? tsNodeExperimentalSpecifierResolution : getOptionValue('--experimental-specifier-resolution');\n  const emittedPackageWarnings = new SafeSet();\n  function emitFolderMapDeprecation(match, pjsonUrl, isExports, base) {\n    const pjsonPath = fileURLToPath(pjsonUrl);\n    if (!pendingDeprecation) {\n      const nodeModulesIndex = StringPrototypeLastIndexOf(pjsonPath, '/node_modules/');\n      if (nodeModulesIndex !== -1) {\n        const afterNodeModulesPath = StringPrototypeSlice(pjsonPath, nodeModulesIndex + 14, -13);\n        try {\n          const {\n            packageSubpath\n          } = parsePackageName(afterNodeModulesPath);\n          if (packageSubpath === '.') return;\n        } catch {}\n      }\n    }\n    if (emittedPackageWarnings.has(pjsonPath + '|' + match)) return;\n    emittedPackageWarnings.add(pjsonPath + '|' + match);\n    process.emitWarning(`Use of deprecated folder mapping \"${match}\" in the ${isExports ? '\"exports\"' : '\"imports\"'} field module resolution of the package at ${pjsonPath}${base ? ` imported from ${fileURLToPath(base)}` : ''}.\\n` + `Update this package.json to use a subpath pattern like \"${match}*\".`, 'DeprecationWarning', 'DEP0148');\n  }\n  function getConditionsSet(conditions) {\n    if (conditions !== undefined && conditions !== DEFAULT_CONDITIONS) {\n      if (!ArrayIsArray(conditions)) {\n        throw new ERR_INVALID_ARG_VALUE('conditions', conditions, 'expected an array');\n      }\n      return new SafeSet(conditions);\n    }\n    return DEFAULT_CONDITIONS_SET;\n  }\n  const realpathCache = new SafeMap();\n  const packageJSONCache = new SafeMap(); /* string -> PackageConfig */\n\n  const statSupportsThrowIfNoEntry = versionGteLt(process.versions.node, '15.3.0') || versionGteLt(process.versions.node, '14.17.0', '15.0.0');\n  const tryStatSync = statSupportsThrowIfNoEntry ? tryStatSyncWithoutErrors : tryStatSyncWithErrors;\n  const statsIfNotFound = new Stats();\n  function tryStatSyncWithoutErrors(path) {\n    const stats = statSync(path, {\n      throwIfNoEntry: false\n    });\n    if (stats != null) return stats;\n    return statsIfNotFound;\n  }\n  function tryStatSyncWithErrors(path) {\n    try {\n      return statSync(path);\n    } catch {\n      return statsIfNotFound;\n    }\n  }\n  function getPackageConfig(path, specifier, base) {\n    const existing = packageJSONCache.get(path);\n    if (existing !== undefined) {\n      return existing;\n    }\n    const source = packageJsonReader.read(path).string;\n    if (source === undefined) {\n      const packageConfig = {\n        pjsonPath: path,\n        exists: false,\n        main: undefined,\n        name: undefined,\n        type: 'none',\n        exports: undefined,\n        imports: undefined\n      };\n      packageJSONCache.set(path, packageConfig);\n      return packageConfig;\n    }\n    let packageJSON;\n    try {\n      packageJSON = JSONParse(source);\n    } catch (error) {\n      throw new ERR_INVALID_PACKAGE_CONFIG(path, (base ? `\"${specifier}\" from ` : '') + fileURLToPath(base || specifier), error.message);\n    }\n    let {\n      imports,\n      main,\n      name,\n      type\n    } = packageJSON;\n    const {\n      exports\n    } = packageJSON;\n    if (typeof imports !== 'object' || imports === null) imports = undefined;\n    if (typeof main !== 'string') main = undefined;\n    if (typeof name !== 'string') name = undefined;\n    // Ignore unknown types for forwards compatibility\n    if (type !== 'module' && type !== 'commonjs') type = 'none';\n    const packageConfig = {\n      pjsonPath: path,\n      exists: true,\n      main,\n      name,\n      type,\n      exports,\n      imports\n    };\n    packageJSONCache.set(path, packageConfig);\n    return packageConfig;\n  }\n  function getPackageScopeConfig(resolved) {\n    let packageJSONUrl = new URL('./package.json', resolved);\n    while (true) {\n      const packageJSONPath = packageJSONUrl.pathname;\n      if (StringPrototypeEndsWith(packageJSONPath, 'node_modules/package.json')) break;\n      const packageConfig = getPackageConfig(fileURLToPath(packageJSONUrl), resolved);\n      if (packageConfig.exists) return packageConfig;\n      const lastPackageJSONUrl = packageJSONUrl;\n      packageJSONUrl = new URL('../package.json', packageJSONUrl);\n\n      // Terminates at root where ../package.json equals ../../package.json\n      // (can't just check \"/package.json\" for Windows support).\n      if (packageJSONUrl.pathname === lastPackageJSONUrl.pathname) break;\n    }\n    const packageJSONPath = fileURLToPath(packageJSONUrl);\n    const packageConfig = {\n      pjsonPath: packageJSONPath,\n      exists: false,\n      main: undefined,\n      name: undefined,\n      type: 'none',\n      exports: undefined,\n      imports: undefined\n    };\n    packageJSONCache.set(packageJSONPath, packageConfig);\n    return packageConfig;\n  }\n\n  /*\n   * Legacy CommonJS main resolution:\n   * 1. let M = pkg_url + (json main field)\n   * 2. TRY(M, M.js, M.json, M.node)\n   * 3. TRY(M/index.js, M/index.json, M/index.node)\n   * 4. TRY(pkg_url/index.js, pkg_url/index.json, pkg_url/index.node)\n   * 5. NOT_FOUND\n   */\n  function fileExists(url) {\n    return tryStatSync(fileURLToPath(url)).isFile();\n  }\n  function legacyMainResolve(packageJSONUrl, packageConfig, base) {\n    let guess;\n    if (packageConfig.main !== undefined) {\n      // Note: fs check redundances will be handled by Descriptor cache here.\n      if (guess = resolveReplacementExtensions(new URL(`./${packageConfig.main}`, packageJSONUrl))) {\n        return guess;\n      }\n      if (fileExists(guess = new URL(`./${packageConfig.main}`, packageJSONUrl))) {\n        return guess;\n      }\n      for (const extension of legacyMainResolveAddsIfOmitted) {\n        if (fileExists(guess = new URL(`./${packageConfig.main}${extension}`, packageJSONUrl))) {\n          return guess;\n        }\n      }\n      for (const extension of legacyMainResolveAddsIfOmitted) {\n        if (fileExists(guess = new URL(`./${packageConfig.main}/index${extension}`, packageJSONUrl))) {\n          return guess;\n        }\n      }\n      // Fallthrough.\n    }\n\n    for (const extension of legacyMainResolveAddsIfOmitted) {\n      if (fileExists(guess = new URL(`./index${extension}`, packageJSONUrl))) {\n        return guess;\n      }\n    }\n    // Not found.\n    throw new ERR_MODULE_NOT_FOUND(fileURLToPath(new URL('.', packageJSONUrl)), fileURLToPath(base));\n  }\n\n  /** attempts replacement extensions, then tries exact name, then attempts appending extensions */\n  function resolveExtensionsWithTryExactName(search) {\n    const resolvedReplacementExtension = resolveReplacementExtensions(search);\n    if (resolvedReplacementExtension) return resolvedReplacementExtension;\n    if (fileExists(search)) return search;\n    return resolveExtensions(search);\n  }\n\n  // This appends missing extensions\n  function resolveExtensions(search) {\n    for (let i = 0; i < esrnExtensions.length; i++) {\n      const extension = esrnExtensions[i];\n      const guess = new URL(`${search.pathname}${extension}`, search);\n      if (fileExists(guess)) return guess;\n    }\n    return undefined;\n  }\n\n  /** This replaces JS with TS extensions */\n  function resolveReplacementExtensions(search) {\n    const lastDotIndex = search.pathname.lastIndexOf('.');\n    if (lastDotIndex >= 0) {\n      const ext = search.pathname.slice(lastDotIndex);\n      if (ext === '.js' || ext === '.jsx' || ext === '.mjs' || ext === '.cjs') {\n        const pathnameWithoutExtension = search.pathname.slice(0, lastDotIndex);\n        const replacementExts = ext === '.js' ? replacementsForJs : ext === '.jsx' ? replacementsForJsx : ext === '.mjs' ? replacementsForMjs : replacementsForCjs;\n        const guess = new URL(search.toString());\n        for (let i = 0; i < replacementExts.length; i++) {\n          const extension = replacementExts[i];\n          guess.pathname = `${pathnameWithoutExtension}${extension}`;\n          if (fileExists(guess)) return guess;\n        }\n      }\n    }\n    return undefined;\n  }\n  function resolveIndex(search) {\n    return resolveExtensions(new URL('index', search));\n  }\n  const encodedSepRegEx = /%2F|%2C/i;\n  function finalizeResolution(resolved, base) {\n    if (RegExpPrototypeTest(encodedSepRegEx, resolved.pathname)) throw new ERR_INVALID_MODULE_SPECIFIER(resolved.pathname, 'must not include encoded \"/\" or \"\\\\\" characters', fileURLToPath(base));\n    if (experimentalSpecifierResolution === 'node') {\n      const path = fileURLToPath(resolved);\n      let file = resolveExtensionsWithTryExactName(resolved);\n      if (file !== undefined) return file;\n      if (!StringPrototypeEndsWith(path, '/')) {\n        file = resolveIndex(new URL(`${resolved}/`));\n        if (file !== undefined) return file;\n      } else {\n        return resolveIndex(resolved) || resolved;\n      }\n      throw new ERR_MODULE_NOT_FOUND(resolved.pathname, fileURLToPath(base), 'module');\n    }\n    const file = resolveReplacementExtensions(resolved) || resolved;\n    const path = fileURLToPath(file);\n    const stats = tryStatSync(StringPrototypeEndsWith(path, '/') ? StringPrototypeSlice(path, -1) : path);\n    if (stats.isDirectory()) {\n      const err = new ERR_UNSUPPORTED_DIR_IMPORT(path, fileURLToPath(base));\n      err.url = String(resolved);\n      throw err;\n    } else if (!stats.isFile()) {\n      throw new ERR_MODULE_NOT_FOUND(path || resolved.pathname, fileURLToPath(base), 'module');\n    }\n    return file;\n  }\n  function throwImportNotDefined(specifier, packageJSONUrl, base) {\n    throw new ERR_PACKAGE_IMPORT_NOT_DEFINED(specifier, packageJSONUrl && fileURLToPath(new URL('.', packageJSONUrl)), fileURLToPath(base));\n  }\n  function throwExportsNotFound(subpath, packageJSONUrl, base) {\n    throw new ERR_PACKAGE_PATH_NOT_EXPORTED(fileURLToPath(new URL('.', packageJSONUrl)), subpath, base && fileURLToPath(base));\n  }\n  function throwInvalidSubpath(subpath, packageJSONUrl, internal, base) {\n    const reason = `request is not a valid subpath for the \"${internal ? 'imports' : 'exports'}\" resolution of ${fileURLToPath(packageJSONUrl)}`;\n    throw new ERR_INVALID_MODULE_SPECIFIER(subpath, reason, base && fileURLToPath(base));\n  }\n  function throwInvalidPackageTarget(subpath, target, packageJSONUrl, internal, base) {\n    if (typeof target === 'object' && target !== null) {\n      target = JSONStringify(target, null, '');\n    } else {\n      target = `${target}`;\n    }\n    throw new ERR_INVALID_PACKAGE_TARGET(fileURLToPath(new URL('.', packageJSONUrl)), subpath, target, internal, base && fileURLToPath(base));\n  }\n  const invalidSegmentRegEx = /(^|\\\\|\\/)(\\.\\.?|node_modules)(\\\\|\\/|$)/;\n  const patternRegEx = /\\*/g;\n  function resolvePackageTargetString(target, subpath, match, packageJSONUrl, base, pattern, internal, conditions) {\n    if (subpath !== '' && !pattern && target[target.length - 1] !== '/') throwInvalidPackageTarget(match, target, packageJSONUrl, internal, base);\n    if (!StringPrototypeStartsWith(target, './')) {\n      if (internal && !StringPrototypeStartsWith(target, '../') && !StringPrototypeStartsWith(target, '/')) {\n        let isURL = false;\n        try {\n          new URL(target);\n          isURL = true;\n        } catch {}\n        if (!isURL) {\n          const exportTarget = pattern ? StringPrototypeReplace(target, patternRegEx, subpath) : target + subpath;\n          return packageResolve(exportTarget, packageJSONUrl, conditions);\n        }\n      }\n      throwInvalidPackageTarget(match, target, packageJSONUrl, internal, base);\n    }\n    if (RegExpPrototypeTest(invalidSegmentRegEx, StringPrototypeSlice(target, 2))) throwInvalidPackageTarget(match, target, packageJSONUrl, internal, base);\n    const resolved = new URL(target, packageJSONUrl);\n    const resolvedPath = resolved.pathname;\n    const packagePath = new URL('.', packageJSONUrl).pathname;\n    if (!StringPrototypeStartsWith(resolvedPath, packagePath)) throwInvalidPackageTarget(match, target, packageJSONUrl, internal, base);\n    if (subpath === '') return resolved;\n    if (RegExpPrototypeTest(invalidSegmentRegEx, subpath)) throwInvalidSubpath(match + subpath, packageJSONUrl, internal, base);\n    if (pattern) return new URL(StringPrototypeReplace(resolved.href, patternRegEx, subpath));\n    return new URL(subpath, resolved);\n  }\n\n  /**\n   * @param {string} key\n   * @returns {boolean}\n   */\n  function isArrayIndex(key) {\n    const keyNum = +key;\n    if (`${keyNum}` !== key) return false;\n    return keyNum >= 0 && keyNum < 0xFFFF_FFFF;\n  }\n  function resolvePackageTarget(packageJSONUrl, target, subpath, packageSubpath, base, pattern, internal, conditions) {\n    if (typeof target === 'string') {\n      return resolvePackageTargetString(target, subpath, packageSubpath, packageJSONUrl, base, pattern, internal, conditions);\n    } else if (ArrayIsArray(target)) {\n      if (target.length === 0) return null;\n      let lastException;\n      for (let i = 0; i < target.length; i++) {\n        const targetItem = target[i];\n        let resolved;\n        try {\n          resolved = resolvePackageTarget(packageJSONUrl, targetItem, subpath, packageSubpath, base, pattern, internal, conditions);\n        } catch (e) {\n          lastException = e;\n          if (e.code === 'ERR_INVALID_PACKAGE_TARGET') continue;\n          throw e;\n        }\n        if (resolved === undefined) continue;\n        if (resolved === null) {\n          lastException = null;\n          continue;\n        }\n        return resolved;\n      }\n      if (lastException === undefined || lastException === null) return lastException;\n      throw lastException;\n    } else if (typeof target === 'object' && target !== null) {\n      const keys = ObjectGetOwnPropertyNames(target);\n      for (let i = 0; i < keys.length; i++) {\n        const key = keys[i];\n        if (isArrayIndex(key)) {\n          throw new ERR_INVALID_PACKAGE_CONFIG(fileURLToPath(packageJSONUrl), base, '\"exports\" cannot contain numeric property keys.');\n        }\n      }\n      for (let i = 0; i < keys.length; i++) {\n        const key = keys[i];\n        if (key === 'default' || conditions.has(key)) {\n          const conditionalTarget = target[key];\n          const resolved = resolvePackageTarget(packageJSONUrl, conditionalTarget, subpath, packageSubpath, base, pattern, internal, conditions);\n          if (resolved === undefined) continue;\n          return resolved;\n        }\n      }\n      return undefined;\n    } else if (target === null) {\n      return null;\n    }\n    throwInvalidPackageTarget(packageSubpath, target, packageJSONUrl, internal, base);\n  }\n  function isConditionalExportsMainSugar(exports, packageJSONUrl, base) {\n    if (typeof exports === 'string' || ArrayIsArray(exports)) return true;\n    if (typeof exports !== 'object' || exports === null) return false;\n    const keys = ObjectGetOwnPropertyNames(exports);\n    let isConditionalSugar = false;\n    let i = 0;\n    for (let j = 0; j < keys.length; j++) {\n      const key = keys[j];\n      const curIsConditionalSugar = key === '' || key[0] !== '.';\n      if (i++ === 0) {\n        isConditionalSugar = curIsConditionalSugar;\n      } else if (isConditionalSugar !== curIsConditionalSugar) {\n        throw new ERR_INVALID_PACKAGE_CONFIG(fileURLToPath(packageJSONUrl), base, '\"exports\" cannot contain some keys starting with \\'.\\' and some not.' + ' The exports object must either be an object of package subpath keys' + ' or an object of main entry condition name keys only.');\n      }\n    }\n    return isConditionalSugar;\n  }\n\n  /**\n   * @param {URL} packageJSONUrl\n   * @param {string} packageSubpath\n   * @param {object} packageConfig\n   * @param {string} base\n   * @param {Set<string>} conditions\n   * @returns {{resolved: URL, exact: boolean}}\n   */\n  function packageExportsResolve(packageJSONUrl, packageSubpath, packageConfig, base, conditions) {\n    let exports = packageConfig.exports;\n    if (isConditionalExportsMainSugar(exports, packageJSONUrl, base)) exports = {\n      '.': exports\n    };\n    if (ObjectPrototypeHasOwnProperty(exports, packageSubpath)) {\n      const target = exports[packageSubpath];\n      const resolved = resolvePackageTarget(packageJSONUrl, target, '', packageSubpath, base, false, false, conditions);\n      if (resolved === null || resolved === undefined) throwExportsNotFound(packageSubpath, packageJSONUrl, base);\n      return {\n        resolved,\n        exact: true\n      };\n    }\n    let bestMatch = '';\n    const keys = ObjectGetOwnPropertyNames(exports);\n    for (let i = 0; i < keys.length; i++) {\n      const key = keys[i];\n      if (key[key.length - 1] === '*' && StringPrototypeStartsWith(packageSubpath, StringPrototypeSlice(key, 0, -1)) && packageSubpath.length >= key.length && key.length > bestMatch.length) {\n        bestMatch = key;\n      } else if (key[key.length - 1] === '/' && StringPrototypeStartsWith(packageSubpath, key) && key.length > bestMatch.length) {\n        bestMatch = key;\n      }\n    }\n    if (bestMatch) {\n      const target = exports[bestMatch];\n      const pattern = bestMatch[bestMatch.length - 1] === '*';\n      const subpath = StringPrototypeSubstr(packageSubpath, bestMatch.length - (pattern ? 1 : 0));\n      const resolved = resolvePackageTarget(packageJSONUrl, target, subpath, bestMatch, base, pattern, false, conditions);\n      if (resolved === null || resolved === undefined) throwExportsNotFound(packageSubpath, packageJSONUrl, base);\n      if (!pattern) emitFolderMapDeprecation(bestMatch, packageJSONUrl, true, base);\n      return {\n        resolved,\n        exact: pattern\n      };\n    }\n    throwExportsNotFound(packageSubpath, packageJSONUrl, base);\n  }\n  function packageImportsResolve(name, base, conditions) {\n    if (name === '#' || StringPrototypeStartsWith(name, '#/')) {\n      const reason = 'is not a valid internal imports specifier name';\n      throw new ERR_INVALID_MODULE_SPECIFIER(name, reason, fileURLToPath(base));\n    }\n    let packageJSONUrl;\n    const packageConfig = getPackageScopeConfig(base);\n    if (packageConfig.exists) {\n      packageJSONUrl = pathToFileURL(packageConfig.pjsonPath);\n      const imports = packageConfig.imports;\n      if (imports) {\n        if (ObjectPrototypeHasOwnProperty(imports, name)) {\n          const resolved = resolvePackageTarget(packageJSONUrl, imports[name], '', name, base, false, true, conditions);\n          if (resolved !== null) return {\n            resolved,\n            exact: true\n          };\n        } else {\n          let bestMatch = '';\n          const keys = ObjectGetOwnPropertyNames(imports);\n          for (let i = 0; i < keys.length; i++) {\n            const key = keys[i];\n            if (key[key.length - 1] === '*' && StringPrototypeStartsWith(name, StringPrototypeSlice(key, 0, -1)) && name.length >= key.length && key.length > bestMatch.length) {\n              bestMatch = key;\n            } else if (key[key.length - 1] === '/' && StringPrototypeStartsWith(name, key) && key.length > bestMatch.length) {\n              bestMatch = key;\n            }\n          }\n          if (bestMatch) {\n            const target = imports[bestMatch];\n            const pattern = bestMatch[bestMatch.length - 1] === '*';\n            const subpath = StringPrototypeSubstr(name, bestMatch.length - (pattern ? 1 : 0));\n            const resolved = resolvePackageTarget(packageJSONUrl, target, subpath, bestMatch, base, pattern, true, conditions);\n            if (resolved !== null) {\n              if (!pattern) emitFolderMapDeprecation(bestMatch, packageJSONUrl, false, base);\n              return {\n                resolved,\n                exact: pattern\n              };\n            }\n          }\n        }\n      }\n    }\n    throwImportNotDefined(name, packageJSONUrl, base);\n  }\n  function getPackageType(url) {\n    const packageConfig = getPackageScopeConfig(url);\n    return packageConfig.type;\n  }\n  function parsePackageName(specifier, base) {\n    let separatorIndex = StringPrototypeIndexOf(specifier, '/');\n    let validPackageName = true;\n    let isScoped = false;\n    if (specifier[0] === '@') {\n      isScoped = true;\n      if (separatorIndex === -1 || specifier.length === 0) {\n        validPackageName = false;\n      } else {\n        separatorIndex = StringPrototypeIndexOf(specifier, '/', separatorIndex + 1);\n      }\n    }\n    const packageName = separatorIndex === -1 ? specifier : StringPrototypeSlice(specifier, 0, separatorIndex);\n\n    // Package name cannot have leading . and cannot have percent-encoding or\n    // separators.\n    for (let i = 0; i < packageName.length; i++) {\n      if (packageName[i] === '%' || packageName[i] === '\\\\') {\n        validPackageName = false;\n        break;\n      }\n    }\n    if (!validPackageName) {\n      throw new ERR_INVALID_MODULE_SPECIFIER(specifier, 'is not a valid package name', fileURLToPath(base));\n    }\n    const packageSubpath = '.' + (separatorIndex === -1 ? '' : StringPrototypeSlice(specifier, separatorIndex));\n    return {\n      packageName,\n      packageSubpath,\n      isScoped\n    };\n  }\n\n  /**\n   * @param {string} specifier\n   * @param {URL} base\n   * @param {Set<string>} conditions\n   * @returns {URL}\n   */\n  function packageResolve(specifier, base, conditions) {\n    const {\n      packageName,\n      packageSubpath,\n      isScoped\n    } = parsePackageName(specifier, base);\n\n    // ResolveSelf\n    const packageConfig = getPackageScopeConfig(base);\n    if (packageConfig.exists) {\n      const packageJSONUrl = pathToFileURL(packageConfig.pjsonPath);\n      if (packageConfig.name === packageName && packageConfig.exports !== undefined && packageConfig.exports !== null) {\n        return packageExportsResolve(packageJSONUrl, packageSubpath, packageConfig, base, conditions).resolved;\n      }\n    }\n    let packageJSONUrl = new URL('./node_modules/' + packageName + '/package.json', base);\n    let packageJSONPath = fileURLToPath(packageJSONUrl);\n    let lastPath;\n    do {\n      const stat = tryStatSync(StringPrototypeSlice(packageJSONPath, 0, packageJSONPath.length - 13));\n      if (!stat.isDirectory()) {\n        lastPath = packageJSONPath;\n        packageJSONUrl = new URL((isScoped ? '../../../../node_modules/' : '../../../node_modules/') + packageName + '/package.json', packageJSONUrl);\n        packageJSONPath = fileURLToPath(packageJSONUrl);\n        continue;\n      }\n\n      // Package match.\n      const packageConfig = getPackageConfig(packageJSONPath, specifier, base);\n      if (packageConfig.exports !== undefined && packageConfig.exports !== null) return packageExportsResolve(packageJSONUrl, packageSubpath, packageConfig, base, conditions).resolved;\n      if (packageSubpath === '.') return legacyMainResolve(packageJSONUrl, packageConfig, base);\n      return new URL(packageSubpath, packageJSONUrl);\n      // Cross-platform root check.\n    } while (packageJSONPath.length !== lastPath.length);\n\n    // eslint can't handle the above code.\n    // eslint-disable-next-line no-unreachable\n    throw new ERR_MODULE_NOT_FOUND(packageName, fileURLToPath(base));\n  }\n  function isBareSpecifier(specifier) {\n    return specifier[0] && specifier[0] !== '/' && specifier[0] !== '.';\n  }\n  function isRelativeSpecifier(specifier) {\n    if (specifier[0] === '.') {\n      if (specifier.length === 1 || specifier[1] === '/') return true;\n      if (specifier[1] === '.') {\n        if (specifier.length === 2 || specifier[2] === '/') return true;\n      }\n    }\n    return false;\n  }\n  function shouldBeTreatedAsRelativeOrAbsolutePath(specifier) {\n    if (specifier === '') return false;\n    if (specifier[0] === '/') return true;\n    return isRelativeSpecifier(specifier);\n  }\n\n  /**\n   * @param {string} specifier\n   * @param {URL} base\n   * @param {Set<string>} conditions\n   * @returns {URL}\n   */\n  function moduleResolve(specifier, base, conditions) {\n    // Order swapped from spec for minor perf gain.\n    // Ok since relative URLs cannot parse as URLs.\n    let resolved;\n    if (shouldBeTreatedAsRelativeOrAbsolutePath(specifier)) {\n      resolved = new URL(specifier, base);\n    } else if (specifier[0] === '#') {\n      ({\n        resolved\n      } = packageImportsResolve(specifier, base, conditions));\n    } else {\n      try {\n        resolved = new URL(specifier);\n      } catch {\n        resolved = packageResolve(specifier, base, conditions);\n      }\n    }\n    return finalizeResolution(resolved, base);\n  }\n\n  /**\n   * Try to resolve an import as a CommonJS module\n   * @param {string} specifier\n   * @param {string} parentURL\n   * @returns {boolean|string}\n   */\n  function resolveAsCommonJS(specifier, parentURL) {\n    try {\n      const parent = fileURLToPath(parentURL);\n      const tmpModule = new CJSModule(parent, null);\n      tmpModule.paths = CJSModule._nodeModulePaths(parent);\n      let found = CJSModule._resolveFilename(specifier, tmpModule, false);\n\n      // If it is a relative specifier return the relative path\n      // to the parent\n      if (isRelativeSpecifier(specifier)) {\n        found = relative(parent, found);\n        // Add '.separator if the path does not start with '..separator'\n        // This should be a safe assumption because when loading\n        // esm modules there should be always a file specified so\n        // there should not be a specifier like '..' or '.'\n        if (!StringPrototypeStartsWith(found, `..${sep}`)) {\n          found = `.${sep}${found}`;\n        }\n      } else if (isBareSpecifier(specifier)) {\n        // If it is a bare specifier return the relative path within the\n        // module\n        const pkg = StringPrototypeSplit(specifier, '/')[0];\n        const index = StringPrototypeIndexOf(found, pkg);\n        if (index !== -1) {\n          found = StringPrototypeSlice(found, index);\n        }\n      }\n      // Normalize the path separator to give a valid suggestion\n      // on Windows\n      if (process.platform === 'win32') {\n        found = StringPrototypeReplace(found, new RegExp(`\\\\${sep}`, 'g'), '/');\n      }\n      return found;\n    } catch {\n      return false;\n    }\n  }\n  function defaultResolve(specifier) {\n    let context = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    let defaultResolveUnused = arguments.length > 2 ? arguments[2] : undefined;\n    let {\n      parentURL,\n      conditions\n    } = context;\n    if (parentURL && policy != null && policy.manifest) {\n      const redirects = policy.manifest.getDependencyMapper(parentURL);\n      if (redirects) {\n        const {\n          resolve,\n          reaction\n        } = redirects;\n        const destination = resolve(specifier, new SafeSet(conditions));\n        let missing = true;\n        if (destination === true) {\n          missing = false;\n        } else if (destination) {\n          const href = destination.href;\n          return {\n            url: href\n          };\n        }\n        if (missing) {\n          reaction(new ERR_MANIFEST_DEPENDENCY_MISSING(parentURL, specifier, ArrayPrototypeJoin([...conditions], ', ')));\n        }\n      }\n    }\n    let parsed;\n    try {\n      parsed = new URL(specifier);\n      if (parsed.protocol === 'data:') {\n        return {\n          url: specifier\n        };\n      }\n    } catch {}\n    if (parsed && parsed.protocol === builtinModuleProtocol) return {\n      url: specifier\n    };\n    if (parsed && parsed.protocol !== 'file:' && parsed.protocol !== 'data:') throw new ERR_UNSUPPORTED_ESM_URL_SCHEME(parsed);\n    if (NativeModule.canBeRequiredByUsers(specifier)) {\n      return {\n        url: builtinModuleProtocol + specifier\n      };\n    }\n    if (parentURL && StringPrototypeStartsWith(parentURL, 'data:')) {\n      // This is gonna blow up, we want the error\n      new URL(specifier, parentURL);\n    }\n    const isMain = parentURL === undefined;\n    if (isMain) {\n      parentURL = pathToFileURL(`${process.cwd()}/`).href;\n\n      // This is the initial entry point to the program, and --input-type has\n      // been passed as an option; but --input-type can only be used with\n      // --eval, --print or STDIN string input. It is not allowed with file\n      // input, to avoid user confusion over how expansive the effect of the\n      // flag should be (i.e. entry point only, package scope surrounding the\n      // entry point, etc.).\n      if (typeFlag) throw new ERR_INPUT_TYPE_NOT_ALLOWED();\n    }\n    conditions = getConditionsSet(conditions);\n    let url;\n    try {\n      url = moduleResolve(specifier, parentURL, conditions);\n    } catch (error) {\n      // Try to give the user a hint of what would have been the\n      // resolved CommonJS module\n      if (error.code === 'ERR_MODULE_NOT_FOUND' || error.code === 'ERR_UNSUPPORTED_DIR_IMPORT') {\n        if (StringPrototypeStartsWith(specifier, 'file://')) {\n          specifier = fileURLToPath(specifier);\n        }\n        const found = resolveAsCommonJS(specifier, parentURL);\n        if (found) {\n          // Modify the stack and message string to include the hint\n          const lines = StringPrototypeSplit(error.stack, '\\n');\n          const hint = `Did you mean to import ${found}?`;\n          error.stack = ArrayPrototypeShift(lines) + '\\n' + hint + '\\n' + ArrayPrototypeJoin(lines, '\\n');\n          error.message += `\\n${hint}`;\n        }\n      }\n      throw error;\n    }\n    if (isMain ? !preserveSymlinksMain : !preserveSymlinks) {\n      const urlPath = fileURLToPath(url);\n      const real = realpathSync(urlPath, {\n        // [internalFS.realpathCacheKey]: realpathCache\n      });\n      const old = url;\n      url = pathToFileURL(real + (StringPrototypeEndsWith(urlPath, sep) ? '/' : ''));\n      url.search = old.search;\n      url.hash = old.hash;\n    }\n    return {\n      url: `${url}`\n    };\n  }\n  return {\n    DEFAULT_CONDITIONS,\n    defaultResolve,\n    encodedSepRegEx,\n    getPackageType,\n    packageExportsResolve,\n    packageImportsResolve\n  };\n}\nmodule.exports = {\n  createResolve\n};","map":{"version":3,"names":["versionGteLt","require","builtinModuleProtocol","process","versions","node","ArrayIsArray","ArrayPrototypeJoin","ArrayPrototypeShift","JSONParse","JSONStringify","ObjectFreeze","ObjectGetOwnPropertyNames","ObjectPrototypeHasOwnProperty","RegExpPrototypeTest","SafeMap","SafeSet","StringPrototypeEndsWith","StringPrototypeIndexOf","StringPrototypeLastIndexOf","StringPrototypeReplace","StringPrototypeSlice","StringPrototypeSplit","StringPrototypeStartsWith","StringPrototypeSubstr","Module","NativeModule","realpathSync","statSync","Stats","getOptionValue","policy","sep","relative","preserveSymlinks","preserveSymlinksMain","typeFlag","URL","pathToFileURL","fileURLToPath","ERR_INPUT_TYPE_NOT_ALLOWED","ERR_INVALID_ARG_VALUE","ERR_INVALID_MODULE_SPECIFIER","ERR_INVALID_PACKAGE_CONFIG","ERR_INVALID_PACKAGE_TARGET","ERR_MANIFEST_DEPENDENCY_MISSING","ERR_MODULE_NOT_FOUND","ERR_PACKAGE_IMPORT_NOT_DEFINED","ERR_PACKAGE_PATH_NOT_EXPORTED","ERR_UNSUPPORTED_DIR_IMPORT","ERR_UNSUPPORTED_ESM_URL_SCHEME","codes","CJSModule","packageJsonReader","userConditions","DEFAULT_CONDITIONS","DEFAULT_CONDITIONS_SET","pendingDeprecation","createResolve","opts","preferTsExts","tsNodeExperimentalSpecifierResolution","extensions","esrnExtensions","experimentalSpecifierResolutionAddsIfOmitted","legacyMainResolveAddsIfOmitted","replacementsForCjs","replacementsForJs","replacementsForMjs","replacementsForJsx","experimentalSpecifierResolution","emittedPackageWarnings","emitFolderMapDeprecation","match","pjsonUrl","isExports","base","pjsonPath","nodeModulesIndex","afterNodeModulesPath","packageSubpath","parsePackageName","has","add","emitWarning","getConditionsSet","conditions","undefined","realpathCache","packageJSONCache","statSupportsThrowIfNoEntry","tryStatSync","tryStatSyncWithoutErrors","tryStatSyncWithErrors","statsIfNotFound","path","stats","throwIfNoEntry","getPackageConfig","specifier","existing","get","source","read","string","packageConfig","exists","main","name","type","exports","imports","set","packageJSON","error","message","getPackageScopeConfig","resolved","packageJSONUrl","packageJSONPath","pathname","lastPackageJSONUrl","fileExists","url","isFile","legacyMainResolve","guess","resolveReplacementExtensions","extension","resolveExtensionsWithTryExactName","search","resolvedReplacementExtension","resolveExtensions","i","length","lastDotIndex","lastIndexOf","ext","slice","pathnameWithoutExtension","replacementExts","toString","resolveIndex","encodedSepRegEx","finalizeResolution","file","isDirectory","err","String","throwImportNotDefined","throwExportsNotFound","subpath","throwInvalidSubpath","internal","reason","throwInvalidPackageTarget","target","invalidSegmentRegEx","patternRegEx","resolvePackageTargetString","pattern","isURL","exportTarget","packageResolve","resolvedPath","packagePath","href","isArrayIndex","key","keyNum","resolvePackageTarget","lastException","targetItem","e","code","keys","conditionalTarget","isConditionalExportsMainSugar","isConditionalSugar","j","curIsConditionalSugar","packageExportsResolve","exact","bestMatch","packageImportsResolve","getPackageType","separatorIndex","validPackageName","isScoped","packageName","lastPath","stat","isBareSpecifier","isRelativeSpecifier","shouldBeTreatedAsRelativeOrAbsolutePath","moduleResolve","resolveAsCommonJS","parentURL","parent","tmpModule","paths","_nodeModulePaths","found","_resolveFilename","pkg","index","platform","RegExp","defaultResolve","context","defaultResolveUnused","manifest","redirects","getDependencyMapper","resolve","reaction","destination","missing","parsed","protocol","canBeRequiredByUsers","isMain","cwd","lines","stack","hint","urlPath","real","old","hash","module"],"sources":["/Users/janrobel/Documents/PersonalProjekty/nftGenerateAi/clientAndContract/node_modules/ts-node/dist-raw/node-internal-modules-esm-resolve.js"],"sourcesContent":["// Copied from https://raw.githubusercontent.com/nodejs/node/v15.3.0/lib/internal/modules/esm/resolve.js\n\n'use strict';\n\nconst {versionGteLt} = require('../dist/util');\n\n// Test for node >14.13.1 || (>=12.20.0 && <13)\nconst builtinModuleProtocol =\n  versionGteLt(process.versions.node, '14.13.1') ||\n  versionGteLt(process.versions.node, '12.20.0', '13.0.0')\n    ? 'node:'\n    : 'nodejs:';\n\nconst {\n  ArrayIsArray,\n  ArrayPrototypeJoin,\n  ArrayPrototypeShift,\n  JSONParse,\n  JSONStringify,\n  ObjectFreeze,\n  ObjectGetOwnPropertyNames,\n  ObjectPrototypeHasOwnProperty,\n  RegExpPrototypeTest,\n  SafeMap,\n  SafeSet,\n  StringPrototypeEndsWith,\n  StringPrototypeIndexOf,\n  StringPrototypeLastIndexOf,\n  StringPrototypeReplace,\n  StringPrototypeSlice,\n  StringPrototypeSplit,\n  StringPrototypeStartsWith,\n  StringPrototypeSubstr,\n} = require('./node-primordials');\n\n// const internalFS = require('internal/fs/utils');\nconst Module = require('module');\nconst { NativeModule } = require('./node-nativemodule');\nconst {\n  realpathSync,\n  statSync,\n  Stats,\n} = require('fs');\n// const { getOptionValue } = require('internal/options');\nconst { getOptionValue } = require('./node-options');\n// // Do not eagerly grab .manifest, it may be in TDZ\n// const policy = getOptionValue('--experimental-policy') ?\n//   require('internal/process/policy') :\n//   null;\n// disabled for now.  I am not sure if/how we should support this\nconst policy = null;\nconst { sep, relative } = require('path');\nconst preserveSymlinks = getOptionValue('--preserve-symlinks');\nconst preserveSymlinksMain = getOptionValue('--preserve-symlinks-main');\nconst typeFlag = getOptionValue('--input-type');\n// const { URL, pathToFileURL, fileURLToPath } = require('internal/url');\nconst { URL, pathToFileURL, fileURLToPath } = require('url');\nconst {\n  ERR_INPUT_TYPE_NOT_ALLOWED,\n  ERR_INVALID_ARG_VALUE,\n  ERR_INVALID_MODULE_SPECIFIER,\n  ERR_INVALID_PACKAGE_CONFIG,\n  ERR_INVALID_PACKAGE_TARGET,\n  ERR_MANIFEST_DEPENDENCY_MISSING,\n  ERR_MODULE_NOT_FOUND,\n  ERR_PACKAGE_IMPORT_NOT_DEFINED,\n  ERR_PACKAGE_PATH_NOT_EXPORTED,\n  ERR_UNSUPPORTED_DIR_IMPORT,\n  ERR_UNSUPPORTED_ESM_URL_SCHEME,\n// } = require('internal/errors').codes;\n} = require('./node-internal-errors').codes;\n\n// const { Module: CJSModule } = require('internal/modules/cjs/loader');\nconst CJSModule = Module;\n\n// const packageJsonReader = require('internal/modules/package_json_reader');\nconst packageJsonReader = require('./node-internal-modules-package_json_reader');\nconst userConditions = getOptionValue('--conditions');\nconst DEFAULT_CONDITIONS = ObjectFreeze(['node', 'import', ...userConditions]);\nconst DEFAULT_CONDITIONS_SET = new SafeSet(DEFAULT_CONDITIONS);\n\nconst pendingDeprecation = getOptionValue('--pending-deprecation');\n\n/**\n * @param {{\n *  extensions: import('../src/file-extensions').Extensions,\n *  preferTsExts: boolean | undefined;\n *  tsNodeExperimentalSpecifierResolution: import('../src/index').ExperimentalSpecifierResolution | undefined;\n * }} opts\n */\nfunction createResolve(opts) {\n// TODO receive cached fs implementations here\nconst {preferTsExts, tsNodeExperimentalSpecifierResolution, extensions} = opts;\nconst esrnExtensions = extensions.experimentalSpecifierResolutionAddsIfOmitted;\nconst {legacyMainResolveAddsIfOmitted, replacementsForCjs, replacementsForJs, replacementsForMjs, replacementsForJsx} = extensions;\n// const experimentalSpecifierResolution = tsNodeExperimentalSpecifierResolution ?? getOptionValue('--experimental-specifier-resolution');\nconst experimentalSpecifierResolution = tsNodeExperimentalSpecifierResolution != null ? tsNodeExperimentalSpecifierResolution : getOptionValue('--experimental-specifier-resolution');\n\nconst emittedPackageWarnings = new SafeSet();\nfunction emitFolderMapDeprecation(match, pjsonUrl, isExports, base) {\n  const pjsonPath = fileURLToPath(pjsonUrl);\n  if (!pendingDeprecation) {\n    const nodeModulesIndex = StringPrototypeLastIndexOf(pjsonPath,\n                                                        '/node_modules/');\n    if (nodeModulesIndex !== -1) {\n      const afterNodeModulesPath = StringPrototypeSlice(pjsonPath,\n                                                        nodeModulesIndex + 14,\n                                                        -13);\n      try {\n        const { packageSubpath } = parsePackageName(afterNodeModulesPath);\n        if (packageSubpath === '.')\n          return;\n      } catch {}\n    }\n  }\n  if (emittedPackageWarnings.has(pjsonPath + '|' + match))\n    return;\n  emittedPackageWarnings.add(pjsonPath + '|' + match);\n  process.emitWarning(\n    `Use of deprecated folder mapping \"${match}\" in the ${isExports ?\n      '\"exports\"' : '\"imports\"'} field module resolution of the package at ${\n      pjsonPath}${base ? ` imported from ${fileURLToPath(base)}` : ''}.\\n` +\n      `Update this package.json to use a subpath pattern like \"${match}*\".`,\n    'DeprecationWarning',\n    'DEP0148'\n  );\n}\n\nfunction getConditionsSet(conditions) {\n  if (conditions !== undefined && conditions !== DEFAULT_CONDITIONS) {\n    if (!ArrayIsArray(conditions)) {\n      throw new ERR_INVALID_ARG_VALUE('conditions', conditions,\n                                      'expected an array');\n    }\n    return new SafeSet(conditions);\n  }\n  return DEFAULT_CONDITIONS_SET;\n}\n\nconst realpathCache = new SafeMap();\nconst packageJSONCache = new SafeMap();  /* string -> PackageConfig */\n\nconst statSupportsThrowIfNoEntry = versionGteLt(process.versions.node, '15.3.0') ||\n  versionGteLt(process.versions.node, '14.17.0', '15.0.0');\nconst tryStatSync = statSupportsThrowIfNoEntry ? tryStatSyncWithoutErrors : tryStatSyncWithErrors;\nconst statsIfNotFound = new Stats();\nfunction tryStatSyncWithoutErrors(path) {\n  const stats = statSync(path, { throwIfNoEntry: false });\n  if(stats != null) return stats;\n  return statsIfNotFound;\n}\nfunction tryStatSyncWithErrors(path) {\n  try {\n    return statSync(path);\n  } catch {\n    return statsIfNotFound;\n  }\n}\n\nfunction getPackageConfig(path, specifier, base) {\n  const existing = packageJSONCache.get(path);\n  if (existing !== undefined) {\n    return existing;\n  }\n  const source = packageJsonReader.read(path).string;\n  if (source === undefined) {\n    const packageConfig = {\n      pjsonPath: path,\n      exists: false,\n      main: undefined,\n      name: undefined,\n      type: 'none',\n      exports: undefined,\n      imports: undefined,\n    };\n    packageJSONCache.set(path, packageConfig);\n    return packageConfig;\n  }\n\n  let packageJSON;\n  try {\n    packageJSON = JSONParse(source);\n  } catch (error) {\n    throw new ERR_INVALID_PACKAGE_CONFIG(\n      path,\n      (base ? `\"${specifier}\" from ` : '') + fileURLToPath(base || specifier),\n      error.message\n    );\n  }\n\n  let { imports, main, name, type } = packageJSON;\n  const { exports } = packageJSON;\n  if (typeof imports !== 'object' || imports === null) imports = undefined;\n  if (typeof main !== 'string') main = undefined;\n  if (typeof name !== 'string') name = undefined;\n  // Ignore unknown types for forwards compatibility\n  if (type !== 'module' && type !== 'commonjs') type = 'none';\n\n  const packageConfig = {\n    pjsonPath: path,\n    exists: true,\n    main,\n    name,\n    type,\n    exports,\n    imports,\n  };\n  packageJSONCache.set(path, packageConfig);\n  return packageConfig;\n}\n\nfunction getPackageScopeConfig(resolved) {\n  let packageJSONUrl = new URL('./package.json', resolved);\n  while (true) {\n    const packageJSONPath = packageJSONUrl.pathname;\n    if (StringPrototypeEndsWith(packageJSONPath, 'node_modules/package.json'))\n      break;\n    const packageConfig = getPackageConfig(fileURLToPath(packageJSONUrl),\n                                           resolved);\n    if (packageConfig.exists) return packageConfig;\n\n    const lastPackageJSONUrl = packageJSONUrl;\n    packageJSONUrl = new URL('../package.json', packageJSONUrl);\n\n    // Terminates at root where ../package.json equals ../../package.json\n    // (can't just check \"/package.json\" for Windows support).\n    if (packageJSONUrl.pathname === lastPackageJSONUrl.pathname) break;\n  }\n  const packageJSONPath = fileURLToPath(packageJSONUrl);\n  const packageConfig = {\n    pjsonPath: packageJSONPath,\n    exists: false,\n    main: undefined,\n    name: undefined,\n    type: 'none',\n    exports: undefined,\n    imports: undefined,\n  };\n  packageJSONCache.set(packageJSONPath, packageConfig);\n  return packageConfig;\n}\n\n/*\n * Legacy CommonJS main resolution:\n * 1. let M = pkg_url + (json main field)\n * 2. TRY(M, M.js, M.json, M.node)\n * 3. TRY(M/index.js, M/index.json, M/index.node)\n * 4. TRY(pkg_url/index.js, pkg_url/index.json, pkg_url/index.node)\n * 5. NOT_FOUND\n */\nfunction fileExists(url) {\n  return tryStatSync(fileURLToPath(url)).isFile();\n}\n\nfunction legacyMainResolve(packageJSONUrl, packageConfig, base) {\n  let guess;\n  if (packageConfig.main !== undefined) {\n    // Note: fs check redundances will be handled by Descriptor cache here.\n    if(guess = resolveReplacementExtensions(new URL(`./${packageConfig.main}`, packageJSONUrl))) {\n      return guess;\n    }\n    if (fileExists(guess = new URL(`./${packageConfig.main}`,\n                                   packageJSONUrl))) {\n      return guess;\n    }\n    for(const extension of legacyMainResolveAddsIfOmitted) {\n      if (fileExists(guess = new URL(`./${packageConfig.main}${extension}`,\n                                    packageJSONUrl))) {\n        return guess;\n      }\n    }\n    for(const extension of legacyMainResolveAddsIfOmitted) {\n      if (fileExists(guess = new URL(`./${packageConfig.main}/index${extension}`,\n                                    packageJSONUrl))) {\n        return guess;\n      }\n    }\n    // Fallthrough.\n  }\n  for(const extension of legacyMainResolveAddsIfOmitted) {\n    if (fileExists(guess = new URL(`./index${extension}`, packageJSONUrl))) {\n      return guess;\n    }\n  }\n  // Not found.\n  throw new ERR_MODULE_NOT_FOUND(\n    fileURLToPath(new URL('.', packageJSONUrl)), fileURLToPath(base));\n}\n\n/** attempts replacement extensions, then tries exact name, then attempts appending extensions */\nfunction resolveExtensionsWithTryExactName(search) {\n  const resolvedReplacementExtension = resolveReplacementExtensions(search);\n  if(resolvedReplacementExtension) return resolvedReplacementExtension;\n  if (fileExists(search)) return search;\n  return resolveExtensions(search);\n}\n\n// This appends missing extensions\nfunction resolveExtensions(search) {\n  for (let i = 0; i < esrnExtensions.length; i++) {\n    const extension = esrnExtensions[i];\n    const guess = new URL(`${search.pathname}${extension}`, search);\n    if (fileExists(guess)) return guess;\n  }\n  return undefined;\n}\n\n/** This replaces JS with TS extensions */\nfunction resolveReplacementExtensions(search) {\n  const lastDotIndex = search.pathname.lastIndexOf('.');\n  if(lastDotIndex >= 0) {\n    const ext = search.pathname.slice(lastDotIndex);\n    if (ext === '.js' || ext === '.jsx' || ext === '.mjs' || ext === '.cjs') {\n      const pathnameWithoutExtension = search.pathname.slice(0, lastDotIndex);\n      const replacementExts =\n        ext === '.js' ? replacementsForJs\n        : ext === '.jsx' ? replacementsForJsx\n        : ext === '.mjs' ? replacementsForMjs\n        : replacementsForCjs;\n      const guess = new URL(search.toString());\n      for (let i = 0; i < replacementExts.length; i++) {\n        const extension = replacementExts[i];\n        guess.pathname = `${pathnameWithoutExtension}${extension}`;\n        if (fileExists(guess)) return guess;\n      }\n    }\n  }\n  return undefined;\n}\n\nfunction resolveIndex(search) {\n  return resolveExtensions(new URL('index', search));\n}\n\nconst encodedSepRegEx = /%2F|%2C/i;\nfunction finalizeResolution(resolved, base) {\n  if (RegExpPrototypeTest(encodedSepRegEx, resolved.pathname))\n    throw new ERR_INVALID_MODULE_SPECIFIER(\n      resolved.pathname, 'must not include encoded \"/\" or \"\\\\\" characters',\n      fileURLToPath(base));\n\n  if (experimentalSpecifierResolution === 'node') {\n    const path = fileURLToPath(resolved);\n    let file = resolveExtensionsWithTryExactName(resolved);\n    if (file !== undefined) return file;\n    if (!StringPrototypeEndsWith(path, '/')) {\n      file = resolveIndex(new URL(`${resolved}/`));\n      if (file !== undefined) return file;\n    } else {\n      return resolveIndex(resolved) || resolved;\n    }\n    throw new ERR_MODULE_NOT_FOUND(\n      resolved.pathname, fileURLToPath(base), 'module');\n  }\n\n  const file = resolveReplacementExtensions(resolved) || resolved;\n  const path = fileURLToPath(file);\n\n  const stats = tryStatSync(StringPrototypeEndsWith(path, '/') ?\n    StringPrototypeSlice(path, -1) : path);\n  if (stats.isDirectory()) {\n    const err = new ERR_UNSUPPORTED_DIR_IMPORT(path, fileURLToPath(base));\n    err.url = String(resolved);\n    throw err;\n  } else if (!stats.isFile()) {\n    throw new ERR_MODULE_NOT_FOUND(\n      path || resolved.pathname, fileURLToPath(base), 'module');\n  }\n\n  return file;\n}\n\nfunction throwImportNotDefined(specifier, packageJSONUrl, base) {\n  throw new ERR_PACKAGE_IMPORT_NOT_DEFINED(\n    specifier, packageJSONUrl && fileURLToPath(new URL('.', packageJSONUrl)),\n    fileURLToPath(base));\n}\n\nfunction throwExportsNotFound(subpath, packageJSONUrl, base) {\n  throw new ERR_PACKAGE_PATH_NOT_EXPORTED(\n    fileURLToPath(new URL('.', packageJSONUrl)), subpath,\n    base && fileURLToPath(base));\n}\n\nfunction throwInvalidSubpath(subpath, packageJSONUrl, internal, base) {\n  const reason = `request is not a valid subpath for the \"${internal ?\n    'imports' : 'exports'}\" resolution of ${fileURLToPath(packageJSONUrl)}`;\n  throw new ERR_INVALID_MODULE_SPECIFIER(subpath, reason,\n                                         base && fileURLToPath(base));\n}\n\nfunction throwInvalidPackageTarget(\n  subpath, target, packageJSONUrl, internal, base) {\n  if (typeof target === 'object' && target !== null) {\n    target = JSONStringify(target, null, '');\n  } else {\n    target = `${target}`;\n  }\n  throw new ERR_INVALID_PACKAGE_TARGET(\n    fileURLToPath(new URL('.', packageJSONUrl)), subpath, target,\n    internal, base && fileURLToPath(base));\n}\n\nconst invalidSegmentRegEx = /(^|\\\\|\\/)(\\.\\.?|node_modules)(\\\\|\\/|$)/;\nconst patternRegEx = /\\*/g;\n\nfunction resolvePackageTargetString(\n  target, subpath, match, packageJSONUrl, base, pattern, internal, conditions) {\n  if (subpath !== '' && !pattern && target[target.length - 1] !== '/')\n    throwInvalidPackageTarget(match, target, packageJSONUrl, internal, base);\n\n  if (!StringPrototypeStartsWith(target, './')) {\n    if (internal && !StringPrototypeStartsWith(target, '../') &&\n        !StringPrototypeStartsWith(target, '/')) {\n      let isURL = false;\n      try {\n        new URL(target);\n        isURL = true;\n      } catch {}\n      if (!isURL) {\n        const exportTarget = pattern ?\n          StringPrototypeReplace(target, patternRegEx, subpath) :\n          target + subpath;\n        return packageResolve(exportTarget, packageJSONUrl, conditions);\n      }\n    }\n    throwInvalidPackageTarget(match, target, packageJSONUrl, internal, base);\n  }\n\n  if (RegExpPrototypeTest(invalidSegmentRegEx, StringPrototypeSlice(target, 2)))\n    throwInvalidPackageTarget(match, target, packageJSONUrl, internal, base);\n\n  const resolved = new URL(target, packageJSONUrl);\n  const resolvedPath = resolved.pathname;\n  const packagePath = new URL('.', packageJSONUrl).pathname;\n\n  if (!StringPrototypeStartsWith(resolvedPath, packagePath))\n    throwInvalidPackageTarget(match, target, packageJSONUrl, internal, base);\n\n  if (subpath === '') return resolved;\n\n  if (RegExpPrototypeTest(invalidSegmentRegEx, subpath))\n    throwInvalidSubpath(match + subpath, packageJSONUrl, internal, base);\n\n  if (pattern)\n    return new URL(StringPrototypeReplace(resolved.href, patternRegEx,\n                                          subpath));\n  return new URL(subpath, resolved);\n}\n\n/**\n * @param {string} key\n * @returns {boolean}\n */\nfunction isArrayIndex(key) {\n  const keyNum = +key;\n  if (`${keyNum}` !== key) return false;\n  return keyNum >= 0 && keyNum < 0xFFFF_FFFF;\n}\n\nfunction resolvePackageTarget(packageJSONUrl, target, subpath, packageSubpath,\n                              base, pattern, internal, conditions) {\n  if (typeof target === 'string') {\n    return resolvePackageTargetString(\n      target, subpath, packageSubpath, packageJSONUrl, base, pattern, internal,\n      conditions);\n  } else if (ArrayIsArray(target)) {\n    if (target.length === 0)\n      return null;\n\n    let lastException;\n    for (let i = 0; i < target.length; i++) {\n      const targetItem = target[i];\n      let resolved;\n      try {\n        resolved = resolvePackageTarget(\n          packageJSONUrl, targetItem, subpath, packageSubpath, base, pattern,\n          internal, conditions);\n      } catch (e) {\n        lastException = e;\n        if (e.code === 'ERR_INVALID_PACKAGE_TARGET')\n          continue;\n        throw e;\n      }\n      if (resolved === undefined)\n        continue;\n      if (resolved === null) {\n        lastException = null;\n        continue;\n      }\n      return resolved;\n    }\n    if (lastException === undefined || lastException === null)\n      return lastException;\n    throw lastException;\n  } else if (typeof target === 'object' && target !== null) {\n    const keys = ObjectGetOwnPropertyNames(target);\n    for (let i = 0; i < keys.length; i++) {\n      const key = keys[i];\n      if (isArrayIndex(key)) {\n        throw new ERR_INVALID_PACKAGE_CONFIG(\n          fileURLToPath(packageJSONUrl), base,\n          '\"exports\" cannot contain numeric property keys.');\n      }\n    }\n    for (let i = 0; i < keys.length; i++) {\n      const key = keys[i];\n      if (key === 'default' || conditions.has(key)) {\n        const conditionalTarget = target[key];\n        const resolved = resolvePackageTarget(\n          packageJSONUrl, conditionalTarget, subpath, packageSubpath, base,\n          pattern, internal, conditions);\n        if (resolved === undefined)\n          continue;\n        return resolved;\n      }\n    }\n    return undefined;\n  } else if (target === null) {\n    return null;\n  }\n  throwInvalidPackageTarget(packageSubpath, target, packageJSONUrl, internal,\n                            base);\n}\n\nfunction isConditionalExportsMainSugar(exports, packageJSONUrl, base) {\n  if (typeof exports === 'string' || ArrayIsArray(exports)) return true;\n  if (typeof exports !== 'object' || exports === null) return false;\n\n  const keys = ObjectGetOwnPropertyNames(exports);\n  let isConditionalSugar = false;\n  let i = 0;\n  for (let j = 0; j < keys.length; j++) {\n    const key = keys[j];\n    const curIsConditionalSugar = key === '' || key[0] !== '.';\n    if (i++ === 0) {\n      isConditionalSugar = curIsConditionalSugar;\n    } else if (isConditionalSugar !== curIsConditionalSugar) {\n      throw new ERR_INVALID_PACKAGE_CONFIG(\n        fileURLToPath(packageJSONUrl), base,\n        '\"exports\" cannot contain some keys starting with \\'.\\' and some not.' +\n        ' The exports object must either be an object of package subpath keys' +\n        ' or an object of main entry condition name keys only.');\n    }\n  }\n  return isConditionalSugar;\n}\n\n/**\n * @param {URL} packageJSONUrl\n * @param {string} packageSubpath\n * @param {object} packageConfig\n * @param {string} base\n * @param {Set<string>} conditions\n * @returns {{resolved: URL, exact: boolean}}\n */\nfunction packageExportsResolve(\n  packageJSONUrl, packageSubpath, packageConfig, base, conditions) {\n  let exports = packageConfig.exports;\n  if (isConditionalExportsMainSugar(exports, packageJSONUrl, base))\n    exports = { '.': exports };\n\n  if (ObjectPrototypeHasOwnProperty(exports, packageSubpath)) {\n    const target = exports[packageSubpath];\n    const resolved = resolvePackageTarget(\n      packageJSONUrl, target, '', packageSubpath, base, false, false, conditions\n    );\n    if (resolved === null || resolved === undefined)\n      throwExportsNotFound(packageSubpath, packageJSONUrl, base);\n    return { resolved, exact: true };\n  }\n\n  let bestMatch = '';\n  const keys = ObjectGetOwnPropertyNames(exports);\n  for (let i = 0; i < keys.length; i++) {\n    const key = keys[i];\n    if (key[key.length - 1] === '*' &&\n        StringPrototypeStartsWith(packageSubpath,\n                                  StringPrototypeSlice(key, 0, -1)) &&\n        packageSubpath.length >= key.length &&\n        key.length > bestMatch.length) {\n      bestMatch = key;\n    } else if (key[key.length - 1] === '/' &&\n      StringPrototypeStartsWith(packageSubpath, key) &&\n      key.length > bestMatch.length) {\n      bestMatch = key;\n    }\n  }\n\n  if (bestMatch) {\n    const target = exports[bestMatch];\n    const pattern = bestMatch[bestMatch.length - 1] === '*';\n    const subpath = StringPrototypeSubstr(packageSubpath, bestMatch.length -\n      (pattern ? 1 : 0));\n    const resolved = resolvePackageTarget(packageJSONUrl, target, subpath,\n                                          bestMatch, base, pattern, false,\n                                          conditions);\n    if (resolved === null || resolved === undefined)\n      throwExportsNotFound(packageSubpath, packageJSONUrl, base);\n    if (!pattern)\n      emitFolderMapDeprecation(bestMatch, packageJSONUrl, true, base);\n    return { resolved, exact: pattern };\n  }\n\n  throwExportsNotFound(packageSubpath, packageJSONUrl, base);\n}\n\nfunction packageImportsResolve(name, base, conditions) {\n  if (name === '#' || StringPrototypeStartsWith(name, '#/')) {\n    const reason = 'is not a valid internal imports specifier name';\n    throw new ERR_INVALID_MODULE_SPECIFIER(name, reason, fileURLToPath(base));\n  }\n  let packageJSONUrl;\n  const packageConfig = getPackageScopeConfig(base);\n  if (packageConfig.exists) {\n    packageJSONUrl = pathToFileURL(packageConfig.pjsonPath);\n    const imports = packageConfig.imports;\n    if (imports) {\n      if (ObjectPrototypeHasOwnProperty(imports, name)) {\n        const resolved = resolvePackageTarget(\n          packageJSONUrl, imports[name], '', name, base, false, true, conditions\n        );\n        if (resolved !== null)\n          return { resolved, exact: true };\n      } else {\n        let bestMatch = '';\n        const keys = ObjectGetOwnPropertyNames(imports);\n        for (let i = 0; i < keys.length; i++) {\n          const key = keys[i];\n          if (key[key.length - 1] === '*' &&\n              StringPrototypeStartsWith(name,\n                                        StringPrototypeSlice(key, 0, -1)) &&\n              name.length >= key.length &&\n              key.length > bestMatch.length) {\n            bestMatch = key;\n          } else if (key[key.length - 1] === '/' &&\n            StringPrototypeStartsWith(name, key) &&\n            key.length > bestMatch.length) {\n            bestMatch = key;\n          }\n        }\n\n        if (bestMatch) {\n          const target = imports[bestMatch];\n          const pattern = bestMatch[bestMatch.length - 1] === '*';\n          const subpath = StringPrototypeSubstr(name, bestMatch.length -\n            (pattern ? 1 : 0));\n          const resolved = resolvePackageTarget(\n            packageJSONUrl, target, subpath, bestMatch, base, pattern, true,\n            conditions);\n          if (resolved !== null) {\n            if (!pattern)\n              emitFolderMapDeprecation(bestMatch, packageJSONUrl, false, base);\n            return { resolved, exact: pattern };\n          }\n        }\n      }\n    }\n  }\n  throwImportNotDefined(name, packageJSONUrl, base);\n}\n\nfunction getPackageType(url) {\n  const packageConfig = getPackageScopeConfig(url);\n  return packageConfig.type;\n}\n\nfunction parsePackageName(specifier, base) {\n  let separatorIndex = StringPrototypeIndexOf(specifier, '/');\n  let validPackageName = true;\n  let isScoped = false;\n  if (specifier[0] === '@') {\n    isScoped = true;\n    if (separatorIndex === -1 || specifier.length === 0) {\n      validPackageName = false;\n    } else {\n      separatorIndex = StringPrototypeIndexOf(\n        specifier, '/', separatorIndex + 1);\n    }\n  }\n\n  const packageName = separatorIndex === -1 ?\n    specifier : StringPrototypeSlice(specifier, 0, separatorIndex);\n\n  // Package name cannot have leading . and cannot have percent-encoding or\n  // separators.\n  for (let i = 0; i < packageName.length; i++) {\n    if (packageName[i] === '%' || packageName[i] === '\\\\') {\n      validPackageName = false;\n      break;\n    }\n  }\n\n  if (!validPackageName) {\n    throw new ERR_INVALID_MODULE_SPECIFIER(\n      specifier, 'is not a valid package name', fileURLToPath(base));\n  }\n\n  const packageSubpath = '.' + (separatorIndex === -1 ? '' :\n    StringPrototypeSlice(specifier, separatorIndex));\n\n  return { packageName, packageSubpath, isScoped };\n}\n\n/**\n * @param {string} specifier\n * @param {URL} base\n * @param {Set<string>} conditions\n * @returns {URL}\n */\nfunction packageResolve(specifier, base, conditions) {\n  const { packageName, packageSubpath, isScoped } =\n    parsePackageName(specifier, base);\n\n  // ResolveSelf\n  const packageConfig = getPackageScopeConfig(base);\n  if (packageConfig.exists) {\n    const packageJSONUrl = pathToFileURL(packageConfig.pjsonPath);\n    if (packageConfig.name === packageName &&\n        packageConfig.exports !== undefined && packageConfig.exports !== null) {\n      return packageExportsResolve(\n        packageJSONUrl, packageSubpath, packageConfig, base, conditions\n      ).resolved;\n    }\n  }\n\n  let packageJSONUrl =\n    new URL('./node_modules/' + packageName + '/package.json', base);\n  let packageJSONPath = fileURLToPath(packageJSONUrl);\n  let lastPath;\n  do {\n    const stat = tryStatSync(StringPrototypeSlice(packageJSONPath, 0,\n                                                  packageJSONPath.length - 13));\n    if (!stat.isDirectory()) {\n      lastPath = packageJSONPath;\n      packageJSONUrl = new URL((isScoped ?\n        '../../../../node_modules/' : '../../../node_modules/') +\n        packageName + '/package.json', packageJSONUrl);\n      packageJSONPath = fileURLToPath(packageJSONUrl);\n      continue;\n    }\n\n    // Package match.\n    const packageConfig = getPackageConfig(packageJSONPath, specifier, base);\n    if (packageConfig.exports !== undefined && packageConfig.exports !== null)\n      return packageExportsResolve(\n        packageJSONUrl, packageSubpath, packageConfig, base, conditions\n      ).resolved;\n    if (packageSubpath === '.')\n      return legacyMainResolve(packageJSONUrl, packageConfig, base);\n    return new URL(packageSubpath, packageJSONUrl);\n    // Cross-platform root check.\n  } while (packageJSONPath.length !== lastPath.length);\n\n  // eslint can't handle the above code.\n  // eslint-disable-next-line no-unreachable\n  throw new ERR_MODULE_NOT_FOUND(packageName, fileURLToPath(base));\n}\n\nfunction isBareSpecifier(specifier) {\n  return specifier[0] && specifier[0] !== '/' && specifier[0] !== '.';\n}\n\nfunction isRelativeSpecifier(specifier) {\n  if (specifier[0] === '.') {\n    if (specifier.length === 1 || specifier[1] === '/') return true;\n    if (specifier[1] === '.') {\n      if (specifier.length === 2 || specifier[2] === '/') return true;\n    }\n  }\n  return false;\n}\n\nfunction shouldBeTreatedAsRelativeOrAbsolutePath(specifier) {\n  if (specifier === '') return false;\n  if (specifier[0] === '/') return true;\n  return isRelativeSpecifier(specifier);\n}\n\n/**\n * @param {string} specifier\n * @param {URL} base\n * @param {Set<string>} conditions\n * @returns {URL}\n */\nfunction moduleResolve(specifier, base, conditions) {\n  // Order swapped from spec for minor perf gain.\n  // Ok since relative URLs cannot parse as URLs.\n  let resolved;\n  if (shouldBeTreatedAsRelativeOrAbsolutePath(specifier)) {\n    resolved = new URL(specifier, base);\n  } else if (specifier[0] === '#') {\n    ({ resolved } = packageImportsResolve(specifier, base, conditions));\n  } else {\n    try {\n      resolved = new URL(specifier);\n    } catch {\n      resolved = packageResolve(specifier, base, conditions);\n    }\n  }\n  return finalizeResolution(resolved, base);\n}\n\n/**\n * Try to resolve an import as a CommonJS module\n * @param {string} specifier\n * @param {string} parentURL\n * @returns {boolean|string}\n */\nfunction resolveAsCommonJS(specifier, parentURL) {\n  try {\n    const parent = fileURLToPath(parentURL);\n    const tmpModule = new CJSModule(parent, null);\n    tmpModule.paths = CJSModule._nodeModulePaths(parent);\n\n    let found = CJSModule._resolveFilename(specifier, tmpModule, false);\n\n    // If it is a relative specifier return the relative path\n    // to the parent\n    if (isRelativeSpecifier(specifier)) {\n      found = relative(parent, found);\n      // Add '.separator if the path does not start with '..separator'\n      // This should be a safe assumption because when loading\n      // esm modules there should be always a file specified so\n      // there should not be a specifier like '..' or '.'\n      if (!StringPrototypeStartsWith(found, `..${sep}`)) {\n        found = `.${sep}${found}`;\n      }\n    } else if (isBareSpecifier(specifier)) {\n      // If it is a bare specifier return the relative path within the\n      // module\n      const pkg = StringPrototypeSplit(specifier, '/')[0];\n      const index = StringPrototypeIndexOf(found, pkg);\n      if (index !== -1) {\n        found = StringPrototypeSlice(found, index);\n      }\n    }\n    // Normalize the path separator to give a valid suggestion\n    // on Windows\n    if (process.platform === 'win32') {\n      found = StringPrototypeReplace(found, new RegExp(`\\\\${sep}`, 'g'), '/');\n    }\n    return found;\n  } catch {\n    return false;\n  }\n}\n\nfunction defaultResolve(specifier, context = {}, defaultResolveUnused) {\n  let { parentURL, conditions } = context;\n  if (parentURL && policy != null && policy.manifest) {\n    const redirects = policy.manifest.getDependencyMapper(parentURL);\n    if (redirects) {\n      const { resolve, reaction } = redirects;\n      const destination = resolve(specifier, new SafeSet(conditions));\n      let missing = true;\n      if (destination === true) {\n        missing = false;\n      } else if (destination) {\n        const href = destination.href;\n        return { url: href };\n      }\n      if (missing) {\n        reaction(new ERR_MANIFEST_DEPENDENCY_MISSING(\n          parentURL,\n          specifier,\n          ArrayPrototypeJoin([...conditions], ', '))\n        );\n      }\n    }\n  }\n  let parsed;\n  try {\n    parsed = new URL(specifier);\n    if (parsed.protocol === 'data:') {\n      return {\n        url: specifier\n      };\n    }\n  } catch {}\n  if (parsed && parsed.protocol === builtinModuleProtocol)\n    return { url: specifier };\n  if (parsed && parsed.protocol !== 'file:' && parsed.protocol !== 'data:')\n    throw new ERR_UNSUPPORTED_ESM_URL_SCHEME(parsed);\n  if (NativeModule.canBeRequiredByUsers(specifier)) {\n    return {\n      url: builtinModuleProtocol + specifier\n    };\n  }\n  if (parentURL && StringPrototypeStartsWith(parentURL, 'data:')) {\n    // This is gonna blow up, we want the error\n    new URL(specifier, parentURL);\n  }\n\n  const isMain = parentURL === undefined;\n  if (isMain) {\n    parentURL = pathToFileURL(`${process.cwd()}/`).href;\n\n    // This is the initial entry point to the program, and --input-type has\n    // been passed as an option; but --input-type can only be used with\n    // --eval, --print or STDIN string input. It is not allowed with file\n    // input, to avoid user confusion over how expansive the effect of the\n    // flag should be (i.e. entry point only, package scope surrounding the\n    // entry point, etc.).\n    if (typeFlag)\n      throw new ERR_INPUT_TYPE_NOT_ALLOWED();\n  }\n\n  conditions = getConditionsSet(conditions);\n  let url;\n  try {\n    url = moduleResolve(specifier, parentURL, conditions);\n  } catch (error) {\n    // Try to give the user a hint of what would have been the\n    // resolved CommonJS module\n    if (error.code === 'ERR_MODULE_NOT_FOUND' ||\n        error.code === 'ERR_UNSUPPORTED_DIR_IMPORT') {\n      if (StringPrototypeStartsWith(specifier, 'file://')) {\n        specifier = fileURLToPath(specifier);\n      }\n      const found = resolveAsCommonJS(specifier, parentURL);\n      if (found) {\n        // Modify the stack and message string to include the hint\n        const lines = StringPrototypeSplit(error.stack, '\\n');\n        const hint = `Did you mean to import ${found}?`;\n        error.stack =\n          ArrayPrototypeShift(lines) + '\\n' +\n          hint + '\\n' +\n          ArrayPrototypeJoin(lines, '\\n');\n        error.message += `\\n${hint}`;\n      }\n    }\n    throw error;\n  }\n\n  if (isMain ? !preserveSymlinksMain : !preserveSymlinks) {\n    const urlPath = fileURLToPath(url);\n    const real = realpathSync(urlPath, {\n      // [internalFS.realpathCacheKey]: realpathCache\n    });\n    const old = url;\n    url = pathToFileURL(\n      real + (StringPrototypeEndsWith(urlPath, sep) ? '/' : ''));\n    url.search = old.search;\n    url.hash = old.hash;\n  }\n\n  return { url: `${url}` };\n}\n\nreturn {\n  DEFAULT_CONDITIONS,\n  defaultResolve,\n  encodedSepRegEx,\n  getPackageType,\n  packageExportsResolve,\n  packageImportsResolve\n};\n}\nmodule.exports = {\n  createResolve\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}