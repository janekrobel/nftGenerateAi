{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.classifyModule = void 0;\nconst node_internal_modules_cjs_loader_1 = require(\"../dist-raw/node-internal-modules-cjs-loader\");\n/**\n * Determine how to emit a module based on tsconfig \"module\" and package.json \"type\"\n *\n * Supports module=nodenext/node16 with transpileOnly, where we cannot ask the\n * TS typechecker to tell us if a file is CJS or ESM.\n *\n * Return values indicate:\n * - cjs\n * - esm\n * - nodecjs == node-flavored cjs where dynamic imports are *not* transformed into `require()`\n * - undefined == emit according to tsconfig `module` config, whatever that is\n * @internal\n */\nfunction classifyModule(nativeFilename, isNodeModuleType) {\n  // [MUST_UPDATE_FOR_NEW_FILE_EXTENSIONS]\n  const lastDotIndex = nativeFilename.lastIndexOf('.');\n  const ext = lastDotIndex >= 0 ? nativeFilename.slice(lastDotIndex) : '';\n  switch (ext) {\n    case '.cjs':\n    case '.cts':\n      return isNodeModuleType ? 'nodecjs' : 'cjs';\n    case '.mjs':\n    case '.mts':\n      return isNodeModuleType ? 'nodeesm' : 'esm';\n  }\n  if (isNodeModuleType) {\n    const packageScope = (0, node_internal_modules_cjs_loader_1.readPackageScope)(nativeFilename);\n    if (packageScope && packageScope.data.type === 'module') return 'nodeesm';\n    return 'nodecjs';\n  }\n  return undefined;\n}\nexports.classifyModule = classifyModule;","map":{"version":3,"mappings":";;;;;;AAAA;AAEA;;;;;;;;;;;;;AAaA,SAAgBA,cAAc,CAC5BC,cAAsB,EACtBC,gBAAyB;EAEzB;EACA,MAAMC,YAAY,GAAGF,cAAc,CAACG,WAAW,CAAC,GAAG,CAAC;EACpD,MAAMC,GAAG,GAAGF,YAAY,IAAI,CAAC,GAAGF,cAAc,CAACK,KAAK,CAACH,YAAY,CAAC,GAAG,EAAE;EACvE,QAAQE,GAAG;IACT,KAAK,MAAM;IACX,KAAK,MAAM;MACT,OAAOH,gBAAgB,GAAG,SAAS,GAAG,KAAK;IAC7C,KAAK,MAAM;IACX,KAAK,MAAM;MACT,OAAOA,gBAAgB,GAAG,SAAS,GAAG,KAAK;EAAC;EAEhD,IAAIA,gBAAgB,EAAE;IACpB,MAAMK,YAAY,GAAG,uDAAgB,EAACN,cAAc,CAAC;IACrD,IAAIM,YAAY,IAAIA,YAAY,CAACC,IAAI,CAACC,IAAI,KAAK,QAAQ,EAAE,OAAO,SAAS;IACzE,OAAO,SAAS;;EAElB,OAAOC,SAAS;AAClB;AArBAC","names":["classifyModule","nativeFilename","isNodeModuleType","lastDotIndex","lastIndexOf","ext","slice","packageScope","data","type","undefined","exports"],"sources":["/Users/janrobel/Documents/PersonalProjekty/nftGenerateAi/clientAndContract/node_modules/ts-node/src/node-module-type-classifier.ts"],"sourcesContent":["import { readPackageScope } from '../dist-raw/node-internal-modules-cjs-loader';\n\n/**\n * Determine how to emit a module based on tsconfig \"module\" and package.json \"type\"\n *\n * Supports module=nodenext/node16 with transpileOnly, where we cannot ask the\n * TS typechecker to tell us if a file is CJS or ESM.\n *\n * Return values indicate:\n * - cjs\n * - esm\n * - nodecjs == node-flavored cjs where dynamic imports are *not* transformed into `require()`\n * - undefined == emit according to tsconfig `module` config, whatever that is\n * @internal\n */\nexport function classifyModule(\n  nativeFilename: string,\n  isNodeModuleType: boolean\n): 'nodecjs' | 'cjs' | 'esm' | 'nodeesm' | undefined {\n  // [MUST_UPDATE_FOR_NEW_FILE_EXTENSIONS]\n  const lastDotIndex = nativeFilename.lastIndexOf('.');\n  const ext = lastDotIndex >= 0 ? nativeFilename.slice(lastDotIndex) : '';\n  switch (ext) {\n    case '.cjs':\n    case '.cts':\n      return isNodeModuleType ? 'nodecjs' : 'cjs';\n    case '.mjs':\n    case '.mts':\n      return isNodeModuleType ? 'nodeesm' : 'esm';\n  }\n  if (isNodeModuleType) {\n    const packageScope = readPackageScope(nativeFilename);\n    if (packageScope && packageScope.data.type === 'module') return 'nodeesm';\n    return 'nodecjs';\n  }\n  return undefined;\n}\n"]},"metadata":{},"sourceType":"script","externalDependencies":[]}