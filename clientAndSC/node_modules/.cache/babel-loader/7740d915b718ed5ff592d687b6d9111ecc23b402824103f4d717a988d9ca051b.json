{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Address = void 0;\nconst account_1 = require(\"./account\");\nconst bytes_1 = require(\"./bytes\");\nclass Address {\n  constructor(buf) {\n    if (buf.length !== 20) {\n      throw new Error('Invalid address length');\n    }\n    this.buf = buf;\n  }\n  /**\n   * Returns the zero address.\n   */\n  static zero() {\n    return new Address((0, bytes_1.zeros)(20));\n  }\n  /**\n   * Returns an Address object from a hex-encoded string.\n   * @param str - Hex-encoded address\n   */\n  static fromString(str) {\n    if (!(0, account_1.isValidAddress)(str)) {\n      throw new Error('Invalid address');\n    }\n    return new Address((0, bytes_1.toBuffer)(str));\n  }\n  /**\n   * Returns an address for a given public key.\n   * @param pubKey The two points of an uncompressed key\n   */\n  static fromPublicKey(pubKey) {\n    if (!Buffer.isBuffer(pubKey)) {\n      throw new Error('Public key should be Buffer');\n    }\n    const buf = (0, account_1.pubToAddress)(pubKey);\n    return new Address(buf);\n  }\n  /**\n   * Returns an address for a given private key.\n   * @param privateKey A private key must be 256 bits wide\n   */\n  static fromPrivateKey(privateKey) {\n    if (!Buffer.isBuffer(privateKey)) {\n      throw new Error('Private key should be Buffer');\n    }\n    const buf = (0, account_1.privateToAddress)(privateKey);\n    return new Address(buf);\n  }\n  /**\n   * Generates an address for a newly created contract.\n   * @param from The address which is creating this new address\n   * @param nonce The nonce of the from account\n   */\n  static generate(from, nonce) {\n    if (typeof nonce !== 'bigint') {\n      throw new Error('Expected nonce to be a bigint');\n    }\n    return new Address((0, account_1.generateAddress)(from.buf, (0, bytes_1.bigIntToBuffer)(nonce)));\n  }\n  /**\n   * Generates an address for a contract created using CREATE2.\n   * @param from The address which is creating this new address\n   * @param salt A salt\n   * @param initCode The init code of the contract being created\n   */\n  static generate2(from, salt, initCode) {\n    if (!Buffer.isBuffer(salt)) {\n      throw new Error('Expected salt to be a Buffer');\n    }\n    if (!Buffer.isBuffer(initCode)) {\n      throw new Error('Expected initCode to be a Buffer');\n    }\n    return new Address((0, account_1.generateAddress2)(from.buf, salt, initCode));\n  }\n  /**\n   * Is address equal to another.\n   */\n  equals(address) {\n    return this.buf.equals(address.buf);\n  }\n  /**\n   * Is address zero.\n   */\n  isZero() {\n    return this.equals(Address.zero());\n  }\n  /**\n   * True if address is in the address range defined\n   * by EIP-1352\n   */\n  isPrecompileOrSystemAddress() {\n    const address = (0, bytes_1.bufferToBigInt)(this.buf);\n    const rangeMin = BigInt(0);\n    const rangeMax = BigInt('0xffff');\n    return address >= rangeMin && address <= rangeMax;\n  }\n  /**\n   * Returns hex encoding of address.\n   */\n  toString() {\n    return '0x' + this.buf.toString('hex');\n  }\n  /**\n   * Returns Buffer representation of address.\n   */\n  toBuffer() {\n    return Buffer.from(this.buf);\n  }\n}\nexports.Address = Address;","map":{"version":3,"mappings":"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","names":["Address","constructor","buf","length","Error","zero","fromString","str","fromPublicKey","pubKey","Buffer","isBuffer","fromPrivateKey","privateKey","generate","from","nonce","generate2","salt","initCode","equals","address","isZero","isPrecompileOrSystemAddress","rangeMin","BigInt","rangeMax","toString","toBuffer","exports"],"sources":["/Users/janrobel/Documents/PersonalProjekty/nftGenerateAi/clientAndContract/node_modules/@nomicfoundation/ethereumjs-util/src/address.ts"],"sourcesContent":["import {\n  generateAddress,\n  generateAddress2,\n  isValidAddress,\n  privateToAddress,\n  pubToAddress,\n} from './account'\nimport { bigIntToBuffer, bufferToBigInt, toBuffer, zeros } from './bytes'\n\nexport class Address {\n  public readonly buf: Buffer\n\n  constructor(buf: Buffer) {\n    if (buf.length !== 20) {\n      throw new Error('Invalid address length')\n    }\n    this.buf = buf\n  }\n\n  /**\n   * Returns the zero address.\n   */\n  static zero(): Address {\n    return new Address(zeros(20))\n  }\n\n  /**\n   * Returns an Address object from a hex-encoded string.\n   * @param str - Hex-encoded address\n   */\n  static fromString(str: string): Address {\n    if (!isValidAddress(str)) {\n      throw new Error('Invalid address')\n    }\n    return new Address(toBuffer(str))\n  }\n\n  /**\n   * Returns an address for a given public key.\n   * @param pubKey The two points of an uncompressed key\n   */\n  static fromPublicKey(pubKey: Buffer): Address {\n    if (!Buffer.isBuffer(pubKey)) {\n      throw new Error('Public key should be Buffer')\n    }\n    const buf = pubToAddress(pubKey)\n    return new Address(buf)\n  }\n\n  /**\n   * Returns an address for a given private key.\n   * @param privateKey A private key must be 256 bits wide\n   */\n  static fromPrivateKey(privateKey: Buffer): Address {\n    if (!Buffer.isBuffer(privateKey)) {\n      throw new Error('Private key should be Buffer')\n    }\n    const buf = privateToAddress(privateKey)\n    return new Address(buf)\n  }\n\n  /**\n   * Generates an address for a newly created contract.\n   * @param from The address which is creating this new address\n   * @param nonce The nonce of the from account\n   */\n  static generate(from: Address, nonce: bigint): Address {\n    if (typeof nonce !== 'bigint') {\n      throw new Error('Expected nonce to be a bigint')\n    }\n    return new Address(generateAddress(from.buf, bigIntToBuffer(nonce)))\n  }\n\n  /**\n   * Generates an address for a contract created using CREATE2.\n   * @param from The address which is creating this new address\n   * @param salt A salt\n   * @param initCode The init code of the contract being created\n   */\n  static generate2(from: Address, salt: Buffer, initCode: Buffer): Address {\n    if (!Buffer.isBuffer(salt)) {\n      throw new Error('Expected salt to be a Buffer')\n    }\n    if (!Buffer.isBuffer(initCode)) {\n      throw new Error('Expected initCode to be a Buffer')\n    }\n    return new Address(generateAddress2(from.buf, salt, initCode))\n  }\n\n  /**\n   * Is address equal to another.\n   */\n  equals(address: Address): boolean {\n    return this.buf.equals(address.buf)\n  }\n\n  /**\n   * Is address zero.\n   */\n  isZero(): boolean {\n    return this.equals(Address.zero())\n  }\n\n  /**\n   * True if address is in the address range defined\n   * by EIP-1352\n   */\n  isPrecompileOrSystemAddress(): boolean {\n    const address = bufferToBigInt(this.buf)\n    const rangeMin = BigInt(0)\n    const rangeMax = BigInt('0xffff')\n    return address >= rangeMin && address <= rangeMax\n  }\n\n  /**\n   * Returns hex encoding of address.\n   */\n  toString(): string {\n    return '0x' + this.buf.toString('hex')\n  }\n\n  /**\n   * Returns Buffer representation of address.\n   */\n  toBuffer(): Buffer {\n    return Buffer.from(this.buf)\n  }\n}\n"]},"metadata":{},"sourceType":"script","externalDependencies":[]}