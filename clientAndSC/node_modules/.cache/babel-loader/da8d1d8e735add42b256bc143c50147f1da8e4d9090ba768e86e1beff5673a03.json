{"ast":null,"code":"'use strict';\n\nconst {\n  randomBytes,\n  createHash\n} = require('crypto');\nconst diagnosticsChannel = require('diagnostics_channel');\nconst {\n  uid,\n  states\n} = require('./constants');\nconst {\n  kReadyState,\n  kResponse,\n  kExtensions,\n  kProtocol,\n  kSentClose,\n  kByteParser,\n  kReceivedClose\n} = require('./symbols');\nconst {\n  fireEvent,\n  failWebsocketConnection\n} = require('./util');\nconst {\n  CloseEvent\n} = require('./events');\nconst {\n  ByteParser\n} = require('./receiver');\nconst {\n  makeRequest\n} = require('../fetch/request');\nconst {\n  fetching\n} = require('../fetch/index');\nconst {\n  getGlobalDispatcher\n} = require('../..');\nconst channels = {};\nchannels.open = diagnosticsChannel.channel('undici:websocket:open');\nchannels.close = diagnosticsChannel.channel('undici:websocket:close');\nchannels.socketError = diagnosticsChannel.channel('undici:websocket:socket_error');\n\n/**\n * @see https://websockets.spec.whatwg.org/#concept-websocket-establish\n * @param {URL} url\n * @param {string|string[]} protocols\n * @param {import('./websocket').WebSocket} ws\n */\nfunction establishWebSocketConnection(url, protocols, ws) {\n  // 1. Let requestURL be a copy of url, with its scheme set to \"http\", if url’s\n  //    scheme is \"ws\", and to \"https\" otherwise.\n  const requestURL = url;\n  requestURL.protocol = url.protocol === 'ws:' ? 'http:' : 'https:';\n\n  // 2. Let request be a new request, whose URL is requestURL, client is client,\n  //    service-workers mode is \"none\", referrer is \"no-referrer\", mode is\n  //    \"websocket\", credentials mode is \"include\", cache mode is \"no-store\" ,\n  //    and redirect mode is \"error\".\n  const request = makeRequest({\n    urlList: [requestURL],\n    serviceWorkers: 'none',\n    referrer: 'no-referrer',\n    mode: 'websocket',\n    credentials: 'include',\n    cache: 'no-store',\n    redirect: 'error'\n  });\n\n  // 3. Append (`Upgrade`, `websocket`) to request’s header list.\n  // 4. Append (`Connection`, `Upgrade`) to request’s header list.\n  // Note: both of these are handled by undici currently.\n  // https://github.com/nodejs/undici/blob/68c269c4144c446f3f1220951338daef4a6b5ec4/lib/client.js#L1397\n\n  // 5. Let keyValue be a nonce consisting of a randomly selected\n  //    16-byte value that has been forgiving-base64-encoded and\n  //    isomorphic encoded.\n  const keyValue = randomBytes(16).toString('base64');\n\n  // 6. Append (`Sec-WebSocket-Key`, keyValue) to request’s\n  //    header list.\n  request.headersList.append('sec-websocket-key', keyValue);\n\n  // 7. Append (`Sec-WebSocket-Version`, `13`) to request’s\n  //    header list.\n  request.headersList.append('sec-websocket-version', '13');\n\n  // 8. For each protocol in protocols, combine\n  //    (`Sec-WebSocket-Protocol`, protocol) in request’s header\n  //    list.\n  for (const protocol of protocols) {\n    request.headersList.append('sec-websocket-protocol', protocol);\n  }\n\n  // 9. Let permessageDeflate be a user-agent defined\n  //    \"permessage-deflate\" extension header value.\n  // https://github.com/mozilla/gecko-dev/blob/ce78234f5e653a5d3916813ff990f053510227bc/netwerk/protocol/websocket/WebSocketChannel.cpp#L2673\n  // TODO: enable once permessage-deflate is supported\n  const permessageDeflate = ''; // 'permessage-deflate; 15'\n\n  // 10. Append (`Sec-WebSocket-Extensions`, permessageDeflate) to\n  //     request’s header list.\n  // request.headersList.append('sec-websocket-extensions', permessageDeflate)\n\n  // 11. Fetch request with useParallelQueue set to true, and\n  //     processResponse given response being these steps:\n  const controller = fetching({\n    request,\n    useParallelQueue: true,\n    dispatcher: getGlobalDispatcher(),\n    processResponse(response) {\n      // 1. If response is a network error or its status is not 101,\n      //    fail the WebSocket connection.\n      if (response.type === 'error' || response.status !== 101) {\n        failWebsocketConnection(ws, 'Received network error or non-101 status code.');\n        return;\n      }\n\n      // 2. If protocols is not the empty list and extracting header\n      //    list values given `Sec-WebSocket-Protocol` and response’s\n      //    header list results in null, failure, or the empty byte\n      //    sequence, then fail the WebSocket connection.\n      if (protocols.length !== 0 && !response.headersList.get('Sec-WebSocket-Protocol')) {\n        failWebsocketConnection(ws, 'Server did not respond with sent protocols.');\n        return;\n      }\n\n      // 3. Follow the requirements stated step 2 to step 6, inclusive,\n      //    of the last set of steps in section 4.1 of The WebSocket\n      //    Protocol to validate response. This either results in fail\n      //    the WebSocket connection or the WebSocket connection is\n      //    established.\n\n      // 2. If the response lacks an |Upgrade| header field or the |Upgrade|\n      //    header field contains a value that is not an ASCII case-\n      //    insensitive match for the value \"websocket\", the client MUST\n      //    _Fail the WebSocket Connection_.\n      if (response.headersList.get('Upgrade')?.toLowerCase() !== 'websocket') {\n        failWebsocketConnection(ws, 'Server did not set Upgrade header to \"websocket\".');\n        return;\n      }\n\n      // 3. If the response lacks a |Connection| header field or the\n      //    |Connection| header field doesn't contain a token that is an\n      //    ASCII case-insensitive match for the value \"Upgrade\", the client\n      //    MUST _Fail the WebSocket Connection_.\n      if (response.headersList.get('Connection')?.toLowerCase() !== 'upgrade') {\n        failWebsocketConnection(ws, 'Server did not set Connection header to \"upgrade\".');\n        return;\n      }\n\n      // 4. If the response lacks a |Sec-WebSocket-Accept| header field or\n      //    the |Sec-WebSocket-Accept| contains a value other than the\n      //    base64-encoded SHA-1 of the concatenation of the |Sec-WebSocket-\n      //    Key| (as a string, not base64-decoded) with the string \"258EAFA5-\n      //    E914-47DA-95CA-C5AB0DC85B11\" but ignoring any leading and\n      //    trailing whitespace, the client MUST _Fail the WebSocket\n      //    Connection_.\n      const secWSAccept = response.headersList.get('Sec-WebSocket-Accept');\n      const digest = createHash('sha1').update(keyValue + uid).digest('base64');\n      if (secWSAccept !== digest) {\n        failWebsocketConnection(ws, 'Incorrect hash received in Sec-WebSocket-Accept header.');\n        return;\n      }\n\n      // 5. If the response includes a |Sec-WebSocket-Extensions| header\n      //    field and this header field indicates the use of an extension\n      //    that was not present in the client's handshake (the server has\n      //    indicated an extension not requested by the client), the client\n      //    MUST _Fail the WebSocket Connection_.  (The parsing of this\n      //    header field to determine which extensions are requested is\n      //    discussed in Section 9.1.)\n      const secExtension = response.headersList.get('Sec-WebSocket-Extensions');\n      if (secExtension !== null && secExtension !== permessageDeflate) {\n        failWebsocketConnection(ws, 'Received different permessage-deflate than the one set.');\n        return;\n      }\n\n      // 6. If the response includes a |Sec-WebSocket-Protocol| header field\n      //    and this header field indicates the use of a subprotocol that was\n      //    not present in the client's handshake (the server has indicated a\n      //    subprotocol not requested by the client), the client MUST _Fail\n      //    the WebSocket Connection_.\n      const secProtocol = response.headersList.get('Sec-WebSocket-Protocol');\n      if (secProtocol !== null && secProtocol !== request.headersList.get('Sec-WebSocket-Protocol')) {\n        failWebsocketConnection(ws, 'Protocol was not set in the opening handshake.');\n        return;\n      }\n\n      // processResponse is called when the \"response’s header list has been received and initialized.\"\n      // once this happens, the connection is open\n      ws[kResponse] = response;\n      const parser = new ByteParser(ws);\n      response.socket.ws = ws; // TODO: use symbol\n      ws[kByteParser] = parser;\n      whenConnectionEstablished(ws);\n      response.socket.on('data', onSocketData);\n      response.socket.on('close', onSocketClose);\n      response.socket.on('error', onSocketError);\n      parser.on('drain', onParserDrain);\n    }\n  });\n  return controller;\n}\n\n/**\n * @see https://websockets.spec.whatwg.org/#feedback-from-the-protocol\n * @param {import('./websocket').WebSocket} ws\n */\nfunction whenConnectionEstablished(ws) {\n  const {\n    [kResponse]: response\n  } = ws;\n\n  // 1. Change the ready state to OPEN (1).\n  ws[kReadyState] = states.OPEN;\n\n  // 2. Change the extensions attribute’s value to the extensions in use, if\n  //    it is not the null value.\n  // https://datatracker.ietf.org/doc/html/rfc6455#section-9.1\n  const extensions = response.headersList.get('sec-websocket-extensions');\n  if (extensions !== null) {\n    ws[kExtensions] = extensions;\n  }\n\n  // 3. Change the protocol attribute’s value to the subprotocol in use, if\n  //    it is not the null value.\n  // https://datatracker.ietf.org/doc/html/rfc6455#section-1.9\n  const protocol = response.headersList.get('sec-websocket-protocol');\n  if (protocol !== null) {\n    ws[kProtocol] = protocol;\n  }\n\n  // 4. Fire an event named open at the WebSocket object.\n  fireEvent('open', ws);\n  if (channels.open.hasSubscribers) {\n    channels.open.publish({\n      address: response.socket.address(),\n      protocol,\n      extensions\n    });\n  }\n}\n\n/**\n * @param {Buffer} chunk\n */\nfunction onSocketData(chunk) {\n  if (!this.ws[kByteParser].write(chunk)) {\n    this.pause();\n  }\n}\nfunction onParserDrain() {\n  this.ws[kResponse].socket.resume();\n}\n\n/**\n * @see https://websockets.spec.whatwg.org/#feedback-from-the-protocol\n * @see https://datatracker.ietf.org/doc/html/rfc6455#section-7.1.4\n */\nfunction onSocketClose() {\n  const {\n    ws\n  } = this;\n\n  // If the TCP connection was closed after the\n  // WebSocket closing handshake was completed, the WebSocket connection\n  // is said to have been closed _cleanly_.\n  const wasClean = ws[kSentClose] && ws[kReceivedClose];\n  let code = 1005;\n  let reason = '';\n  const result = ws[kByteParser].closingInfo;\n  if (result) {\n    code = result.code ?? 1005;\n    reason = result.reason;\n  } else if (!ws[kSentClose]) {\n    // If _The WebSocket\n    // Connection is Closed_ and no Close control frame was received by the\n    // endpoint (such as could occur if the underlying transport connection\n    // is lost), _The WebSocket Connection Close Code_ is considered to be\n    // 1006.\n    code = 1006;\n  }\n\n  // 1. Change the ready state to CLOSED (3).\n  ws[kReadyState] = states.CLOSED;\n\n  // 2. If the user agent was required to fail the WebSocket\n  //    connection, or if the WebSocket connection was closed\n  //    after being flagged as full, fire an event named error\n  //    at the WebSocket object.\n  // TODO\n\n  // 3. Fire an event named close at the WebSocket object,\n  //    using CloseEvent, with the wasClean attribute\n  //    initialized to true if the connection closed cleanly\n  //    and false otherwise, the code attribute initialized to\n  //    the WebSocket connection close code, and the reason\n  //    attribute initialized to the result of applying UTF-8\n  //    decode without BOM to the WebSocket connection close\n  //    reason.\n  fireEvent('close', ws, CloseEvent, {\n    wasClean,\n    code,\n    reason\n  });\n  if (channels.close.hasSubscribers) {\n    channels.close.publish({\n      websocket: ws,\n      code,\n      reason\n    });\n  }\n}\nfunction onSocketError(error) {\n  const {\n    ws\n  } = this;\n  ws[kReadyState] = states.CLOSING;\n  if (channels.socketError.hasSubscribers) {\n    channels.socketError.publish(error);\n  }\n  this.destroy();\n}\nmodule.exports = {\n  establishWebSocketConnection\n};","map":{"version":3,"names":["randomBytes","createHash","require","diagnosticsChannel","uid","states","kReadyState","kResponse","kExtensions","kProtocol","kSentClose","kByteParser","kReceivedClose","fireEvent","failWebsocketConnection","CloseEvent","ByteParser","makeRequest","fetching","getGlobalDispatcher","channels","open","channel","close","socketError","establishWebSocketConnection","url","protocols","ws","requestURL","protocol","request","urlList","serviceWorkers","referrer","mode","credentials","cache","redirect","keyValue","toString","headersList","append","permessageDeflate","controller","useParallelQueue","dispatcher","processResponse","response","type","status","length","get","toLowerCase","secWSAccept","digest","update","secExtension","secProtocol","parser","socket","whenConnectionEstablished","on","onSocketData","onSocketClose","onSocketError","onParserDrain","OPEN","extensions","hasSubscribers","publish","address","chunk","write","pause","resume","wasClean","code","reason","result","closingInfo","CLOSED","websocket","error","CLOSING","destroy","module","exports"],"sources":["/Users/janrobel/Documents/PersonalProjekty/nftGenerateAi/clientAndContract/node_modules/undici/lib/websocket/connection.js"],"sourcesContent":["'use strict'\n\nconst { randomBytes, createHash } = require('crypto')\nconst diagnosticsChannel = require('diagnostics_channel')\nconst { uid, states } = require('./constants')\nconst {\n  kReadyState,\n  kResponse,\n  kExtensions,\n  kProtocol,\n  kSentClose,\n  kByteParser,\n  kReceivedClose\n} = require('./symbols')\nconst { fireEvent, failWebsocketConnection } = require('./util')\nconst { CloseEvent } = require('./events')\nconst { ByteParser } = require('./receiver')\nconst { makeRequest } = require('../fetch/request')\nconst { fetching } = require('../fetch/index')\nconst { getGlobalDispatcher } = require('../..')\n\nconst channels = {}\nchannels.open = diagnosticsChannel.channel('undici:websocket:open')\nchannels.close = diagnosticsChannel.channel('undici:websocket:close')\nchannels.socketError = diagnosticsChannel.channel('undici:websocket:socket_error')\n\n/**\n * @see https://websockets.spec.whatwg.org/#concept-websocket-establish\n * @param {URL} url\n * @param {string|string[]} protocols\n * @param {import('./websocket').WebSocket} ws\n */\nfunction establishWebSocketConnection (url, protocols, ws) {\n  // 1. Let requestURL be a copy of url, with its scheme set to \"http\", if url’s\n  //    scheme is \"ws\", and to \"https\" otherwise.\n  const requestURL = url\n\n  requestURL.protocol = url.protocol === 'ws:' ? 'http:' : 'https:'\n\n  // 2. Let request be a new request, whose URL is requestURL, client is client,\n  //    service-workers mode is \"none\", referrer is \"no-referrer\", mode is\n  //    \"websocket\", credentials mode is \"include\", cache mode is \"no-store\" ,\n  //    and redirect mode is \"error\".\n  const request = makeRequest({\n    urlList: [requestURL],\n    serviceWorkers: 'none',\n    referrer: 'no-referrer',\n    mode: 'websocket',\n    credentials: 'include',\n    cache: 'no-store',\n    redirect: 'error'\n  })\n\n  // 3. Append (`Upgrade`, `websocket`) to request’s header list.\n  // 4. Append (`Connection`, `Upgrade`) to request’s header list.\n  // Note: both of these are handled by undici currently.\n  // https://github.com/nodejs/undici/blob/68c269c4144c446f3f1220951338daef4a6b5ec4/lib/client.js#L1397\n\n  // 5. Let keyValue be a nonce consisting of a randomly selected\n  //    16-byte value that has been forgiving-base64-encoded and\n  //    isomorphic encoded.\n  const keyValue = randomBytes(16).toString('base64')\n\n  // 6. Append (`Sec-WebSocket-Key`, keyValue) to request’s\n  //    header list.\n  request.headersList.append('sec-websocket-key', keyValue)\n\n  // 7. Append (`Sec-WebSocket-Version`, `13`) to request’s\n  //    header list.\n  request.headersList.append('sec-websocket-version', '13')\n\n  // 8. For each protocol in protocols, combine\n  //    (`Sec-WebSocket-Protocol`, protocol) in request’s header\n  //    list.\n  for (const protocol of protocols) {\n    request.headersList.append('sec-websocket-protocol', protocol)\n  }\n\n  // 9. Let permessageDeflate be a user-agent defined\n  //    \"permessage-deflate\" extension header value.\n  // https://github.com/mozilla/gecko-dev/blob/ce78234f5e653a5d3916813ff990f053510227bc/netwerk/protocol/websocket/WebSocketChannel.cpp#L2673\n  // TODO: enable once permessage-deflate is supported\n  const permessageDeflate = '' // 'permessage-deflate; 15'\n\n  // 10. Append (`Sec-WebSocket-Extensions`, permessageDeflate) to\n  //     request’s header list.\n  // request.headersList.append('sec-websocket-extensions', permessageDeflate)\n\n  // 11. Fetch request with useParallelQueue set to true, and\n  //     processResponse given response being these steps:\n  const controller = fetching({\n    request,\n    useParallelQueue: true,\n    dispatcher: getGlobalDispatcher(),\n    processResponse (response) {\n      // 1. If response is a network error or its status is not 101,\n      //    fail the WebSocket connection.\n      if (response.type === 'error' || response.status !== 101) {\n        failWebsocketConnection(ws, 'Received network error or non-101 status code.')\n        return\n      }\n\n      // 2. If protocols is not the empty list and extracting header\n      //    list values given `Sec-WebSocket-Protocol` and response’s\n      //    header list results in null, failure, or the empty byte\n      //    sequence, then fail the WebSocket connection.\n      if (protocols.length !== 0 && !response.headersList.get('Sec-WebSocket-Protocol')) {\n        failWebsocketConnection(ws, 'Server did not respond with sent protocols.')\n        return\n      }\n\n      // 3. Follow the requirements stated step 2 to step 6, inclusive,\n      //    of the last set of steps in section 4.1 of The WebSocket\n      //    Protocol to validate response. This either results in fail\n      //    the WebSocket connection or the WebSocket connection is\n      //    established.\n\n      // 2. If the response lacks an |Upgrade| header field or the |Upgrade|\n      //    header field contains a value that is not an ASCII case-\n      //    insensitive match for the value \"websocket\", the client MUST\n      //    _Fail the WebSocket Connection_.\n      if (response.headersList.get('Upgrade')?.toLowerCase() !== 'websocket') {\n        failWebsocketConnection(ws, 'Server did not set Upgrade header to \"websocket\".')\n        return\n      }\n\n      // 3. If the response lacks a |Connection| header field or the\n      //    |Connection| header field doesn't contain a token that is an\n      //    ASCII case-insensitive match for the value \"Upgrade\", the client\n      //    MUST _Fail the WebSocket Connection_.\n      if (response.headersList.get('Connection')?.toLowerCase() !== 'upgrade') {\n        failWebsocketConnection(ws, 'Server did not set Connection header to \"upgrade\".')\n        return\n      }\n\n      // 4. If the response lacks a |Sec-WebSocket-Accept| header field or\n      //    the |Sec-WebSocket-Accept| contains a value other than the\n      //    base64-encoded SHA-1 of the concatenation of the |Sec-WebSocket-\n      //    Key| (as a string, not base64-decoded) with the string \"258EAFA5-\n      //    E914-47DA-95CA-C5AB0DC85B11\" but ignoring any leading and\n      //    trailing whitespace, the client MUST _Fail the WebSocket\n      //    Connection_.\n      const secWSAccept = response.headersList.get('Sec-WebSocket-Accept')\n      const digest = createHash('sha1').update(keyValue + uid).digest('base64')\n      if (secWSAccept !== digest) {\n        failWebsocketConnection(ws, 'Incorrect hash received in Sec-WebSocket-Accept header.')\n        return\n      }\n\n      // 5. If the response includes a |Sec-WebSocket-Extensions| header\n      //    field and this header field indicates the use of an extension\n      //    that was not present in the client's handshake (the server has\n      //    indicated an extension not requested by the client), the client\n      //    MUST _Fail the WebSocket Connection_.  (The parsing of this\n      //    header field to determine which extensions are requested is\n      //    discussed in Section 9.1.)\n      const secExtension = response.headersList.get('Sec-WebSocket-Extensions')\n\n      if (secExtension !== null && secExtension !== permessageDeflate) {\n        failWebsocketConnection(ws, 'Received different permessage-deflate than the one set.')\n        return\n      }\n\n      // 6. If the response includes a |Sec-WebSocket-Protocol| header field\n      //    and this header field indicates the use of a subprotocol that was\n      //    not present in the client's handshake (the server has indicated a\n      //    subprotocol not requested by the client), the client MUST _Fail\n      //    the WebSocket Connection_.\n      const secProtocol = response.headersList.get('Sec-WebSocket-Protocol')\n\n      if (secProtocol !== null && secProtocol !== request.headersList.get('Sec-WebSocket-Protocol')) {\n        failWebsocketConnection(ws, 'Protocol was not set in the opening handshake.')\n        return\n      }\n\n      // processResponse is called when the \"response’s header list has been received and initialized.\"\n      // once this happens, the connection is open\n      ws[kResponse] = response\n\n      const parser = new ByteParser(ws)\n      response.socket.ws = ws // TODO: use symbol\n      ws[kByteParser] = parser\n\n      whenConnectionEstablished(ws)\n\n      response.socket.on('data', onSocketData)\n      response.socket.on('close', onSocketClose)\n      response.socket.on('error', onSocketError)\n\n      parser.on('drain', onParserDrain)\n    }\n  })\n\n  return controller\n}\n\n/**\n * @see https://websockets.spec.whatwg.org/#feedback-from-the-protocol\n * @param {import('./websocket').WebSocket} ws\n */\nfunction whenConnectionEstablished (ws) {\n  const { [kResponse]: response } = ws\n\n  // 1. Change the ready state to OPEN (1).\n  ws[kReadyState] = states.OPEN\n\n  // 2. Change the extensions attribute’s value to the extensions in use, if\n  //    it is not the null value.\n  // https://datatracker.ietf.org/doc/html/rfc6455#section-9.1\n  const extensions = response.headersList.get('sec-websocket-extensions')\n\n  if (extensions !== null) {\n    ws[kExtensions] = extensions\n  }\n\n  // 3. Change the protocol attribute’s value to the subprotocol in use, if\n  //    it is not the null value.\n  // https://datatracker.ietf.org/doc/html/rfc6455#section-1.9\n  const protocol = response.headersList.get('sec-websocket-protocol')\n\n  if (protocol !== null) {\n    ws[kProtocol] = protocol\n  }\n\n  // 4. Fire an event named open at the WebSocket object.\n  fireEvent('open', ws)\n\n  if (channels.open.hasSubscribers) {\n    channels.open.publish({\n      address: response.socket.address(),\n      protocol,\n      extensions\n    })\n  }\n}\n\n/**\n * @param {Buffer} chunk\n */\nfunction onSocketData (chunk) {\n  if (!this.ws[kByteParser].write(chunk)) {\n    this.pause()\n  }\n}\n\nfunction onParserDrain () {\n  this.ws[kResponse].socket.resume()\n}\n\n/**\n * @see https://websockets.spec.whatwg.org/#feedback-from-the-protocol\n * @see https://datatracker.ietf.org/doc/html/rfc6455#section-7.1.4\n */\nfunction onSocketClose () {\n  const { ws } = this\n\n  // If the TCP connection was closed after the\n  // WebSocket closing handshake was completed, the WebSocket connection\n  // is said to have been closed _cleanly_.\n  const wasClean = ws[kSentClose] && ws[kReceivedClose]\n\n  let code = 1005\n  let reason = ''\n\n  const result = ws[kByteParser].closingInfo\n\n  if (result) {\n    code = result.code ?? 1005\n    reason = result.reason\n  } else if (!ws[kSentClose]) {\n    // If _The WebSocket\n    // Connection is Closed_ and no Close control frame was received by the\n    // endpoint (such as could occur if the underlying transport connection\n    // is lost), _The WebSocket Connection Close Code_ is considered to be\n    // 1006.\n    code = 1006\n  }\n\n  // 1. Change the ready state to CLOSED (3).\n  ws[kReadyState] = states.CLOSED\n\n  // 2. If the user agent was required to fail the WebSocket\n  //    connection, or if the WebSocket connection was closed\n  //    after being flagged as full, fire an event named error\n  //    at the WebSocket object.\n  // TODO\n\n  // 3. Fire an event named close at the WebSocket object,\n  //    using CloseEvent, with the wasClean attribute\n  //    initialized to true if the connection closed cleanly\n  //    and false otherwise, the code attribute initialized to\n  //    the WebSocket connection close code, and the reason\n  //    attribute initialized to the result of applying UTF-8\n  //    decode without BOM to the WebSocket connection close\n  //    reason.\n  fireEvent('close', ws, CloseEvent, {\n    wasClean, code, reason\n  })\n\n  if (channels.close.hasSubscribers) {\n    channels.close.publish({\n      websocket: ws,\n      code,\n      reason\n    })\n  }\n}\n\nfunction onSocketError (error) {\n  const { ws } = this\n\n  ws[kReadyState] = states.CLOSING\n\n  if (channels.socketError.hasSubscribers) {\n    channels.socketError.publish(error)\n  }\n\n  this.destroy()\n}\n\nmodule.exports = {\n  establishWebSocketConnection\n}\n"],"mappings":"AAAA,YAAY;;AAEZ,MAAM;EAAEA,WAAW;EAAEC;AAAW,CAAC,GAAGC,OAAO,CAAC,QAAQ,CAAC;AACrD,MAAMC,kBAAkB,GAAGD,OAAO,CAAC,qBAAqB,CAAC;AACzD,MAAM;EAAEE,GAAG;EAAEC;AAAO,CAAC,GAAGH,OAAO,CAAC,aAAa,CAAC;AAC9C,MAAM;EACJI,WAAW;EACXC,SAAS;EACTC,WAAW;EACXC,SAAS;EACTC,UAAU;EACVC,WAAW;EACXC;AACF,CAAC,GAAGV,OAAO,CAAC,WAAW,CAAC;AACxB,MAAM;EAAEW,SAAS;EAAEC;AAAwB,CAAC,GAAGZ,OAAO,CAAC,QAAQ,CAAC;AAChE,MAAM;EAAEa;AAAW,CAAC,GAAGb,OAAO,CAAC,UAAU,CAAC;AAC1C,MAAM;EAAEc;AAAW,CAAC,GAAGd,OAAO,CAAC,YAAY,CAAC;AAC5C,MAAM;EAAEe;AAAY,CAAC,GAAGf,OAAO,CAAC,kBAAkB,CAAC;AACnD,MAAM;EAAEgB;AAAS,CAAC,GAAGhB,OAAO,CAAC,gBAAgB,CAAC;AAC9C,MAAM;EAAEiB;AAAoB,CAAC,GAAGjB,OAAO,CAAC,OAAO,CAAC;AAEhD,MAAMkB,QAAQ,GAAG,CAAC,CAAC;AACnBA,QAAQ,CAACC,IAAI,GAAGlB,kBAAkB,CAACmB,OAAO,CAAC,uBAAuB,CAAC;AACnEF,QAAQ,CAACG,KAAK,GAAGpB,kBAAkB,CAACmB,OAAO,CAAC,wBAAwB,CAAC;AACrEF,QAAQ,CAACI,WAAW,GAAGrB,kBAAkB,CAACmB,OAAO,CAAC,+BAA+B,CAAC;;AAElF;AACA;AACA;AACA;AACA;AACA;AACA,SAASG,4BAA4B,CAAEC,GAAG,EAAEC,SAAS,EAAEC,EAAE,EAAE;EACzD;EACA;EACA,MAAMC,UAAU,GAAGH,GAAG;EAEtBG,UAAU,CAACC,QAAQ,GAAGJ,GAAG,CAACI,QAAQ,KAAK,KAAK,GAAG,OAAO,GAAG,QAAQ;;EAEjE;EACA;EACA;EACA;EACA,MAAMC,OAAO,GAAGd,WAAW,CAAC;IAC1Be,OAAO,EAAE,CAACH,UAAU,CAAC;IACrBI,cAAc,EAAE,MAAM;IACtBC,QAAQ,EAAE,aAAa;IACvBC,IAAI,EAAE,WAAW;IACjBC,WAAW,EAAE,SAAS;IACtBC,KAAK,EAAE,UAAU;IACjBC,QAAQ,EAAE;EACZ,CAAC,CAAC;;EAEF;EACA;EACA;EACA;;EAEA;EACA;EACA;EACA,MAAMC,QAAQ,GAAGvC,WAAW,CAAC,EAAE,CAAC,CAACwC,QAAQ,CAAC,QAAQ,CAAC;;EAEnD;EACA;EACAT,OAAO,CAACU,WAAW,CAACC,MAAM,CAAC,mBAAmB,EAAEH,QAAQ,CAAC;;EAEzD;EACA;EACAR,OAAO,CAACU,WAAW,CAACC,MAAM,CAAC,uBAAuB,EAAE,IAAI,CAAC;;EAEzD;EACA;EACA;EACA,KAAK,MAAMZ,QAAQ,IAAIH,SAAS,EAAE;IAChCI,OAAO,CAACU,WAAW,CAACC,MAAM,CAAC,wBAAwB,EAAEZ,QAAQ,CAAC;EAChE;;EAEA;EACA;EACA;EACA;EACA,MAAMa,iBAAiB,GAAG,EAAE,EAAC;;EAE7B;EACA;EACA;;EAEA;EACA;EACA,MAAMC,UAAU,GAAG1B,QAAQ,CAAC;IAC1Ba,OAAO;IACPc,gBAAgB,EAAE,IAAI;IACtBC,UAAU,EAAE3B,mBAAmB,EAAE;IACjC4B,eAAe,CAAEC,QAAQ,EAAE;MACzB;MACA;MACA,IAAIA,QAAQ,CAACC,IAAI,KAAK,OAAO,IAAID,QAAQ,CAACE,MAAM,KAAK,GAAG,EAAE;QACxDpC,uBAAuB,CAACc,EAAE,EAAE,gDAAgD,CAAC;QAC7E;MACF;;MAEA;MACA;MACA;MACA;MACA,IAAID,SAAS,CAACwB,MAAM,KAAK,CAAC,IAAI,CAACH,QAAQ,CAACP,WAAW,CAACW,GAAG,CAAC,wBAAwB,CAAC,EAAE;QACjFtC,uBAAuB,CAACc,EAAE,EAAE,6CAA6C,CAAC;QAC1E;MACF;;MAEA;MACA;MACA;MACA;MACA;;MAEA;MACA;MACA;MACA;MACA,IAAIoB,QAAQ,CAACP,WAAW,CAACW,GAAG,CAAC,SAAS,CAAC,EAAEC,WAAW,EAAE,KAAK,WAAW,EAAE;QACtEvC,uBAAuB,CAACc,EAAE,EAAE,mDAAmD,CAAC;QAChF;MACF;;MAEA;MACA;MACA;MACA;MACA,IAAIoB,QAAQ,CAACP,WAAW,CAACW,GAAG,CAAC,YAAY,CAAC,EAAEC,WAAW,EAAE,KAAK,SAAS,EAAE;QACvEvC,uBAAuB,CAACc,EAAE,EAAE,oDAAoD,CAAC;QACjF;MACF;;MAEA;MACA;MACA;MACA;MACA;MACA;MACA;MACA,MAAM0B,WAAW,GAAGN,QAAQ,CAACP,WAAW,CAACW,GAAG,CAAC,sBAAsB,CAAC;MACpE,MAAMG,MAAM,GAAGtD,UAAU,CAAC,MAAM,CAAC,CAACuD,MAAM,CAACjB,QAAQ,GAAGnC,GAAG,CAAC,CAACmD,MAAM,CAAC,QAAQ,CAAC;MACzE,IAAID,WAAW,KAAKC,MAAM,EAAE;QAC1BzC,uBAAuB,CAACc,EAAE,EAAE,yDAAyD,CAAC;QACtF;MACF;;MAEA;MACA;MACA;MACA;MACA;MACA;MACA;MACA,MAAM6B,YAAY,GAAGT,QAAQ,CAACP,WAAW,CAACW,GAAG,CAAC,0BAA0B,CAAC;MAEzE,IAAIK,YAAY,KAAK,IAAI,IAAIA,YAAY,KAAKd,iBAAiB,EAAE;QAC/D7B,uBAAuB,CAACc,EAAE,EAAE,yDAAyD,CAAC;QACtF;MACF;;MAEA;MACA;MACA;MACA;MACA;MACA,MAAM8B,WAAW,GAAGV,QAAQ,CAACP,WAAW,CAACW,GAAG,CAAC,wBAAwB,CAAC;MAEtE,IAAIM,WAAW,KAAK,IAAI,IAAIA,WAAW,KAAK3B,OAAO,CAACU,WAAW,CAACW,GAAG,CAAC,wBAAwB,CAAC,EAAE;QAC7FtC,uBAAuB,CAACc,EAAE,EAAE,gDAAgD,CAAC;QAC7E;MACF;;MAEA;MACA;MACAA,EAAE,CAACrB,SAAS,CAAC,GAAGyC,QAAQ;MAExB,MAAMW,MAAM,GAAG,IAAI3C,UAAU,CAACY,EAAE,CAAC;MACjCoB,QAAQ,CAACY,MAAM,CAAChC,EAAE,GAAGA,EAAE,EAAC;MACxBA,EAAE,CAACjB,WAAW,CAAC,GAAGgD,MAAM;MAExBE,yBAAyB,CAACjC,EAAE,CAAC;MAE7BoB,QAAQ,CAACY,MAAM,CAACE,EAAE,CAAC,MAAM,EAAEC,YAAY,CAAC;MACxCf,QAAQ,CAACY,MAAM,CAACE,EAAE,CAAC,OAAO,EAAEE,aAAa,CAAC;MAC1ChB,QAAQ,CAACY,MAAM,CAACE,EAAE,CAAC,OAAO,EAAEG,aAAa,CAAC;MAE1CN,MAAM,CAACG,EAAE,CAAC,OAAO,EAAEI,aAAa,CAAC;IACnC;EACF,CAAC,CAAC;EAEF,OAAOtB,UAAU;AACnB;;AAEA;AACA;AACA;AACA;AACA,SAASiB,yBAAyB,CAAEjC,EAAE,EAAE;EACtC,MAAM;IAAE,CAACrB,SAAS,GAAGyC;EAAS,CAAC,GAAGpB,EAAE;;EAEpC;EACAA,EAAE,CAACtB,WAAW,CAAC,GAAGD,MAAM,CAAC8D,IAAI;;EAE7B;EACA;EACA;EACA,MAAMC,UAAU,GAAGpB,QAAQ,CAACP,WAAW,CAACW,GAAG,CAAC,0BAA0B,CAAC;EAEvE,IAAIgB,UAAU,KAAK,IAAI,EAAE;IACvBxC,EAAE,CAACpB,WAAW,CAAC,GAAG4D,UAAU;EAC9B;;EAEA;EACA;EACA;EACA,MAAMtC,QAAQ,GAAGkB,QAAQ,CAACP,WAAW,CAACW,GAAG,CAAC,wBAAwB,CAAC;EAEnE,IAAItB,QAAQ,KAAK,IAAI,EAAE;IACrBF,EAAE,CAACnB,SAAS,CAAC,GAAGqB,QAAQ;EAC1B;;EAEA;EACAjB,SAAS,CAAC,MAAM,EAAEe,EAAE,CAAC;EAErB,IAAIR,QAAQ,CAACC,IAAI,CAACgD,cAAc,EAAE;IAChCjD,QAAQ,CAACC,IAAI,CAACiD,OAAO,CAAC;MACpBC,OAAO,EAAEvB,QAAQ,CAACY,MAAM,CAACW,OAAO,EAAE;MAClCzC,QAAQ;MACRsC;IACF,CAAC,CAAC;EACJ;AACF;;AAEA;AACA;AACA;AACA,SAASL,YAAY,CAAES,KAAK,EAAE;EAC5B,IAAI,CAAC,IAAI,CAAC5C,EAAE,CAACjB,WAAW,CAAC,CAAC8D,KAAK,CAACD,KAAK,CAAC,EAAE;IACtC,IAAI,CAACE,KAAK,EAAE;EACd;AACF;AAEA,SAASR,aAAa,GAAI;EACxB,IAAI,CAACtC,EAAE,CAACrB,SAAS,CAAC,CAACqD,MAAM,CAACe,MAAM,EAAE;AACpC;;AAEA;AACA;AACA;AACA;AACA,SAASX,aAAa,GAAI;EACxB,MAAM;IAAEpC;EAAG,CAAC,GAAG,IAAI;;EAEnB;EACA;EACA;EACA,MAAMgD,QAAQ,GAAGhD,EAAE,CAAClB,UAAU,CAAC,IAAIkB,EAAE,CAAChB,cAAc,CAAC;EAErD,IAAIiE,IAAI,GAAG,IAAI;EACf,IAAIC,MAAM,GAAG,EAAE;EAEf,MAAMC,MAAM,GAAGnD,EAAE,CAACjB,WAAW,CAAC,CAACqE,WAAW;EAE1C,IAAID,MAAM,EAAE;IACVF,IAAI,GAAGE,MAAM,CAACF,IAAI,IAAI,IAAI;IAC1BC,MAAM,GAAGC,MAAM,CAACD,MAAM;EACxB,CAAC,MAAM,IAAI,CAAClD,EAAE,CAAClB,UAAU,CAAC,EAAE;IAC1B;IACA;IACA;IACA;IACA;IACAmE,IAAI,GAAG,IAAI;EACb;;EAEA;EACAjD,EAAE,CAACtB,WAAW,CAAC,GAAGD,MAAM,CAAC4E,MAAM;;EAE/B;EACA;EACA;EACA;EACA;;EAEA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACApE,SAAS,CAAC,OAAO,EAAEe,EAAE,EAAEb,UAAU,EAAE;IACjC6D,QAAQ;IAAEC,IAAI;IAAEC;EAClB,CAAC,CAAC;EAEF,IAAI1D,QAAQ,CAACG,KAAK,CAAC8C,cAAc,EAAE;IACjCjD,QAAQ,CAACG,KAAK,CAAC+C,OAAO,CAAC;MACrBY,SAAS,EAAEtD,EAAE;MACbiD,IAAI;MACJC;IACF,CAAC,CAAC;EACJ;AACF;AAEA,SAASb,aAAa,CAAEkB,KAAK,EAAE;EAC7B,MAAM;IAAEvD;EAAG,CAAC,GAAG,IAAI;EAEnBA,EAAE,CAACtB,WAAW,CAAC,GAAGD,MAAM,CAAC+E,OAAO;EAEhC,IAAIhE,QAAQ,CAACI,WAAW,CAAC6C,cAAc,EAAE;IACvCjD,QAAQ,CAACI,WAAW,CAAC8C,OAAO,CAACa,KAAK,CAAC;EACrC;EAEA,IAAI,CAACE,OAAO,EAAE;AAChB;AAEAC,MAAM,CAACC,OAAO,GAAG;EACf9D;AACF,CAAC"},"metadata":{},"sourceType":"script","externalDependencies":[]}