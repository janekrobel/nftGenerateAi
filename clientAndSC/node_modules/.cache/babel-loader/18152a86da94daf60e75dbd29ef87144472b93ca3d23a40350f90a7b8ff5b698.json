{"ast":null,"code":"\"use strict\";\n\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  Object.defineProperty(o, k2, {\n    enumerable: true,\n    get: function () {\n      return m[k];\n    }\n  });\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, \"default\", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o[\"default\"] = v;\n});\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n  __setModuleDefault(result, mod);\n  return result;\n};\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.download = void 0;\nconst fs_1 = __importDefault(require(\"fs\"));\nconst fs_extra_1 = __importDefault(require(\"fs-extra\"));\nconst path_1 = __importDefault(require(\"path\"));\nconst util_1 = __importDefault(require(\"util\"));\nconst packageInfo_1 = require(\"./packageInfo\");\nconst proxy_1 = require(\"./proxy\");\nconst TEMP_FILE_PREFIX = \"tmp-\";\nfunction resolveTempFileName(filePath) {\n  const {\n    dir,\n    ext,\n    name\n  } = path_1.default.parse(filePath);\n  return path_1.default.format({\n    dir,\n    ext,\n    name: `${TEMP_FILE_PREFIX}${name}`\n  });\n}\nasync function download(url, filePath) {\n  let timeoutMillis = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 10000;\n  let extraHeaders = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n  const {\n    pipeline\n  } = await Promise.resolve().then(() => __importStar(require(\"stream\")));\n  const {\n    getGlobalDispatcher,\n    ProxyAgent,\n    request\n  } = await Promise.resolve().then(() => __importStar(require(\"undici\")));\n  const streamPipeline = util_1.default.promisify(pipeline);\n  let dispatcher;\n  if (process.env.http_proxy !== undefined && (0, proxy_1.shouldUseProxy)(url)) {\n    dispatcher = new ProxyAgent(process.env.http_proxy);\n  } else {\n    dispatcher = getGlobalDispatcher();\n  }\n  const hardhatVersion = (0, packageInfo_1.getHardhatVersion)();\n  // Fetch the url\n  const response = await request(url, {\n    dispatcher,\n    headersTimeout: timeoutMillis,\n    maxRedirections: 10,\n    method: \"GET\",\n    headers: {\n      ...extraHeaders,\n      \"User-Agent\": `hardhat ${hardhatVersion}`\n    }\n  });\n  if (response.statusCode >= 200 && response.statusCode <= 299) {\n    const tmpFilePath = resolveTempFileName(filePath);\n    await fs_extra_1.default.ensureDir(path_1.default.dirname(filePath));\n    await streamPipeline(response.body, fs_1.default.createWriteStream(tmpFilePath));\n    return fs_extra_1.default.move(tmpFilePath, filePath, {\n      overwrite: true\n    });\n  } else {\n    // undici's response bodies must always be consumed to prevent leaks\n    await response.body.text();\n  }\n  // eslint-disable-next-line @nomiclabs/hardhat-internal-rules/only-hardhat-error\n  throw new Error(`Failed to download ${url} - ${response.statusCode} received. ${await response.body.text()}`);\n}\nexports.download = download;","map":{"version":3,"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA,MAAMA,gBAAgB,GAAG,MAAM;AAE/B,SAASC,mBAAmB,CAACC,QAAgB;EAC3C,MAAM;IAAEC,GAAG;IAAEC,GAAG;IAAEC;EAAI,CAAE,GAAGC,cAAI,CAACC,KAAK,CAACL,QAAQ,CAAC;EAE/C,OAAOI,cAAI,CAACE,MAAM,CAAC;IACjBL,GAAG;IACHC,GAAG;IACHC,IAAI,EAAE,GAAGL,gBAAgB,GAAGK,IAAI;GACjC,CAAC;AACJ;AAEO,eAAeI,QAAQ,CAC5BC,GAAW,EACXR,QAAgB,EAE6B;EAAA,IAD7CS,aAAa,uEAAG,KAAK;EAAA,IACrBC,mFAA2C,EAAE;EAE7C,MAAM;IAAEC;EAAQ,CAAE,GAAG,wDAAa,QAAQ,GAAC;EAC3C,MAAM;IAAEC,mBAAmB;IAAEC,UAAU;IAAEC;EAAO,CAAE,GAAG,wDAAa,QAAQ,GAAC;EAC3E,MAAMC,cAAc,GAAGC,cAAI,CAACC,SAAS,CAACN,QAAQ,CAAC;EAE/C,IAAIO,UAAsB;EAC1B,IAAIC,OAAO,CAACC,GAAG,CAACC,UAAU,KAAKC,SAAS,IAAI,0BAAc,EAACd,GAAG,CAAC,EAAE;IAC/DU,UAAU,GAAG,IAAIL,UAAU,CAACM,OAAO,CAACC,GAAG,CAACC,UAAU,CAAC;GACpD,MAAM;IACLH,UAAU,GAAGN,mBAAmB,EAAE;;EAGpC,MAAMW,cAAc,GAAG,mCAAiB,GAAE;EAE1C;EACA,MAAMC,QAAQ,GAAG,MAAMV,OAAO,CAACN,GAAG,EAAE;IAClCU,UAAU;IACVO,cAAc,EAAEhB,aAAa;IAC7BiB,eAAe,EAAE,EAAE;IACnBC,MAAM,EAAE,KAAK;IACbC,OAAO,EAAE;MACP,GAAGlB,YAAY;MACf,YAAY,EAAE,WAAWa,cAAc;;GAE1C,CAAC;EAEF,IAAIC,QAAQ,CAACK,UAAU,IAAI,GAAG,IAAIL,QAAQ,CAACK,UAAU,IAAI,GAAG,EAAE;IAC5D,MAAMC,WAAW,GAAG/B,mBAAmB,CAACC,QAAQ,CAAC;IACjD,MAAM+B,kBAAO,CAACC,SAAS,CAAC5B,cAAI,CAAC6B,OAAO,CAACjC,QAAQ,CAAC,CAAC;IAE/C,MAAMe,cAAc,CAACS,QAAQ,CAACU,IAAI,EAAEC,YAAE,CAACC,iBAAiB,CAACN,WAAW,CAAC,CAAC;IACtE,OAAOC,kBAAO,CAACM,IAAI,CAACP,WAAW,EAAE9B,QAAQ,EAAE;MAAEsC,SAAS,EAAE;IAAI,CAAE,CAAC;GAChE,MAAM;IACL;IACA,MAAMd,QAAQ,CAACU,IAAI,CAACK,IAAI,EAAE;;EAG5B;EACA,MAAM,IAAIC,KAAK,CACb,sBAAsBhC,GAAG,MACvBgB,QAAQ,CAACK,UACX,cAAc,MAAML,QAAQ,CAACU,IAAI,CAACK,IAAI,EAAE,EAAE,CAC3C;AACH;AAhDAE","names":["TEMP_FILE_PREFIX","resolveTempFileName","filePath","dir","ext","name","path_1","parse","format","download","url","timeoutMillis","extraHeaders","pipeline","getGlobalDispatcher","ProxyAgent","request","streamPipeline","util_1","promisify","dispatcher","process","env","http_proxy","undefined","hardhatVersion","response","headersTimeout","maxRedirections","method","headers","statusCode","tmpFilePath","fs_extra_1","ensureDir","dirname","body","fs_1","createWriteStream","move","overwrite","text","Error","exports"],"sources":["/Users/janrobel/Documents/PersonalProjekty/nftGenerateAi/clientAndContract/node_modules/hardhat/src/internal/util/download.ts"],"sourcesContent":["import type { Dispatcher } from \"undici\";\n\nimport fs from \"fs\";\nimport fsExtra from \"fs-extra\";\nimport path from \"path\";\nimport util from \"util\";\n\nimport { getHardhatVersion } from \"./packageInfo\";\nimport { shouldUseProxy } from \"./proxy\";\n\nconst TEMP_FILE_PREFIX = \"tmp-\";\n\nfunction resolveTempFileName(filePath: string): string {\n  const { dir, ext, name } = path.parse(filePath);\n\n  return path.format({\n    dir,\n    ext,\n    name: `${TEMP_FILE_PREFIX}${name}`,\n  });\n}\n\nexport async function download(\n  url: string,\n  filePath: string,\n  timeoutMillis = 10000,\n  extraHeaders: { [name: string]: string } = {}\n) {\n  const { pipeline } = await import(\"stream\");\n  const { getGlobalDispatcher, ProxyAgent, request } = await import(\"undici\");\n  const streamPipeline = util.promisify(pipeline);\n\n  let dispatcher: Dispatcher;\n  if (process.env.http_proxy !== undefined && shouldUseProxy(url)) {\n    dispatcher = new ProxyAgent(process.env.http_proxy);\n  } else {\n    dispatcher = getGlobalDispatcher();\n  }\n\n  const hardhatVersion = getHardhatVersion();\n\n  // Fetch the url\n  const response = await request(url, {\n    dispatcher,\n    headersTimeout: timeoutMillis,\n    maxRedirections: 10,\n    method: \"GET\",\n    headers: {\n      ...extraHeaders,\n      \"User-Agent\": `hardhat ${hardhatVersion}`,\n    },\n  });\n\n  if (response.statusCode >= 200 && response.statusCode <= 299) {\n    const tmpFilePath = resolveTempFileName(filePath);\n    await fsExtra.ensureDir(path.dirname(filePath));\n\n    await streamPipeline(response.body, fs.createWriteStream(tmpFilePath));\n    return fsExtra.move(tmpFilePath, filePath, { overwrite: true });\n  } else {\n    // undici's response bodies must always be consumed to prevent leaks\n    await response.body.text();\n  }\n\n  // eslint-disable-next-line @nomiclabs/hardhat-internal-rules/only-hardhat-error\n  throw new Error(\n    `Failed to download ${url} - ${\n      response.statusCode\n    } received. ${await response.body.text()}`\n  );\n}\n"]},"metadata":{},"sourceType":"script","externalDependencies":[]}