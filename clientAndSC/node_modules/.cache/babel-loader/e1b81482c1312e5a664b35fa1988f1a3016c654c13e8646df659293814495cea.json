{"ast":null,"code":"\"use strict\";\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.ModulesLogger = void 0;\nconst ethereumjs_util_1 = require(\"@nomicfoundation/ethereumjs-util\");\nconst ansi_escapes_1 = __importDefault(require(\"ansi-escapes\"));\nconst chalk_1 = __importDefault(require(\"chalk\"));\nconst util_1 = __importDefault(require(\"util\"));\nconst errors_1 = require(\"../../../core/errors\");\nconst errors_2 = require(\"../../../core/providers/errors\");\nconst wei_values_1 = require(\"../../../util/wei-values\");\nconst message_trace_1 = require(\"../../stack-traces/message-trace\");\nconst model_1 = require(\"../../stack-traces/model\");\nconst solidity_errors_1 = require(\"../../stack-traces/solidity-errors\");\nconst solidity_stack_trace_1 = require(\"../../stack-traces/solidity-stack-trace\");\nfunction printLine(line) {\n  console.log(line);\n}\nfunction replaceLastLine(newLine) {\n  if (process.stdout.isTTY === true) {\n    process.stdout.write(\n    // eslint-disable-next-line prefer-template\n    ansi_escapes_1.default.cursorHide + ansi_escapes_1.default.cursorPrevLine + newLine + ansi_escapes_1.default.eraseEndLine + \"\\n\" + ansi_escapes_1.default.cursorShow);\n  } else {\n    process.stdout.write(`${newLine}\\n`);\n  }\n}\n/**\n * Handles all the logging made from the Hardhat Network.\n *\n * Methods of this class follow this convention:\n * - Methods that start with `log` add those messages to a list of things to log\n * - Methods that start with `print` print to stdout immediately\n */\nclass ModulesLogger {\n  constructor(_enabled) {\n    let _printLine = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : printLine;\n    let _replaceLastLine = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : replaceLastLine;\n    this._enabled = _enabled;\n    this._printLine = _printLine;\n    this._replaceLastLine = _replaceLastLine;\n    this._logs = [];\n    this._titleLength = 0;\n    this._currentIndent = 0;\n    this._emptyIntervalMinedBlocksRangeStart = undefined;\n    this._emptyHardhatMinedBlocksRangeStart = undefined;\n    this._methodCollapsedCount = 0;\n  }\n  isEnabled() {\n    return this._enabled;\n  }\n  setEnabled(enabled) {\n    this._enabled = enabled;\n  }\n  isLoggedError(err) {\n    return err instanceof solidity_errors_1.SolidityError || err instanceof errors_2.TransactionExecutionError;\n  }\n  logBlockFromAutomine(result, codes, txHashToHighlight) {\n    const {\n      block,\n      blockResult,\n      traces\n    } = result;\n    const {\n      results\n    } = blockResult;\n    (0, errors_1.assertHardhatInvariant)(results.length === codes.length, \"The array of codes should have the same length as the array of results\");\n    this._indent(() => {\n      this._logBlockNumber(block);\n      this._indent(() => {\n        this._logBaseFeePerGas(block);\n        for (let i = 0; i < block.transactions.length; i++) {\n          const tx = block.transactions[i];\n          const txGasUsed = results[i].totalGasSpent;\n          const txTrace = traces[i];\n          const code = codes[i];\n          const highlightTxHash = tx.hash().equals(txHashToHighlight);\n          this._logTxInsideBlock(tx, txTrace, code, txGasUsed, {\n            highlightTxHash\n          });\n          this._logEmptyLineBetweenTransactions(i, block.transactions.length);\n        }\n      });\n    });\n  }\n  logMinedBlock(result, codes) {\n    const {\n      block,\n      blockResult,\n      traces\n    } = result;\n    const {\n      results\n    } = blockResult;\n    (0, errors_1.assertHardhatInvariant)(results.length === codes.length, \"The array of codes should have the same length as the array of results\");\n    const blockNumber = result.block.header.number;\n    const isEmpty = result.block.transactions.length === 0;\n    this._indent(() => {\n      this.logMinedBlockNumber(blockNumber, isEmpty, block.header.baseFeePerGas);\n      if (isEmpty) {\n        return;\n      }\n      this._indent(() => {\n        this._logBlockHash(block);\n        this._indent(() => {\n          this._logBaseFeePerGas(block);\n          for (let i = 0; i < block.transactions.length; i++) {\n            const tx = block.transactions[i];\n            const txGasUsed = results[i].totalGasSpent;\n            const txTrace = traces[i];\n            const code = codes[i];\n            this._logTxInsideBlock(tx, txTrace, code, txGasUsed, {\n              highlightTxHash: false\n            });\n            this._logEmptyLineBetweenTransactions(i, block.transactions.length);\n          }\n        });\n      });\n    });\n  }\n  logIntervalMinedBlock(result, codes) {\n    const {\n      block,\n      blockResult,\n      traces\n    } = result;\n    const {\n      results\n    } = blockResult;\n    (0, errors_1.assertHardhatInvariant)(results.length === codes.length, \"The array of codes should have the same length as the array of results\");\n    this._indent(() => {\n      this._logBlockHash(block);\n      this._indent(() => {\n        this._logBaseFeePerGas(block);\n        for (let i = 0; i < block.transactions.length; i++) {\n          const tx = block.transactions[i];\n          const txGasUsed = results[i].totalGasSpent;\n          const txTrace = traces[i];\n          const code = codes[i];\n          this._logTxInsideBlock(tx, txTrace, code, txGasUsed, {\n            highlightTxHash: false\n          });\n          this._logEmptyLineBetweenTransactions(i, block.transactions.length);\n        }\n      });\n    });\n  }\n  logSingleTransaction(tx, block, txGasUsed, txTrace, code) {\n    this._indent(() => {\n      this._logContractAndFunctionName(txTrace.trace, code);\n      const txHash = (0, ethereumjs_util_1.bufferToHex)(tx.hash());\n      this._logWithTitle(\"Transaction\", txHash);\n      this._logTxFrom(tx.getSenderAddress().toBuffer());\n      this._logTxTo(tx.to?.toBuffer(), txTrace.trace);\n      this._logTxValue(tx.value);\n      this._logWithTitle(\"Gas used\", `${txGasUsed} of ${tx.gasLimit}`);\n      this._logWithTitle(`Block #${block.header.number}`, (0, ethereumjs_util_1.bufferToHex)(block.hash()));\n      this._logConsoleLogMessages(txTrace.consoleLogMessages);\n      if (txTrace.error !== undefined) {\n        this._logError(txTrace.error);\n      }\n    });\n  }\n  logCurrentlySentTransaction(tx, txGasUsed, txTrace, code, block) {\n    this._indent(() => {\n      this._log(\"Currently sent transaction:\");\n      this.logEmptyLine();\n      this._logContractAndFunctionName(txTrace.trace, code);\n      const txHash = (0, ethereumjs_util_1.bufferToHex)(tx.hash());\n      this._logWithTitle(\"Transaction\", txHash);\n      this._logTxFrom(tx.getSenderAddress().toBuffer());\n      this._logTxTo(tx.to?.toBuffer(), txTrace.trace);\n      this._logTxValue(tx.value);\n      this._logWithTitle(\"Gas used\", `${txGasUsed} of ${tx.gasLimit}`);\n      this._logWithTitle(`Block #${block.header.number}`, (0, ethereumjs_util_1.bufferToHex)(block.hash()));\n      this._logConsoleLogMessages(txTrace.consoleLogMessages);\n      if (txTrace.error !== undefined) {\n        this._logError(txTrace.error);\n      }\n    });\n  }\n  logEstimateGasTrace(callParams, code, trace, consoleLogMessages, error) {\n    this._indent(() => {\n      this._logContractAndFunctionName(trace, code, {\n        printNonContractCalled: true\n      });\n      this._logTxFrom(callParams.from);\n      this._logTxTo(callParams.to, trace);\n      this._logTxValue(callParams.value);\n      this._logConsoleLogMessages(consoleLogMessages);\n      this._logError(error);\n    });\n  }\n  logCallTrace(callParams, code, trace, consoleLogMessages, error) {\n    this._indent(() => {\n      this._logContractAndFunctionName(trace, code, {\n        printNonContractCalled: true\n      });\n      this._logTxFrom(callParams.from);\n      this._logTxTo(callParams.to, trace);\n      if (callParams.value > 0n) {\n        this._logTxValue(callParams.value);\n      }\n      this._logConsoleLogMessages(consoleLogMessages);\n      if (error !== undefined) {\n        // TODO: If throwOnCallFailures is false, this will log the error, but the RPC method won't be red\n        this._logError(error);\n      }\n    });\n  }\n  logMinedBlockNumber(blockNumber, isEmpty, baseFeePerGas) {\n    if (isEmpty) {\n      this._log(`Mined empty block #${blockNumber}${baseFeePerGas !== undefined ? ` with base fee ${baseFeePerGas.toString()}` : \"\"}`);\n      return;\n    }\n    this._log(`Mined block #${blockNumber}`);\n  }\n  logMultipleTransactionsWarning() {\n    this._indent(() => {\n      this._log(\"There were other pending transactions mined in the same block:\");\n    });\n    this.logEmptyLine();\n  }\n  logMultipleBlocksWarning() {\n    this._indent(() => {\n      this._log(\"There were other pending transactions. More than one block had to be mined:\");\n    });\n    this.logEmptyLine();\n  }\n  logEmptyLine() {\n    this._log(\"\");\n  }\n  _logBaseFeePerGas(block) {\n    if (block.header.baseFeePerGas !== undefined) {\n      this._log(`Base fee: ${block.header.baseFeePerGas.toString()}`);\n    }\n  }\n  printErrorMessage(errorMessage) {\n    this._indent(() => {\n      this._print(errorMessage);\n    });\n  }\n  printFailedMethod(method) {\n    this._print(method, {\n      color: chalk_1.default.red\n    });\n  }\n  /**\n   * Print all accumulated logs\n   */\n  printLogs() {\n    const logs = this._getLogs();\n    if (logs.length === 0) {\n      return false;\n    }\n    for (const msg of logs) {\n      this._print(msg);\n    }\n    this._clearLogs();\n    return true;\n  }\n  printIntervalMinedBlockNumber(blockNumber, isEmpty, baseFeePerGas) {\n    if (this._emptyIntervalMinedBlocksRangeStart !== undefined) {\n      this._print(`Mined empty block range #${this._emptyIntervalMinedBlocksRangeStart} to #${blockNumber}`, {\n        collapseIntervalMinedBlock: true,\n        replaceLastLine: true\n      });\n    } else {\n      this._emptyIntervalMinedBlocksRangeStart = blockNumber;\n      if (isEmpty) {\n        this._print(`Mined empty block #${blockNumber}${baseFeePerGas !== undefined ? ` with base fee ${baseFeePerGas.toString()}` : \"\"}`, {\n          collapseIntervalMinedBlock: true\n        });\n        return;\n      }\n      this._print(`Mined block #${blockNumber}`, {\n        collapseIntervalMinedBlock: true\n      });\n    }\n  }\n  logEmptyHardhatMinedBlock(blockNumber, baseFeePerGas) {\n    this._indent(() => {\n      if (this._emptyHardhatMinedBlocksRangeStart !== undefined) {\n        this._log(`Mined empty block range #${this._emptyHardhatMinedBlocksRangeStart} to #${blockNumber}`, {\n          collapseHardhatMinedBlock: true,\n          replaceLastLine: true\n        });\n      } else {\n        this._emptyHardhatMinedBlocksRangeStart = blockNumber;\n        this._log(`Mined empty block #${blockNumber}${baseFeePerGas !== undefined ? ` with base fee ${baseFeePerGas.toString()}` : \"\"}`, {\n          collapseHardhatMinedBlock: true\n        });\n        return;\n      }\n    });\n  }\n  printMetaMaskWarning() {\n    const message = \"If you are using MetaMask, you can learn how to fix this error here: https://hardhat.org/metamask-issue\";\n    this._indent(() => {\n      this._print(message, {\n        color: chalk_1.default.yellow\n      });\n    });\n  }\n  printMethod(method) {\n    if (this._shouldCollapseMethod(method)) {\n      this._methodCollapsedCount += 1;\n      this._print(chalk_1.default.green(`${method} (${this._methodCollapsedCount})`), {\n        collapsePrintedMethod: true,\n        replaceLastLine: true\n      });\n    } else {\n      this._startCollapsingMethod(method);\n      this._print(method, {\n        color: chalk_1.default.green,\n        collapsePrintedMethod: true\n      });\n    }\n  }\n  printMethodNotSupported(method) {\n    this._print(`${method} - Method not supported`, {\n      color: chalk_1.default.red\n    });\n  }\n  printEmptyLine() {\n    this._print(\"\");\n  }\n  printUnknownError(err) {\n    this._indent(() => {\n      this._printError(err);\n      this.printEmptyLine();\n      this._print(\"If you think this is a bug in Hardhat, please report it here: https://hardhat.org/report-bug\");\n    });\n  }\n  _format(msg) {\n    let {\n      color\n    } = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    if (msg === \"\") {\n      // don't indent empty lines\n      return msg;\n    }\n    if (this._currentIndent > 0) {\n      msg = msg.split(\"\\n\").map(line => \" \".repeat(this._currentIndent) + line).join(\"\\n\");\n    }\n    if (color !== undefined) {\n      return color(msg);\n    }\n    return msg;\n  }\n  _indent(cb) {\n    let enabled = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n    if (enabled) {\n      this._currentIndent += 2;\n    }\n    try {\n      return cb();\n    } finally {\n      if (enabled) {\n        this._currentIndent -= 2;\n      }\n    }\n  }\n  _indentSingleLine(message) {\n    return \" \".repeat(this._currentIndent) + message;\n  }\n  _log(msg) {\n    let printOptions = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    if (printOptions.collapsePrintedMethod !== true) {\n      this._stopCollapsingMethod();\n    }\n    if (printOptions.collapseIntervalMinedBlock !== true) {\n      this._emptyIntervalMinedBlocksRangeStart = undefined;\n    }\n    if (printOptions.collapseHardhatMinedBlock !== true) {\n      this._emptyHardhatMinedBlocksRangeStart = undefined;\n    }\n    const formattedMessage = this._format(msg, printOptions);\n    if (printOptions.replaceLastLine === true) {\n      this._logs[this._logs.length - 1] = formattedMessage;\n    } else {\n      this._logs.push(formattedMessage);\n    }\n  }\n  _logError(err) {\n    if (this.isLoggedError(err)) {\n      this.logEmptyLine();\n      this._log(util_1.default.inspect(err));\n    }\n  }\n  _logTxInsideBlock(tx, txTrace, code, txGasUsed, _ref) {\n    let {\n      highlightTxHash\n    } = _ref;\n    // indentAfterTransactionHash: true,\n    // printTxBlockNumber: false,\n    // startWithTxHash: true,\n    let txHash = (0, ethereumjs_util_1.bufferToHex)(tx.hash());\n    if (highlightTxHash) {\n      txHash = chalk_1.default.bold(txHash);\n    }\n    this._logWithTitle(\"Transaction\", txHash);\n    this._indent(() => {\n      this._logContractAndFunctionName(txTrace.trace, code);\n      this._logTxFrom(tx.getSenderAddress().toBuffer());\n      this._logTxTo(tx.to?.toBuffer(), txTrace.trace);\n      this._logTxValue(tx.value);\n      this._logWithTitle(\"Gas used\", `${txGasUsed} of ${tx.gasLimit}`);\n      this._logConsoleLogMessages(txTrace.consoleLogMessages);\n      if (txTrace.error !== undefined) {\n        this._logError(txTrace.error);\n      }\n    });\n  }\n  /**\n   *  This should be the only function that calls _printLine and\n   *  _replaceLastLine (except for the special console.sol case),\n   *  because it's the only function that checks if the logger\n   *  is enabled.\n   */\n  _print(msg) {\n    let printOptions = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    if (!this._enabled) {\n      return;\n    }\n    if (printOptions.collapsePrintedMethod !== true) {\n      this._stopCollapsingMethod();\n    }\n    if (printOptions.collapseIntervalMinedBlock !== true) {\n      this._emptyIntervalMinedBlocksRangeStart = undefined;\n    }\n    if (printOptions.collapseHardhatMinedBlock !== true) {\n      this._emptyHardhatMinedBlocksRangeStart = undefined;\n    }\n    const formattedMessage = this._format(msg, printOptions);\n    if (printOptions.replaceLastLine === true) {\n      this._replaceLastLine(formattedMessage);\n    } else {\n      this._printLine(formattedMessage);\n    }\n  }\n  _printError(err) {\n    if (this.isLoggedError(err)) {\n      this.printEmptyLine();\n      this._print(util_1.default.inspect(err));\n    }\n  }\n  _logContractAndFunctionName(trace, code) {\n    let {\n      printNonContractCalled = false\n    } = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    if (trace === undefined) {\n      return;\n    }\n    if ((0, message_trace_1.isPrecompileTrace)(trace)) {\n      this._logWithTitle(\"Precompile call\", `<PrecompileContract ${trace.precompile}>`);\n      return;\n    }\n    if ((0, message_trace_1.isCreateTrace)(trace)) {\n      if (trace.bytecode === undefined) {\n        this._logWithTitle(\"Contract deployment\", solidity_stack_trace_1.UNRECOGNIZED_CONTRACT_NAME);\n      } else {\n        this._logWithTitle(\"Contract deployment\", trace.bytecode.contract.name);\n      }\n      if (trace.deployedContract !== undefined && trace.error === undefined) {\n        this._logWithTitle(\"Contract address\", (0, ethereumjs_util_1.bufferToHex)(trace.deployedContract));\n      }\n      return;\n    }\n    if (code.length === 0) {\n      if (printNonContractCalled) {\n        this._log(`WARNING: Calling an account which is not a contract`);\n      }\n      return;\n    }\n    if (trace.bytecode === undefined) {\n      this._logWithTitle(\"Contract call\", solidity_stack_trace_1.UNRECOGNIZED_CONTRACT_NAME);\n      return;\n    }\n    const func = trace.bytecode.contract.getFunctionFromSelector(trace.calldata.slice(0, 4));\n    const functionName = func === undefined ? solidity_stack_trace_1.UNRECOGNIZED_FUNCTION_NAME : func.type === model_1.ContractFunctionType.FALLBACK ? solidity_stack_trace_1.FALLBACK_FUNCTION_NAME : func.type === model_1.ContractFunctionType.RECEIVE ? solidity_stack_trace_1.RECEIVE_FUNCTION_NAME : func.name;\n    this._logWithTitle(\"Contract call\", `${trace.bytecode.contract.name}#${functionName}`);\n  }\n  _shouldCollapseMethod(method) {\n    return method === this._methodBeingCollapsed && !this._hasLogs() && this._methodCollapsedCount > 0;\n  }\n  _startCollapsingMethod(method) {\n    this._methodBeingCollapsed = method;\n    this._methodCollapsedCount = 1;\n  }\n  _stopCollapsingMethod() {\n    this._methodBeingCollapsed = undefined;\n    this._methodCollapsedCount = 0;\n  }\n  _logTxTo(to, trace) {\n    if (trace !== undefined && (0, message_trace_1.isCreateTrace)(trace)) {\n      return;\n    }\n    if (to === undefined) {\n      // only for the type-checker, since `to` is undefined only when\n      // the message is a create trace\n      return;\n    }\n    const toString = (0, ethereumjs_util_1.bufferToHex)(to);\n    this._logWithTitle(\"To\", toString);\n  }\n  _logTxValue(value) {\n    this._logWithTitle(\"Value\", (0, wei_values_1.weiToHumanReadableString)(value));\n  }\n  _logTxFrom(from) {\n    this._logWithTitle(\"From\", (0, ethereumjs_util_1.bufferToHex)(from));\n  }\n  _logBlockNumber(block) {\n    this._log(`Block #${block.header.number}: ${(0, ethereumjs_util_1.bufferToHex)(block.hash())}`);\n  }\n  _logEmptyLineBetweenTransactions(currentIndex, totalTransactions) {\n    if (currentIndex + 1 < totalTransactions && totalTransactions > 1) {\n      this.logEmptyLine();\n    }\n  }\n  _logBlockHash(block) {\n    this._log(`Block: ${(0, ethereumjs_util_1.bufferToHex)(block.hash())}`);\n  }\n  _logConsoleLogMessages(messages) {\n    // This is a especial case, as we always want to print the console.log\n    // messages. The difference is how.\n    // If we have a logger, we should use that, so that logs are printed in\n    // order. If we don't, we just print the messages here.\n    if (!this._enabled) {\n      for (const msg of messages) {\n        this._printLine(msg);\n      }\n      return;\n    }\n    if (messages.length === 0) {\n      return;\n    }\n    this.logEmptyLine();\n    this._log(\"console.log:\");\n    for (const msg of messages) {\n      this._log(`  ${msg}`);\n    }\n  }\n  _logWithTitle(title, message) {\n    title = this._indentSingleLine(title);\n    // We always use the max title length we've seen. Otherwise the value move\n    // a lot with each tx/call.\n    if (title.length > this._titleLength) {\n      this._titleLength = title.length;\n    }\n    this._logs.push([title, message]);\n  }\n  _clearLogs() {\n    this._logs = [];\n  }\n  _hasLogs() {\n    return this._logs.length > 0;\n  }\n  _getLogs() {\n    return this._logs.map(l => {\n      if (typeof l === \"string\") {\n        return l;\n      }\n      const title = `${l[0]}:`;\n      return `${title.padEnd(this._titleLength + 1)} ${l[1]}`;\n    });\n  }\n}\nexports.ModulesLogger = ModulesLogger;","map":{"version":3,"mappings":"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","names":["printLine","line","console","log","replaceLastLine","newLine","process","stdout","isTTY","write","ansi_escapes_1","cursorHide","cursorPrevLine","eraseEndLine","cursorShow","ModulesLogger","constructor","_enabled","_printLine","_replaceLastLine","undefined","isEnabled","setEnabled","enabled","isLoggedError","err","solidity_errors_1","errors_2","logBlockFromAutomine","result","codes","txHashToHighlight","block","blockResult","traces","results","length","_indent","_logBlockNumber","_logBaseFeePerGas","i","transactions","tx","txGasUsed","totalGasSpent","txTrace","code","highlightTxHash","hash","equals","_logTxInsideBlock","_logEmptyLineBetweenTransactions","logMinedBlock","blockNumber","header","number","isEmpty","logMinedBlockNumber","baseFeePerGas","_logBlockHash","logIntervalMinedBlock","logSingleTransaction","_logContractAndFunctionName","trace","txHash","_logWithTitle","_logTxFrom","getSenderAddress","toBuffer","_logTxTo","to","_logTxValue","value","gasLimit","_logConsoleLogMessages","consoleLogMessages","error","_logError","logCurrentlySentTransaction","_log","logEmptyLine","logEstimateGasTrace","callParams","printNonContractCalled","from","logCallTrace","toString","logMultipleTransactionsWarning","logMultipleBlocksWarning","printErrorMessage","errorMessage","_print","printFailedMethod","method","color","chalk_1","red","printLogs","logs","_getLogs","msg","_clearLogs","printIntervalMinedBlockNumber","_emptyIntervalMinedBlocksRangeStart","collapseIntervalMinedBlock","logEmptyHardhatMinedBlock","_emptyHardhatMinedBlocksRangeStart","collapseHardhatMinedBlock","printMetaMaskWarning","message","yellow","printMethod","_shouldCollapseMethod","_methodCollapsedCount","green","collapsePrintedMethod","_startCollapsingMethod","printMethodNotSupported","printEmptyLine","printUnknownError","_printError","_format","_currentIndent","split","map","repeat","join","cb","_indentSingleLine","printOptions","_stopCollapsingMethod","formattedMessage","_logs","push","util_1","inspect","bold","precompile","bytecode","solidity_stack_trace_1","contract","name","deployedContract","func","getFunctionFromSelector","calldata","slice","functionName","type","model_1","FALLBACK","RECEIVE","_methodBeingCollapsed","_hasLogs","currentIndex","totalTransactions","messages","title","_titleLength","l","padEnd","exports"],"sources":["/Users/janrobel/Documents/PersonalProjekty/nftGenerateAi/clientAndContract/node_modules/hardhat/src/internal/hardhat-network/provider/modules/logger.ts"],"sourcesContent":["import { Block } from \"@nomicfoundation/ethereumjs-block\";\nimport { TypedTransaction } from \"@nomicfoundation/ethereumjs-tx\";\nimport { bufferToHex } from \"@nomicfoundation/ethereumjs-util\";\nimport ansiEscapes from \"ansi-escapes\";\nimport chalk, { Chalk } from \"chalk\";\nimport util from \"util\";\n\nimport { assertHardhatInvariant } from \"../../../core/errors\";\nimport { TransactionExecutionError } from \"../../../core/providers/errors\";\nimport { weiToHumanReadableString } from \"../../../util/wei-values\";\nimport {\n  isCreateTrace,\n  isPrecompileTrace,\n  MessageTrace,\n} from \"../../stack-traces/message-trace\";\nimport { ContractFunctionType } from \"../../stack-traces/model\";\nimport { SolidityError } from \"../../stack-traces/solidity-errors\";\nimport {\n  FALLBACK_FUNCTION_NAME,\n  RECEIVE_FUNCTION_NAME,\n  UNRECOGNIZED_CONTRACT_NAME,\n  UNRECOGNIZED_FUNCTION_NAME,\n} from \"../../stack-traces/solidity-stack-trace\";\nimport { CallParams, GatherTracesResult, MineBlockResult } from \"../node-types\";\n\ninterface PrintOptions {\n  color?: Chalk;\n  replaceLastLine?: boolean;\n  collapsePrintedMethod?: boolean;\n  collapseIntervalMinedBlock?: boolean;\n  collapseHardhatMinedBlock?: boolean;\n}\n\nfunction printLine(line: string) {\n  console.log(line);\n}\n\nfunction replaceLastLine(newLine: string) {\n  if (process.stdout.isTTY === true) {\n    process.stdout.write(\n      // eslint-disable-next-line prefer-template\n      ansiEscapes.cursorHide +\n        ansiEscapes.cursorPrevLine +\n        newLine +\n        ansiEscapes.eraseEndLine +\n        \"\\n\" +\n        ansiEscapes.cursorShow\n    );\n  } else {\n    process.stdout.write(`${newLine}\\n`);\n  }\n}\n\n/**\n * Handles all the logging made from the Hardhat Network.\n *\n * Methods of this class follow this convention:\n * - Methods that start with `log` add those messages to a list of things to log\n * - Methods that start with `print` print to stdout immediately\n */\nexport class ModulesLogger {\n  private _logs: Array<string | [string, string]> = [];\n  private _titleLength = 0;\n  private _currentIndent = 0;\n  private _emptyIntervalMinedBlocksRangeStart: bigint | undefined = undefined;\n  private _emptyHardhatMinedBlocksRangeStart: bigint | undefined = undefined;\n  private _methodBeingCollapsed?: string;\n  private _methodCollapsedCount: number = 0;\n\n  constructor(\n    private _enabled: boolean,\n    private _printLine = printLine,\n    private _replaceLastLine = replaceLastLine\n  ) {}\n\n  public isEnabled() {\n    return this._enabled;\n  }\n\n  public setEnabled(enabled: boolean) {\n    this._enabled = enabled;\n  }\n\n  public isLoggedError(err: Error) {\n    return (\n      err instanceof SolidityError || err instanceof TransactionExecutionError\n    );\n  }\n\n  public logBlockFromAutomine(\n    result: MineBlockResult,\n    codes: Buffer[],\n    txHashToHighlight: Buffer\n  ) {\n    const { block, blockResult, traces } = result;\n    const { results } = blockResult;\n\n    assertHardhatInvariant(\n      results.length === codes.length,\n      \"The array of codes should have the same length as the array of results\"\n    );\n\n    this._indent(() => {\n      this._logBlockNumber(block);\n\n      this._indent(() => {\n        this._logBaseFeePerGas(block);\n\n        for (let i = 0; i < block.transactions.length; i++) {\n          const tx = block.transactions[i];\n\n          const txGasUsed = results[i].totalGasSpent;\n          const txTrace = traces[i];\n          const code = codes[i];\n\n          const highlightTxHash = tx.hash().equals(txHashToHighlight);\n\n          this._logTxInsideBlock(tx, txTrace, code, txGasUsed, {\n            highlightTxHash,\n          });\n\n          this._logEmptyLineBetweenTransactions(i, block.transactions.length);\n        }\n      });\n    });\n  }\n\n  public logMinedBlock(result: MineBlockResult, codes: Buffer[]) {\n    const { block, blockResult, traces } = result;\n    const { results } = blockResult;\n\n    assertHardhatInvariant(\n      results.length === codes.length,\n      \"The array of codes should have the same length as the array of results\"\n    );\n\n    const blockNumber = result.block.header.number;\n    const isEmpty = result.block.transactions.length === 0;\n\n    this._indent(() => {\n      this.logMinedBlockNumber(\n        blockNumber,\n        isEmpty,\n        block.header.baseFeePerGas\n      );\n\n      if (isEmpty) {\n        return;\n      }\n\n      this._indent(() => {\n        this._logBlockHash(block);\n\n        this._indent(() => {\n          this._logBaseFeePerGas(block);\n\n          for (let i = 0; i < block.transactions.length; i++) {\n            const tx = block.transactions[i];\n            const txGasUsed = results[i].totalGasSpent;\n            const txTrace = traces[i];\n            const code = codes[i];\n\n            this._logTxInsideBlock(tx, txTrace, code, txGasUsed, {\n              highlightTxHash: false,\n            });\n\n            this._logEmptyLineBetweenTransactions(i, block.transactions.length);\n          }\n        });\n      });\n    });\n  }\n\n  public logIntervalMinedBlock(result: MineBlockResult, codes: Buffer[]) {\n    const { block, blockResult, traces } = result;\n    const { results } = blockResult;\n\n    assertHardhatInvariant(\n      results.length === codes.length,\n      \"The array of codes should have the same length as the array of results\"\n    );\n\n    this._indent(() => {\n      this._logBlockHash(block);\n\n      this._indent(() => {\n        this._logBaseFeePerGas(block);\n\n        for (let i = 0; i < block.transactions.length; i++) {\n          const tx = block.transactions[i];\n          const txGasUsed = results[i].totalGasSpent;\n          const txTrace = traces[i];\n          const code = codes[i];\n\n          this._logTxInsideBlock(tx, txTrace, code, txGasUsed, {\n            highlightTxHash: false,\n          });\n\n          this._logEmptyLineBetweenTransactions(i, block.transactions.length);\n        }\n      });\n    });\n  }\n\n  public logSingleTransaction(\n    tx: TypedTransaction,\n    block: Block,\n    txGasUsed: bigint,\n    txTrace: GatherTracesResult,\n    code: Buffer\n  ) {\n    this._indent(() => {\n      this._logContractAndFunctionName(txTrace.trace, code);\n\n      const txHash = bufferToHex(tx.hash());\n\n      this._logWithTitle(\"Transaction\", txHash);\n\n      this._logTxFrom(tx.getSenderAddress().toBuffer());\n      this._logTxTo(tx.to?.toBuffer(), txTrace.trace);\n      this._logTxValue(tx.value);\n      this._logWithTitle(\"Gas used\", `${txGasUsed} of ${tx.gasLimit}`);\n\n      this._logWithTitle(\n        `Block #${block.header.number}`,\n        bufferToHex(block.hash())\n      );\n\n      this._logConsoleLogMessages(txTrace.consoleLogMessages);\n\n      if (txTrace.error !== undefined) {\n        this._logError(txTrace.error);\n      }\n    });\n  }\n\n  public logCurrentlySentTransaction(\n    tx: TypedTransaction,\n    txGasUsed: bigint,\n    txTrace: GatherTracesResult,\n    code: Buffer,\n    block: Block\n  ) {\n    this._indent(() => {\n      this._log(\"Currently sent transaction:\");\n      this.logEmptyLine();\n\n      this._logContractAndFunctionName(txTrace.trace, code);\n\n      const txHash = bufferToHex(tx.hash());\n\n      this._logWithTitle(\"Transaction\", txHash);\n\n      this._logTxFrom(tx.getSenderAddress().toBuffer());\n      this._logTxTo(tx.to?.toBuffer(), txTrace.trace);\n      this._logTxValue(tx.value);\n      this._logWithTitle(\"Gas used\", `${txGasUsed} of ${tx.gasLimit}`);\n\n      this._logWithTitle(\n        `Block #${block.header.number}`,\n        bufferToHex(block.hash())\n      );\n\n      this._logConsoleLogMessages(txTrace.consoleLogMessages);\n\n      if (txTrace.error !== undefined) {\n        this._logError(txTrace.error);\n      }\n    });\n  }\n\n  public logEstimateGasTrace(\n    callParams: CallParams,\n    code: Buffer,\n    trace: MessageTrace | undefined,\n    consoleLogMessages: string[],\n    error: Error\n  ) {\n    this._indent(() => {\n      this._logContractAndFunctionName(trace, code, {\n        printNonContractCalled: true,\n      });\n\n      this._logTxFrom(callParams.from);\n      this._logTxTo(callParams.to, trace);\n      this._logTxValue(callParams.value);\n\n      this._logConsoleLogMessages(consoleLogMessages);\n\n      this._logError(error);\n    });\n  }\n\n  public logCallTrace(\n    callParams: CallParams,\n    code: Buffer,\n    trace: MessageTrace | undefined,\n    consoleLogMessages: string[],\n    error: Error | undefined\n  ) {\n    this._indent(() => {\n      this._logContractAndFunctionName(trace, code, {\n        printNonContractCalled: true,\n      });\n\n      this._logTxFrom(callParams.from);\n      this._logTxTo(callParams.to, trace);\n      if (callParams.value > 0n) {\n        this._logTxValue(callParams.value);\n      }\n\n      this._logConsoleLogMessages(consoleLogMessages);\n\n      if (error !== undefined) {\n        // TODO: If throwOnCallFailures is false, this will log the error, but the RPC method won't be red\n        this._logError(error);\n      }\n    });\n  }\n\n  public logMinedBlockNumber(\n    blockNumber: bigint,\n    isEmpty: boolean,\n    baseFeePerGas?: bigint\n  ) {\n    if (isEmpty) {\n      this._log(\n        `Mined empty block #${blockNumber}${\n          baseFeePerGas !== undefined\n            ? ` with base fee ${baseFeePerGas.toString()}`\n            : \"\"\n        }`\n      );\n\n      return;\n    }\n\n    this._log(`Mined block #${blockNumber}`);\n  }\n\n  public logMultipleTransactionsWarning() {\n    this._indent(() => {\n      this._log(\n        \"There were other pending transactions mined in the same block:\"\n      );\n    });\n    this.logEmptyLine();\n  }\n\n  public logMultipleBlocksWarning() {\n    this._indent(() => {\n      this._log(\n        \"There were other pending transactions. More than one block had to be mined:\"\n      );\n    });\n    this.logEmptyLine();\n  }\n\n  public logEmptyLine() {\n    this._log(\"\");\n  }\n\n  private _logBaseFeePerGas(block: Block) {\n    if (block.header.baseFeePerGas !== undefined) {\n      this._log(`Base fee: ${block.header.baseFeePerGas.toString()}`);\n    }\n  }\n\n  public printErrorMessage(errorMessage: string) {\n    this._indent(() => {\n      this._print(errorMessage);\n    });\n  }\n\n  public printFailedMethod(method: string) {\n    this._print(method, { color: chalk.red });\n  }\n\n  /**\n   * Print all accumulated logs\n   */\n  public printLogs(): boolean {\n    const logs = this._getLogs();\n    if (logs.length === 0) {\n      return false;\n    }\n\n    for (const msg of logs) {\n      this._print(msg);\n    }\n\n    this._clearLogs();\n\n    return true;\n  }\n\n  public printIntervalMinedBlockNumber(\n    blockNumber: bigint,\n    isEmpty: boolean,\n    baseFeePerGas?: bigint\n  ) {\n    if (this._emptyIntervalMinedBlocksRangeStart !== undefined) {\n      this._print(\n        `Mined empty block range #${this._emptyIntervalMinedBlocksRangeStart} to #${blockNumber}`,\n        { collapseIntervalMinedBlock: true, replaceLastLine: true }\n      );\n    } else {\n      this._emptyIntervalMinedBlocksRangeStart = blockNumber;\n\n      if (isEmpty) {\n        this._print(\n          `Mined empty block #${blockNumber}${\n            baseFeePerGas !== undefined\n              ? ` with base fee ${baseFeePerGas.toString()}`\n              : \"\"\n          }`,\n          {\n            collapseIntervalMinedBlock: true,\n          }\n        );\n\n        return;\n      }\n\n      this._print(`Mined block #${blockNumber}`, {\n        collapseIntervalMinedBlock: true,\n      });\n    }\n  }\n\n  public logEmptyHardhatMinedBlock(\n    blockNumber: bigint,\n    baseFeePerGas?: bigint\n  ) {\n    this._indent(() => {\n      if (this._emptyHardhatMinedBlocksRangeStart !== undefined) {\n        this._log(\n          `Mined empty block range #${this._emptyHardhatMinedBlocksRangeStart} to #${blockNumber}`,\n          { collapseHardhatMinedBlock: true, replaceLastLine: true }\n        );\n      } else {\n        this._emptyHardhatMinedBlocksRangeStart = blockNumber;\n\n        this._log(\n          `Mined empty block #${blockNumber}${\n            baseFeePerGas !== undefined\n              ? ` with base fee ${baseFeePerGas.toString()}`\n              : \"\"\n          }`,\n          {\n            collapseHardhatMinedBlock: true,\n          }\n        );\n\n        return;\n      }\n    });\n  }\n\n  public printMetaMaskWarning() {\n    const message =\n      \"If you are using MetaMask, you can learn how to fix this error here: https://hardhat.org/metamask-issue\";\n\n    this._indent(() => {\n      this._print(message, { color: chalk.yellow });\n    });\n  }\n\n  public printMethod(method: string) {\n    if (this._shouldCollapseMethod(method)) {\n      this._methodCollapsedCount += 1;\n\n      this._print(chalk.green(`${method} (${this._methodCollapsedCount})`), {\n        collapsePrintedMethod: true,\n        replaceLastLine: true,\n      });\n    } else {\n      this._startCollapsingMethod(method);\n      this._print(method, { color: chalk.green, collapsePrintedMethod: true });\n    }\n  }\n\n  public printMethodNotSupported(method: string) {\n    this._print(`${method} - Method not supported`, { color: chalk.red });\n  }\n\n  public printEmptyLine() {\n    this._print(\"\");\n  }\n\n  public printUnknownError(err: Error) {\n    this._indent(() => {\n      this._printError(err);\n      this.printEmptyLine();\n\n      this._print(\n        \"If you think this is a bug in Hardhat, please report it here: https://hardhat.org/report-bug\"\n      );\n    });\n  }\n\n  private _format(msg: string, { color }: PrintOptions = {}): string {\n    if (msg === \"\") {\n      // don't indent empty lines\n      return msg;\n    }\n\n    if (this._currentIndent > 0) {\n      msg = msg\n        .split(\"\\n\")\n        .map((line) => \" \".repeat(this._currentIndent) + line)\n        .join(\"\\n\");\n    }\n\n    if (color !== undefined) {\n      return color(msg);\n    }\n\n    return msg;\n  }\n\n  private _indent<T>(cb: () => T, enabled = true) {\n    if (enabled) {\n      this._currentIndent += 2;\n    }\n    try {\n      return cb();\n    } finally {\n      if (enabled) {\n        this._currentIndent -= 2;\n      }\n    }\n  }\n\n  private _indentSingleLine(message: string): string {\n    return \" \".repeat(this._currentIndent) + message;\n  }\n\n  private _log(msg: string, printOptions: PrintOptions = {}) {\n    if (printOptions.collapsePrintedMethod !== true) {\n      this._stopCollapsingMethod();\n    }\n    if (printOptions.collapseIntervalMinedBlock !== true) {\n      this._emptyIntervalMinedBlocksRangeStart = undefined;\n    }\n    if (printOptions.collapseHardhatMinedBlock !== true) {\n      this._emptyHardhatMinedBlocksRangeStart = undefined;\n    }\n    const formattedMessage = this._format(msg, printOptions);\n\n    if (printOptions.replaceLastLine === true) {\n      this._logs[this._logs.length - 1] = formattedMessage;\n    } else {\n      this._logs.push(formattedMessage);\n    }\n  }\n\n  private _logError(err: Error) {\n    if (this.isLoggedError(err)) {\n      this.logEmptyLine();\n      this._log(util.inspect(err));\n    }\n  }\n\n  private _logTxInsideBlock(\n    tx: TypedTransaction,\n    txTrace: GatherTracesResult,\n    code: Buffer,\n    txGasUsed: bigint,\n    {\n      highlightTxHash,\n    }: {\n      highlightTxHash: boolean;\n    }\n  ) {\n    // indentAfterTransactionHash: true,\n    // printTxBlockNumber: false,\n    // startWithTxHash: true,\n    let txHash = bufferToHex(tx.hash());\n\n    if (highlightTxHash) {\n      txHash = chalk.bold(txHash);\n    }\n\n    this._logWithTitle(\"Transaction\", txHash);\n\n    this._indent(() => {\n      this._logContractAndFunctionName(txTrace.trace, code);\n      this._logTxFrom(tx.getSenderAddress().toBuffer());\n      this._logTxTo(tx.to?.toBuffer(), txTrace.trace);\n      this._logTxValue(tx.value);\n      this._logWithTitle(\"Gas used\", `${txGasUsed} of ${tx.gasLimit}`);\n\n      this._logConsoleLogMessages(txTrace.consoleLogMessages);\n\n      if (txTrace.error !== undefined) {\n        this._logError(txTrace.error);\n      }\n    });\n  }\n\n  /**\n   *  This should be the only function that calls _printLine and\n   *  _replaceLastLine (except for the special console.sol case),\n   *  because it's the only function that checks if the logger\n   *  is enabled.\n   */\n  private _print(msg: string, printOptions: PrintOptions = {}) {\n    if (!this._enabled) {\n      return;\n    }\n\n    if (printOptions.collapsePrintedMethod !== true) {\n      this._stopCollapsingMethod();\n    }\n    if (printOptions.collapseIntervalMinedBlock !== true) {\n      this._emptyIntervalMinedBlocksRangeStart = undefined;\n    }\n    if (printOptions.collapseHardhatMinedBlock !== true) {\n      this._emptyHardhatMinedBlocksRangeStart = undefined;\n    }\n    const formattedMessage = this._format(msg, printOptions);\n\n    if (printOptions.replaceLastLine === true) {\n      this._replaceLastLine(formattedMessage);\n    } else {\n      this._printLine(formattedMessage);\n    }\n  }\n\n  private _printError(err: Error) {\n    if (this.isLoggedError(err)) {\n      this.printEmptyLine();\n      this._print(util.inspect(err));\n    }\n  }\n\n  private _logContractAndFunctionName(\n    trace: MessageTrace | undefined,\n    code: Buffer,\n    {\n      printNonContractCalled = false,\n    }: { printNonContractCalled?: boolean } = {}\n  ) {\n    if (trace === undefined) {\n      return;\n    }\n\n    if (isPrecompileTrace(trace)) {\n      this._logWithTitle(\n        \"Precompile call\",\n        `<PrecompileContract ${trace.precompile}>`\n      );\n      return;\n    }\n\n    if (isCreateTrace(trace)) {\n      if (trace.bytecode === undefined) {\n        this._logWithTitle(\"Contract deployment\", UNRECOGNIZED_CONTRACT_NAME);\n      } else {\n        this._logWithTitle(\"Contract deployment\", trace.bytecode.contract.name);\n      }\n\n      if (trace.deployedContract !== undefined && trace.error === undefined) {\n        this._logWithTitle(\n          \"Contract address\",\n          bufferToHex(trace.deployedContract)\n        );\n      }\n\n      return;\n    }\n\n    if (code.length === 0) {\n      if (printNonContractCalled) {\n        this._log(`WARNING: Calling an account which is not a contract`);\n      }\n\n      return;\n    }\n\n    if (trace.bytecode === undefined) {\n      this._logWithTitle(\"Contract call\", UNRECOGNIZED_CONTRACT_NAME);\n      return;\n    }\n\n    const func = trace.bytecode.contract.getFunctionFromSelector(\n      trace.calldata.slice(0, 4)\n    );\n\n    const functionName: string =\n      func === undefined\n        ? UNRECOGNIZED_FUNCTION_NAME\n        : func.type === ContractFunctionType.FALLBACK\n        ? FALLBACK_FUNCTION_NAME\n        : func.type === ContractFunctionType.RECEIVE\n        ? RECEIVE_FUNCTION_NAME\n        : func.name;\n\n    this._logWithTitle(\n      \"Contract call\",\n      `${trace.bytecode.contract.name}#${functionName}`\n    );\n  }\n\n  private _shouldCollapseMethod(method: string) {\n    return (\n      method === this._methodBeingCollapsed &&\n      !this._hasLogs() &&\n      this._methodCollapsedCount > 0\n    );\n  }\n\n  private _startCollapsingMethod(method: string) {\n    this._methodBeingCollapsed = method;\n    this._methodCollapsedCount = 1;\n  }\n\n  private _stopCollapsingMethod() {\n    this._methodBeingCollapsed = undefined;\n    this._methodCollapsedCount = 0;\n  }\n\n  private _logTxTo(to: Buffer | undefined, trace?: MessageTrace) {\n    if (trace !== undefined && isCreateTrace(trace)) {\n      return;\n    }\n    if (to === undefined) {\n      // only for the type-checker, since `to` is undefined only when\n      // the message is a create trace\n      return;\n    }\n\n    const toString = bufferToHex(to);\n\n    this._logWithTitle(\"To\", toString);\n  }\n\n  private _logTxValue(value: bigint) {\n    this._logWithTitle(\"Value\", weiToHumanReadableString(value));\n  }\n\n  private _logTxFrom(from: Buffer) {\n    this._logWithTitle(\"From\", bufferToHex(from));\n  }\n\n  private _logBlockNumber(block: Block) {\n    this._log(`Block #${block.header.number}: ${bufferToHex(block.hash())}`);\n  }\n\n  private _logEmptyLineBetweenTransactions(\n    currentIndex: number,\n    totalTransactions: number\n  ) {\n    if (currentIndex + 1 < totalTransactions && totalTransactions > 1) {\n      this.logEmptyLine();\n    }\n  }\n\n  private _logBlockHash(block: Block) {\n    this._log(`Block: ${bufferToHex(block.hash())}`);\n  }\n\n  private _logConsoleLogMessages(messages: string[]) {\n    // This is a especial case, as we always want to print the console.log\n    // messages. The difference is how.\n    // If we have a logger, we should use that, so that logs are printed in\n    // order. If we don't, we just print the messages here.\n    if (!this._enabled) {\n      for (const msg of messages) {\n        this._printLine(msg);\n      }\n      return;\n    }\n\n    if (messages.length === 0) {\n      return;\n    }\n\n    this.logEmptyLine();\n    this._log(\"console.log:\");\n\n    for (const msg of messages) {\n      this._log(`  ${msg}`);\n    }\n  }\n\n  private _logWithTitle(title: string, message: string) {\n    title = this._indentSingleLine(title);\n\n    // We always use the max title length we've seen. Otherwise the value move\n    // a lot with each tx/call.\n    if (title.length > this._titleLength) {\n      this._titleLength = title.length;\n    }\n\n    this._logs.push([title, message]);\n  }\n\n  private _clearLogs() {\n    this._logs = [];\n  }\n\n  private _hasLogs(): boolean {\n    return this._logs.length > 0;\n  }\n\n  private _getLogs(): string[] {\n    return this._logs.map((l) => {\n      if (typeof l === \"string\") {\n        return l;\n      }\n\n      const title = `${l[0]}:`;\n\n      return `${title.padEnd(this._titleLength + 1)} ${l[1]}`;\n    });\n  }\n}\n"]},"metadata":{},"sourceType":"script","externalDependencies":[]}