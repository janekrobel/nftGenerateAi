{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.createSwcOptions = exports.targetMapping = exports.create = void 0;\nfunction create(createOptions) {\n  const {\n    swc,\n    service: {\n      config,\n      projectLocalResolveHelper\n    },\n    transpilerConfigLocalResolveHelper,\n    nodeModuleEmitKind\n  } = createOptions;\n  // Load swc compiler\n  let swcInstance;\n  // Used later in diagnostics; merely needs to be human-readable.\n  let swcDepName = 'swc';\n  if (typeof swc === 'string') {\n    swcDepName = swc;\n    swcInstance = require(transpilerConfigLocalResolveHelper(swc, true));\n  } else if (swc == null) {\n    let swcResolved;\n    try {\n      swcDepName = '@swc/core';\n      swcResolved = transpilerConfigLocalResolveHelper(swcDepName, true);\n    } catch (e) {\n      try {\n        swcDepName = '@swc/wasm';\n        swcResolved = transpilerConfigLocalResolveHelper(swcDepName, true);\n      } catch (e) {\n        throw new Error('swc compiler requires either @swc/core or @swc/wasm to be installed as a dependency.  See https://typestrong.org/ts-node/docs/transpilers');\n      }\n    }\n    swcInstance = require(swcResolved);\n  } else {\n    swcInstance = swc;\n  }\n  // Prepare SWC options derived from typescript compiler options\n  const {\n    nonTsxOptions,\n    tsxOptions\n  } = createSwcOptions(config.options, nodeModuleEmitKind, swcInstance, swcDepName);\n  const transpile = (input, transpileOptions) => {\n    const {\n      fileName\n    } = transpileOptions;\n    const swcOptions = fileName.endsWith('.tsx') || fileName.endsWith('.jsx') ? tsxOptions : nonTsxOptions;\n    const {\n      code,\n      map\n    } = swcInstance.transformSync(input, {\n      ...swcOptions,\n      filename: fileName\n    });\n    return {\n      outputText: code,\n      sourceMapText: map\n    };\n  };\n  return {\n    transpile\n  };\n}\nexports.create = create;\n/** @internal */\nexports.targetMapping = new Map();\nexports.targetMapping.set( /* ts.ScriptTarget.ES3 */0, 'es3');\nexports.targetMapping.set( /* ts.ScriptTarget.ES5 */1, 'es5');\nexports.targetMapping.set( /* ts.ScriptTarget.ES2015 */2, 'es2015');\nexports.targetMapping.set( /* ts.ScriptTarget.ES2016 */3, 'es2016');\nexports.targetMapping.set( /* ts.ScriptTarget.ES2017 */4, 'es2017');\nexports.targetMapping.set( /* ts.ScriptTarget.ES2018 */5, 'es2018');\nexports.targetMapping.set( /* ts.ScriptTarget.ES2019 */6, 'es2019');\nexports.targetMapping.set( /* ts.ScriptTarget.ES2020 */7, 'es2020');\nexports.targetMapping.set( /* ts.ScriptTarget.ES2021 */8, 'es2021');\nexports.targetMapping.set( /* ts.ScriptTarget.ES2022 */9, 'es2022');\nexports.targetMapping.set( /* ts.ScriptTarget.ESNext */99, 'es2022');\n/**\n * @internal\n * We use this list to downgrade to a prior target when we probe swc to detect if it supports a particular target\n */\nconst swcTargets = ['es3', 'es5', 'es2015', 'es2016', 'es2017', 'es2018', 'es2019', 'es2020', 'es2021', 'es2022'];\nconst ModuleKind = {\n  None: 0,\n  CommonJS: 1,\n  AMD: 2,\n  UMD: 3,\n  System: 4,\n  ES2015: 5,\n  ES2020: 6,\n  ESNext: 99,\n  Node16: 100,\n  NodeNext: 199\n};\nconst JsxEmit = {\n  ReactJSX: /* ts.JsxEmit.ReactJSX */4,\n  ReactJSXDev: /* ts.JsxEmit.ReactJSXDev */5\n};\n/**\n * Prepare SWC options derived from typescript compiler options.\n * @internal exported for testing\n */\nfunction createSwcOptions(compilerOptions, nodeModuleEmitKind, swcInstance, swcDepName) {\n  var _a;\n  const {\n    esModuleInterop,\n    sourceMap,\n    importHelpers,\n    experimentalDecorators,\n    emitDecoratorMetadata,\n    target,\n    module,\n    jsx,\n    jsxFactory,\n    jsxFragmentFactory,\n    strict,\n    alwaysStrict,\n    noImplicitUseStrict\n  } = compilerOptions;\n  let swcTarget = (_a = exports.targetMapping.get(target)) !== null && _a !== void 0 ? _a : 'es3';\n  // Downgrade to lower target if swc does not support the selected target.\n  // Perhaps project has an older version of swc.\n  // TODO cache the results of this; slightly faster\n  let swcTargetIndex = swcTargets.indexOf(swcTarget);\n  for (; swcTargetIndex >= 0; swcTargetIndex--) {\n    try {\n      swcInstance.transformSync('', {\n        jsc: {\n          target: swcTargets[swcTargetIndex]\n        }\n      });\n      break;\n    } catch (e) {}\n  }\n  swcTarget = swcTargets[swcTargetIndex];\n  const keepClassNames = target >= /* ts.ScriptTarget.ES2016 */3;\n  const isNodeModuleKind = module === ModuleKind.Node16 || module === ModuleKind.NodeNext;\n  // swc only supports these 4x module options [MUST_UPDATE_FOR_NEW_MODULEKIND]\n  const moduleType = module === ModuleKind.CommonJS ? 'commonjs' : module === ModuleKind.AMD ? 'amd' : module === ModuleKind.UMD ? 'umd' : isNodeModuleKind && nodeModuleEmitKind === 'nodecjs' ? 'commonjs' : isNodeModuleKind && nodeModuleEmitKind === 'nodeesm' ? 'es6' : 'es6';\n  // In swc:\n  //   strictMode means `\"use strict\"` is *always* emitted for non-ES module, *never* for ES module where it is assumed it can be omitted.\n  //   (this assumption is invalid, but that's the way swc behaves)\n  // tsc is a bit more complex:\n  //   alwaysStrict will force emitting it always unless `import`/`export` syntax is emitted which implies it per the JS spec.\n  //   if not alwaysStrict, will emit implicitly whenever module target is non-ES *and* transformed module syntax is emitted.\n  // For node, best option is to assume that all scripts are modules (commonjs or esm) and thus should get tsc's implicit strict behavior.\n  // Always set strictMode, *unless* alwaysStrict is disabled and noImplicitUseStrict is enabled\n  const strictMode =\n  // if `alwaysStrict` is disabled, remembering that `strict` defaults `alwaysStrict` to true\n  (alwaysStrict === false || alwaysStrict !== true && strict !== true) &&\n  // if noImplicitUseStrict is enabled\n  noImplicitUseStrict === true ? false : true;\n  const jsxRuntime = jsx === JsxEmit.ReactJSX || jsx === JsxEmit.ReactJSXDev ? 'automatic' : undefined;\n  const jsxDevelopment = jsx === JsxEmit.ReactJSXDev ? true : undefined;\n  const nonTsxOptions = createVariant(false);\n  const tsxOptions = createVariant(true);\n  return {\n    nonTsxOptions,\n    tsxOptions\n  };\n  function createVariant(isTsx) {\n    const swcOptions = {\n      sourceMaps: sourceMap,\n      // isModule: true,\n      module: moduleType ? {\n        noInterop: !esModuleInterop,\n        type: moduleType,\n        strictMode,\n        // For NodeNext and Node12, emit as CJS but do not transform dynamic imports\n        ignoreDynamic: nodeModuleEmitKind === 'nodecjs'\n      } : undefined,\n      swcrc: false,\n      jsc: {\n        externalHelpers: importHelpers,\n        parser: {\n          syntax: 'typescript',\n          tsx: isTsx,\n          decorators: experimentalDecorators,\n          dynamicImport: true,\n          importAssertions: true\n        },\n        target: swcTarget,\n        transform: {\n          decoratorMetadata: emitDecoratorMetadata,\n          legacyDecorator: true,\n          react: {\n            throwIfNamespace: false,\n            development: jsxDevelopment,\n            useBuiltins: false,\n            pragma: jsxFactory,\n            pragmaFrag: jsxFragmentFactory,\n            runtime: jsxRuntime\n          }\n        },\n        keepClassNames,\n        experimental: {\n          keepImportAssertions: true\n        }\n      }\n    };\n    // Throw a helpful error if swc version is old, for example, if it rejects `ignoreDynamic`\n    try {\n      swcInstance.transformSync('', swcOptions);\n    } catch (e) {\n      throw new Error(`${swcDepName} threw an error when attempting to validate swc compiler options.\\n` + 'You may be using an old version of swc which does not support the options used by ts-node.\\n' + 'Try upgrading to the latest version of swc.\\n' + 'Error message from swc:\\n' + (e === null || e === void 0 ? void 0 : e.message));\n    }\n    return swcOptions;\n  }\n}\nexports.createSwcOptions = createSwcOptions;","map":{"version":3,"mappings":"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","names":["create","createOptions","swc","service","config","projectLocalResolveHelper","transpilerConfigLocalResolveHelper","nodeModuleEmitKind","swcInstance","swcDepName","require","swcResolved","e","Error","nonTsxOptions","tsxOptions","createSwcOptions","options","transpile","input","transpileOptions","fileName","swcOptions","endsWith","code","map","transformSync","filename","outputText","sourceMapText","exports","Map","set","swcTargets","ModuleKind","None","CommonJS","AMD","UMD","System","ES2015","ES2020","ESNext","Node16","NodeNext","JsxEmit","ReactJSX","ReactJSXDev","compilerOptions","esModuleInterop","sourceMap","importHelpers","experimentalDecorators","emitDecoratorMetadata","target","module","jsx","jsxFactory","jsxFragmentFactory","strict","alwaysStrict","noImplicitUseStrict","swcTarget","get","swcTargetIndex","indexOf","jsc","keepClassNames","isNodeModuleKind","moduleType","strictMode","jsxRuntime","undefined","jsxDevelopment","createVariant","isTsx","sourceMaps","noInterop","type","ignoreDynamic","swcrc","externalHelpers","parser","syntax","tsx","decorators","dynamicImport","importAssertions","transform","decoratorMetadata","legacyDecorator","react","throwIfNamespace","development","useBuiltins","pragma","pragmaFrag","runtime","experimental","keepImportAssertions","message"],"sources":["/Users/janrobel/Documents/PersonalProjekty/nftGenerateAi/clientAndContract/node_modules/ts-node/src/transpilers/swc.ts"],"sourcesContent":["import type * as ts from 'typescript';\nimport type * as swcWasm from '@swc/wasm';\nimport type * as swcTypes from '@swc/core';\nimport type { CreateTranspilerOptions, Transpiler } from './types';\nimport type { NodeModuleEmitKind } from '..';\n\ntype SwcInstance = typeof swcWasm;\nexport interface SwcTranspilerOptions extends CreateTranspilerOptions {\n  /**\n   * swc compiler to use for compilation\n   * Set to '@swc/wasm' to use swc's WASM compiler\n   * Default: '@swc/core', falling back to '@swc/wasm'\n   */\n  swc?: string | typeof swcWasm;\n}\n\nexport function create(createOptions: SwcTranspilerOptions): Transpiler {\n  const {\n    swc,\n    service: { config, projectLocalResolveHelper },\n    transpilerConfigLocalResolveHelper,\n    nodeModuleEmitKind,\n  } = createOptions;\n\n  // Load swc compiler\n  let swcInstance: SwcInstance;\n  // Used later in diagnostics; merely needs to be human-readable.\n  let swcDepName: string = 'swc';\n  if (typeof swc === 'string') {\n    swcDepName = swc;\n    swcInstance = require(transpilerConfigLocalResolveHelper(\n      swc,\n      true\n    )) as typeof swcWasm;\n  } else if (swc == null) {\n    let swcResolved;\n    try {\n      swcDepName = '@swc/core';\n      swcResolved = transpilerConfigLocalResolveHelper(swcDepName, true);\n    } catch (e) {\n      try {\n        swcDepName = '@swc/wasm';\n        swcResolved = transpilerConfigLocalResolveHelper(swcDepName, true);\n      } catch (e) {\n        throw new Error(\n          'swc compiler requires either @swc/core or @swc/wasm to be installed as a dependency.  See https://typestrong.org/ts-node/docs/transpilers'\n        );\n      }\n    }\n    swcInstance = require(swcResolved) as typeof swcWasm;\n  } else {\n    swcInstance = swc;\n  }\n\n  // Prepare SWC options derived from typescript compiler options\n  const { nonTsxOptions, tsxOptions } = createSwcOptions(\n    config.options,\n    nodeModuleEmitKind,\n    swcInstance,\n    swcDepName\n  );\n\n  const transpile: Transpiler['transpile'] = (input, transpileOptions) => {\n    const { fileName } = transpileOptions;\n    const swcOptions =\n      fileName.endsWith('.tsx') || fileName.endsWith('.jsx')\n        ? tsxOptions\n        : nonTsxOptions;\n    const { code, map } = swcInstance.transformSync(input, {\n      ...swcOptions,\n      filename: fileName,\n    });\n    return { outputText: code, sourceMapText: map };\n  };\n\n  return {\n    transpile,\n  };\n}\n\n/** @internal */\nexport const targetMapping = new Map<ts.ScriptTarget, SwcTarget>();\ntargetMapping.set(/* ts.ScriptTarget.ES3 */ 0, 'es3');\ntargetMapping.set(/* ts.ScriptTarget.ES5 */ 1, 'es5');\ntargetMapping.set(/* ts.ScriptTarget.ES2015 */ 2, 'es2015');\ntargetMapping.set(/* ts.ScriptTarget.ES2016 */ 3, 'es2016');\ntargetMapping.set(/* ts.ScriptTarget.ES2017 */ 4, 'es2017');\ntargetMapping.set(/* ts.ScriptTarget.ES2018 */ 5, 'es2018');\ntargetMapping.set(/* ts.ScriptTarget.ES2019 */ 6, 'es2019');\ntargetMapping.set(/* ts.ScriptTarget.ES2020 */ 7, 'es2020');\ntargetMapping.set(/* ts.ScriptTarget.ES2021 */ 8, 'es2021');\ntargetMapping.set(/* ts.ScriptTarget.ES2022 */ 9, 'es2022');\ntargetMapping.set(/* ts.ScriptTarget.ESNext */ 99, 'es2022');\n\ntype SwcTarget = typeof swcTargets[number];\n/**\n * @internal\n * We use this list to downgrade to a prior target when we probe swc to detect if it supports a particular target\n */\nconst swcTargets = [\n  'es3',\n  'es5',\n  'es2015',\n  'es2016',\n  'es2017',\n  'es2018',\n  'es2019',\n  'es2020',\n  'es2021',\n  'es2022',\n] as const;\n\nconst ModuleKind = {\n  None: 0,\n  CommonJS: 1,\n  AMD: 2,\n  UMD: 3,\n  System: 4,\n  ES2015: 5,\n  ES2020: 6,\n  ESNext: 99,\n  Node16: 100,\n  NodeNext: 199,\n} as const;\n\nconst JsxEmit = {\n  ReactJSX: /* ts.JsxEmit.ReactJSX */ 4,\n  ReactJSXDev: /* ts.JsxEmit.ReactJSXDev */ 5,\n} as const;\n\n/**\n * Prepare SWC options derived from typescript compiler options.\n * @internal exported for testing\n */\nexport function createSwcOptions(\n  compilerOptions: ts.CompilerOptions,\n  nodeModuleEmitKind: NodeModuleEmitKind | undefined,\n  swcInstance: SwcInstance,\n  swcDepName: string\n) {\n  const {\n    esModuleInterop,\n    sourceMap,\n    importHelpers,\n    experimentalDecorators,\n    emitDecoratorMetadata,\n    target,\n    module,\n    jsx,\n    jsxFactory,\n    jsxFragmentFactory,\n    strict,\n    alwaysStrict,\n    noImplicitUseStrict,\n  } = compilerOptions;\n\n  let swcTarget = targetMapping.get(target!) ?? 'es3';\n  // Downgrade to lower target if swc does not support the selected target.\n  // Perhaps project has an older version of swc.\n  // TODO cache the results of this; slightly faster\n  let swcTargetIndex = swcTargets.indexOf(swcTarget);\n  for (; swcTargetIndex >= 0; swcTargetIndex--) {\n    try {\n      swcInstance.transformSync('', {\n        jsc: { target: swcTargets[swcTargetIndex] },\n      });\n      break;\n    } catch (e) {}\n  }\n  swcTarget = swcTargets[swcTargetIndex];\n  const keepClassNames = target! >= /* ts.ScriptTarget.ES2016 */ 3;\n  const isNodeModuleKind =\n    module === ModuleKind.Node16 || module === ModuleKind.NodeNext;\n  // swc only supports these 4x module options [MUST_UPDATE_FOR_NEW_MODULEKIND]\n  const moduleType =\n    module === ModuleKind.CommonJS\n      ? 'commonjs'\n      : module === ModuleKind.AMD\n      ? 'amd'\n      : module === ModuleKind.UMD\n      ? 'umd'\n      : isNodeModuleKind && nodeModuleEmitKind === 'nodecjs'\n      ? 'commonjs'\n      : isNodeModuleKind && nodeModuleEmitKind === 'nodeesm'\n      ? 'es6'\n      : 'es6';\n  // In swc:\n  //   strictMode means `\"use strict\"` is *always* emitted for non-ES module, *never* for ES module where it is assumed it can be omitted.\n  //   (this assumption is invalid, but that's the way swc behaves)\n  // tsc is a bit more complex:\n  //   alwaysStrict will force emitting it always unless `import`/`export` syntax is emitted which implies it per the JS spec.\n  //   if not alwaysStrict, will emit implicitly whenever module target is non-ES *and* transformed module syntax is emitted.\n  // For node, best option is to assume that all scripts are modules (commonjs or esm) and thus should get tsc's implicit strict behavior.\n\n  // Always set strictMode, *unless* alwaysStrict is disabled and noImplicitUseStrict is enabled\n  const strictMode =\n    // if `alwaysStrict` is disabled, remembering that `strict` defaults `alwaysStrict` to true\n    (alwaysStrict === false || (alwaysStrict !== true && strict !== true)) &&\n    // if noImplicitUseStrict is enabled\n    noImplicitUseStrict === true\n      ? false\n      : true;\n\n  const jsxRuntime: swcTypes.ReactConfig['runtime'] =\n    jsx === JsxEmit.ReactJSX || jsx === JsxEmit.ReactJSXDev\n      ? 'automatic'\n      : undefined;\n  const jsxDevelopment: swcTypes.ReactConfig['development'] =\n    jsx === JsxEmit.ReactJSXDev ? true : undefined;\n\n  const nonTsxOptions = createVariant(false);\n  const tsxOptions = createVariant(true);\n  return { nonTsxOptions, tsxOptions };\n\n  function createVariant(isTsx: boolean): swcTypes.Options {\n    const swcOptions: swcTypes.Options = {\n      sourceMaps: sourceMap,\n      // isModule: true,\n      module: moduleType\n        ? ({\n            noInterop: !esModuleInterop,\n            type: moduleType,\n            strictMode,\n            // For NodeNext and Node12, emit as CJS but do not transform dynamic imports\n            ignoreDynamic: nodeModuleEmitKind === 'nodecjs',\n          } as swcTypes.ModuleConfig)\n        : undefined,\n      swcrc: false,\n      jsc: {\n        externalHelpers: importHelpers,\n        parser: {\n          syntax: 'typescript',\n          tsx: isTsx,\n          decorators: experimentalDecorators,\n          dynamicImport: true,\n          importAssertions: true,\n        },\n        target: swcTarget,\n        transform: {\n          decoratorMetadata: emitDecoratorMetadata,\n          legacyDecorator: true,\n          react: {\n            throwIfNamespace: false,\n            development: jsxDevelopment,\n            useBuiltins: false,\n            pragma: jsxFactory!,\n            pragmaFrag: jsxFragmentFactory!,\n            runtime: jsxRuntime,\n          } as swcTypes.ReactConfig,\n        },\n        keepClassNames,\n        experimental: {\n          keepImportAssertions: true,\n        },\n      } as swcTypes.JscConfig,\n    };\n\n    // Throw a helpful error if swc version is old, for example, if it rejects `ignoreDynamic`\n    try {\n      swcInstance.transformSync('', swcOptions);\n    } catch (e) {\n      throw new Error(\n        `${swcDepName} threw an error when attempting to validate swc compiler options.\\n` +\n          'You may be using an old version of swc which does not support the options used by ts-node.\\n' +\n          'Try upgrading to the latest version of swc.\\n' +\n          'Error message from swc:\\n' +\n          (e as Error)?.message\n      );\n    }\n\n    return swcOptions;\n  }\n}\n"]},"metadata":{},"sourceType":"script","externalDependencies":[]}