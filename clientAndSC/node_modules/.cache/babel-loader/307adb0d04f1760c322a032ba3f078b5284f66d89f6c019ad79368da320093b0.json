{"ast":null,"code":"\"use strict\";\n\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  Object.defineProperty(o, k2, {\n    enumerable: true,\n    get: function () {\n      return m[k];\n    }\n  });\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, \"default\", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o[\"default\"] = v;\n});\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n  __setModuleDefault(result, mod);\n  return result;\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.validateResolvedConfig = exports.getValidationErrors = exports.validateConfig = exports.decimalString = exports.address = exports.hexString = exports.DotPathReporter = exports.success = exports.failure = void 0;\nconst t = __importStar(require(\"io-ts\"));\nconst lib_1 = require(\"io-ts/lib\");\nconst constants_1 = require(\"../../constants\");\nconst io_ts_1 = require(\"../../util/io-ts\");\nconst lang_1 = require(\"../../util/lang\");\nconst errors_1 = require(\"../errors\");\nconst errors_list_1 = require(\"../errors-list\");\nconst hardforks_1 = require(\"../../util/hardforks\");\nconst default_config_1 = require(\"./default-config\");\nfunction stringify(v) {\n  if (typeof v === \"function\") {\n    return (0, lib_1.getFunctionName)(v);\n  }\n  if (typeof v === \"number\" && !isFinite(v)) {\n    if (isNaN(v)) {\n      return \"NaN\";\n    }\n    return v > 0 ? \"Infinity\" : \"-Infinity\";\n  }\n  return JSON.stringify(v);\n}\nfunction getContextPath(context) {\n  const keysPath = context.slice(1).map(c => c.key).join(\".\");\n  return `${context[0].type.name}.${keysPath}`;\n}\nfunction getMessage(e) {\n  const lastContext = e.context[e.context.length - 1];\n  return e.message !== undefined ? e.message : getErrorMessage(getContextPath(e.context), e.value, lastContext.type.name);\n}\nfunction getErrorMessage(path, value, expectedType) {\n  return `Invalid value ${stringify(value)} for ${path} - Expected a value of type ${expectedType}.`;\n}\nfunction getPrivateKeyError(index, network, message) {\n  return `Invalid account: #${index} for network: ${network} - ${message}`;\n}\nfunction validatePrivateKey(privateKey, index, network, errors) {\n  if (typeof privateKey !== \"string\") {\n    errors.push(getPrivateKeyError(index, network, `Expected string, received ${typeof privateKey}`));\n  } else {\n    // private key validation\n    const pkWithPrefix = /^0x/.test(privateKey) ? privateKey : `0x${privateKey}`;\n    // 32 bytes = 64 characters + 2 char prefix = 66\n    if (pkWithPrefix.length < 66) {\n      errors.push(getPrivateKeyError(index, network, \"private key too short, expected 32 bytes\"));\n    } else if (pkWithPrefix.length > 66) {\n      errors.push(getPrivateKeyError(index, network, \"private key too long, expected 32 bytes\"));\n    } else if (exports.hexString.decode(pkWithPrefix).isLeft()) {\n      errors.push(getPrivateKeyError(index, network, \"invalid hex character(s) found in string\"));\n    }\n  }\n}\nfunction failure(es) {\n  return es.map(getMessage);\n}\nexports.failure = failure;\nfunction success() {\n  return [];\n}\nexports.success = success;\nexports.DotPathReporter = {\n  report: validation => validation.fold(failure, success)\n};\nconst HEX_STRING_REGEX = /^(0x)?([0-9a-f]{2})+$/gi;\nconst DEC_STRING_REGEX = /^(0|[1-9][0-9]*)$/g;\nfunction isHexString(v) {\n  if (typeof v !== \"string\") {\n    return false;\n  }\n  return v.trim().match(HEX_STRING_REGEX) !== null;\n}\nfunction isDecimalString(v) {\n  if (typeof v !== \"string\") {\n    return false;\n  }\n  return v.match(DEC_STRING_REGEX) !== null;\n}\nexports.hexString = new t.Type(\"hex string\", isHexString, (u, c) => isHexString(u) ? t.success(u) : t.failure(u, c), t.identity);\nfunction isAddress(v) {\n  if (typeof v !== \"string\") {\n    return false;\n  }\n  const trimmed = v.trim();\n  return trimmed.match(HEX_STRING_REGEX) !== null && trimmed.startsWith(\"0x\") && trimmed.length === 42;\n}\nexports.address = new t.Type(\"address\", isAddress, (u, c) => isAddress(u) ? t.success(u) : t.failure(u, c), t.identity);\nexports.decimalString = new t.Type(\"decimal string\", isDecimalString, (u, c) => isDecimalString(u) ? t.success(u) : t.failure(u, c), t.identity);\n// TODO: These types have outdated name. They should match the UserConfig types.\n// IMPORTANT: This t.types MUST be kept in sync with the actual types.\nconst HardhatNetworkAccount = t.type({\n  privateKey: exports.hexString,\n  balance: exports.decimalString\n});\nconst commonHDAccountsFields = {\n  initialIndex: (0, io_ts_1.optional)(t.number),\n  count: (0, io_ts_1.optional)(t.number),\n  path: (0, io_ts_1.optional)(t.string)\n};\nconst HardhatNetworkHDAccountsConfig = t.type({\n  mnemonic: (0, io_ts_1.optional)(t.string),\n  accountsBalance: (0, io_ts_1.optional)(exports.decimalString),\n  passphrase: (0, io_ts_1.optional)(t.string),\n  ...commonHDAccountsFields\n});\nconst Integer = new t.Type(\"Integer\", num => typeof num === \"number\", (u, c) => {\n  try {\n    return typeof u === \"string\" ? t.success(parseInt(u, 10)) : t.failure(u, c);\n  } catch {\n    return t.failure(u, c);\n  }\n}, t.identity);\nconst HardhatNetworkForkingConfig = t.type({\n  enabled: (0, io_ts_1.optional)(t.boolean),\n  url: t.string,\n  blockNumber: (0, io_ts_1.optional)(t.number)\n});\nconst HardhatNetworkMempoolConfig = t.type({\n  order: (0, io_ts_1.optional)(t.keyof((0, lang_1.fromEntries)(constants_1.HARDHAT_MEMPOOL_SUPPORTED_ORDERS.map(order => [order, null]))))\n});\nconst HardhatNetworkMiningConfig = t.type({\n  auto: (0, io_ts_1.optional)(t.boolean),\n  interval: (0, io_ts_1.optional)(t.union([t.number, t.tuple([t.number, t.number])])),\n  mempool: (0, io_ts_1.optional)(HardhatNetworkMempoolConfig)\n});\nfunction isValidHardforkName(name) {\n  return Object.values(hardforks_1.HardforkName).includes(name);\n}\nconst HardforkNameType = new t.Type(Object.values(hardforks_1.HardforkName).map(v => `\"${v}\"`).join(\" | \"), name => typeof name === \"string\" && isValidHardforkName(name), (u, c) => {\n  return typeof u === \"string\" && isValidHardforkName(u) ? t.success(u) : t.failure(u, c);\n}, t.identity);\nconst HardhatNetworkHardforkHistory = t.record(HardforkNameType, t.number, \"HardhatNetworkHardforkHistory\");\nconst HardhatNetworkChainConfig = t.type({\n  hardforkHistory: HardhatNetworkHardforkHistory\n});\nconst HardhatNetworkChainsConfig = t.record(Integer, HardhatNetworkChainConfig);\nconst commonNetworkConfigFields = {\n  chainId: (0, io_ts_1.optional)(t.number),\n  from: (0, io_ts_1.optional)(t.string),\n  gas: (0, io_ts_1.optional)(t.union([t.literal(\"auto\"), t.number])),\n  gasPrice: (0, io_ts_1.optional)(t.union([t.literal(\"auto\"), t.number])),\n  gasMultiplier: (0, io_ts_1.optional)(t.number)\n};\nconst HardhatNetworkConfig = t.type({\n  ...commonNetworkConfigFields,\n  hardfork: (0, io_ts_1.optional)(t.keyof((0, lang_1.fromEntries)(constants_1.HARDHAT_NETWORK_SUPPORTED_HARDFORKS.map(hf => [hf, null])))),\n  accounts: (0, io_ts_1.optional)(t.union([t.array(HardhatNetworkAccount), HardhatNetworkHDAccountsConfig])),\n  blockGasLimit: (0, io_ts_1.optional)(t.number),\n  minGasPrice: (0, io_ts_1.optional)(t.union([t.number, t.string])),\n  throwOnTransactionFailures: (0, io_ts_1.optional)(t.boolean),\n  throwOnCallFailures: (0, io_ts_1.optional)(t.boolean),\n  allowUnlimitedContractSize: (0, io_ts_1.optional)(t.boolean),\n  initialDate: (0, io_ts_1.optional)(t.string),\n  loggingEnabled: (0, io_ts_1.optional)(t.boolean),\n  forking: (0, io_ts_1.optional)(HardhatNetworkForkingConfig),\n  mining: (0, io_ts_1.optional)(HardhatNetworkMiningConfig),\n  coinbase: (0, io_ts_1.optional)(exports.address),\n  chains: (0, io_ts_1.optional)(HardhatNetworkChainsConfig)\n});\nconst HDAccountsConfig = t.type({\n  mnemonic: t.string,\n  passphrase: (0, io_ts_1.optional)(t.string),\n  ...commonHDAccountsFields\n});\nconst NetworkConfigAccounts = t.union([t.literal(\"remote\"), t.array(exports.hexString), HDAccountsConfig]);\nconst HttpHeaders = t.record(t.string, t.string, \"httpHeaders\");\nconst HttpNetworkConfig = t.type({\n  ...commonNetworkConfigFields,\n  url: (0, io_ts_1.optional)(t.string),\n  accounts: (0, io_ts_1.optional)(NetworkConfigAccounts),\n  httpHeaders: (0, io_ts_1.optional)(HttpHeaders),\n  timeout: (0, io_ts_1.optional)(t.number)\n});\nconst NetworkConfig = t.union([HardhatNetworkConfig, HttpNetworkConfig]);\nconst Networks = t.record(t.string, NetworkConfig);\nconst ProjectPaths = t.type({\n  root: (0, io_ts_1.optional)(t.string),\n  cache: (0, io_ts_1.optional)(t.string),\n  artifacts: (0, io_ts_1.optional)(t.string),\n  sources: (0, io_ts_1.optional)(t.string),\n  tests: (0, io_ts_1.optional)(t.string)\n});\nconst SingleSolcConfig = t.type({\n  version: t.string,\n  settings: (0, io_ts_1.optional)(t.any)\n});\nconst MultiSolcConfig = t.type({\n  compilers: t.array(SingleSolcConfig),\n  overrides: (0, io_ts_1.optional)(t.record(t.string, SingleSolcConfig))\n});\nconst SolidityConfig = t.union([t.string, SingleSolcConfig, MultiSolcConfig]);\nconst HardhatConfig = t.type({\n  defaultNetwork: (0, io_ts_1.optional)(t.string),\n  networks: (0, io_ts_1.optional)(Networks),\n  paths: (0, io_ts_1.optional)(ProjectPaths),\n  solidity: (0, io_ts_1.optional)(SolidityConfig)\n}, \"HardhatConfig\");\n/**\n * Validates the config, throwing a HardhatError if invalid.\n * @param config\n */\nfunction validateConfig(config) {\n  const errors = getValidationErrors(config);\n  if (errors.length === 0) {\n    return;\n  }\n  let errorList = errors.join(\"\\n  * \");\n  errorList = `  * ${errorList}`;\n  throw new errors_1.HardhatError(errors_list_1.ERRORS.GENERAL.INVALID_CONFIG, {\n    errors: errorList\n  });\n}\nexports.validateConfig = validateConfig;\nfunction getValidationErrors(config) {\n  const errors = [];\n  // These can't be validated with io-ts\n  if (config !== undefined && typeof config.networks === \"object\") {\n    const hardhatNetwork = config.networks[constants_1.HARDHAT_NETWORK_NAME];\n    if (hardhatNetwork !== undefined && typeof hardhatNetwork === \"object\") {\n      if (\"url\" in hardhatNetwork) {\n        errors.push(`HardhatConfig.networks.${constants_1.HARDHAT_NETWORK_NAME} can't have an url`);\n      }\n      // Validating the accounts with io-ts leads to very confusing errors messages\n      const {\n        accounts,\n        ...configExceptAccounts\n      } = hardhatNetwork;\n      const netConfigResult = HardhatNetworkConfig.decode(configExceptAccounts);\n      if (netConfigResult.isLeft()) {\n        errors.push(getErrorMessage(`HardhatConfig.networks.${constants_1.HARDHAT_NETWORK_NAME}`, hardhatNetwork, \"HardhatNetworkConfig\"));\n      }\n      // manual validation of accounts\n      if (Array.isArray(accounts)) {\n        for (const [index, account] of accounts.entries()) {\n          if (typeof account !== \"object\") {\n            errors.push(getPrivateKeyError(index, constants_1.HARDHAT_NETWORK_NAME, `Expected object, received ${typeof account}`));\n            continue;\n          }\n          const {\n            privateKey,\n            balance\n          } = account;\n          validatePrivateKey(privateKey, index, constants_1.HARDHAT_NETWORK_NAME, errors);\n          if (typeof balance !== \"string\") {\n            errors.push(getErrorMessage(`HardhatConfig.networks.${constants_1.HARDHAT_NETWORK_NAME}.accounts[].balance`, balance, \"string\"));\n          } else if (exports.decimalString.decode(balance).isLeft()) {\n            errors.push(getErrorMessage(`HardhatConfig.networks.${constants_1.HARDHAT_NETWORK_NAME}.accounts[].balance`, balance, \"decimal(wei)\"));\n          }\n        }\n      } else if (typeof hardhatNetwork.accounts === \"object\") {\n        const hdConfigResult = HardhatNetworkHDAccountsConfig.decode(hardhatNetwork.accounts);\n        if (hdConfigResult.isLeft()) {\n          errors.push(getErrorMessage(`HardhatConfig.networks.${constants_1.HARDHAT_NETWORK_NAME}.accounts`, hardhatNetwork.accounts, \"[{privateKey: string, balance: string}] | HardhatNetworkHDAccountsConfig | undefined\"));\n        }\n      } else if (hardhatNetwork.accounts !== undefined) {\n        errors.push(getErrorMessage(`HardhatConfig.networks.${constants_1.HARDHAT_NETWORK_NAME}.accounts`, hardhatNetwork.accounts, \"[{privateKey: string, balance: string}] | HardhatNetworkHDAccountsConfig | undefined\"));\n      }\n      const hardfork = hardhatNetwork.hardfork ?? default_config_1.defaultHardhatNetworkParams.hardfork;\n      if ((0, hardforks_1.hardforkGte)(hardfork, hardforks_1.HardforkName.LONDON)) {\n        if (hardhatNetwork.minGasPrice !== undefined) {\n          errors.push(`Unexpected config HardhatConfig.networks.${constants_1.HARDHAT_NETWORK_NAME}.minGasPrice found - This field is not valid for networks with EIP-1559. Try an older hardfork or remove it.`);\n        }\n      } else {\n        if (hardhatNetwork.initialBaseFeePerGas !== undefined) {\n          errors.push(`Unexpected config HardhatConfig.networks.${constants_1.HARDHAT_NETWORK_NAME}.initialBaseFeePerGas found - This field is only valid for networks with EIP-1559. Try a newer hardfork or remove it.`);\n        }\n      }\n      if (hardhatNetwork.chains !== undefined) {\n        Object.entries(hardhatNetwork.chains).forEach(chainEntry => {\n          const [chainId, chainConfig] = chainEntry;\n          const {\n            hardforkHistory\n          } = chainConfig;\n          if (hardforkHistory !== undefined) {\n            Object.keys(hardforkHistory).forEach(hardforkName => {\n              if (!constants_1.HARDHAT_NETWORK_SUPPORTED_HARDFORKS.includes(hardforkName)) {\n                errors.push(getErrorMessage(`HardhatConfig.networks.${constants_1.HARDHAT_NETWORK_NAME}.chains[${chainId}].hardforkHistory`, hardforkName, `\"${constants_1.HARDHAT_NETWORK_SUPPORTED_HARDFORKS.join('\" | \"')}\"`));\n              }\n            });\n          }\n        });\n      }\n    }\n    for (const [networkName, netConfig] of Object.entries(config.networks)) {\n      if (networkName === constants_1.HARDHAT_NETWORK_NAME) {\n        continue;\n      }\n      if (networkName !== \"localhost\" || netConfig.url !== undefined) {\n        if (typeof netConfig.url !== \"string\") {\n          errors.push(getErrorMessage(`HardhatConfig.networks.${networkName}.url`, netConfig.url, \"string\"));\n        }\n      }\n      const {\n        accounts,\n        ...configExceptAccounts\n      } = netConfig;\n      const netConfigResult = HttpNetworkConfig.decode(configExceptAccounts);\n      if (netConfigResult.isLeft()) {\n        errors.push(getErrorMessage(`HardhatConfig.networks.${networkName}`, netConfig, \"HttpNetworkConfig\"));\n      }\n      // manual validation of accounts\n      if (Array.isArray(accounts)) {\n        accounts.forEach((privateKey, index) => validatePrivateKey(privateKey, index, networkName, errors));\n      } else if (typeof accounts === \"object\") {\n        const hdConfigResult = HDAccountsConfig.decode(accounts);\n        if (hdConfigResult.isLeft()) {\n          errors.push(getErrorMessage(`HardhatConfig.networks.${networkName}`, accounts, \"HttpNetworkHDAccountsConfig\"));\n        }\n      } else if (typeof accounts === \"string\") {\n        if (accounts !== \"remote\") {\n          errors.push(`Invalid 'accounts' entry for network '${networkName}': expected an array of accounts or the string 'remote', but got the string '${accounts}'`);\n        }\n      } else if (accounts !== undefined) {\n        errors.push(getErrorMessage(`HardhatConfig.networks.${networkName}.accounts`, accounts, '\"remote\" | string[] | HttpNetworkHDAccountsConfig | undefined'));\n      }\n    }\n  }\n  // io-ts can get confused if there are errors that it can't understand.\n  // Especially around Hardhat Network's config. It will treat it as an HTTPConfig,\n  // and may give a loot of errors.\n  if (errors.length > 0) {\n    return errors;\n  }\n  const result = HardhatConfig.decode(config);\n  if (result.isRight()) {\n    return errors;\n  }\n  const ioTsErrors = exports.DotPathReporter.report(result);\n  return [...errors, ...ioTsErrors];\n}\nexports.getValidationErrors = getValidationErrors;\nfunction validateResolvedConfig(resolvedConfig) {\n  const solcConfigs = [...resolvedConfig.solidity.compilers, ...Object.values(resolvedConfig.solidity.overrides)];\n  const runs = solcConfigs.filter(_ref => {\n    let {\n      settings\n    } = _ref;\n    return settings?.optimizer?.runs !== undefined;\n  }).map(_ref2 => {\n    let {\n      settings\n    } = _ref2;\n    return settings?.optimizer?.runs;\n  });\n  for (const run of runs) {\n    if (run >= 2 ** 32) {\n      throw new errors_1.HardhatError(errors_list_1.ERRORS.GENERAL.INVALID_CONFIG, {\n        errors: \"The number of optimizer runs exceeds the maximum of 2**32 - 1\"\n      });\n    }\n  }\n}\nexports.validateResolvedConfig = validateResolvedConfig;","map":{"version":3,"mappings":"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","names":["stringify","v","isFinite","isNaN","JSON","getContextPath","context","keysPath","slice","map","c","key","join","type","name","getMessage","e","lastContext","length","message","undefined","getErrorMessage","value","path","expectedType","getPrivateKeyError","index","network","validatePrivateKey","privateKey","errors","push","pkWithPrefix","test","exports","decode","isLeft","failure","es","success","report","validation","fold","HEX_STRING_REGEX","DEC_STRING_REGEX","isHexString","trim","match","isDecimalString","t","Type","u","identity","isAddress","trimmed","startsWith","HardhatNetworkAccount","balance","commonHDAccountsFields","initialIndex","number","count","string","HardhatNetworkHDAccountsConfig","mnemonic","accountsBalance","passphrase","Integer","num","parseInt","HardhatNetworkForkingConfig","enabled","boolean","url","blockNumber","HardhatNetworkMempoolConfig","order","keyof","constants_1","HardhatNetworkMiningConfig","auto","interval","union","tuple","mempool","isValidHardforkName","Object","values","hardforks_1","includes","HardforkNameType","HardhatNetworkHardforkHistory","record","HardhatNetworkChainConfig","hardforkHistory","HardhatNetworkChainsConfig","commonNetworkConfigFields","chainId","from","gas","literal","gasPrice","gasMultiplier","HardhatNetworkConfig","hardfork","hf","accounts","array","blockGasLimit","minGasPrice","throwOnTransactionFailures","throwOnCallFailures","allowUnlimitedContractSize","initialDate","loggingEnabled","forking","mining","coinbase","chains","HDAccountsConfig","NetworkConfigAccounts","HttpHeaders","HttpNetworkConfig","httpHeaders","timeout","NetworkConfig","Networks","ProjectPaths","root","cache","artifacts","sources","tests","SingleSolcConfig","version","settings","any","MultiSolcConfig","compilers","overrides","SolidityConfig","HardhatConfig","defaultNetwork","networks","paths","solidity","validateConfig","config","getValidationErrors","errorList","errors_1","errors_list_1","GENERAL","INVALID_CONFIG","hardhatNetwork","configExceptAccounts","netConfigResult","Array","isArray","account","entries","hdConfigResult","default_config_1","LONDON","initialBaseFeePerGas","forEach","chainEntry","chainConfig","keys","hardforkName","networkName","netConfig","result","isRight","ioTsErrors","validateResolvedConfig","resolvedConfig","solcConfigs","runs","filter","optimizer","run"],"sources":["/Users/janrobel/Documents/PersonalProjekty/nftGenerateAi/clientAndContract/node_modules/hardhat/src/internal/core/config/config-validation.ts"],"sourcesContent":["import type { HardhatConfig as HardhatConfigT } from \"../../../types\";\n\nimport * as t from \"io-ts\";\nimport { Context, getFunctionName, ValidationError } from \"io-ts/lib\";\nimport { Reporter } from \"io-ts/lib/Reporter\";\n\nimport {\n  HARDHAT_MEMPOOL_SUPPORTED_ORDERS,\n  HARDHAT_NETWORK_NAME,\n  HARDHAT_NETWORK_SUPPORTED_HARDFORKS,\n} from \"../../constants\";\nimport { optional } from \"../../util/io-ts\";\nimport { fromEntries } from \"../../util/lang\";\nimport { HardhatError } from \"../errors\";\nimport { ERRORS } from \"../errors-list\";\nimport { hardforkGte, HardforkName } from \"../../util/hardforks\";\nimport { HardhatNetworkChainUserConfig } from \"../../../types/config\";\nimport { defaultHardhatNetworkParams } from \"./default-config\";\n\nfunction stringify(v: any): string {\n  if (typeof v === \"function\") {\n    return getFunctionName(v);\n  }\n  if (typeof v === \"number\" && !isFinite(v)) {\n    if (isNaN(v)) {\n      return \"NaN\";\n    }\n    return v > 0 ? \"Infinity\" : \"-Infinity\";\n  }\n  return JSON.stringify(v);\n}\n\nfunction getContextPath(context: Context): string {\n  const keysPath = context\n    .slice(1)\n    .map((c) => c.key)\n    .join(\".\");\n\n  return `${context[0].type.name}.${keysPath}`;\n}\n\nfunction getMessage(e: ValidationError): string {\n  const lastContext = e.context[e.context.length - 1];\n\n  return e.message !== undefined\n    ? e.message\n    : getErrorMessage(\n        getContextPath(e.context),\n        e.value,\n        lastContext.type.name\n      );\n}\n\nfunction getErrorMessage(path: string, value: any, expectedType: string) {\n  return `Invalid value ${stringify(\n    value\n  )} for ${path} - Expected a value of type ${expectedType}.`;\n}\n\nfunction getPrivateKeyError(index: number, network: string, message: string) {\n  return `Invalid account: #${index} for network: ${network} - ${message}`;\n}\n\nfunction validatePrivateKey(\n  privateKey: unknown,\n  index: number,\n  network: string,\n  errors: string[]\n) {\n  if (typeof privateKey !== \"string\") {\n    errors.push(\n      getPrivateKeyError(\n        index,\n        network,\n        `Expected string, received ${typeof privateKey}`\n      )\n    );\n  } else {\n    // private key validation\n    const pkWithPrefix = /^0x/.test(privateKey)\n      ? privateKey\n      : `0x${privateKey}`;\n\n    // 32 bytes = 64 characters + 2 char prefix = 66\n    if (pkWithPrefix.length < 66) {\n      errors.push(\n        getPrivateKeyError(\n          index,\n          network,\n          \"private key too short, expected 32 bytes\"\n        )\n      );\n    } else if (pkWithPrefix.length > 66) {\n      errors.push(\n        getPrivateKeyError(\n          index,\n          network,\n          \"private key too long, expected 32 bytes\"\n        )\n      );\n    } else if (hexString.decode(pkWithPrefix).isLeft()) {\n      errors.push(\n        getPrivateKeyError(\n          index,\n          network,\n          \"invalid hex character(s) found in string\"\n        )\n      );\n    }\n  }\n}\n\nexport function failure(es: ValidationError[]): string[] {\n  return es.map(getMessage);\n}\n\nexport function success(): string[] {\n  return [];\n}\n\nexport const DotPathReporter: Reporter<string[]> = {\n  report: (validation) => validation.fold(failure, success),\n};\n\nconst HEX_STRING_REGEX = /^(0x)?([0-9a-f]{2})+$/gi;\nconst DEC_STRING_REGEX = /^(0|[1-9][0-9]*)$/g;\n\nfunction isHexString(v: unknown): v is string {\n  if (typeof v !== \"string\") {\n    return false;\n  }\n\n  return v.trim().match(HEX_STRING_REGEX) !== null;\n}\n\nfunction isDecimalString(v: unknown): v is string {\n  if (typeof v !== \"string\") {\n    return false;\n  }\n\n  return v.match(DEC_STRING_REGEX) !== null;\n}\n\nexport const hexString = new t.Type<string>(\n  \"hex string\",\n  isHexString,\n  (u, c) => (isHexString(u) ? t.success(u) : t.failure(u, c)),\n  t.identity\n);\n\nfunction isAddress(v: unknown): v is string {\n  if (typeof v !== \"string\") {\n    return false;\n  }\n\n  const trimmed = v.trim();\n\n  return (\n    trimmed.match(HEX_STRING_REGEX) !== null &&\n    trimmed.startsWith(\"0x\") &&\n    trimmed.length === 42\n  );\n}\n\nexport const address = new t.Type<string>(\n  \"address\",\n  isAddress,\n  (u, c) => (isAddress(u) ? t.success(u) : t.failure(u, c)),\n  t.identity\n);\n\nexport const decimalString = new t.Type<string>(\n  \"decimal string\",\n  isDecimalString,\n  (u, c) => (isDecimalString(u) ? t.success(u) : t.failure(u, c)),\n  t.identity\n);\n// TODO: These types have outdated name. They should match the UserConfig types.\n// IMPORTANT: This t.types MUST be kept in sync with the actual types.\n\nconst HardhatNetworkAccount = t.type({\n  privateKey: hexString,\n  balance: decimalString,\n});\n\nconst commonHDAccountsFields = {\n  initialIndex: optional(t.number),\n  count: optional(t.number),\n  path: optional(t.string),\n};\n\nconst HardhatNetworkHDAccountsConfig = t.type({\n  mnemonic: optional(t.string),\n  accountsBalance: optional(decimalString),\n  passphrase: optional(t.string),\n  ...commonHDAccountsFields,\n});\n\nconst Integer = new t.Type<number>(\n  \"Integer\",\n  (num: unknown): num is number => typeof num === \"number\",\n  (u, c) => {\n    try {\n      return typeof u === \"string\"\n        ? t.success(parseInt(u, 10))\n        : t.failure(u, c);\n    } catch {\n      return t.failure(u, c);\n    }\n  },\n  t.identity\n);\n\nconst HardhatNetworkForkingConfig = t.type({\n  enabled: optional(t.boolean),\n  url: t.string,\n  blockNumber: optional(t.number),\n});\n\nconst HardhatNetworkMempoolConfig = t.type({\n  order: optional(\n    t.keyof(\n      fromEntries(\n        HARDHAT_MEMPOOL_SUPPORTED_ORDERS.map((order) => [order, null])\n      )\n    )\n  ),\n});\n\nconst HardhatNetworkMiningConfig = t.type({\n  auto: optional(t.boolean),\n  interval: optional(t.union([t.number, t.tuple([t.number, t.number])])),\n  mempool: optional(HardhatNetworkMempoolConfig),\n});\n\nfunction isValidHardforkName(name: string) {\n  return Object.values(HardforkName).includes(name as HardforkName);\n}\n\nconst HardforkNameType = new t.Type<HardforkName>(\n  Object.values(HardforkName)\n    .map((v) => `\"${v}\"`)\n    .join(\" | \"),\n  (name: unknown): name is HardforkName =>\n    typeof name === \"string\" && isValidHardforkName(name),\n  (u, c) => {\n    return typeof u === \"string\" && isValidHardforkName(u)\n      ? t.success(u as HardforkName)\n      : t.failure(u, c);\n  },\n  t.identity\n);\n\nconst HardhatNetworkHardforkHistory = t.record(\n  HardforkNameType,\n  t.number,\n  \"HardhatNetworkHardforkHistory\"\n);\n\nconst HardhatNetworkChainConfig = t.type({\n  hardforkHistory: HardhatNetworkHardforkHistory,\n});\n\nconst HardhatNetworkChainsConfig = t.record(Integer, HardhatNetworkChainConfig);\n\nconst commonNetworkConfigFields = {\n  chainId: optional(t.number),\n  from: optional(t.string),\n  gas: optional(t.union([t.literal(\"auto\"), t.number])),\n  gasPrice: optional(t.union([t.literal(\"auto\"), t.number])),\n  gasMultiplier: optional(t.number),\n};\n\nconst HardhatNetworkConfig = t.type({\n  ...commonNetworkConfigFields,\n  hardfork: optional(\n    t.keyof(\n      fromEntries(HARDHAT_NETWORK_SUPPORTED_HARDFORKS.map((hf) => [hf, null]))\n    )\n  ),\n  accounts: optional(\n    t.union([t.array(HardhatNetworkAccount), HardhatNetworkHDAccountsConfig])\n  ),\n  blockGasLimit: optional(t.number),\n  minGasPrice: optional(t.union([t.number, t.string])),\n  throwOnTransactionFailures: optional(t.boolean),\n  throwOnCallFailures: optional(t.boolean),\n  allowUnlimitedContractSize: optional(t.boolean),\n  initialDate: optional(t.string),\n  loggingEnabled: optional(t.boolean),\n  forking: optional(HardhatNetworkForkingConfig),\n  mining: optional(HardhatNetworkMiningConfig),\n  coinbase: optional(address),\n  chains: optional(HardhatNetworkChainsConfig),\n});\n\nconst HDAccountsConfig = t.type({\n  mnemonic: t.string,\n  passphrase: optional(t.string),\n  ...commonHDAccountsFields,\n});\n\nconst NetworkConfigAccounts = t.union([\n  t.literal(\"remote\"),\n  t.array(hexString),\n  HDAccountsConfig,\n]);\n\nconst HttpHeaders = t.record(t.string, t.string, \"httpHeaders\");\n\nconst HttpNetworkConfig = t.type({\n  ...commonNetworkConfigFields,\n  url: optional(t.string),\n  accounts: optional(NetworkConfigAccounts),\n  httpHeaders: optional(HttpHeaders),\n  timeout: optional(t.number),\n});\n\nconst NetworkConfig = t.union([HardhatNetworkConfig, HttpNetworkConfig]);\n\nconst Networks = t.record(t.string, NetworkConfig);\n\nconst ProjectPaths = t.type({\n  root: optional(t.string),\n  cache: optional(t.string),\n  artifacts: optional(t.string),\n  sources: optional(t.string),\n  tests: optional(t.string),\n});\n\nconst SingleSolcConfig = t.type({\n  version: t.string,\n  settings: optional(t.any),\n});\n\nconst MultiSolcConfig = t.type({\n  compilers: t.array(SingleSolcConfig),\n  overrides: optional(t.record(t.string, SingleSolcConfig)),\n});\n\nconst SolidityConfig = t.union([t.string, SingleSolcConfig, MultiSolcConfig]);\n\nconst HardhatConfig = t.type(\n  {\n    defaultNetwork: optional(t.string),\n    networks: optional(Networks),\n    paths: optional(ProjectPaths),\n    solidity: optional(SolidityConfig),\n  },\n  \"HardhatConfig\"\n);\n\n/**\n * Validates the config, throwing a HardhatError if invalid.\n * @param config\n */\nexport function validateConfig(config: any) {\n  const errors = getValidationErrors(config);\n\n  if (errors.length === 0) {\n    return;\n  }\n\n  let errorList = errors.join(\"\\n  * \");\n  errorList = `  * ${errorList}`;\n\n  throw new HardhatError(ERRORS.GENERAL.INVALID_CONFIG, { errors: errorList });\n}\n\nexport function getValidationErrors(config: any): string[] {\n  const errors: string[] = [];\n\n  // These can't be validated with io-ts\n  if (config !== undefined && typeof config.networks === \"object\") {\n    const hardhatNetwork = config.networks[HARDHAT_NETWORK_NAME];\n    if (hardhatNetwork !== undefined && typeof hardhatNetwork === \"object\") {\n      if (\"url\" in hardhatNetwork) {\n        errors.push(\n          `HardhatConfig.networks.${HARDHAT_NETWORK_NAME} can't have an url`\n        );\n      }\n\n      // Validating the accounts with io-ts leads to very confusing errors messages\n      const { accounts, ...configExceptAccounts } = hardhatNetwork;\n\n      const netConfigResult = HardhatNetworkConfig.decode(configExceptAccounts);\n      if (netConfigResult.isLeft()) {\n        errors.push(\n          getErrorMessage(\n            `HardhatConfig.networks.${HARDHAT_NETWORK_NAME}`,\n            hardhatNetwork,\n            \"HardhatNetworkConfig\"\n          )\n        );\n      }\n\n      // manual validation of accounts\n      if (Array.isArray(accounts)) {\n        for (const [index, account] of accounts.entries()) {\n          if (typeof account !== \"object\") {\n            errors.push(\n              getPrivateKeyError(\n                index,\n                HARDHAT_NETWORK_NAME,\n                `Expected object, received ${typeof account}`\n              )\n            );\n            continue;\n          }\n\n          const { privateKey, balance } = account;\n\n          validatePrivateKey(privateKey, index, HARDHAT_NETWORK_NAME, errors);\n\n          if (typeof balance !== \"string\") {\n            errors.push(\n              getErrorMessage(\n                `HardhatConfig.networks.${HARDHAT_NETWORK_NAME}.accounts[].balance`,\n                balance,\n                \"string\"\n              )\n            );\n          } else if (decimalString.decode(balance).isLeft()) {\n            errors.push(\n              getErrorMessage(\n                `HardhatConfig.networks.${HARDHAT_NETWORK_NAME}.accounts[].balance`,\n                balance,\n                \"decimal(wei)\"\n              )\n            );\n          }\n        }\n      } else if (typeof hardhatNetwork.accounts === \"object\") {\n        const hdConfigResult = HardhatNetworkHDAccountsConfig.decode(\n          hardhatNetwork.accounts\n        );\n        if (hdConfigResult.isLeft()) {\n          errors.push(\n            getErrorMessage(\n              `HardhatConfig.networks.${HARDHAT_NETWORK_NAME}.accounts`,\n              hardhatNetwork.accounts,\n              \"[{privateKey: string, balance: string}] | HardhatNetworkHDAccountsConfig | undefined\"\n            )\n          );\n        }\n      } else if (hardhatNetwork.accounts !== undefined) {\n        errors.push(\n          getErrorMessage(\n            `HardhatConfig.networks.${HARDHAT_NETWORK_NAME}.accounts`,\n            hardhatNetwork.accounts,\n            \"[{privateKey: string, balance: string}] | HardhatNetworkHDAccountsConfig | undefined\"\n          )\n        );\n      }\n\n      const hardfork =\n        hardhatNetwork.hardfork ?? defaultHardhatNetworkParams.hardfork;\n      if (hardforkGte(hardfork, HardforkName.LONDON)) {\n        if (hardhatNetwork.minGasPrice !== undefined) {\n          errors.push(\n            `Unexpected config HardhatConfig.networks.${HARDHAT_NETWORK_NAME}.minGasPrice found - This field is not valid for networks with EIP-1559. Try an older hardfork or remove it.`\n          );\n        }\n      } else {\n        if (hardhatNetwork.initialBaseFeePerGas !== undefined) {\n          errors.push(\n            `Unexpected config HardhatConfig.networks.${HARDHAT_NETWORK_NAME}.initialBaseFeePerGas found - This field is only valid for networks with EIP-1559. Try a newer hardfork or remove it.`\n          );\n        }\n      }\n\n      if (hardhatNetwork.chains !== undefined) {\n        Object.entries(hardhatNetwork.chains).forEach((chainEntry) => {\n          const [chainId, chainConfig] = chainEntry as [\n            string,\n            HardhatNetworkChainUserConfig\n          ];\n          const { hardforkHistory } = chainConfig;\n          if (hardforkHistory !== undefined) {\n            Object.keys(hardforkHistory).forEach((hardforkName) => {\n              if (!HARDHAT_NETWORK_SUPPORTED_HARDFORKS.includes(hardforkName)) {\n                errors.push(\n                  getErrorMessage(\n                    `HardhatConfig.networks.${HARDHAT_NETWORK_NAME}.chains[${chainId}].hardforkHistory`,\n                    hardforkName,\n                    `\"${HARDHAT_NETWORK_SUPPORTED_HARDFORKS.join('\" | \"')}\"`\n                  )\n                );\n              }\n            });\n          }\n        });\n      }\n    }\n\n    for (const [networkName, netConfig] of Object.entries<any>(\n      config.networks\n    )) {\n      if (networkName === HARDHAT_NETWORK_NAME) {\n        continue;\n      }\n\n      if (networkName !== \"localhost\" || netConfig.url !== undefined) {\n        if (typeof netConfig.url !== \"string\") {\n          errors.push(\n            getErrorMessage(\n              `HardhatConfig.networks.${networkName}.url`,\n              netConfig.url,\n              \"string\"\n            )\n          );\n        }\n      }\n\n      const { accounts, ...configExceptAccounts } = netConfig;\n\n      const netConfigResult = HttpNetworkConfig.decode(configExceptAccounts);\n      if (netConfigResult.isLeft()) {\n        errors.push(\n          getErrorMessage(\n            `HardhatConfig.networks.${networkName}`,\n            netConfig,\n            \"HttpNetworkConfig\"\n          )\n        );\n      }\n\n      // manual validation of accounts\n      if (Array.isArray(accounts)) {\n        accounts.forEach((privateKey, index) =>\n          validatePrivateKey(privateKey, index, networkName, errors)\n        );\n      } else if (typeof accounts === \"object\") {\n        const hdConfigResult = HDAccountsConfig.decode(accounts);\n        if (hdConfigResult.isLeft()) {\n          errors.push(\n            getErrorMessage(\n              `HardhatConfig.networks.${networkName}`,\n              accounts,\n              \"HttpNetworkHDAccountsConfig\"\n            )\n          );\n        }\n      } else if (typeof accounts === \"string\") {\n        if (accounts !== \"remote\") {\n          errors.push(\n            `Invalid 'accounts' entry for network '${networkName}': expected an array of accounts or the string 'remote', but got the string '${accounts}'`\n          );\n        }\n      } else if (accounts !== undefined) {\n        errors.push(\n          getErrorMessage(\n            `HardhatConfig.networks.${networkName}.accounts`,\n            accounts,\n            '\"remote\" | string[] | HttpNetworkHDAccountsConfig | undefined'\n          )\n        );\n      }\n    }\n  }\n\n  // io-ts can get confused if there are errors that it can't understand.\n  // Especially around Hardhat Network's config. It will treat it as an HTTPConfig,\n  // and may give a loot of errors.\n  if (errors.length > 0) {\n    return errors;\n  }\n\n  const result = HardhatConfig.decode(config);\n\n  if (result.isRight()) {\n    return errors;\n  }\n\n  const ioTsErrors = DotPathReporter.report(result);\n  return [...errors, ...ioTsErrors];\n}\n\nexport function validateResolvedConfig(resolvedConfig: HardhatConfigT) {\n  const solcConfigs = [\n    ...resolvedConfig.solidity.compilers,\n    ...Object.values(resolvedConfig.solidity.overrides),\n  ];\n  const runs = solcConfigs\n    .filter(({ settings }) => settings?.optimizer?.runs !== undefined)\n    .map(({ settings }) => settings?.optimizer?.runs);\n\n  for (const run of runs) {\n    if (run >= 2 ** 32) {\n      throw new HardhatError(ERRORS.GENERAL.INVALID_CONFIG, {\n        errors: \"The number of optimizer runs exceeds the maximum of 2**32 - 1\",\n      });\n    }\n  }\n}\n"]},"metadata":{},"sourceType":"script","externalDependencies":[]}